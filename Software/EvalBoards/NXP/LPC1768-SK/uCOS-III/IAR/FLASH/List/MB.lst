###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Aug/2017  10:05:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MB.C
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MB.C -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MB.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MB.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MB.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                        uC/MODBUS Source Code
     19          *
     20          * Filename      : mb.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          /*
     29          *********************************************************************************************************
     30          *                                            INCLUDE FILES
     31          *********************************************************************************************************
     32          */
     33          
     34          #define   MB_MODULE
     35          // modified by SE
     36          #include  <includes.h>

   \                                 In section .bss, align 2
   \   __absolute CPU_INT16U MB_RTU_Freq
   \                     MB_RTU_Freq:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U MB_RTU_TmrCtr
   \                     MB_RTU_TmrCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute OS_SEM MB_OS_RxSemTbl[4]
   \                     MB_OS_RxSemTbl:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
   \   __absolute OS_SEM MB_OS_TxSemTbl[4]
   \                     MB_OS_TxSemTbl:
   \   00000000                      DS8 160

   \                                 In section .bss, align 1
   \   __absolute CPU_INT08U MB_ChCtr
   \                     MB_ChCtr:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute MODBUS_CH MB_ChTbl[4]
   \                     MB_ChTbl:
   \   00000000                      DS8 4512
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          /*
     46          *********************************************************************************************************
     47          *                                           LOCAL CONSTANTS
     48          *********************************************************************************************************
     49          */
     50          
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                          LOCAL DATA TYPES
     55          *********************************************************************************************************
     56          */
     57          
     58          
     59          /*
     60          *********************************************************************************************************
     61          *                                            LOCAL TABLES
     62          *********************************************************************************************************
     63          */
     64          
     65          /*
     66          *********************************************************************************************************
     67          *                                       LOCAL GLOBAL VARIABLES
     68          *********************************************************************************************************
     69          */
     70          /*
     71          *********************************************************************************************************
     72          *                                        RAM STORAGE REQUIREMENTS
     73          *********************************************************************************************************
     74          */
     75                                                                          /* RAM Storage Requiremets                            */
     76          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .rodata, align 4
     77          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_RTU_Freq)
   \                     MB_TotalRAMSize:
   \   00000000   0x000011A6         DC32 4518
     78                                             + sizeof(MB_RTU_TmrCtr)
     79                                             + sizeof(MB_ChTbl);
     80          #else
     81          CPU_INT32U  const  MB_TotalRAMSize = sizeof(MB_ChTbl);
     82          #endif
     83          

   \                                 In section .rodata, align 2
     84          CPU_INT16U  const  MB_ChSize       = sizeof(MODBUS_CH);
   \                     MB_ChSize:
   \   00000000   0x0468             DC16 1128
     85          
     86          /*
     87          *********************************************************************************************************
     88          *                                      LOCAL FUNCTION PROTOTYPES
     89          *********************************************************************************************************
     90          */
     91          
     92          
     93          /*
     94          *********************************************************************************************************
     95          *                                     LOCAL CONFIGURATION ERRORS
     96          *********************************************************************************************************
     97          */
     98          
     99          
    100          /*
    101          *********************************************************************************************************
    102          *                                               MB_Init()
    103          *
    104          * Description : Handle either Modbus ASCII or Modbus RTU received packets.
    105          *
    106          * Argument(s) : freq       Specifies the Modbus RTU timer frequency (in Hz)
    107          *
    108          * Return(s)   : none.
    109          *
    110          * Caller(s)   : Application
    111          *
    112          * Note(s)     : none.
    113          *********************************************************************************************************
    114          */
    115          

   \                                 In section .text, align 2, keep-with-next
    116          void  MB_Init (CPU_INT32U freq)
    117          {
   \                     MB_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    118              CPU_INT08U   ch;
    119              MODBUS_CH   *pch;
    120          
    121          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    122              MB_RTU_Freq = freq;                              /* Save the RTU frequency                         */
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable3
   \   00000008   0x8004             STRH     R4,[R0, #+0]
    123          #endif
    124          
    125              pch         = &MB_ChTbl[0];                      /* Save Modbus channel number in data structure   */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable3_1
   \   0000000E   0x0006             MOVS     R6,R0
    126              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {     /* Initialize default values                          */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0005             MOVS     R5,R0
   \                     ??MB_Init_0: (+1)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA18             BGE.N    ??MB_Init_1
    127                  pch->Ch            = ch;
   \   0000001A   0x7035             STRB     R5,[R6, #+0]
    128                  pch->NodeAddr      = 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x7230             STRB     R0,[R6, #+8]
    129                  pch->MasterSlave   = MODBUS_SLAVE;           /* Channel defaults to MODBUS_SLAVE mode          */
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x7530             STRB     R0,[R6, #+20]
    130                  pch->Mode          = MODBUS_MODE_ASCII;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x74F0             STRB     R0,[R6, #+19]
    131                  pch->RxBufByteCtr  = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x8630             STRH     R0,[R6, #+48]
    132                  pch->RxBufPtr      = &pch->RxBuf[0];
   \   0000002C   0xF116 0x0038      ADDS     R0,R6,#+56
   \   00000030   0x6370             STR      R0,[R6, #+52]
    133                  pch->WrEn          = MODBUS_WR_EN;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x7070             STRB     R0,[R6, #+1]
    134                  pch->WrCtr         = 0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6070             STR      R0,[R6, #+4]
    135          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    136                  pch->RTU_TimeoutEn = DEF_TRUE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7730             STRB     R0,[R6, #+28]
    137          #endif
    138          
    139          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)  && \
    140              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)
    141                  MBS_StatInit(pch);
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       MBS_StatInit
    142          #endif
    143                  pch++;
   \   00000044   0xF516 0x668D      ADDS     R6,R6,#+1128
    144              }
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
   \   0000004A   0xE7E3             B.N      ??MB_Init_0
    145          
    146              MB_ChCtr = 0;
   \                     ??MB_Init_1: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable3_2
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    147          
    148              MB_OS_Init();                                       /* Initialize OS interface functions              */
   \   00000054   0x.... 0x....      BL       MB_OS_Init
    149          
    150          
    151          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)                  /* MODBUS 'RTU' Initialization                         */
    152              MB_RTU_TmrInit();
   \   00000058   0x.... 0x....      BL       MB_RTU_TmrInit
    153          #else
    154              (void)&freq;
    155          #endif
    156          }
   \   0000005C   0xBD70             POP      {R4-R6,PC}       ;; return
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                               MB_Exit()
    161          *
    162          * Description : This function is called to terminate all Modbus communications
    163          *
    164          * Argument(s) : none.
    165          *
    166          * Return(s)   : none.
    167          *
    168          * Caller(s)   : Application.
    169          *
    170          * Note(s)     : none.
    171          *********************************************************************************************************
    172          */

   \                                 In section .text, align 2, keep-with-next
    173          void  MB_Exit (void)
    174          {
   \                     MB_Exit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    175          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    176              MB_RTU_TmrExit();                                /* Stop the RTU timer interrupts                  */
   \   00000002   0x.... 0x....      BL       MB_RTU_TmrExit
    177          #endif
    178          
    179              MB_CommExit();                                   /* Disable all communications                     */
   \   00000006   0x.... 0x....      BL       MB_CommExit
    180          
    181              MB_OS_Exit();                                    /* Stop RTOS services                             */
   \   0000000A   0x.... 0x....      BL       MB_OS_Exit
    182          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    183          
    184          /*
    185          *********************************************************************************************************
    186          *                                              MB_CfgCh()
    187          *
    188          * Description : This function must be called after calling MB_Init() to initialize each of the Modbus
    189          *               channels in your system.
    190          *
    191          * Argument(s) : node_addr     is the Modbus node address that the channel is assigned to.
    192          *
    193          *               master_slave  specifies whether the channel is a MODBUS_MASTER or a MODBUS_SLAVE
    194          *
    195          *               rx_timeout    amount of time Master will wait for a response from the slave.
    196          *
    197          *               modbus_mode   specifies the type of modbus channel.  The choices are:
    198          *                             MODBUS_MODE_ASCII
    199          *                             MODBUS_MODE_RTU
    200          *
    201          *               port_nbr      is the UART port number associated with the channel, 0 <= port_nbr < MODBUS_CFG_MAX_CH
    202          *
    203          *               baud          is the desired baud rate
    204          *
    205          *               parity        is the UART's parity setting:
    206          *                             MODBUS_PARITY_NONE
    207          *                             MODBUS_PARITY_ODD
    208          *                             MODBUS_PARITY_EVEN
    209          *
    210          *               bits          UART's number of bits (7 or 8)
    211          *
    212          *               stops         Number of stops bits (1 or 2)
    213          *
    214          *               wr_en         This argument determines whether a Modbus WRITE request will be accepted.
    215          *                             The choices are:
    216          *                             MODBUS_WR_EN
    217          *                             MODBUS_WR_DIS
    218          *
    219          * Return(s)   : none.
    220          *
    221          * Caller(s)   : Application.
    222          *
    223          * Note(s)     : none.
    224          *********************************************************************************************************
    225          */

   \                                 In section .text, align 2, keep-with-next
    226          MODBUS_CH  *MB_CfgCh (CPU_INT08U  node_addr,
    227                                CPU_INT08U  master_slave,
    228                                CPU_INT32U  rx_timeout,
    229                                CPU_INT08U  modbus_mode,
    230                                CPU_INT08U  port_nbr,
    231                                CPU_INT32U  baud,
    232                                CPU_INT08U  bits,
    233                                CPU_INT08U  parity,
    234                                CPU_INT08U  stops,
    235                                CPU_INT08U  wr_en)
    236          {
   \                     MB_CfgCh: (+1)
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4699             MOV      R9,R3
   \   00000008   0x9C10             LDR      R4,[SP, #+64]
   \   0000000A   0xF8DD 0xA044      LDR      R10,[SP, #+68]
   \   0000000E   0x9D12             LDR      R5,[SP, #+72]
   \   00000010   0x9E13             LDR      R6,[SP, #+76]
   \   00000012   0x9F14             LDR      R7,[SP, #+80]
   \   00000014   0xF8DD 0x8054      LDR      R8,[SP, #+84]
    237              MODBUS_CH   *pch;
    238          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    239              CPU_INT16U   cnts;
    240          #endif
    241          
    242              if (MB_ChCtr < MODBUS_CFG_MAX_CH) {
   \   00000018   0x....             LDR.N    R0,??DataTable3_2
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2804             CMP      R0,#+4
   \   0000001E   0xDA62             BGE.N    ??MB_CfgCh_0
    243                  pch = &MB_ChTbl[MB_ChCtr];
   \   00000020   0x....             LDR.N    R0,??DataTable3_1
   \   00000022   0x....             LDR.N    R1,??DataTable3_2
   \   00000024   0x7809             LDRB     R1,[R1, #+0]
   \   00000026   0xF44F 0x628D      MOV      R2,#+1128
   \   0000002A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002E   0x4683             MOV      R11,R0
    244                  MB_MasterTimeoutSet(pch, rx_timeout);
   \   00000030   0x9906             LDR      R1,[SP, #+24]
   \   00000032   0x4658             MOV      R0,R11
   \   00000034   0x.... 0x....      BL       MB_MasterTimeoutSet
    245                  MB_NodeAddrSet(pch, node_addr);
   \   00000038   0xF89D 0x1010      LDRB     R1,[SP, #+16]
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0x.... 0x....      BL       MB_NodeAddrSet
    246                  MB_ModeSet(pch, master_slave, modbus_mode);
   \   00000042   0x464A             MOV      R2,R9
   \   00000044   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000046   0xF89D 0x1014      LDRB     R1,[SP, #+20]
   \   0000004A   0x4658             MOV      R0,R11
   \   0000004C   0x.... 0x....      BL       MB_ModeSet
    247                  MB_WrEnSet(pch, wr_en);
   \   00000050   0x4641             MOV      R1,R8
   \   00000052   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000054   0x4658             MOV      R0,R11
   \   00000056   0x.... 0x....      BL       MB_WrEnSet
    248                  MB_ChToPortMap(pch, port_nbr);
   \   0000005A   0x0021             MOVS     R1,R4
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0x4658             MOV      R0,R11
   \   00000060   0x.... 0x....      BL       MB_ChToPortMap
    249                  MB_CommPortCfg(pch, port_nbr, baud, bits, parity, stops);
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0x0030             MOVS     R0,R6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x9000             STR      R0,[SP, #+0]
   \   00000070   0x002B             MOVS     R3,R5
   \   00000072   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000074   0x4652             MOV      R2,R10
   \   00000076   0x0021             MOVS     R1,R4
   \   00000078   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000007A   0x4658             MOV      R0,R11
   \   0000007C   0x.... 0x....      BL       MB_CommPortCfg
    250          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    251                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000080   0xF89B 0x0014      LDRB     R0,[R11, #+20]
   \   00000084   0x2801             CMP      R0,#+1
   \   00000086   0xD102             BNE.N    ??MB_CfgCh_1
    252                      pch->RTU_TimeoutEn = DEF_FALSE;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xF88B 0x001C      STRB     R0,[R11, #+28]
    253                  }
    254          
    255                  cnts = ((CPU_INT32U)MB_RTU_Freq * 5L * 10L) / baud;           /* Freq * 5 char * 10 bits/char * 1/BaudRate  */
   \                     ??MB_CfgCh_1: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable3
   \   00000090   0x8800             LDRH     R0,[R0, #+0]
   \   00000092   0x2132             MOVS     R1,#+50
   \   00000094   0x4348             MULS     R0,R1,R0
   \   00000096   0xFBB0 0xF0FA      UDIV     R0,R0,R10
   \   0000009A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    256                  if (cnts <= 3) {
   \   0000009E   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000A2   0x2804             CMP      R0,#+4
   \   000000A4   0xDA02             BGE.N    ??MB_CfgCh_2
    257                      cnts = 3;
   \   000000A6   0x2003             MOVS     R0,#+3
   \   000000A8   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    258                  }
    259                  pch->RTU_TimeoutCnts = cnts;
   \                     ??MB_CfgCh_2: (+1)
   \   000000AC   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000B0   0xF8AB 0x0018      STRH     R0,[R11, #+24]
    260                  pch->RTU_TimeoutCtr  = cnts;
   \   000000B4   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   000000B8   0xF8AB 0x001A      STRH     R0,[R11, #+26]
    261          #endif
    262                  pch->RxSem  = &MB_OS_RxSemTbl[port_nbr];                      // port_nbr < MODBUS_CFG_MAX_CH
   \   000000BC   0x....             LDR.N    R0,??DataTable3_3
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0x2128             MOVS     R1,#+40
   \   000000C2   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000C6   0xF8CB 0x0454      STR      R0,[R11, #+1108]
    263                  pch->TxSem  = &MB_OS_TxSemTbl[port_nbr];                      // port_nbr < MODBUS_CFG_MAX_CH 
   \   000000CA   0x....             LDR.N    R0,??DataTable3_4
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2128             MOVS     R1,#+40
   \   000000D0   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   000000D4   0xF8CB 0x0458      STR      R0,[R11, #+1112]
    264                  
    265                  MB_ChCtr++;
   \   000000D8   0x....             LDR.N    R0,??DataTable3_2
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x....             LDR.N    R1,??DataTable3_2
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
    266                  return (pch);
   \   000000E2   0x4658             MOV      R0,R11
   \   000000E4   0xE000             B.N      ??MB_CfgCh_3
    267              } else {
    268                  return ((MODBUS_CH *)0);
   \                     ??MB_CfgCh_0: (+1)
   \   000000E6   0x2000             MOVS     R0,#+0
   \                     ??MB_CfgCh_3: (+1)
   \   000000E8   0xB007             ADD      SP,SP,#+28
   \   000000EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    269              }
    270          }
    271          
    272          /*
    273          *********************************************************************************************************
    274          *                                         MB_MasterTimeoutSet()
    275          *
    276          * Description : This function is called to change the operating mode of a Modbus channel.
    277          *
    278          * Argument(s) : pch          is a pointer to the Modbus channel to change
    279          *
    280          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    281          *                            MODBUS_MODE_ASCII
    282          *                            MODBUS_MODE_RTU
    283          *
    284          * Return(s)   : none.
    285          *
    286          * Caller(s)   : Application.
    287          *
    288          * Note(s)     : none.
    289          *********************************************************************************************************
    290          */

   \                                 In section .text, align 2, keep-with-next
    291          void  MB_MasterTimeoutSet (MODBUS_CH  *pch,
    292                                     CPU_INT32U  timeout)
    293          {
    294              if (pch != (MODBUS_CH *)0) {
   \                     MB_MasterTimeoutSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_MasterTimeoutSet_0
    295                  pch->RxTimeout = timeout;
   \   00000004   0x6281             STR      R1,[R0, #+40]
    296              }
    297          }
   \                     ??MB_MasterTimeoutSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    298          
    299          /*
    300          *********************************************************************************************************
    301          *                                             MB_ModeSet()
    302          *
    303          * Description : This function is called to change the operating mode of a Modbus channel.
    304          *
    305          * Argument(s) : pch          is a pointer to the Modbus channel to change
    306          *
    307          *               modbus_mode  specifies the type of modbus channel.  The choices are:
    308          *                            MODBUS_MODE_ASCII
    309          *                            MODBUS_MODE_RTU
    310          *
    311          * Return(s)   : none.
    312          *
    313          * Caller(s)   : Application.
    314          *
    315          * Note(s)     : none.
    316          *********************************************************************************************************
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void  MB_ModeSet (MODBUS_CH  *pch,
    319                            CPU_INT08U  master_slave,
    320                            CPU_INT08U  mode)
    321          {
    322              if (pch != (MODBUS_CH *)0) {
   \                     MB_ModeSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD00F             BEQ.N    ??MB_ModeSet_0
    323          
    324                  switch (master_slave) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2901             CMP      R1,#+1
   \   00000008   0xD102             BNE.N    ??MB_ModeSet_1
    325                      case MODBUS_MASTER:
    326                           pch->MasterSlave = MODBUS_MASTER;
   \   0000000A   0x2301             MOVS     R3,#+1
   \   0000000C   0x7503             STRB     R3,[R0, #+20]
    327                           break;
   \   0000000E   0xE001             B.N      ??MB_ModeSet_2
    328          
    329                      case MODBUS_SLAVE:
    330                      default:
    331                           pch->MasterSlave = MODBUS_SLAVE;
   \                     ??MB_ModeSet_1: (+1)
   \   00000010   0x2300             MOVS     R3,#+0
   \   00000012   0x7503             STRB     R3,[R0, #+20]
    332                           break;
    333                  }
    334          
    335                  switch (mode) {
   \                     ??MB_ModeSet_2: (+1)
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD102             BNE.N    ??MB_ModeSet_3
    336          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    337                      case MODBUS_MODE_ASCII:
    338                           pch->Mode = MODBUS_MODE_ASCII;
    339                           break;
    340          #endif
    341          
    342          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    343                      case MODBUS_MODE_RTU:
    344                           pch->Mode = MODBUS_MODE_RTU;
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x74C3             STRB     R3,[R0, #+19]
    345                           break;
   \   0000001E   0xE001             B.N      ??MB_ModeSet_0
    346          #endif
    347          
    348                      default:
    349          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    350                           pch->Mode = MODBUS_MODE_RTU;
   \                     ??MB_ModeSet_3: (+1)
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x74C3             STRB     R3,[R0, #+19]
    351          #else
    352                           pch->Mode = MODBUS_MODE_ASCII;
    353          #endif
    354                           break;
    355                  }
    356              }
    357          }
   \                     ??MB_ModeSet_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    358          
    359          /*
    360          *********************************************************************************************************
    361          *                                           MB_NodeAddrSet()
    362          *
    363          * Description : This function is called to change the Modbus node address that the channel will respond to.
    364          *
    365          * Argument(s) : pch          is a pointer to the Modbus channel to change
    366          *
    367          *               node_addr    is the Modbus node address that the channel is assigned to.
    368          *
    369          * Return(s)   : none.
    370          *
    371          * Caller(s)   : Application.
    372          *
    373          * Note(s)     : none.
    374          *********************************************************************************************************
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          void  MB_NodeAddrSet (MODBUS_CH  *pch,
    377                                CPU_INT08U  node_addr)
    378          {
    379              if (pch != (MODBUS_CH *)0) {
   \                     MB_NodeAddrSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_NodeAddrSet_0
    380                  pch->NodeAddr = node_addr;
   \   00000004   0x7201             STRB     R1,[R0, #+8]
    381              }
    382          }
   \                     ??MB_NodeAddrSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    383          
    384          /*
    385          *********************************************************************************************************
    386          *                                             MB_WrEnSet()
    387          *
    388          * Description : This function is called to enable or disable write accesses to the data.
    389          *
    390          * Argument(s) : ch           is the Modbus channel to change
    391          *
    392          *               wr_en        This argument determines whether a Modbus WRITE request will be accepted.
    393          *                            The choices are:
    394          *                            MODBUS_WR_EN
    395          *                            MODBUS_WR_DIS
    396          *
    397          * Return(s)   : none.
    398          *
    399          * Caller(s)   : Application.
    400          *
    401          * Note(s)     : none.
    402          *********************************************************************************************************
    403          */

   \                                 In section .text, align 2, keep-with-next
    404          void  MB_WrEnSet (MODBUS_CH  *pch,
    405                            CPU_INT08U  wr_en)
    406          {
    407              if (pch != (MODBUS_CH *)0) {
   \                     MB_WrEnSet: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_WrEnSet_0
    408                  pch->WrEn = wr_en;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    409              }
    410          }
   \                     ??MB_WrEnSet_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    411          
    412          /*
    413          *********************************************************************************************************
    414          *                                           MB_ChToPortMap()
    415          *
    416          * Description : This function is called to change the physical port number of the Modbus channel.
    417          *
    418          * Argument(s) : pch          is a pointer to the Modbus channel to change
    419          *
    420          *               port_nbr     This argument determines the physical port number of the Modbus channel
    421          *
    422          * Return(s)   : none.
    423          *
    424          * Caller(s)   : Application.
    425          *
    426          * Note(s)     : none.
    427          *********************************************************************************************************
    428          */

   \                                 In section .text, align 2, keep-with-next
    429          void  MB_ChToPortMap (MODBUS_CH  *pch,
    430                                CPU_INT08U  port_nbr)
    431          {
    432              if (pch != (MODBUS_CH *)0) {
   \                     MB_ChToPortMap: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD000             BEQ.N    ??MB_ChToPortMap_0
    433                  pch->PortNbr = port_nbr;
   \   00000004   0x7241             STRB     R1,[R0, #+9]
    434              }
    435          }
   \                     ??MB_ChToPortMap_0: (+1)
   \   00000006   0x4770             BX       LR               ;; return
    436          
    437          /*$PAGE*/
    438          /*
    439          *********************************************************************************************************
    440          *                                              MB_RxByte()
    441          *
    442          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    443          *               when a complete packet has been received.
    444          *
    445          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    446          *
    447          *               rx_byte     Is the byte received.
    448          *
    449          * Return(s)   : none.
    450          *
    451          * Caller(s)   : MB_CommRxTxISR_Handler()
    452          *
    453          * Note(s)     : none.
    454          *********************************************************************************************************
    455          */

   \                                 In section .text, align 2, keep-with-next
    456          void  MB_RxByte (MODBUS_CH  *pch,
    457                           CPU_INT08U  rx_byte)
    458          {
   \                     MB_RxByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    459              switch (pch->Mode) {
   \   00000006   0x7CE0             LDRB     R0,[R4, #+19]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD105             BNE.N    ??MB_RxByte_0
    460          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    461                  case MODBUS_MODE_ASCII:
    462                       MB_ASCII_RxByte(pch, rx_byte & 0x7F);
    463                       break;
    464          #endif
    465          
    466          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    467                  case MODBUS_MODE_RTU:
    468                       MB_RTU_RxByte(pch, rx_byte);
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       MB_RTU_RxByte
    469                       break;
   \   00000016   0xE7FF             B.N      ??MB_RxByte_1
    470          #endif
    471          
    472                  default:
    473                       break;
    474              }
    475          }
   \                     ??MB_RxByte_0: (+1)
   \                     ??MB_RxByte_1: (+1)
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    476          
    477          /*$PAGE*/
    478          /*
    479          *********************************************************************************************************
    480          *                                              MB_RxTask() 
    481          *
    482          * Description : This function is called when a packet needs to be processed. 
    483          *
    484          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    485          *
    486          * Return(s)   : none.
    487          *
    488          * Caller(s)   : MB_OS_RxTask()
    489          *
    490          * Note(s)     : none.
    491          *********************************************************************************************************
    492          */

   \                                 In section .text, align 2, keep-with-next
    493          void  MB_RxTask (MODBUS_CH *pch)
    494          {
   \                     MB_RxTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    495          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    496              if (pch != (MODBUS_CH *)0) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ.N    ??MB_RxTask_0
    497                  if (pch->MasterSlave == MODBUS_SLAVE) {
   \   00000008   0x7D20             LDRB     R0,[R4, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??MB_RxTask_0
    498                      MBS_RxTask(pch);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       MBS_RxTask
    499                  }
    500              }
    501          #endif
    502          }
   \                     ??MB_RxTask_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    503          /*
    504          *********************************************************************************************************
    505          *                                                MB_Tx()
    506          *
    507          * Description : This function is called to start transmitting a packet to a modbus channel.
    508          *
    509          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    510          *
    511          * Return(s)   : none.
    512          *
    513          * Caller(s)   : MB_ASCII_Tx()
    514          *               MB_RTU_Tx()
    515          *
    516          * Note(s)     : none.
    517          *********************************************************************************************************
    518          */

   \                                 In section .text, align 2, keep-with-next
    519          void  MB_Tx (MODBUS_CH  *pch)
    520          {
   \                     MB_Tx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    521              pch->TxBufPtr = &pch->TxBuf[0];
   \   00000004   0xF514 0x70A2      ADDS     R0,R4,#+324
   \   00000008   0xF8C4 0x0140      STR      R0,[R4, #+320]
    522              MB_CommRxIntDis(pch);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       MB_CommRxIntDis
    523              MB_CommTxIntEn(pch); 
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       MB_CommTxIntEn
    524              MB_TxByte(pch);
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x.... 0x....      BL       MB_TxByte
    525          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    526          
    527          /*$PAGE*/
    528          /*
    529          *********************************************************************************************************
    530          *                                              MB_TxByte()
    531          *
    532          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    533          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    534          *               is enabled to accept the next Modbus request.
    535          *
    536          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    537          *
    538          * Return(s)   : none.
    539          *
    540          * Caller(s)   : MB_CommRxTxISR_Handler()
    541          *               MB_Tx()
    542          *
    543          * Note(s)     : none.
    544          *********************************************************************************************************
    545          */

   \                                 In section .text, align 2, keep-with-next
    546          void  MB_TxByte (MODBUS_CH  *pch)
    547          {
   \                     MB_TxByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    548              CPU_INT08U  c;
    549          
    550              if (pch->TxBufByteCtr > 0) {
   \   00000004   0xF8B4 0x013C      LDRH     R0,[R4, #+316]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD01D             BEQ.N    ??MB_TxByte_0
    551                  pch->TxBufByteCtr--;
   \   0000000C   0xF8B4 0x013C      LDRH     R0,[R4, #+316]
   \   00000010   0x1E40             SUBS     R0,R0,#+1
   \   00000012   0xF8A4 0x013C      STRH     R0,[R4, #+316]
    552                  pch->TxCtr++;
   \   00000016   0xF8D4 0x0138      LDR      R0,[R4, #+312]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xF8C4 0x0138      STR      R0,[R4, #+312]
    553                  c = *pch->TxBufPtr++;
   \   00000020   0xF8D4 0x0140      LDR      R0,[R4, #+320]
   \   00000024   0x1C41             ADDS     R1,R0,#+1
   \   00000026   0xF8C4 0x1140      STR      R1,[R4, #+320]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x0005             MOVS     R5,R0
    554                  MB_CommTx1(pch,c);                         /* Write one byte to the serial port                  */
   \   0000002E   0x0029             MOVS     R1,R5
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       MB_CommTx1
    555                                                                  
    556          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    557                  if (pch->MasterSlave == MODBUS_MASTER) {
   \   00000038   0x7D20             LDRB     R0,[R4, #+20]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD10E             BNE.N    ??MB_TxByte_1
    558          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    559                      pch->RTU_TimeoutEn = MODBUS_FALSE;     /* Disable RTU timeout timer until we start receiving */
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7720             STRB     R0,[R4, #+28]
    560          #endif            
    561                      pch->RxBufByteCtr  = 0;                /* Flush Rx buffer                                           */
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x8620             STRH     R0,[R4, #+48]
   \   00000046   0xE009             B.N      ??MB_TxByte_1
    562                  }
    563          #endif
    564              } else {                                       /* If there is nothing to do end transmission                */
    565                  pch->TxBufPtr = &pch->TxBuf[0];            /* Reset at beginning of buffer                              */
   \                     ??MB_TxByte_0: (+1)
   \   00000048   0xF514 0x70A2      ADDS     R0,R4,#+324
   \   0000004C   0xF8C4 0x0140      STR      R0,[R4, #+320]
    566                  MB_CommTxIntDis(pch);                      /* No more data to send, disable Tx interrupts               */
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x.... 0x....      BL       MB_CommTxIntDis
    567                  MB_CommRxIntEn(pch);                       /* Re-enable the receiver for the next packet                */
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       MB_CommRxIntEn
    568              }
    569          }
   \                     ??MB_TxByte_1: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    570          
    571          /*$PAGE*/
    572          /*
    573          *********************************************************************************************************
    574          *                                           MB_ASCII_RxByte()
    575          *
    576          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    577          *               when a complete packet has been received.
    578          *
    579          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    580          *
    581          *               rx_byte     Is the byte received.
    582          *
    583          * Return(s)   : none.
    584          *
    585          * Caller(s)   : MB_RxByte().
    586          *
    587          * Return(s)   : none.
    588          *********************************************************************************************************
    589          */
    590          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    591          void  MB_ASCII_RxByte (MODBUS_CH  *pch,
    592                                 CPU_INT08U  rx_byte)
    593          {
    594              CPU_INT08U    node_addr;
    595              CPU_INT08U   *phex;
    596          
    597          
    598              pch->RxCtr++;                                   /* Increment the number of bytes received                   */
    599              if (rx_byte == ':') {                           /* Is it the start of frame character?                      */
    600                  pch->RxBufPtr     = &pch->RxBuf[0];         /* Yes, Restart a new frame                                 */
    601                  pch->RxBufByteCtr = 0;
    602              }
    603              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                    */
    604                  *pch->RxBufPtr++  = rx_byte;
    605                  pch->RxBufByteCtr++;                                    /* Increment byte counter to see if we have Rx ...    */
    606                                                                          /* ... activity                                       */
    607              }
    608              if (rx_byte == MODBUS_ASCII_END_FRAME_CHAR2) {  /* See if we received a complete ASCII frame                */
    609                  phex      = &pch->RxBuf[1];
    610                  node_addr = MB_ASCII_HexToBin(phex);
    611                  if ((node_addr == pch->NodeAddr) ||                     /* Is the address for us?                             */
    612                      (node_addr == 0)) {                                 /* ... or a 'broadcast'?                              */
    613                      MB_OS_RxSignal(pch);                    /* Yes, Let task handle reply                               */
    614                  } else {
    615                      pch->RxBufPtr     = &pch->RxBuf[0];     /* No,  Wipe out anything, we have to re-synchronize.       */
    616                      pch->RxBufByteCtr = 0;
    617                  }
    618              }
    619          }
    620          #endif
    621          
    622          /*$PAGE*/
    623          /*
    624          *********************************************************************************************************
    625          *                                             MB_ASCII_Rx()
    626          *
    627          * Description : Parses and converts an ASCII style message into a Modbus frame.  A check is performed
    628          *               to verify that the Modbus packet is valid.
    629          *
    630          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    631          *
    632          * Return(s)   : DEF_TRUE        If all checks pass.
    633          *               DEF_FALSE       If any checks fail.
    634          *
    635          * Caller(s)   : MBM_RxReply().
    636          *
    637          * Note(s)     : none.
    638          *********************************************************************************************************
    639          */
    640          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    641          CPU_BOOLEAN  MB_ASCII_Rx (MODBUS_CH  *pch)
    642          {
    643              CPU_INT08U    *pmsg;
    644              CPU_INT08U    *prx_data;
    645              CPU_INT16U     rx_size;
    646          
    647          
    648              pmsg      = &pch->RxBuf[0];
    649              rx_size   =  pch->RxBufByteCtr;
    650              prx_data  = &pch->RxFrameData[0];
    651              if ((rx_size & 0x01)                                     &&        /* Message should have an ODD nbr of bytes.        */
    652                  (rx_size           >  MODBUS_ASCII_MIN_MSG_SIZE)     &&        /* Check if message is long enough                 */
    653                  (pmsg[0]           == MODBUS_ASCII_START_FRAME_CHAR) &&        /* Check the first char.                           */
    654                  (pmsg[rx_size - 2] == MODBUS_ASCII_END_FRAME_CHAR1)  &&        /* Check the last two.                             */
    655                  (pmsg[rx_size - 1] == MODBUS_ASCII_END_FRAME_CHAR2)) {
    656                  rx_size               -= 3;                                    /* Take away for the ':', CR, and LF               */
    657                  pmsg++;                                                        /* Point past the ':' to the address.              */
    658                  pch->RxFrameNDataBytes = 0;                                    /* Get the data from the message                   */
    659                  while (rx_size > 2) {
    660                      *prx_data++  = MB_ASCII_HexToBin(pmsg);
    661                      pmsg        += 2;
    662                      rx_size     -= 2;
    663                      pch->RxFrameNDataBytes++;                                  /* Increment the number of Modbus packets received */
    664                  }
    665                  pch->RxFrameNDataBytes -= 2;                                   /* Subtract the Address and function code          */
    666                  pch->RxFrameCRC         = (CPU_INT16U)MB_ASCII_HexToBin(pmsg); /* Extract the message's LRC                       */
    667                  return (DEF_TRUE);
    668              } else {
    669                  return (DEF_FALSE);
    670              }
    671          }
    672          #endif
    673          
    674          /*$PAGE*/
    675          /*
    676          *********************************************************************************************************
    677          *                                             MB_ASCII_Tx()
    678          *
    679          * Description : The format of the message is ASCII.  The actual information is taken from the given
    680          *               MODBUS frame.
    681          *
    682          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    683          *
    684          * Return(s)   : none.
    685          *
    686          * Caller(s)   : MBM_TxCmd()
    687          *               MBS_ASCII_Task()
    688          *
    689          * Note(s)     : none.   
    690          *********************************************************************************************************
    691          */
    692          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    693          void  MB_ASCII_Tx (MODBUS_CH  *pch)
    694          {
    695              CPU_INT08U    *ptx_data;
    696              CPU_INT08U    *pbuf;
    697              CPU_INT16U     i;
    698              CPU_INT16U     tx_bytes;
    699              CPU_INT08U     lrc;
    700          
    701          
    702              ptx_data = &pch->TxFrameData[0];
    703              pbuf     = &pch->TxBuf[0];
    704              *pbuf++  = MODBUS_ASCII_START_FRAME_CHAR;                   /* Place the start-of-frame character into output buffer  */
    705              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    706                                           pbuf);
    707              pbuf     = MB_ASCII_BinToHex(*ptx_data++, 
    708                                           pbuf);
    709              tx_bytes = 5;
    710              i        = (CPU_INT08U)pch->TxFrameNDataBytes;             /* Transmit the actual data                                 */
    711              while (i > 0) {
    712                  pbuf      = MB_ASCII_BinToHex(*ptx_data++, 
    713                                                pbuf);
    714                  tx_bytes += 2;
    715                  i--;
    716              }
    717              lrc               = MB_ASCII_TxCalcLRC(pch,                 /* Compute outbound packet LRC                            */
    718                                                     tx_bytes);      
    719              pbuf              = MB_ASCII_BinToHex(lrc,                  /* Add the LRC checksum in the packet                     */
    720                                                    pbuf);           
    721              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR1;           /* Add 1st end-of-frame character (0x0D) to output buffer */
    722              *pbuf++           = MODBUS_ASCII_END_FRAME_CHAR2;           /* Add 2nd end-of-frame character (0x0A) to output buffer */
    723              tx_bytes         += 4;
    724              pch->TxFrameCRC   = (CPU_INT16U)lrc;                       /* Save the computed LRC into the channel                   */
    725              pch->TxBufByteCtr = tx_bytes;                              /* Update the total number of bytes to send                 */
    726              MB_Tx(pch);                                                /* Send it out the communication driver.                    */
    727          }
    728          #endif
    729          
    730          /*$PAGE*/
    731          /*
    732          *********************************************************************************************************
    733          *                                            MB_RTU_RxByte()
    734          *
    735          * Description : A byte has been received from a serial port.  We just store it in the buffer for processing
    736          *               when a complete packet has been received.
    737          *
    738          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    739          *
    740          *               rx_byte     Is the byte received.
    741          *
    742          * Return(s)   : none.
    743          *
    744          * Caller(s)   : MB_RxByte()
    745          *
    746          * Note(s)     : none.
    747          *********************************************************************************************************
    748          */
    749          
    750          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    751          void  MB_RTU_RxByte (MODBUS_CH  *pch,
    752                               CPU_INT08U  rx_byte)
    753          {
   \                     MB_RTU_RxByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    754              MB_RTU_TmrReset(pch);                                       /* Reset the timeout timer on a new character               */
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       MB_RTU_TmrReset
    755          #if (MODBUS_CFG_MASTER_EN == DEF_ENABLED)
    756              if (pch->MasterSlave == MODBUS_MASTER) {                  // 无名沈注释掉
   \   0000000C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD103             BNE.N    ??MB_RTU_RxByte_0
    757                  pch->RTU_TimeoutEn = MODBUS_TRUE;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x7720             STRB     R0,[R4, #+28]
    758                  pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \   00000016   0x8B20             LDRH     R0,[R4, #+24]
   \   00000018   0x8360             STRH     R0,[R4, #+26]
    759              }                                                         // 无名沈注释掉
    760          #endif
    761                  pch->RTU_TimeoutEn = MODBUS_TRUE;                       //redmorningcn 增加 170526    
   \                     ??MB_RTU_RxByte_0: (+1)
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x7720             STRB     R0,[R4, #+28]
    762                  pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;             //redmorningcn 增加 170526  接收到数据，超时定时器重启。
   \   0000001E   0x8B20             LDRH     R0,[R4, #+24]
   \   00000020   0x8360             STRH     R0,[R4, #+26]
    763              
    764              if (pch->RxBufByteCtr < MODBUS_CFG_BUF_SIZE) {              /* No, add received byte to buffer                        */
   \   00000022   0x8E20             LDRH     R0,[R4, #+48]
   \   00000024   0x28FF             CMP      R0,#+255
   \   00000026   0xDC09             BGT.N    ??MB_RTU_RxByte_1
    765                  pch->RxCtr++;                                           /* Increment the number of bytes received                   */
   \   00000028   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \   0000002C   0x62E0             STR      R0,[R4, #+44]
    766                  *pch->RxBufPtr++ = rx_byte;
   \   0000002E   0x6B60             LDR      R0,[R4, #+52]
   \   00000030   0x1C41             ADDS     R1,R0,#+1
   \   00000032   0x6361             STR      R1,[R4, #+52]
   \   00000034   0x7005             STRB     R5,[R0, #+0]
    767                  pch->RxBufByteCtr++;                                    /* Increment byte counter to see if we have Rx activity     */
   \   00000036   0x8E20             LDRH     R0,[R4, #+48]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x8620             STRH     R0,[R4, #+48]
    768              }
    769          }
   \                     ??MB_RTU_RxByte_1: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    770          #endif
    771          
    772          /*$PAGE*/
    773          /*
    774          *********************************************************************************************************
    775          *                                              MB_RTU_Rx()
    776          *
    777          * Description : Parses a Modbus RTU packet and processes the request if the packet is valid.
    778          *
    779          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    780          *
    781          * Return(s)   : DEF_TRUE    If all checks pass.
    782          *               DEF_FALSE   If any checks fail.
    783          *
    784          * Caller(s)   : MBM_RxReply()
    785          *               MBS_RTU_Task()
    786          *
    787          * Note(s)     : none.
    788          *********************************************************************************************************
    789          */
    790          
    791          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    792          CPU_BOOLEAN  MB_RTU_Rx (MODBUS_CH  *pch)
    793          {
   \                     MB_RTU_Rx: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0001             MOVS     R1,R0
    794              CPU_INT08U    *prx_data;
    795              CPU_INT08U    *pmsg;
    796              CPU_INT16U     rx_size;
    797              CPU_INT16U     crc;
    798          
    799          
    800              pmsg    = &pch->RxBuf[0];
   \   00000004   0xF111 0x0038      ADDS     R0,R1,#+56
   \   00000008   0x0004             MOVS     R4,R0
    801              
    802          #if MB_AES_EN == DEF_ENABLED  
    803              if ( pch->AesEn )
    804                pch->RxBufByteCtr = MB_AESCbcDecrypt(pch->RxBuf,pch->RxBufByteCtr);
    805          #endif
    806              
    807              rx_size =  pch->RxBufByteCtr;
   \   0000000A   0x8E08             LDRH     R0,[R1, #+48]
   \   0000000C   0x0003             MOVS     R3,R0
    808              
    809              if (rx_size >= MODBUS_RTU_MIN_MSG_SIZE) {         /* Is the message long enough?                        */
   \   0000000E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000010   0x2B04             CMP      R3,#+4
   \   00000012   0xDB2E             BLT.N    ??MB_RTU_Rx_0
    810                  if (rx_size <= MODBUS_CFG_BUF_SIZE) {
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0xF5B3 0x7F80      CMP      R3,#+256
   \   0000001A   0xDC28             BGT.N    ??MB_RTU_Rx_1
    811                      prx_data    = &pch->RxFrameData[0];
   \   0000001C   0xF511 0x7011      ADDS     R0,R1,#+580
   \   00000020   0x0005             MOVS     R5,R0
    812                      *prx_data++ = *pmsg++;                    /* Transfer the node address                          */
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x7028             STRB     R0,[R5, #+0]
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
    813                      rx_size--;
   \   0000002A   0x1E5B             SUBS     R3,R3,#+1
    814          
    815                      *prx_data++ = *pmsg++;                    /* Transfer the function code                         */
   \   0000002C   0x7820             LDRB     R0,[R4, #+0]
   \   0000002E   0x7028             STRB     R0,[R5, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x1C6D             ADDS     R5,R5,#+1
    816                      rx_size--;
   \   00000034   0x1E5B             SUBS     R3,R3,#+1
    817          
    818                      pch->RxFrameNDataBytes = 0;               /* Transfer the data                                  */
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF8A1 0x0344      STRH     R0,[R1, #+836]
    819                      while (rx_size > 2) {
   \                     ??MB_RTU_Rx_2: (+1)
   \   0000003C   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000003E   0x2B03             CMP      R3,#+3
   \   00000040   0xDB0A             BLT.N    ??MB_RTU_Rx_3
    820                          *prx_data++ = *pmsg++;
   \   00000042   0x7820             LDRB     R0,[R4, #+0]
   \   00000044   0x7028             STRB     R0,[R5, #+0]
   \   00000046   0x1C64             ADDS     R4,R4,#+1
   \   00000048   0x1C6D             ADDS     R5,R5,#+1
    821                          pch->RxFrameNDataBytes++;
   \   0000004A   0xF8B1 0x0344      LDRH     R0,[R1, #+836]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0xF8A1 0x0344      STRH     R0,[R1, #+836]
    822                          rx_size--;
   \   00000054   0x1E5B             SUBS     R3,R3,#+1
   \   00000056   0xE7F1             B.N      ??MB_RTU_Rx_2
    823                      }
    824          
    825                      crc              = (CPU_INT16U)*pmsg++;   /* Transfer the CRC over.  It's LSB first, then MSB.  */
   \                     ??MB_RTU_Rx_3: (+1)
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x0002             MOVS     R2,R0
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
    826                      crc             += (CPU_INT16U)*pmsg << 8;
   \   0000005E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000060   0x7820             LDRB     R0,[R4, #+0]
   \   00000062   0xEB12 0x2200      ADDS     R2,R2,R0, LSL #+8
    827                      pch->RxFrameCRC  = crc;
   \   00000066   0xF8A1 0x2346      STRH     R2,[R1, #+838]
    828                      return (DEF_TRUE);
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0xE002             B.N      ??MB_RTU_Rx_4
    829                  } else {
    830                      return (DEF_FALSE);
   \                     ??MB_RTU_Rx_1: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE000             B.N      ??MB_RTU_Rx_4
    831                  }
    832              } else {
    833                  return (DEF_FALSE);
   \                     ??MB_RTU_Rx_0: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \                     ??MB_RTU_Rx_4: (+1)
   \   00000074   0xBC30             POP      {R4,R5}
   \   00000076   0x4770             BX       LR               ;; return
    834              }
    835          }
    836          #endif
    837          
    838          /*$PAGE*/
    839          /*
    840          *********************************************************************************************************
    841          *                                              MB_RTU_Tx()
    842          *
    843          * Description : A MODBUS message is formed into a buffer and sent to the appropriate communication port.
    844          *               The actual reply is taken from the given MODBUS Frame.
    845          *
    846          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    847          *
    848          * Return(s)   : none.
    849          *
    850          * Caller(s)   : MBM_TxCmd()
    851          *               MBS_RTU_Task()
    852          * 
    853          * Note(s)     : none.
    854          *********************************************************************************************************
    855          */
    856          
    857          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    858          void  MB_RTU_Tx (MODBUS_CH  *pch)
    859          {
   \                     MB_RTU_Tx: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    860              CPU_INT08U  *ptx_data;
    861              CPU_INT08U  *pbuf;
    862              CPU_INT08U   i;
    863              CPU_INT16U   tx_bytes;
    864              CPU_INT16U   crc;
    865          
    866          
    867              tx_bytes  = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x4680             MOV      R8,R0
    868              pbuf      = &pch->TxBuf[0];                                    /* Point to the beginning of the output buffer.             */
   \   0000000A   0xF514 0x70A2      ADDS     R0,R4,#+324
   \   0000000E   0x0006             MOVS     R6,R0
    869              ptx_data  = &(pch->TxFrameData[0]);
   \   00000010   0xF204 0x304E      ADDW     R0,R4,#+846
   \   00000014   0x0005             MOVS     R5,R0
    870              i         = (CPU_INT08U)pch->TxFrameNDataBytes + 2;            /* Include the actual data in the buffer                    */
   \   00000016   0xF8B4 0x044E      LDRH     R0,[R4, #+1102]
   \   0000001A   0x1C80             ADDS     R0,R0,#+2
   \   0000001C   0x0007             MOVS     R7,R0
    871              while (i > 0) {
   \                     ??MB_RTU_Tx_0: (+1)
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD007             BEQ.N    ??MB_RTU_Tx_1
    872                  *pbuf++ = *ptx_data++;
   \   00000024   0x7828             LDRB     R0,[R5, #+0]
   \   00000026   0x7030             STRB     R0,[R6, #+0]
   \   00000028   0x1C6D             ADDS     R5,R5,#+1
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
    873                  tx_bytes++;
   \   0000002C   0xF118 0x0801      ADDS     R8,R8,#+1
    874                  i--;
   \   00000030   0x1E7F             SUBS     R7,R7,#+1
   \   00000032   0xE7F4             B.N      ??MB_RTU_Tx_0
    875              }
    876              crc               = MB_RTU_TxCalcCRC(pch);
   \                     ??MB_RTU_Tx_1: (+1)
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       MB_RTU_TxCalcCRC
   \   0000003A   0x4681             MOV      R9,R0
    877              *pbuf++           = (CPU_INT08U)(crc & 0x00FF);                /* Add in the CRC checksum.  Low byte first!                */
   \   0000003C   0xF886 0x9000      STRB     R9,[R6, #+0]
   \   00000040   0x1C76             ADDS     R6,R6,#+1
    878              *pbuf             = (CPU_INT08U)(crc >> 8);
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0x7030             STRB     R0,[R6, #+0]
    879              tx_bytes         += 2;
   \   0000004A   0xF118 0x0802      ADDS     R8,R8,#+2
    880              pch->TxFrameCRC   = crc;                                       /* Save the calculated CRC in the channel                   */
   \   0000004E   0xF8A4 0x9450      STRH     R9,[R4, #+1104]
    881              
    882              pch->TxBufByteCtr = tx_bytes;
   \   00000052   0xF8A4 0x813C      STRH     R8,[R4, #+316]
    883              
    884          #if MB_AES_EN == DEF_ENABLED  
    885              if ( pch->AesEn )
    886                pch->TxBufByteCtr = MB_AESCbcEncrypt(pch->TxBuf,pch->TxBufByteCtr);
    887          #endif
    888              
    889              MB_Tx(pch);                                                    /* Send it out the communication driver.                    */
   \   00000056   0x0020             MOVS     R0,R4
   \   00000058   0x.... 0x....      BL       MB_Tx
    890          }
   \   0000005C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    891          #endif
    892          
    893          /*$PAGE*/
    894          /*
    895          *********************************************************************************************************
    896          *                                           MB_RTU_TmrReset()
    897          *
    898          * Description : This function is called when a byte a received and thus, we reset the RTU timeout timer value
    899          *               indicating that we are not done receiving a complete RTU packet.
    900          *
    901          * Argument(s) : none
    902          *
    903          * Return(s)   : none.
    904          *
    905          * Caller(s)   : MB_RTU_TmrResetAll()
    906          *
    907          * Note(s)     : none.
    908          *********************************************************************************************************
    909          */
    910          
    911          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    912          void  MB_RTU_TmrReset (MODBUS_CH  *pch)
    913          {
    914              pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     MB_RTU_TmrReset: (+1)
   \   00000000   0x8B01             LDRH     R1,[R0, #+24]
   \   00000002   0x8341             STRH     R1,[R0, #+26]
    915          }
   \   00000004   0x4770             BX       LR               ;; return
    916          #endif
    917          
    918          /*$PAGE*/
    919          /*
    920          *********************************************************************************************************
    921          *                                           MB_RTU_TmrResetAll()
    922          *
    923          * Description : This function is used to reset all the RTU timers for all Modbus channels.
    924          *
    925          * Argument(s) : none
    926          *
    927          * Return(s)   : none.
    928          *
    929          * Caller(s)   : MB_RTU_TmrInit()
    930          *
    931          * Note(s)     : none.
    932          *********************************************************************************************************
    933          */
    934          
    935          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    936          void  MB_RTU_TmrResetAll (void)
    937          {
   \                     MB_RTU_TmrResetAll: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    938              CPU_INT08U   ch;
    939              MODBUS_CH   *pch;
    940          
    941          
    942              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R0,??DataTable3_1
   \   00000004   0x0005             MOVS     R5,R0
    943              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0004             MOVS     R4,R0
   \                     ??MB_RTU_TmrResetAll_0: (+1)
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xDA09             BGE.N    ??MB_RTU_TmrResetAll_1
    944                  if (pch->Mode == MODBUS_MODE_RTU) {
   \   00000010   0x7CE8             LDRB     R0,[R5, #+19]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??MB_RTU_TmrResetAll_2
    945                      MB_RTU_TmrReset(pch);
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       MB_RTU_TmrReset
    946                  }
    947                  pch++;
   \                     ??MB_RTU_TmrResetAll_2: (+1)
   \   0000001C   0xF515 0x658D      ADDS     R5,R5,#+1128
    948              }
   \   00000020   0x1C64             ADDS     R4,R4,#+1
   \   00000022   0xE7F2             B.N      ??MB_RTU_TmrResetAll_0
    949          }
   \                     ??MB_RTU_TmrResetAll_1: (+1)
   \   00000024   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    950          #endif
    951          
    952          /*$PAGE*/
    953          /*
    954          *********************************************************************************************************
    955          *                                           MB_RTU_TmrUpdate()
    956          *
    957          * Description : This function is called when the application supplied RTU framing timer expires.
    958          *
    959          * Argument(s) : none
    960          *
    961          * Return(s)   : none.
    962          *
    963          * Caller(s)   : MB_RTU_TmrISR_Handler()
    964          *
    965          * Note(s)     : none.
    966          *********************************************************************************************************
    967          */
    968          
    969          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    970          void  MB_RTU_TmrUpdate (void)
    971          {
   \                     MB_RTU_TmrUpdate: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    972              CPU_INT08U   ch;
    973              MODBUS_CH   *pch;
    974          
    975          
    976              pch = &MB_ChTbl[0];
   \   00000002   0x....             LDR.N    R0,??DataTable3_1
   \   00000004   0x0005             MOVS     R5,R0
    977              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0004             MOVS     R4,R0
   \                     ??MB_RTU_TmrUpdate_0: (+1)
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xDA1A             BGE.N    ??MB_RTU_TmrUpdate_1
    978                  if (pch->Mode == MODBUS_MODE_RTU) {
   \   00000010   0x7CE8             LDRB     R0,[R5, #+19]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD113             BNE.N    ??MB_RTU_TmrUpdate_2
    979                      if (pch->RTU_TimeoutEn == DEF_TRUE) {
   \   00000016   0x7F28             LDRB     R0,[R5, #+28]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10E             BNE.N    ??MB_RTU_TmrUpdate_3
    980                          if (pch->RTU_TimeoutCtr > 0) {
   \   0000001C   0x8B68             LDRH     R0,[R5, #+26]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD00D             BEQ.N    ??MB_RTU_TmrUpdate_2
    981                              pch->RTU_TimeoutCtr--;
   \   00000022   0x8B68             LDRH     R0,[R5, #+26]
   \   00000024   0x1E40             SUBS     R0,R0,#+1
   \   00000026   0x8368             STRH     R0,[R5, #+26]
    982                              if (pch->RTU_TimeoutCtr == 0) {
   \   00000028   0x8B68             LDRH     R0,[R5, #+26]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD107             BNE.N    ??MB_RTU_TmrUpdate_2
    983          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    984                                  //if (pch->MasterSlave == MODBUS_MASTER) {  // 无名沈注释掉
    985                                      pch->RTU_TimeoutEn = DEF_FALSE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7728             STRB     R0,[R5, #+28]
    986                                  //}                                         // 无名沈注释掉
    987          #endif
    988                                  MB_OS_RxSignal(pch);          /* RTU Timer expired for this Modbus channel         */
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       MB_OS_RxSignal
   \   00000038   0xE001             B.N      ??MB_RTU_TmrUpdate_2
    989                              }
    990                          }
    991                      } else {
    992                          pch->RTU_TimeoutCtr = pch->RTU_TimeoutCnts;
   \                     ??MB_RTU_TmrUpdate_3: (+1)
   \   0000003A   0x8B28             LDRH     R0,[R5, #+24]
   \   0000003C   0x8368             STRH     R0,[R5, #+26]
    993                      }
    994                  }
    995                  pch++;
   \                     ??MB_RTU_TmrUpdate_2: (+1)
   \   0000003E   0xF515 0x658D      ADDS     R5,R5,#+1128
    996              }
   \   00000042   0x1C64             ADDS     R4,R4,#+1
   \   00000044   0xE7E1             B.N      ??MB_RTU_TmrUpdate_0
    997          }
   \                     ??MB_RTU_TmrUpdate_1: (+1)
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    998          #endif
    999          
   1000          /*******************************************************************************
   1001           * 名    称： NMB_Tx
   1002           * 功    能： 非MODBUS通信协议发送
   1003           * 入口参数： 无
   1004           * 出口参数： 无
   1005           * 作  　者： 无名沈
   1006           * 创建日期： 2015-03-28
   1007           * 修    改：
   1008           * 修改日期：
   1009           * 备    注： 该初始化会创建Modbus任务。
   1010           *******************************************************************************/
   1011          
   1012          #if (MB_NONMODBUS_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1013          void NMB_Tx(MODBUS_CH   *pch,
   1014                      CPU_INT08U  *p_reg_tbl,
   1015                      CPU_INT16U   nbr_bytes)
   1016          {
   \                     NMB_Tx: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1017              CPU_INT08U  *ptx_data;
   1018              CPU_INT08U  *pbuf;
   1019              CPU_INT08U   i;
   1020          
   1021              pbuf      = &pch->TxBuf[0];                                     /* Point to the beginning of the output buffer.             */
   \   0000000A   0xF514 0x70A2      ADDS     R0,R4,#+324
   \   0000000E   0x4680             MOV      R8,R0
   1022              ptx_data  = p_reg_tbl;
   \   00000010   0x002F             MOVS     R7,R5
   1023              i         = nbr_bytes;                                          /* Include the actual data in the buffer                    */
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0x4681             MOV      R9,R0
   1024              
   1025              while (i > 0) {
   \                     ??NMB_Tx_0: (+1)
   \   00000016   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000001A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000001E   0xD008             BEQ.N    ??NMB_Tx_1
   1026                  *pbuf++ = *ptx_data++;
   \   00000020   0x7838             LDRB     R0,[R7, #+0]
   \   00000022   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0xF118 0x0801      ADDS     R8,R8,#+1
   1027                  i--;
   \   0000002C   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000030   0xE7F1             B.N      ??NMB_Tx_0
   1028              }
   1029              
   1030              pch->TxBufByteCtr = nbr_bytes;
   \                     ??NMB_Tx_1: (+1)
   \   00000032   0xF8A4 0x613C      STRH     R6,[R4, #+316]
   1031              
   1032          #if MB_AES_EN == DEF_ENABLED  
   1033              if ( pch->AesEn )
   1034                pch->TxBufByteCtr = MB_AESCbcEncrypt(pch->TxBuf,pch->TxBufByteCtr);
   1035          #endif
   1036          //    if (pch->MasterSlave == MODBUS_MASTER) {
   1037          //        CPU_INT16U      err;
   1038          //        MB_OS_TxWait(pch,&err);
   1039          //        if ( err != MODBUS_ERR_NONE )
   1040          //            return;
   1041          //    }
   1042              MB_Tx(pch);                                                    /* Send it out the communication driver.                    */
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0x.... 0x....      BL       MB_Tx
   1043          }
   \   0000003C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     MB_RTU_Freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     MB_ChCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     MB_OS_RxSemTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     MB_OS_TxSemTbl
   1044          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   MB_CfgCh
        64   -> MB_ChToPortMap
        64   -> MB_CommPortCfg
        64   -> MB_MasterTimeoutSet
        64   -> MB_ModeSet
        64   -> MB_NodeAddrSet
        64   -> MB_WrEnSet
       0   MB_ChToPortMap
       8   MB_Exit
         8   -> MB_CommExit
         8   -> MB_OS_Exit
         8   -> MB_RTU_TmrExit
      16   MB_Init
        16   -> MBS_StatInit
        16   -> MB_OS_Init
        16   -> MB_RTU_TmrInit
       0   MB_MasterTimeoutSet
       0   MB_ModeSet
       0   MB_NodeAddrSet
       8   MB_RTU_Rx
      16   MB_RTU_RxByte
        16   -> MB_RTU_TmrReset
       0   MB_RTU_TmrReset
      16   MB_RTU_TmrResetAll
        16   -> MB_RTU_TmrReset
      16   MB_RTU_TmrUpdate
        16   -> MB_OS_RxSignal
      32   MB_RTU_Tx
        32   -> MB_RTU_TxCalcCRC
        32   -> MB_Tx
      16   MB_RxByte
        16   -> MB_RTU_RxByte
       8   MB_RxTask
         8   -> MBS_RxTask
       8   MB_Tx
         8   -> MB_CommRxIntDis
         8   -> MB_CommTxIntEn
         8   -> MB_TxByte
      16   MB_TxByte
        16   -> MB_CommRxIntEn
        16   -> MB_CommTx1
        16   -> MB_CommTxIntDis
       0   MB_WrEnSet
      32   NMB_Tx
        32   -> MB_Tx


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
     238  MB_CfgCh
       1  MB_ChCtr
       2  MB_ChSize
    4512  MB_ChTbl
       8  MB_ChToPortMap
      16  MB_Exit
      94  MB_Init
       8  MB_MasterTimeoutSet
      38  MB_ModeSet
       8  MB_NodeAddrSet
     160  MB_OS_RxSemTbl
     160  MB_OS_TxSemTbl
       2  MB_RTU_Freq
     120  MB_RTU_Rx
      62  MB_RTU_RxByte
       4  MB_RTU_TmrCtr
       6  MB_RTU_TmrReset
      38  MB_RTU_TmrResetAll
      72  MB_RTU_TmrUpdate
      96  MB_RTU_Tx
      26  MB_RxByte
      22  MB_RxTask
       4  MB_TotalRAMSize
      32  MB_Tx
      94  MB_TxByte
       8  MB_WrEnSet
      64  NMB_Tx

 
 4 839 bytes in section .bss
     6 bytes in section .rodata
 1 070 bytes in section .text
 
 1 070 bytes of CODE  memory
     6 bytes of CONST memory
 4 839 bytes of DATA  memory

Errors: none
Warnings: none
