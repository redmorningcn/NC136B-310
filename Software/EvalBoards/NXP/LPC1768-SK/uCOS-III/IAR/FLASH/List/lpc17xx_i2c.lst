###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Aug/2017  16:25:15
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_i2c.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_i2c.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_i2c.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_i2c.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_i2c.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_i2c.c				2011-03-31
      3          *//**
      4          * @file		lpc17xx_i2c.c
      5          * @brief	Contains all functions support for I2C firmware
      6          * 			library on LPC17xx
      7          * @version	2.1
      8          * @date		31. Mar. 2011
      9          * @author	NXP MCU SW Application Team
     10          *
     11          * Copyright(C) 2010, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          * Permission to use, copy, modify, and distribute this software and its
     26          * documentation is hereby granted, under NXP Semiconductors'
     27          * relevant copyright in the software, without fee, provided that it
     28          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     29          * copyright, permission, and disclaimer notice must appear in all copies of
     30          * this code.
     31          **********************************************************************/
     32          
     33          /* Peripheral group ----------------------------------------------------------- */
     34          /** @addtogroup I2C
     35           * @{
     36           */
     37          
     38          /* Includes ------------------------------------------------------------------- */
     39          #include "lpc17xx_i2c.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable18  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable18_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     40          #include "lpc17xx_clkpwr.h"
     41          #include "lpc17xx_pinsel.h"
     42          
     43          
     44          /* If this source file built with example, the LPC17xx FW library configuration
     45           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     46           * otherwise the default FW library configuration file must be included instead
     47           */
     48          #ifdef __BUILD_WITH_EXAMPLE__
     49          #include "lpc17xx_libcfg.h"
     50          #else
     51          #include "lpc17xx_libcfg_default.h"
     52          #endif /* __BUILD_WITH_EXAMPLE__ */
     53          
     54          
     55          #ifdef _I2C
     56          
     57          
     58          /* Private Types -------------------------------------------------------------- */
     59          /** @defgroup I2C_Private_Types I2C Private Types
     60           * @{
     61           */
     62          
     63          /**
     64           * @brief I2C device configuration structure type
     65           */
     66          typedef struct
     67          {
     68            uint32_t      txrx_setup; 						/* Transmission setup */
     69            int32_t		dir;								/* Current direction phase, 0 - write, 1 - read */
     70          } I2C_CFG_T;
     71          
     72          /**
     73           * @}
     74           */
     75          
     76          /* Private Variables ---------------------------------------------------------- */
     77          /**
     78           * @brief II2C driver data for I2C0, I2C1 and I2C2
     79           */

   \                                 In section .bss, align 4
     80          static I2C_CFG_T i2cdat[3];
   \                     i2cdat:
   \   00000000                      DS8 24
     81          

   \                                 In section .bss, align 4
     82          static uint32_t I2C_MasterComplete[3];
   \                     I2C_MasterComplete:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     83          static uint32_t I2C_SlaveComplete[3];
   \                     I2C_SlaveComplete:
   \   00000000                      DS8 12
     84          

   \                                 In section .bss, align 4
     85          static uint32_t I2C_MonitorBufferIndex;
   \                     I2C_MonitorBufferIndex:
   \   00000000                      DS8 4
     86          
     87          /* Private Functions ---------------------------------------------------------- */
     88          
     89          /* Get I2C number */
     90          static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx);
     91          
     92          /* Generate a start condition on I2C bus (in master mode only) */
     93          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx);
     94          
     95          /* Generate a stop condition on I2C bus (in master mode only) */
     96          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx);
     97          
     98          /* I2C send byte subroutine */
     99          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte);
    100          
    101          /* I2C get byte subroutine */
    102          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack);
    103          
    104          /* I2C set clock (hz) */
    105          static void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock);
    106          
    107          /*--------------------------------------------------------------------------------*/
    108          /********************************************************************//**
    109           * @brief		Convert from I2C peripheral to number
    110           * @param[in]	I2Cx: I2C peripheral selected, should be:
    111           * 				- LPC_I2C0
    112           * 				- LPC_I2C1
    113           * 				- LPC_I2C2
    114           * @return 		I2C number, could be: 0..2
    115           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          static int32_t I2C_getNum(LPC_I2C_TypeDef *I2Cx){
   \                     I2C_getNum: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    117          	if (I2Cx == LPC_I2C0) {
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??I2C_getNum_0
    118          		return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE00D             B.N      ??I2C_getNum_1
    119          	} else if (I2Cx == LPC_I2C1) {
   \                     ??I2C_getNum_0: (+1)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD101             BNE.N    ??I2C_getNum_2
    120          		return (1);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE007             B.N      ??I2C_getNum_1
    121          	} else if (I2Cx == LPC_I2C2) {
   \                     ??I2C_getNum_2: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001E   0x4281             CMP      R1,R0
   \   00000020   0xD101             BNE.N    ??I2C_getNum_3
    122          		return (2);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0xE001             B.N      ??I2C_getNum_1
    123          	}
    124          	return (-1);
   \                     ??I2C_getNum_3: (+1)
   \   00000026   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??I2C_getNum_1: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    125          }
    126          
    127          /********************************************************************//**
    128           * @brief		Generate a start condition on I2C bus (in master mode only)
    129           * @param[in]	I2Cx: I2C peripheral selected, should be:
    130           * 				- LPC_I2C0
    131           * 				- LPC_I2C1
    132           * 				- LPC_I2C2
    133           * @return 		value of I2C status register after generate a start condition
    134           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    135          static uint32_t I2C_Start (LPC_I2C_TypeDef *I2Cx)
    136          {
    137          	// Reset STA, STO, SI
    138          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
   \                     I2C_Start: (+1)
   \   00000000   0x2138             MOVS     R1,#+56
   \   00000002   0x6181             STR      R1,[R0, #+24]
    139          
    140          	// Enter to Master Transmitter mode
    141          	I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   00000004   0x2120             MOVS     R1,#+32
   \   00000006   0x6001             STR      R1,[R0, #+0]
    142          
    143          	// Wait for complete
    144          	while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
   \                     ??I2C_Start_0: (+1)
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0709             LSLS     R1,R1,#+28
   \   0000000C   0xD5FC             BPL.N    ??I2C_Start_0
    145          	I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   0000000E   0x2120             MOVS     R1,#+32
   \   00000010   0x6181             STR      R1,[R0, #+24]
    146          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000018   0x4770             BX       LR               ;; return
    147          }
    148          
    149          /********************************************************************//**
    150           * @brief		Generate a stop condition on I2C bus (in master mode only)
    151           * @param[in]	I2Cx: I2C peripheral selected, should be:
    152           * 				- LPC_I2C0
    153           * 				- LPC_I2C1
    154           * 				- LPC_I2C2
    155           * @return 		None
    156           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    157          static void I2C_Stop (LPC_I2C_TypeDef *I2Cx)
    158          {
    159          
    160          	/* Make sure start bit is not active */
    161          	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
   \                     I2C_Stop: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0689             LSLS     R1,R1,#+26
   \   00000004   0xD501             BPL.N    ??I2C_Stop_0
    162          	{
    163          		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x6181             STR      R1,[R0, #+24]
    164          	}
    165          
    166          	I2Cx->I2CONSET = I2C_I2CONSET_STO|I2C_I2CONSET_AA;
   \                     ??I2C_Stop_0: (+1)
   \   0000000A   0x2114             MOVS     R1,#+20
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    167          
    168          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x6181             STR      R1,[R0, #+24]
    169          }
   \   00000012   0x4770             BX       LR               ;; return
    170          
    171          /********************************************************************//**
    172           * @brief		Send a byte
    173           * @param[in]	I2Cx: I2C peripheral selected, should be:
    174           * 				- LPC_I2C0
    175           * 				- LPC_I2C1
    176           * 				- LPC_I2C2
    177           * @param[in]	databyte: number of byte
    178           * @return 		value of I2C status register after sending
    179           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    180          static uint32_t I2C_SendByte (LPC_I2C_TypeDef *I2Cx, uint8_t databyte)
    181          {
   \                     I2C_SendByte: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    182          	uint32_t CodeStatus = I2Cx->I2STAT & I2C_STAT_CODE_BITMASK;
   \   00000002   0x6850             LDR      R0,[R2, #+4]
   \   00000004   0xF010 0x03F8      ANDS     R3,R0,#0xF8
    183          
    184          	if((CodeStatus != I2C_I2STAT_M_TX_START) &&
    185          		(CodeStatus != I2C_I2STAT_M_TX_RESTART) &&
    186          		(CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK)  &&
    187          		(CodeStatus != I2C_I2STAT_M_TX_DAT_ACK)  )
   \   00000008   0x2B08             CMP      R3,#+8
   \   0000000A   0xD007             BEQ.N    ??I2C_SendByte_0
   \   0000000C   0x2B10             CMP      R3,#+16
   \   0000000E   0xD005             BEQ.N    ??I2C_SendByte_0
   \   00000010   0x2B18             CMP      R3,#+24
   \   00000012   0xD003             BEQ.N    ??I2C_SendByte_0
   \   00000014   0x2B28             CMP      R3,#+40
   \   00000016   0xD001             BEQ.N    ??I2C_SendByte_0
    188          	{
    189          		return CodeStatus;
   \   00000018   0x0018             MOVS     R0,R3
   \   0000001A   0xE00D             B.N      ??I2C_SendByte_1
    190          	}
    191          	
    192          	/* Make sure start bit is not active */
    193          	if (I2Cx->I2CONSET & I2C_I2CONSET_STA)
   \                     ??I2C_SendByte_0: (+1)
   \   0000001C   0x6810             LDR      R0,[R2, #+0]
   \   0000001E   0x0680             LSLS     R0,R0,#+26
   \   00000020   0xD501             BPL.N    ??I2C_SendByte_2
    194          	{
    195          		I2Cx->I2CONCLR = I2C_I2CONCLR_STAC;
   \   00000022   0x2020             MOVS     R0,#+32
   \   00000024   0x6190             STR      R0,[R2, #+24]
    196          	}
    197          	I2Cx->I2DAT = databyte & I2C_I2DAT_BITMASK;
   \                     ??I2C_SendByte_2: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x6091             STR      R1,[R2, #+8]
    198          
    199          	I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   0000002A   0x2004             MOVS     R0,#+4
   \   0000002C   0x6010             STR      R0,[R2, #+0]
    200          
    201          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x6190             STR      R0,[R2, #+24]
    202          
    203          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000032   0x6850             LDR      R0,[R2, #+4]
   \   00000034   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \                     ??I2C_SendByte_1: (+1)
   \   00000038   0x4770             BX       LR               ;; return
    204          }
    205          
    206          /********************************************************************//**
    207           * @brief		Get a byte
    208           * @param[in]	I2Cx: I2C peripheral selected, should be:
    209           * 				- LPC_I2C0
    210           * 				- LPC_I2C1
    211           * 				- LPC_I2C2
    212           * @param[out]	retdat	pointer to return data
    213           * @param[in]	ack		assert acknowledge or not, should be: TRUE/FALSE
    214           * @return 		value of I2C status register after sending
    215           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    216          static uint32_t I2C_GetByte (LPC_I2C_TypeDef *I2Cx, uint8_t *retdat, Bool ack)
    217          {
    218          	*retdat = (uint8_t) (I2Cx->I2DAT & I2C_I2DAT_BITMASK);
   \                     I2C_GetByte: (+1)
   \   00000000   0x6883             LDR      R3,[R0, #+8]
   \   00000002   0x700B             STRB     R3,[R1, #+0]
    219          	
    220          	if (ack == TRUE)
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x2A01             CMP      R2,#+1
   \   00000008   0xD102             BNE.N    ??I2C_GetByte_0
    221          	{
    222          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   0000000A   0x2304             MOVS     R3,#+4
   \   0000000C   0x6003             STR      R3,[R0, #+0]
   \   0000000E   0xE001             B.N      ??I2C_GetByte_1
    223          	}
    224          	else
    225          	{
    226          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   \                     ??I2C_GetByte_0: (+1)
   \   00000010   0x2304             MOVS     R3,#+4
   \   00000012   0x6183             STR      R3,[R0, #+24]
    227          	}
    228          
    229          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_GetByte_1: (+1)
   \   00000014   0x2308             MOVS     R3,#+8
   \   00000016   0x6183             STR      R3,[R0, #+24]
    230          	
    231          	return (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   0000001E   0x4770             BX       LR               ;; return
    232          }
    233          
    234          /*********************************************************************//**
    235           * @brief 		Setup clock rate for I2C peripheral
    236           * @param[in] 	I2Cx	I2C peripheral selected, should be:
    237           * 				- LPC_I2C0
    238           * 				- LPC_I2C1
    239           * 				- LPC_I2C2
    240           * @param[in]	target_clock : clock of SSP (Hz)
    241           * @return 		None
    242           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          static void I2C_SetClock (LPC_I2C_TypeDef *I2Cx, uint32_t target_clock)
    244          {
   \                     I2C_SetClock: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    245          	uint32_t temp;
    246          
    247          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00C             BEQ.N    ??I2C_SetClock_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD008             BEQ.N    ??I2C_SetClock_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD004             BEQ.N    ??I2C_SetClock_0
   \   0000001E   0x21F7             MOVS     R1,#+247
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000024   0x.... 0x....      BL       check_failed
    248          
    249          	// Get PCLK of I2C controller
    250          	if (I2Cx == LPC_I2C0)
   \                     ??I2C_SetClock_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD106             BNE.N    ??I2C_SetClock_1
    251          	{
    252          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C0) / target_clock;
   \   00000030   0x200E             MOVS     R0,#+14
   \   00000032   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000036   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   0000003A   0x0006             MOVS     R6,R0
   \   0000003C   0xE014             B.N      ??I2C_SetClock_2
    253          	}
    254          	else if (I2Cx == LPC_I2C1)
   \                     ??I2C_SetClock_1: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD106             BNE.N    ??I2C_SetClock_3
    255          	{
    256          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C1) / target_clock;
   \   00000046   0x2026             MOVS     R0,#+38
   \   00000048   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000004C   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000050   0x0006             MOVS     R6,R0
   \   00000052   0xE009             B.N      ??I2C_SetClock_2
    257          	}
    258          	else if (I2Cx == LPC_I2C2)
   \                     ??I2C_SetClock_3: (+1)
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000058   0x4284             CMP      R4,R0
   \   0000005A   0xD105             BNE.N    ??I2C_SetClock_2
    259          	{
    260          		temp = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_I2C2) / target_clock;
   \   0000005C   0x2034             MOVS     R0,#+52
   \   0000005E   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000062   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000066   0x0006             MOVS     R6,R0
    261          	}
    262          
    263          	/* Set the I2C clock value to register */
    264          	I2Cx->I2SCLH = (uint32_t)(temp / 2);
   \                     ??I2C_SetClock_2: (+1)
   \   00000068   0x0870             LSRS     R0,R6,#+1
   \   0000006A   0x6120             STR      R0,[R4, #+16]
    265          	I2Cx->I2SCLL = (uint32_t)(temp - I2Cx->I2SCLH);
   \   0000006C   0x6920             LDR      R0,[R4, #+16]
   \   0000006E   0x1A30             SUBS     R0,R6,R0
   \   00000070   0x6160             STR      R0,[R4, #+20]
    266          }
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    267          /* End of Private Functions --------------------------------------------------- */
    268          
    269          
    270          /* Public Functions ----------------------------------------------------------- */
    271          /** @addtogroup I2C_Public_Functions
    272           * @{
    273           */
    274          
    275          /********************************************************************//**
    276           * @brief		Initializes the I2Cx peripheral with specified parameter.
    277           * @param[in]	I2Cx	I2C peripheral selected, should be
    278           * 				- LPC_I2C0
    279           * 				- LPC_I2C1
    280           * 				- LPC_I2C2
    281           * @param[in]	clockrate Target clock rate value to initialized I2C
    282           * 				peripheral (Hz)
    283           * @return 		None
    284           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          void I2C_Init(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate)
    286          {
   \                     I2C_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    287          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00D             BEQ.N    ??I2C_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD009             BEQ.N    ??I2C_Init_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD005             BEQ.N    ??I2C_Init_0
   \   0000001E   0xF240 0x111F      MOVW     R1,#+287
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000026   0x.... 0x....      BL       check_failed
    288          
    289          	if (I2Cx==LPC_I2C0)
   \                     ??I2C_Init_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD108             BNE.N    ??I2C_Init_1
    290          	{
    291          		/* Set up clock and power for I2C0 module */
    292          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x2080             MOVS     R0,#+128
   \   00000036   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    293          		/* As default, peripheral clock for I2C0 module
    294          		 * is set to FCCLK / 2 */
    295          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C0, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   0000003A   0x2102             MOVS     R1,#+2
   \   0000003C   0x200E             MOVS     R0,#+14
   \   0000003E   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   00000042   0xE01C             B.N      ??I2C_Init_2
    296          	}
    297          	else if (I2Cx==LPC_I2C1)
   \                     ??I2C_Init_1: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000048   0x4284             CMP      R4,R0
   \   0000004A   0xD109             BNE.N    ??I2C_Init_3
    298          	{
    299          		/* Set up clock and power for I2C1 module */
    300          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, ENABLE);
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0xF45F 0x2000      MOVS     R0,#+524288
   \   00000052   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    301          		/* As default, peripheral clock for I2C1 module
    302          		 * is set to FCCLK / 2 */
    303          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C1, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x2026             MOVS     R0,#+38
   \   0000005A   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   0000005E   0xE00E             B.N      ??I2C_Init_2
    304          	}
    305          	else if (I2Cx==LPC_I2C2)
   \                     ??I2C_Init_3: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD109             BNE.N    ??I2C_Init_4
    306          	{
    307          		/* Set up clock and power for I2C2 module */
    308          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, ENABLE);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xF05F 0x6080      MOVS     R0,#+67108864
   \   0000006E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    309          		/* As default, peripheral clock for I2C2 module
    310          		 * is set to FCCLK / 2 */
    311          		CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_I2C2, CLKPWR_PCLKSEL_CCLK_DIV_2);
   \   00000072   0x2102             MOVS     R1,#+2
   \   00000074   0x2034             MOVS     R0,#+52
   \   00000076   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
   \   0000007A   0xE000             B.N      ??I2C_Init_2
    312          	}
    313          	else {
    314          		// Up-Support this device
    315          		return;
   \                     ??I2C_Init_4: (+1)
   \   0000007C   0xE005             B.N      ??I2C_Init_5
    316          	}
    317          
    318              /* Set clock rate */
    319              I2C_SetClock(I2Cx, clockrate);
   \                     ??I2C_Init_2: (+1)
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       I2C_SetClock
    320              /* Set I2C operation to default */
    321              I2Cx->I2CONCLR = (I2C_I2CONCLR_AAC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
   \   00000086   0x2064             MOVS     R0,#+100
   \   00000088   0x61A0             STR      R0,[R4, #+24]
    322          }
   \                     ??I2C_Init_5: (+1)
   \   0000008A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    323          
    324          /*********************************************************************//**
    325           * @brief		De-initializes the I2C peripheral registers to their
    326           *                  default reset values.
    327           * @param[in]	I2Cx	I2C peripheral selected, should be
    328           *  			- LPC_I2C0
    329           * 				- LPC_I2C1
    330           * 				- LPC_I2C2
    331           * @return 		None
    332           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    333          void I2C_DeInit(LPC_I2C_TypeDef* I2Cx)
    334          {
   \                     I2C_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    335          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00D             BEQ.N    ??I2C_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD009             BEQ.N    ??I2C_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD005             BEQ.N    ??I2C_DeInit_0
   \   0000001C   0xF240 0x114F      MOVW     R1,#+335
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000024   0x.... 0x....      BL       check_failed
    336          
    337          	/* Disable I2C control */
    338          	I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
   \                     ??I2C_DeInit_0: (+1)
   \   00000028   0x2040             MOVS     R0,#+64
   \   0000002A   0x61A0             STR      R0,[R4, #+24]
    339          
    340          	if (I2Cx==LPC_I2C0)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD104             BNE.N    ??I2C_DeInit_1
    341          	{
    342          		/* Disable power for I2C0 module */
    343          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C0, DISABLE);
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x2080             MOVS     R0,#+128
   \   00000038   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   0000003C   0xE012             B.N      ??I2C_DeInit_2
    344          	}
    345          	else if (I2Cx==LPC_I2C1)
   \                     ??I2C_DeInit_1: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xD105             BNE.N    ??I2C_DeInit_3
    346          	{
    347          		/* Disable power for I2C1 module */
    348          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C1, DISABLE);
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000004C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000050   0xE008             B.N      ??I2C_DeInit_2
    349          	}
    350          	else if (I2Cx==LPC_I2C2)
   \                     ??I2C_DeInit_3: (+1)
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0xD104             BNE.N    ??I2C_DeInit_2
    351          	{
    352          		/* Disable power for I2C2 module */
    353          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCI2C2, DISABLE);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000060   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    354          	}
    355          }
   \                     ??I2C_DeInit_2: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    356          
    357          /*********************************************************************//**
    358           * @brief		Enable or disable I2C peripheral's operation
    359           * @param[in]	I2Cx I2C peripheral selected, should be
    360           *  			- LPC_I2C0
    361           * 				- LPC_I2C1
    362           * 				- LPC_I2C2
    363           * @param[in]	NewState New State of I2Cx peripheral's operation
    364           * @return 		none
    365           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    366          void I2C_Cmd(LPC_I2C_TypeDef* I2Cx, en_I2C_Mode Mode,  FunctionalState NewState)
    367          {
   \                     I2C_Cmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    368          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \   00000008   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD008             BEQ.N    ??I2C_Cmd_0
   \   0000000E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   0x2E01             CMP      R6,#+1
   \   00000012   0xD005             BEQ.N    ??I2C_Cmd_0
   \   00000014   0xF44F 0x71B8      MOV      R1,#+368
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   0000001C   0x.... 0x....      BL       check_failed
    369          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \                     ??I2C_Cmd_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD00D             BEQ.N    ??I2C_Cmd_1
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   0000002C   0x4284             CMP      R4,R0
   \   0000002E   0xD009             BEQ.N    ??I2C_Cmd_1
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD005             BEQ.N    ??I2C_Cmd_1
   \   00000038   0xF240 0x1171      MOVW     R1,#+369
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000040   0x.... 0x....      BL       check_failed
    370          
    371          	if (NewState == ENABLE)
   \                     ??I2C_Cmd_1: (+1)
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E01             CMP      R6,#+1
   \   00000048   0xD108             BNE.N    ??I2C_Cmd_2
    372          	{
    373          		if(Mode != I2C_SLAVE_MODE)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D01             CMP      R5,#+1
   \   0000004E   0xD002             BEQ.N    ??I2C_Cmd_3
    374          			I2Cx->I2CONSET = I2C_I2CONSET_I2EN;
   \   00000050   0x2040             MOVS     R0,#+64
   \   00000052   0x6020             STR      R0,[R4, #+0]
   \   00000054   0xE004             B.N      ??I2C_Cmd_4
    375          		else
    376          			I2Cx->I2CONSET = I2C_I2CONSET_I2EN | I2C_I2CONSET_AA;
   \                     ??I2C_Cmd_3: (+1)
   \   00000056   0x2044             MOVS     R0,#+68
   \   00000058   0x6020             STR      R0,[R4, #+0]
   \   0000005A   0xE001             B.N      ??I2C_Cmd_4
    377          	}
    378          	else
    379          	{
    380          		I2Cx->I2CONCLR = I2C_I2CONCLR_I2ENC;
   \                     ??I2C_Cmd_2: (+1)
   \   0000005C   0x2040             MOVS     R0,#+64
   \   0000005E   0x61A0             STR      R0,[R4, #+24]
    381          	}
    382          }
   \                     ??I2C_Cmd_4: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
    383          
    384          /*********************************************************************//**
    385           * @brief 		Enable/Disable interrupt for I2C peripheral
    386           * @param[in]	I2Cx	I2C peripheral selected, should be:
    387           * 				- LPC_I2C0
    388           * 				- LPC_I2C1
    389           * 				- LPC_I2C2
    390           * @param[in]	NewState	New State of I2C peripheral interrupt in NVIC core
    391           * 				should be:
    392           * 				- ENABLE: enable interrupt for this I2C peripheral
    393           * 				- DISABLE: disable interrupt for this I2C peripheral
    394           * @return 		None
    395           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void I2C_IntCmd (LPC_I2C_TypeDef *I2Cx, Bool NewState)
    397          {
   \                     I2C_IntCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    398          	if (NewState)
   \   00000006   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD017             BEQ.N    ??I2C_IntCmd_0
    399          	{
    400          		if(I2Cx == LPC_I2C0)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD103             BNE.N    ??I2C_IntCmd_1
    401          		{
    402          			NVIC_EnableIRQ(I2C0_IRQn);
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000001A   0xE026             B.N      ??I2C_IntCmd_2
    403          		}
    404          		else if (I2Cx == LPC_I2C1)
   \                     ??I2C_IntCmd_1: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD103             BNE.N    ??I2C_IntCmd_3
    405          		{
    406          			NVIC_EnableIRQ(I2C1_IRQn);
   \   00000024   0x200B             MOVS     R0,#+11
   \   00000026   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000002A   0xE01E             B.N      ??I2C_IntCmd_2
    407          		}
    408          		else if (I2Cx == LPC_I2C2)
   \                     ??I2C_IntCmd_3: (+1)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD11A             BNE.N    ??I2C_IntCmd_2
    409          		{
    410          			NVIC_EnableIRQ(I2C2_IRQn);
   \   00000034   0x200C             MOVS     R0,#+12
   \   00000036   0x.... 0x....      BL       NVIC_EnableIRQ
   \   0000003A   0xE016             B.N      ??I2C_IntCmd_2
    411          		}
    412          	}
    413          	else
    414          	{
    415          		if(I2Cx == LPC_I2C0)
   \                     ??I2C_IntCmd_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_2  ;; 0x4001c000
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD103             BNE.N    ??I2C_IntCmd_4
    416          		{
    417          			NVIC_DisableIRQ(I2C0_IRQn);
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0x.... 0x....      BL       NVIC_DisableIRQ
   \   0000004A   0xE00E             B.N      ??I2C_IntCmd_2
    418          		}
    419          		else if (I2Cx == LPC_I2C1)
   \                     ??I2C_IntCmd_4: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable18_3  ;; 0x4005c000
   \   00000050   0x4284             CMP      R4,R0
   \   00000052   0xD103             BNE.N    ??I2C_IntCmd_5
    420          		{
    421          			NVIC_DisableIRQ(I2C1_IRQn);
   \   00000054   0x200B             MOVS     R0,#+11
   \   00000056   0x.... 0x....      BL       NVIC_DisableIRQ
   \   0000005A   0xE006             B.N      ??I2C_IntCmd_2
    422          		}
    423          		else if (I2Cx == LPC_I2C2)
   \                     ??I2C_IntCmd_5: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable18_4  ;; 0x400a0000
   \   00000060   0x4284             CMP      R4,R0
   \   00000062   0xD102             BNE.N    ??I2C_IntCmd_2
    424          		{
    425          			NVIC_DisableIRQ(I2C2_IRQn);
   \   00000064   0x200C             MOVS     R0,#+12
   \   00000066   0x.... 0x....      BL       NVIC_DisableIRQ
    426          		}
    427          	}
    428              return;
   \                     ??I2C_IntCmd_2: (+1)
   \   0000006A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    429          }
    430          
    431          
    432          /*********************************************************************//**
    433           * @brief 		Handle I2C Master states.
    434           * @param[in]	I2Cx	I2C peripheral selected, should be:
    435           * 				- LPC_I2C
    436           * 				- LPC_I2C1
    437           * 				- LPC_I2C2
    438           * @param[in]	CodeStatus	I2C state
    439           * @param[in]	TransferCfg   Pointer to a I2C_S_SETUP_Type structure that
    440           * 								contains specified information about the
    441           * 								configuration for master transfer.
    442           * @return 		It can be
    443           *				- I2C_OK
    444           *				-I2C_BYTE_RECV
    445           *				-I2C_BYTE_SENT
    446           *				-I2C_SEND_END
    447           *				-I2C_RECV_END
    448           *				- I2C_ERR
    449           *				- I2C_NAK_RECV
    450           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          int32_t I2C_MasterHanleStates(LPC_I2C_TypeDef  *I2Cx, uint32_t CodeStatus, I2C_M_SETUP_Type *TransferCfg)
    452          {
   \                     I2C_MasterHanleStates: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    453          	uint8_t *txdat;
    454          	uint8_t *rxdat;
    455          	uint8_t tmp;
    456          	int32_t Ret = I2C_OK;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
    457          	
    458          	//get buffer to send/receive
    459          	txdat = (uint8_t *) &TransferCfg->tx_data[TransferCfg->tx_count];
   \   0000000E   0x6870             LDR      R0,[R6, #+4]
   \   00000010   0x68F1             LDR      R1,[R6, #+12]
   \   00000012   0x1808             ADDS     R0,R1,R0
   \   00000014   0x0007             MOVS     R7,R0
    460          	rxdat = (uint8_t *) &TransferCfg->rx_data[TransferCfg->rx_count];
   \   00000016   0x6930             LDR      R0,[R6, #+16]
   \   00000018   0x69B1             LDR      R1,[R6, #+24]
   \   0000001A   0x1808             ADDS     R0,R1,R0
   \   0000001C   0x4680             MOV      R8,R0
    461          
    462          	switch(CodeStatus)
   \   0000001E   0x0028             MOVS     R0,R5
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xF000 0x8095      BEQ.W    ??I2C_MasterHanleStates_0
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD016             BEQ.N    ??I2C_MasterHanleStates_1
   \   0000002A   0x2810             CMP      R0,#+16
   \   0000002C   0xD014             BEQ.N    ??I2C_MasterHanleStates_1
   \   0000002E   0x2818             CMP      R0,#+24
   \   00000030   0xD02E             BEQ.N    ??I2C_MasterHanleStates_2
   \   00000032   0x2820             CMP      R0,#+32
   \   00000034   0xF000 0x808C      BEQ.W    ??I2C_MasterHanleStates_0
   \   00000038   0x2828             CMP      R0,#+40
   \   0000003A   0xD029             BEQ.N    ??I2C_MasterHanleStates_2
   \   0000003C   0x2830             CMP      R0,#+48
   \   0000003E   0xD03C             BEQ.N    ??I2C_MasterHanleStates_3
   \   00000040   0x2838             CMP      R0,#+56
   \   00000042   0xD040             BEQ.N    ??I2C_MasterHanleStates_4
   \   00000044   0x2840             CMP      R0,#+64
   \   00000046   0xD043             BEQ.N    ??I2C_MasterHanleStates_5
   \   00000048   0x2848             CMP      R0,#+72
   \   0000004A   0xF000 0x8081      BEQ.W    ??I2C_MasterHanleStates_0
   \   0000004E   0x2850             CMP      R0,#+80
   \   00000050   0xD045             BEQ.N    ??I2C_MasterHanleStates_6
   \   00000052   0x2858             CMP      R0,#+88
   \   00000054   0xD068             BEQ.N    ??I2C_MasterHanleStates_7
   \   00000056   0xE082             B.N      ??I2C_MasterHanleStates_8
    463          	{
    464          		case I2C_I2STAT_M_TX_START:
    465          		case I2C_I2STAT_M_TX_RESTART:
    466          		//case I2C_I2STAT_M_RX_START:
    467          		//case I2C_I2STAT_M_RX_RESTART
    468          			// Send data first
    469          			if(TransferCfg->tx_count < TransferCfg->tx_length)
   \                     ??I2C_MasterHanleStates_1: (+1)
   \   00000058   0x68F0             LDR      R0,[R6, #+12]
   \   0000005A   0x68B1             LDR      R1,[R6, #+8]
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD208             BCS.N    ??I2C_MasterHanleStates_9
    470          			{
    471          				/* Send slave address + WR direction bit = 0 ----------------------------------- */
    472          				I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
   \   00000060   0x6830             LDR      R0,[R6, #+0]
   \   00000062   0x0041             LSLS     R1,R0,#+1
   \   00000064   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       I2C_SendByte
    473          				Ret = I2C_BYTE_SENT;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0x4681             MOV      R9,R0
   \   00000070   0xE00D             B.N      ??I2C_MasterHanleStates_10
    474          			}
    475          			else if (TransferCfg->rx_count  < TransferCfg->rx_length)
   \                     ??I2C_MasterHanleStates_9: (+1)
   \   00000072   0x69B0             LDR      R0,[R6, #+24]
   \   00000074   0x6971             LDR      R1,[R6, #+20]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD209             BCS.N    ??I2C_MasterHanleStates_10
    476          			{
    477          				/* Send slave address + RD direction bit = 1 ----------------------------------- */
    478          				I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
   \   0000007A   0x6830             LDR      R0,[R6, #+0]
   \   0000007C   0x0040             LSLS     R0,R0,#+1
   \   0000007E   0xF050 0x0101      ORRS     R1,R0,#0x1
   \   00000082   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       I2C_SendByte
    479          				Ret = I2C_BYTE_SENT;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x4681             MOV      R9,R0
    480          			}
    481          			break;
   \                     ??I2C_MasterHanleStates_10: (+1)
   \   0000008E   0xE068             B.N      ??I2C_MasterHanleStates_11
    482          		case I2C_I2STAT_M_TX_SLAW_ACK:
    483          		case I2C_I2STAT_M_TX_DAT_ACK:
    484          			
    485          			if(TransferCfg->tx_count < TransferCfg->tx_length)
   \                     ??I2C_MasterHanleStates_2: (+1)
   \   00000090   0x68F0             LDR      R0,[R6, #+12]
   \   00000092   0x68B1             LDR      R1,[R6, #+8]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD20A             BCS.N    ??I2C_MasterHanleStates_12
    486          			{
    487          				I2C_SendByte(I2Cx, *txdat);
   \   00000098   0x7839             LDRB     R1,[R7, #+0]
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       I2C_SendByte
    488          				
    489          				txdat++;
   \   000000A0   0x1C7F             ADDS     R7,R7,#+1
    490          
    491          				TransferCfg->tx_count++;
   \   000000A2   0x68F0             LDR      R0,[R6, #+12]
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0x60F0             STR      R0,[R6, #+12]
    492          
    493          				Ret = I2C_BYTE_SENT;
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0x4681             MOV      R9,R0
   \   000000AC   0xE004             B.N      ??I2C_MasterHanleStates_13
    494          			}
    495          			else
    496          			{
    497          				I2C_Stop(I2Cx);
   \                     ??I2C_MasterHanleStates_12: (+1)
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       I2C_Stop
    498          
    499          				Ret = I2C_SEND_END;
   \   000000B4   0x2008             MOVS     R0,#+8
   \   000000B6   0x4681             MOV      R9,R0
    500          				
    501          			}
    502          			break;
   \                     ??I2C_MasterHanleStates_13: (+1)
   \   000000B8   0xE053             B.N      ??I2C_MasterHanleStates_11
    503          		case I2C_I2STAT_M_TX_DAT_NACK:
    504          			I2C_Stop(I2Cx);
   \                     ??I2C_MasterHanleStates_3: (+1)
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       I2C_Stop
    505          			Ret = I2C_SEND_END;
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x4681             MOV      R9,R0
    506          			break;
   \   000000C4   0xE04D             B.N      ??I2C_MasterHanleStates_11
    507          		case I2C_I2STAT_M_RX_ARB_LOST:
    508          		//case I2C_I2STAT_M_TX_ARB_LOST:
    509          			I2Cx->I2CONSET = I2C_I2CONSET_STA|I2C_I2CONSET_AA;
   \                     ??I2C_MasterHanleStates_4: (+1)
   \   000000C6   0x2024             MOVS     R0,#+36
   \   000000C8   0x6020             STR      R0,[R4, #+0]
    510          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000CA   0x2008             MOVS     R0,#+8
   \   000000CC   0x61A0             STR      R0,[R4, #+24]
    511          			break;
   \   000000CE   0xE048             B.N      ??I2C_MasterHanleStates_11
    512          		case I2C_I2STAT_M_RX_SLAR_ACK:
    513          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_MasterHanleStates_5: (+1)
   \   000000D0   0x2004             MOVS     R0,#+4
   \   000000D2   0x6020             STR      R0,[R4, #+0]
    514          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000D4   0x2008             MOVS     R0,#+8
   \   000000D6   0x61A0             STR      R0,[R4, #+24]
    515          
    516          			Ret = I2C_BYTE_RECV;
   \   000000D8   0x2002             MOVS     R0,#+2
   \   000000DA   0x4681             MOV      R9,R0
    517          			break;
   \   000000DC   0xE041             B.N      ??I2C_MasterHanleStates_11
    518          		case I2C_I2STAT_M_RX_DAT_ACK:
    519          			if (TransferCfg->rx_count <TransferCfg->rx_length)
   \                     ??I2C_MasterHanleStates_6: (+1)
   \   000000DE   0x69B0             LDR      R0,[R6, #+24]
   \   000000E0   0x6971             LDR      R1,[R6, #+20]
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xD21D             BCS.N    ??I2C_MasterHanleStates_14
    520          			{
    521          				if (TransferCfg->rx_count < (TransferCfg->rx_length - 2))
   \   000000E6   0x69B0             LDR      R0,[R6, #+24]
   \   000000E8   0x6971             LDR      R1,[R6, #+20]
   \   000000EA   0x1E89             SUBS     R1,R1,#+2
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xD207             BCS.N    ??I2C_MasterHanleStates_15
    522          				{
    523          					I2C_GetByte(I2Cx, &tmp, TRUE);
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0x4669             MOV      R1,SP
   \   000000F4   0x0020             MOVS     R0,R4
   \   000000F6   0x.... 0x....      BL       I2C_GetByte
    524          
    525          					Ret = I2C_BYTE_RECV;
   \   000000FA   0x2002             MOVS     R0,#+2
   \   000000FC   0x4681             MOV      R9,R0
   \   000000FE   0xE006             B.N      ??I2C_MasterHanleStates_16
    526          				}
    527          				else  // the next byte is the last byte, send NACK instead.
    528          				 {
    529          					I2C_GetByte(I2Cx, &tmp, FALSE);
   \                     ??I2C_MasterHanleStates_15: (+1)
   \   00000100   0x2200             MOVS     R2,#+0
   \   00000102   0x4669             MOV      R1,SP
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       I2C_GetByte
    530          					Ret = I2C_BYTE_RECV;
   \   0000010A   0x2002             MOVS     R0,#+2
   \   0000010C   0x4681             MOV      R9,R0
    531          				 }
    532          				*rxdat++ = tmp;
   \                     ??I2C_MasterHanleStates_16: (+1)
   \   0000010E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000112   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000116   0xF118 0x0801      ADDS     R8,R8,#+1
    533          
    534          				TransferCfg->rx_count++;
   \   0000011A   0x69B0             LDR      R0,[R6, #+24]
   \   0000011C   0x1C40             ADDS     R0,R0,#+1
   \   0000011E   0x61B0             STR      R0,[R6, #+24]
   \   00000120   0xE001             B.N      ??I2C_MasterHanleStates_17
    535          			}
    536          			 else
    537          			 {
    538          				Ret = I2C_RECV_END;
   \                     ??I2C_MasterHanleStates_14: (+1)
   \   00000122   0x2010             MOVS     R0,#+16
   \   00000124   0x4681             MOV      R9,R0
    539          			}
    540          			
    541          			break;
   \                     ??I2C_MasterHanleStates_17: (+1)
   \   00000126   0xE01C             B.N      ??I2C_MasterHanleStates_11
    542          		case I2C_I2STAT_M_RX_DAT_NACK:
    543          			I2C_GetByte(I2Cx, &tmp, FALSE);
   \                     ??I2C_MasterHanleStates_7: (+1)
   \   00000128   0x2200             MOVS     R2,#+0
   \   0000012A   0x4669             MOV      R1,SP
   \   0000012C   0x0020             MOVS     R0,R4
   \   0000012E   0x.... 0x....      BL       I2C_GetByte
    544          			*rxdat++ = tmp;
   \   00000132   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000136   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000013A   0xF118 0x0801      ADDS     R8,R8,#+1
    545          			TransferCfg->rx_count++;
   \   0000013E   0x69B0             LDR      R0,[R6, #+24]
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0x61B0             STR      R0,[R6, #+24]
    546          			I2C_Stop(I2Cx);
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x.... 0x....      BL       I2C_Stop
    547          			Ret = I2C_RECV_END;
   \   0000014A   0x2010             MOVS     R0,#+16
   \   0000014C   0x4681             MOV      R9,R0
    548          			break;
   \   0000014E   0xE008             B.N      ??I2C_MasterHanleStates_11
    549          		case I2C_I2STAT_M_RX_SLAR_NACK:
    550          		case I2C_I2STAT_M_TX_SLAW_NACK:
    551          		case I2C_I2STAT_BUS_ERROR:
    552          			// Send STOP condition
    553          			I2C_Stop(I2Cx);
   \                     ??I2C_MasterHanleStates_0: (+1)
   \   00000150   0x0020             MOVS     R0,R4
   \   00000152   0x.... 0x....      BL       I2C_Stop
    554          			Ret = I2C_ERR;
   \   00000156   0xF05F 0x5080      MOVS     R0,#+268435456
   \   0000015A   0x4681             MOV      R9,R0
    555          			break;
   \   0000015C   0xE001             B.N      ??I2C_MasterHanleStates_11
    556          		/* No status information */
    557          		case I2C_I2STAT_NO_INF:
    558          		default:
    559          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \                     ??I2C_MasterHanleStates_8: (+1)
   \   0000015E   0x2008             MOVS     R0,#+8
   \   00000160   0x61A0             STR      R0,[R4, #+24]
    560          			break;
    561          	}
    562          	
    563          	return Ret;
   \                     ??I2C_MasterHanleStates_11: (+1)
   \   00000162   0x4648             MOV      R0,R9
   \   00000164   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    564          }
    565          
    566          /*********************************************************************//**
    567           * @brief 		Handle I2C Slave states.
    568           * @param[in]	I2Cx	I2C peripheral selected, should be:
    569           * 				- LPC_I2C
    570           * 				- LPC_I2C1
    571           * 				- LPC_I2C2
    572           * @param[in]	CodeStatus	I2C state
    573           * @param[in]	TransferCfg   Pointer to a I2C_S_SETUP_Type structure that
    574           * 								contains specified information about the
    575           * 								configuration for master transfer.
    576           * @return 		It can be
    577           *				- I2C_OK
    578           *				-I2C_BYTE_RECV
    579           *				-I2C_BYTE_SENT
    580           *				-I2C_SEND_END
    581           *				-I2C_RECV_END
    582           *				- I2C_ERR
    583           *				- I2C_NAK_RECV
    584           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    585          int32_t I2C_SlaveHanleStates(LPC_I2C_TypeDef  *I2Cx, uint32_t CodeStatus, I2C_S_SETUP_Type *TransferCfg)
    586          {
   \                     I2C_SlaveHanleStates: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0003             MOVS     R3,R0
    587          
    588          	int32_t Ret = I2C_OK;
   \   00000004   0x2000             MOVS     R0,#+0
    589          	uint8_t *txdat;
    590          	uint8_t *rxdat;
    591          
    592          	//get buffer to send/receive
    593          	txdat = (uint8_t *) &TransferCfg->tx_data[TransferCfg->tx_count];
   \   00000006   0x6816             LDR      R6,[R2, #+0]
   \   00000008   0x6897             LDR      R7,[R2, #+8]
   \   0000000A   0x19BE             ADDS     R6,R7,R6
   \   0000000C   0x0034             MOVS     R4,R6
    594          	rxdat = (uint8_t *) &TransferCfg->rx_data[TransferCfg->rx_count];
   \   0000000E   0x68D6             LDR      R6,[R2, #+12]
   \   00000010   0x6957             LDR      R7,[R2, #+20]
   \   00000012   0x19BE             ADDS     R6,R7,R6
   \   00000014   0x0035             MOVS     R5,R6
    595          	
    596          	switch (CodeStatus)
   \   00000016   0x000E             MOVS     R6,R1
   \   00000018   0x2E60             CMP      R6,#+96
   \   0000001A   0xD01A             BEQ.N    ??I2C_SlaveHanleStates_0
   \   0000001C   0x2E68             CMP      R6,#+104
   \   0000001E   0xD022             BEQ.N    ??I2C_SlaveHanleStates_1
   \   00000020   0x2E70             CMP      R6,#+112
   \   00000022   0xD016             BEQ.N    ??I2C_SlaveHanleStates_0
   \   00000024   0x2E78             CMP      R6,#+120
   \   00000026   0xD019             BEQ.N    ??I2C_SlaveHanleStates_2
   \   00000028   0x2E80             CMP      R6,#+128
   \   0000002A   0xD01C             BEQ.N    ??I2C_SlaveHanleStates_1
   \   0000002C   0x2E88             CMP      R6,#+136
   \   0000002E   0xD078             BEQ.N    ??I2C_SlaveHanleStates_3
   \   00000030   0x2E90             CMP      R6,#+144
   \   00000032   0xD035             BEQ.N    ??I2C_SlaveHanleStates_4
   \   00000034   0x2E98             CMP      R6,#+152
   \   00000036   0xD074             BEQ.N    ??I2C_SlaveHanleStates_3
   \   00000038   0x2EA0             CMP      R6,#+160
   \   0000003A   0xD079             BEQ.N    ??I2C_SlaveHanleStates_5
   \   0000003C   0x2EA8             CMP      R6,#+168
   \   0000003E   0xD041             BEQ.N    ??I2C_SlaveHanleStates_6
   \   00000040   0x2EB0             CMP      R6,#+176
   \   00000042   0xD053             BEQ.N    ??I2C_SlaveHanleStates_7
   \   00000044   0x2EB8             CMP      R6,#+184
   \   00000046   0xD03D             BEQ.N    ??I2C_SlaveHanleStates_6
   \   00000048   0x2EC0             CMP      R6,#+192
   \   0000004A   0xD063             BEQ.N    ??I2C_SlaveHanleStates_8
   \   0000004C   0x2EC8             CMP      R6,#+200
   \   0000004E   0xD061             BEQ.N    ??I2C_SlaveHanleStates_8
   \   00000050   0xE075             B.N      ??I2C_SlaveHanleStates_9
    597          	{
    598          		/* Reading phase -------------------------------------------------------- */
    599          		/* Own SLA+R has been received, ACK has been returned */
    600          		case I2C_I2STAT_S_RX_SLAW_ACK:
    601          
    602          		/* General call address has been received, ACK has been returned */
    603          		case I2C_I2STAT_S_RX_GENCALL_ACK:
    604          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_0: (+1)
   \   00000052   0x2604             MOVS     R6,#+4
   \   00000054   0x601E             STR      R6,[R3, #+0]
    605          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000056   0x2608             MOVS     R6,#+8
   \   00000058   0x619E             STR      R6,[R3, #+24]
    606          			break;
   \   0000005A   0xE074             B.N      ??I2C_SlaveHanleStates_10
    607          		/* Arbitration has been lost in Slave Address + R/W bit as bus Master. General Call has
    608          			been received and ACK has been returned.*/
    609          		case I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL:
    610          			I2Cx->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;
   \                     ??I2C_SlaveHanleStates_2: (+1)
   \   0000005C   0x2624             MOVS     R6,#+36
   \   0000005E   0x601E             STR      R6,[R3, #+0]
    611          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000060   0x2608             MOVS     R6,#+8
   \   00000062   0x619E             STR      R6,[R3, #+24]
    612          			break;
   \   00000064   0xE06F             B.N      ??I2C_SlaveHanleStates_10
    613          		/* Previously addressed with own SLA;
    614          		 * DATA byte has been received;
    615          		 * ACK has been returned */
    616          		case I2C_I2STAT_S_RX_ARB_LOST_M_SLA:
    617          		case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
    618          
    619          			/*
    620          			 * All data bytes that over-flow the specified receive
    621          			 * data length, just ignore them.
    622          			 */
    623          			if ((TransferCfg->rx_count < TransferCfg->rx_length) && (TransferCfg->rx_data != NULL))
   \                     ??I2C_SlaveHanleStates_1: (+1)
   \   00000066   0x6956             LDR      R6,[R2, #+20]
   \   00000068   0x6917             LDR      R7,[R2, #+16]
   \   0000006A   0x42BE             CMP      R6,R7
   \   0000006C   0xD20A             BCS.N    ??I2C_SlaveHanleStates_11
   \   0000006E   0x68D6             LDR      R6,[R2, #+12]
   \   00000070   0x2E00             CMP      R6,#+0
   \   00000072   0xD007             BEQ.N    ??I2C_SlaveHanleStates_11
    624          			{
    625          				*rxdat++ = (uint8_t)I2Cx->I2DAT;
   \   00000074   0x689E             LDR      R6,[R3, #+8]
   \   00000076   0x702E             STRB     R6,[R5, #+0]
   \   00000078   0x1C6D             ADDS     R5,R5,#+1
    626          
    627          				TransferCfg->rx_count++;
   \   0000007A   0x6956             LDR      R6,[R2, #+20]
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
   \   0000007E   0x6156             STR      R6,[R2, #+20]
    628          
    629          				Ret = I2C_BYTE_RECV;
   \   00000080   0x2602             MOVS     R6,#+2
   \   00000082   0x0030             MOVS     R0,R6
    630          			}
    631          			if(TransferCfg->rx_count == (TransferCfg->rx_length) ) {
   \                     ??I2C_SlaveHanleStates_11: (+1)
   \   00000084   0x6956             LDR      R6,[R2, #+20]
   \   00000086   0x6917             LDR      R7,[R2, #+16]
   \   00000088   0x42BE             CMP      R6,R7
   \   0000008A   0xD104             BNE.N    ??I2C_SlaveHanleStates_12
    632          				I2Cx->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC;
   \   0000008C   0x260C             MOVS     R6,#+12
   \   0000008E   0x619E             STR      R6,[R3, #+24]
    633          				Ret = I2C_BYTE_RECV;
   \   00000090   0x2602             MOVS     R6,#+2
   \   00000092   0x0030             MOVS     R0,R6
   \   00000094   0xE003             B.N      ??I2C_SlaveHanleStates_13
    634          			}
    635          			else {
    636          				I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_12: (+1)
   \   00000096   0x2604             MOVS     R6,#+4
   \   00000098   0x601E             STR      R6,[R3, #+0]
    637          				I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000009A   0x2608             MOVS     R6,#+8
   \   0000009C   0x619E             STR      R6,[R3, #+24]
    638          			}
    639          			
    640          			break;
   \                     ??I2C_SlaveHanleStates_13: (+1)
   \   0000009E   0xE052             B.N      ??I2C_SlaveHanleStates_10
    641          		/* DATA has been received, Only the first data byte will be received with ACK. Additional
    642          				data will be received with NOT ACK. */
    643          		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
    644          			if ((TransferCfg->rx_count < TransferCfg->rx_length) && (TransferCfg->rx_data != NULL))
   \                     ??I2C_SlaveHanleStates_4: (+1)
   \   000000A0   0x6956             LDR      R6,[R2, #+20]
   \   000000A2   0x6917             LDR      R7,[R2, #+16]
   \   000000A4   0x42BE             CMP      R6,R7
   \   000000A6   0xD20A             BCS.N    ??I2C_SlaveHanleStates_14
   \   000000A8   0x68D6             LDR      R6,[R2, #+12]
   \   000000AA   0x2E00             CMP      R6,#+0
   \   000000AC   0xD007             BEQ.N    ??I2C_SlaveHanleStates_14
    645          			{
    646          				*rxdat++ = (uint8_t)I2Cx->I2DAT;
   \   000000AE   0x689E             LDR      R6,[R3, #+8]
   \   000000B0   0x702E             STRB     R6,[R5, #+0]
   \   000000B2   0x1C6D             ADDS     R5,R5,#+1
    647          
    648          				TransferCfg->rx_count++;
   \   000000B4   0x6956             LDR      R6,[R2, #+20]
   \   000000B6   0x1C76             ADDS     R6,R6,#+1
   \   000000B8   0x6156             STR      R6,[R2, #+20]
    649          
    650          				Ret = I2C_BYTE_RECV;
   \   000000BA   0x2602             MOVS     R6,#+2
   \   000000BC   0x0030             MOVS     R0,R6
    651          			}
    652          			I2Cx->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC;
   \                     ??I2C_SlaveHanleStates_14: (+1)
   \   000000BE   0x260C             MOVS     R6,#+12
   \   000000C0   0x619E             STR      R6,[R3, #+24]
    653          			break;
   \   000000C2   0xE040             B.N      ??I2C_SlaveHanleStates_10
    654          
    655          		/* Writing phase -------------------------------------------------------- */
    656          		/* Own SLA+R has been received, ACK has been returned */
    657          		case I2C_I2STAT_S_TX_SLAR_ACK:
    658          
    659          		/* Data has been transmitted, ACK has been received */
    660          		case I2C_I2STAT_S_TX_DAT_ACK:
    661          			/*
    662          			 * All data bytes that over-flow the specified receive
    663          			 * data length, just ignore them.
    664          			 */
    665          			if ((TransferCfg->tx_count < TransferCfg->tx_length) && (TransferCfg->tx_data != NULL))
   \                     ??I2C_SlaveHanleStates_6: (+1)
   \   000000C4   0x6896             LDR      R6,[R2, #+8]
   \   000000C6   0x6857             LDR      R7,[R2, #+4]
   \   000000C8   0x42BE             CMP      R6,R7
   \   000000CA   0xD20A             BCS.N    ??I2C_SlaveHanleStates_15
   \   000000CC   0x6816             LDR      R6,[R2, #+0]
   \   000000CE   0x2E00             CMP      R6,#+0
   \   000000D0   0xD007             BEQ.N    ??I2C_SlaveHanleStates_15
    666          			{
    667          				I2Cx->I2DAT = *txdat++;
   \   000000D2   0x7826             LDRB     R6,[R4, #+0]
   \   000000D4   0x609E             STR      R6,[R3, #+8]
   \   000000D6   0x1C64             ADDS     R4,R4,#+1
    668          
    669          				TransferCfg->tx_count++;
   \   000000D8   0x6896             LDR      R6,[R2, #+8]
   \   000000DA   0x1C76             ADDS     R6,R6,#+1
   \   000000DC   0x6096             STR      R6,[R2, #+8]
    670          
    671          				Ret = I2C_BYTE_SENT;
   \   000000DE   0x2601             MOVS     R6,#+1
   \   000000E0   0x0030             MOVS     R0,R6
    672          			}
    673          
    674          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_15: (+1)
   \   000000E2   0x2604             MOVS     R6,#+4
   \   000000E4   0x601E             STR      R6,[R3, #+0]
    675          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   000000E6   0x2608             MOVS     R6,#+8
   \   000000E8   0x619E             STR      R6,[R3, #+24]
    676          			break;
   \   000000EA   0xE02C             B.N      ??I2C_SlaveHanleStates_10
    677          		/* Arbitration lost in Slave Address and R/W bit as bus Master. Own Slave Address + Read
    678          				has been received, ACK has been returned. */
    679          		case I2C_I2STAT_S_TX_ARB_LOST_M_SLA:
    680          			if ((TransferCfg->tx_count < TransferCfg->tx_length) && (TransferCfg->tx_data != NULL))
   \                     ??I2C_SlaveHanleStates_7: (+1)
   \   000000EC   0x6896             LDR      R6,[R2, #+8]
   \   000000EE   0x6857             LDR      R7,[R2, #+4]
   \   000000F0   0x42BE             CMP      R6,R7
   \   000000F2   0xD20A             BCS.N    ??I2C_SlaveHanleStates_16
   \   000000F4   0x6816             LDR      R6,[R2, #+0]
   \   000000F6   0x2E00             CMP      R6,#+0
   \   000000F8   0xD007             BEQ.N    ??I2C_SlaveHanleStates_16
    681          			{
    682          				I2Cx->I2DAT = *txdat++;
   \   000000FA   0x7826             LDRB     R6,[R4, #+0]
   \   000000FC   0x609E             STR      R6,[R3, #+8]
   \   000000FE   0x1C64             ADDS     R4,R4,#+1
    683          
    684          				TransferCfg->tx_count++;
   \   00000100   0x6896             LDR      R6,[R2, #+8]
   \   00000102   0x1C76             ADDS     R6,R6,#+1
   \   00000104   0x6096             STR      R6,[R2, #+8]
    685          
    686          				Ret = I2C_BYTE_SENT;
   \   00000106   0x2601             MOVS     R6,#+1
   \   00000108   0x0030             MOVS     R0,R6
    687          			}
    688          			I2Cx->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;
   \                     ??I2C_SlaveHanleStates_16: (+1)
   \   0000010A   0x2624             MOVS     R6,#+36
   \   0000010C   0x601E             STR      R6,[R3, #+0]
    689          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   0000010E   0x2608             MOVS     R6,#+8
   \   00000110   0x619E             STR      R6,[R3, #+24]
    690          			break;
   \   00000112   0xE018             B.N      ??I2C_SlaveHanleStates_10
    691          			
    692          		case I2C_I2STAT_S_TX_LAST_DAT_ACK:
    693          		/* Data has been transmitted, NACK has been received,
    694          		 * that means there's no more data to send, exit now */
    695          		/*
    696          		 * Note: Don't wait for stop event since in slave transmit mode,
    697          		 * since there no proof lets us know when a stop signal has been received
    698          		 * on slave side.
    699          		 */
    700          		case I2C_I2STAT_S_TX_DAT_NACK:
    701          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_8: (+1)
   \   00000114   0x2604             MOVS     R6,#+4
   \   00000116   0x601E             STR      R6,[R3, #+0]
    702          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000118   0x2608             MOVS     R6,#+8
   \   0000011A   0x619E             STR      R6,[R3, #+24]
    703          			Ret = I2C_SEND_END;
   \   0000011C   0x2608             MOVS     R6,#+8
   \   0000011E   0x0030             MOVS     R0,R6
    704          			break;
   \   00000120   0xE011             B.N      ??I2C_SlaveHanleStates_10
    705          
    706          		/* Previously addressed with own SLA;
    707          		 * DATA byte has been received;
    708          		 * NOT ACK has been returned */
    709          		case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
    710          
    711          		/* DATA has been received, NOT ACK has been returned */
    712          		case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
    713          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_3: (+1)
   \   00000122   0x2604             MOVS     R6,#+4
   \   00000124   0x601E             STR      R6,[R3, #+0]
    714          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000126   0x2608             MOVS     R6,#+8
   \   00000128   0x619E             STR      R6,[R3, #+24]
    715          			Ret = I2C_RECV_END;
   \   0000012A   0x2610             MOVS     R6,#+16
   \   0000012C   0x0030             MOVS     R0,R6
    716          			break;
   \   0000012E   0xE00A             B.N      ??I2C_SlaveHanleStates_10
    717          
    718          		/*
    719          		 * Note that: Return code only let us know a stop condition mixed
    720          		 * with a repeat start condition in the same code value.
    721          		 * So we should provide a time-out. In case this is really a stop
    722          		 * condition, this will return back after time out condition. Otherwise,
    723          		 * next session that is slave receive data will be completed.
    724          		 */
    725          
    726          		/* A Stop or a repeat start condition */
    727          		case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
    728          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_5: (+1)
   \   00000130   0x2604             MOVS     R6,#+4
   \   00000132   0x601E             STR      R6,[R3, #+0]
    729          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000134   0x2608             MOVS     R6,#+8
   \   00000136   0x619E             STR      R6,[R3, #+24]
    730          			Ret = I2C_STA_STO_RECV;
   \   00000138   0x2620             MOVS     R6,#+32
   \   0000013A   0x0030             MOVS     R0,R6
    731          			break;
   \   0000013C   0xE003             B.N      ??I2C_SlaveHanleStates_10
    732          		
    733          		/* No status information */
    734          		case I2C_I2STAT_NO_INF:
    735          		/* Other status must be captured */
    736          		default:
    737          			I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \                     ??I2C_SlaveHanleStates_9: (+1)
   \   0000013E   0x2604             MOVS     R6,#+4
   \   00000140   0x601E             STR      R6,[R3, #+0]
    738          			I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000142   0x2608             MOVS     R6,#+8
   \   00000144   0x619E             STR      R6,[R3, #+24]
    739          			break;
    740          		
    741          	}
    742          
    743          	return Ret;
   \                     ??I2C_SlaveHanleStates_10: (+1)
   \   00000146   0xBCF0             POP      {R4-R7}
   \   00000148   0x4770             BX       LR               ;; return
    744          }
    745          /*********************************************************************//**
    746           * @brief 		General Master Interrupt handler for I2C peripheral
    747           * @param[in]	I2Cx	I2C peripheral selected, should be:
    748           * 				- LPC_I2C
    749           * 				- LPC_I2C1
    750           * 				- LPC_I2C2
    751           * @return 		None
    752           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    753          void I2C_MasterHandler(LPC_I2C_TypeDef  *I2Cx)
    754          {
   \                     I2C_MasterHandler: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    755          	uint32_t i2cId = I2C_getNum(I2Cx);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_getNum
   \   0000000C   0x0005             MOVS     R5,R0
    756          	uint8_t returnCode;
    757          	I2C_M_SETUP_Type *txrx_setup;
    758          	int32_t Ret = I2C_OK;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    759          
    760          	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[i2cId].txrx_setup;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   00000016   0xF850 0x0035      LDR      R0,[R0, R5, LSL #+3]
   \   0000001A   0x0007             MOVS     R7,R0
    761          
    762          	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000022   0x0006             MOVS     R6,R0
    763          
    764          	// Save current status
    765          	txrx_setup->status = returnCode;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x627E             STR      R6,[R7, #+36]
    766          
    767          	Ret = I2C_MasterHanleStates(I2Cx, returnCode, txrx_setup);
   \   00000028   0x003A             MOVS     R2,R7
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       I2C_MasterHanleStates
   \   00000034   0x4680             MOV      R8,R0
    768          
    769          	if(I2C_CheckError(Ret))
   \   00000036   0xEA5F 0x00C8      LSLS     R0,R8,#+3
   \   0000003A   0xD510             BPL.N    ??I2C_MasterHandler_0
    770          	{
    771          		if(txrx_setup->retransmissions_count < txrx_setup->retransmissions_max)
   \   0000003C   0x6A38             LDR      R0,[R7, #+32]
   \   0000003E   0x69F9             LDR      R1,[R7, #+28]
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD20B             BCS.N    ??I2C_MasterHandler_1
    772          		{
    773          			// Retry
    774          			txrx_setup->retransmissions_count ++;
   \   00000044   0x6A38             LDR      R0,[R7, #+32]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x6238             STR      R0,[R7, #+32]
    775          			txrx_setup->tx_count = 0;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x60F8             STR      R0,[R7, #+12]
    776          			txrx_setup->rx_count = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x61B8             STR      R0,[R7, #+24]
    777          			// Reset STA, STO, SI
    778          	        I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
   \   00000052   0x2038             MOVS     R0,#+56
   \   00000054   0x61A0             STR      R0,[R4, #+24]
    779          			I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   00000056   0x2020             MOVS     R0,#+32
   \   00000058   0x6020             STR      R0,[R4, #+0]
    780          			return;
   \   0000005A   0xE01B             B.N      ??I2C_MasterHandler_2
    781          		}
    782          		else
    783          		{
    784          			goto s_int_end;
   \                     ??I2C_MasterHandler_1: (+1)
   \   0000005C   0xE00F             B.N      ??I2C_MasterHandler_3
    785          		}
    786          	}
    787          	else if (Ret & I2C_SEND_END)
   \                     ??I2C_MasterHandler_0: (+1)
   \   0000005E   0xEA5F 0x7008      LSLS     R0,R8,#+28
   \   00000062   0xD508             BPL.N    ??I2C_MasterHandler_4
    788          	{
    789          		// If no need to wait for data from Slave
    790          		if(txrx_setup->rx_count >= (txrx_setup->rx_length)) 
   \   00000064   0x69B8             LDR      R0,[R7, #+24]
   \   00000066   0x6979             LDR      R1,[R7, #+20]
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD208             BCS.N    ??I2C_MasterHandler_3
    791          		{
    792          			goto s_int_end;
    793          		}
    794          		else	// Start to wait for data from Slave
    795          		{
    796          			// Reset STA, STO, SI
    797          	       		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
   \                     ??I2C_MasterHandler_5: (+1)
   \   0000006C   0x2038             MOVS     R0,#+56
   \   0000006E   0x61A0             STR      R0,[R4, #+24]
    798          	       		I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   00000070   0x2020             MOVS     R0,#+32
   \   00000072   0x6020             STR      R0,[R4, #+0]
    799          	       		return;
   \   00000074   0xE00E             B.N      ??I2C_MasterHandler_2
    800          		}
    801          	}
    802          	else if (Ret & I2C_RECV_END) 
   \                     ??I2C_MasterHandler_4: (+1)
   \   00000076   0xEA5F 0x60C8      LSLS     R0,R8,#+27
   \   0000007A   0xD400             BMI.N    ??I2C_MasterHandler_3
    803          	{
    804          		goto s_int_end;
    805          	}
    806          	else
    807          	{
    808          		return;
   \                     ??I2C_MasterHandler_6: (+1)
   \   0000007C   0xE00A             B.N      ??I2C_MasterHandler_2
    809          	}
    810          
    811          s_int_end:
    812          	// Disable interrupt
    813          	I2C_IntCmd(I2Cx, FALSE);
   \                     ??I2C_MasterHandler_3: (+1)
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       I2C_IntCmd
    814          
    815          	I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000086   0x202C             MOVS     R0,#+44
   \   00000088   0x61A0             STR      R0,[R4, #+24]
    816          
    817          	I2C_MasterComplete[i2cId] = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable18_7
   \   00000090   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    818          		
    819          }
   \                     ??I2C_MasterHandler_2: (+1)
   \   00000094   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    820          
    821          
    822          /*********************************************************************//**
    823           * @brief 		General Slave Interrupt handler for I2C peripheral
    824           * @param[in]	I2Cx	I2C peripheral selected, should be:
    825           *  			- LPC_I2C0
    826           *  			- LPC_I2C1
    827           *  			- LPC_I2C2
    828           * @return 		None
    829           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    830          void I2C_SlaveHandler (LPC_I2C_TypeDef  *I2Cx)
    831          {
   \                     I2C_SlaveHandler: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    832          	uint32_t i2cId = I2C_getNum(I2Cx);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0x.... 0x....      BL       I2C_getNum
   \   0000000C   0x0005             MOVS     R5,R0
    833          	uint8_t returnCode;
    834          	I2C_S_SETUP_Type *txrx_setup;
    835          	uint32_t timeout;
    836          	int32_t Ret = I2C_OK;
   \   0000000E   0xF05F 0x0900      MOVS     R9,#+0
    837          
    838          	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[i2cId].txrx_setup;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_6
   \   00000016   0xF850 0x0035      LDR      R0,[R0, R5, LSL #+3]
   \   0000001A   0x0007             MOVS     R7,R0
    839          
    840          handle_state:
    841          
    842          	returnCode = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \                     ??I2C_SlaveHandler_0: (+1)
   \   0000001C   0x6860             LDR      R0,[R4, #+4]
   \   0000001E   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000022   0x0006             MOVS     R6,R0
    843          	// Save current status
    844          	txrx_setup->status = returnCode;
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x61BE             STR      R6,[R7, #+24]
    845          
    846          
    847          	Ret = I2C_SlaveHanleStates(I2Cx, returnCode, txrx_setup);
   \   00000028   0x003A             MOVS     R2,R7
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x.... 0x....      BL       I2C_SlaveHanleStates
   \   00000034   0x4681             MOV      R9,R0
    848          
    849          	if(I2C_CheckError(Ret))
   \   00000036   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   0000003A   0xD41F             BMI.N    ??I2C_SlaveHandler_1
    850          	{
    851          		goto s_int_end;
    852          	}
    853          	else if (Ret & I2C_STA_STO_RECV)
   \                     ??I2C_SlaveHandler_2: (+1)
   \   0000003C   0xEA5F 0x6089      LSLS     R0,R9,#+26
   \   00000040   0xD518             BPL.N    ??I2C_SlaveHandler_3
    854          	{
    855          		// Temporally lock the interrupt for timeout condition
    856          		I2C_IntCmd(I2Cx, FALSE);
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       I2C_IntCmd
    857          		// enable time out
    858          		timeout = I2C_SLAVE_TIME_OUT;
   \   0000004A   0xF45F 0x3080      MOVS     R0,#+65536
   \   0000004E   0x4680             MOV      R8,R0
    859          		while(1)
    860          		{
    861          			if (I2Cx->I2CONSET & I2C_I2CONSET_SI)
   \                     ??I2C_SlaveHandler_4: (+1)
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x0700             LSLS     R0,R0,#+28
   \   00000054   0xD504             BPL.N    ??I2C_SlaveHandler_5
    862          			{
    863          				// re-Enable interrupt
    864          				I2C_IntCmd(I2Cx, TRUE);
   \   00000056   0x2101             MOVS     R1,#+1
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0x.... 0x....      BL       I2C_IntCmd
    865          				goto handle_state;
   \   0000005E   0xE7DD             B.N      ??I2C_SlaveHandler_0
    866          			}
    867          			else
    868          			{
    869          				timeout--;
   \                     ??I2C_SlaveHandler_5: (+1)
   \   00000060   0xF1B8 0x0801      SUBS     R8,R8,#+1
    870          				if (timeout == 0)
   \   00000064   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000068   0xD1F2             BNE.N    ??I2C_SlaveHandler_4
    871          				{
    872          					// timeout occur, it's really a stop condition
    873          					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
   \   0000006A   0x69B8             LDR      R0,[R7, #+24]
   \   0000006C   0xF450 0x6080      ORRS     R0,R0,#0x400
   \   00000070   0x61B8             STR      R0,[R7, #+24]
    874          					goto s_int_end;
   \   00000072   0xE003             B.N      ??I2C_SlaveHandler_1
    875          				}
    876          			}
    877          		}	
    878          	}
    879          	else if(Ret &I2C_SEND_END)
   \                     ??I2C_SlaveHandler_3: (+1)
   \   00000074   0xEA5F 0x7009      LSLS     R0,R9,#+28
   \   00000078   0xD400             BMI.N    ??I2C_SlaveHandler_1
    880          	{
    881          		goto s_int_end;
    882          	}
    883          	else
    884          	{
    885          		return;
   \                     ??I2C_SlaveHandler_6: (+1)
   \   0000007A   0xE00A             B.N      ??I2C_SlaveHandler_7
    886          	}
    887          
    888          s_int_end:
    889          	// Disable interrupt
    890          	I2C_IntCmd(I2Cx, FALSE);
   \                     ??I2C_SlaveHandler_1: (+1)
   \   0000007C   0x2100             MOVS     R1,#+0
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0x.... 0x....      BL       I2C_IntCmd
    891          	I2Cx->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   00000084   0x202C             MOVS     R0,#+44
   \   00000086   0x61A0             STR      R0,[R4, #+24]
    892          
    893          	I2C_SlaveComplete[i2cId] = TRUE;
   \   00000088   0x2001             MOVS     R0,#+1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable18_8
   \   0000008E   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    894          }
   \                     ??I2C_SlaveHandler_7: (+1)
   \   00000092   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    895          
    896          /*********************************************************************//**
    897           * @brief 		Transmit and Receive data in master mode
    898           * @param[in]	I2Cx			I2C peripheral selected, should be:
    899           *  			- LPC_I2C0
    900           * 				- LPC_I2C1
    901           * 				- LPC_I2C2
    902           * @param[in]	TransferCfg		Pointer to a I2C_M_SETUP_Type structure that
    903           * 								contains specified information about the
    904           * 								configuration for master transfer.
    905           * @param[in]	Opt				a I2C_TRANSFER_OPT_Type type that selected for
    906           * 								interrupt or polling mode.
    907           * @return 		SUCCESS or ERROR
    908           *
    909           * Note:
    910           * - In case of using I2C to transmit data only, either transmit length set to 0
    911           * or transmit data pointer set to NULL.
    912           * - In case of using I2C to receive data only, either receive length set to 0
    913           * or receive data pointer set to NULL.
    914           * - In case of using I2C to transmit followed by receive data, transmit length,
    915           * transmit data pointer, receive length and receive data pointer should be set
    916           * corresponding.
    917           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    918          Status I2C_MasterTransferData(LPC_I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
    919          																	I2C_TRANSFER_OPT_Type Opt)
    920          {
   \                     I2C_MasterTransferData: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    921          	uint32_t i2cId = I2C_getNum(I2Cx);	uint32_t CodeStatus;
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       I2C_getNum
   \   00000010   0x0007             MOVS     R7,R0
    922          	int32_t Ret = I2C_OK;
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
    923          
    924          	// Reset I2C setup value to default state
    925          	TransferCfg->tx_count = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x60E8             STR      R0,[R5, #+12]
    926          	TransferCfg->rx_count = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x61A8             STR      R0,[R5, #+24]
    927          	TransferCfg->status = 0;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6268             STR      R0,[R5, #+36]
    928          
    929          	if (Opt == I2C_TRANSFER_POLLING)
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD13B             BNE.N    ??I2C_MasterTransferData_0
    930          	{
    931          		/* First Start condition -------------------------------------------------------------- */
    932          		TransferCfg->retransmissions_count = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6228             STR      R0,[R5, #+32]
    933          retry:
    934          		// Reset I2C setup value to default state
    935          		TransferCfg->tx_count = 0;
   \                     ??I2C_MasterTransferData_1: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x60E8             STR      R0,[R5, #+12]
    936          		TransferCfg->rx_count = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x61A8             STR      R0,[R5, #+24]
    937          
    938          		// Start command
    939          		CodeStatus = I2C_Start(I2Cx);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x.... 0x....      BL       I2C_Start
   \   0000003A   0x4680             MOV      R8,R0
    940          		
    941          		while(1)	// send data first and then receive data from Slave.
    942          		{
    943          			Ret = I2C_MasterHanleStates(I2Cx, CodeStatus, TransferCfg);
   \                     ??I2C_MasterTransferData_2: (+1)
   \   0000003C   0x002A             MOVS     R2,R5
   \   0000003E   0x4641             MOV      R1,R8
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       I2C_MasterHanleStates
   \   00000046   0x4681             MOV      R9,R0
    944          			if(I2C_CheckError(Ret))
   \   00000048   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   0000004C   0xD50C             BPL.N    ??I2C_MasterTransferData_3
    945          			{
    946          				TransferCfg->retransmissions_count++;
   \   0000004E   0x6A28             LDR      R0,[R5, #+32]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x6228             STR      R0,[R5, #+32]
    947          				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
   \   00000054   0x69E8             LDR      R0,[R5, #+28]
   \   00000056   0x6A29             LDR      R1,[R5, #+32]
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD204             BCS.N    ??I2C_MasterTransferData_4
    948          						// save status
    949          						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
   \   0000005C   0xF458 0x7000      ORRS     R0,R8,#0x200
   \   00000060   0x6268             STR      R0,[R5, #+36]
    950          						goto error;
    951          					} else {
    952          						goto retry;
    953          					}
    954          			}
    955          			else if( (Ret & I2C_BYTE_SENT) ||
    956          					(Ret & I2C_BYTE_RECV))
    957          			{
    958          				// Wait for sending ends				
    959          				while (!(I2Cx->I2CONSET & I2C_I2CONSET_SI));
    960          			}
    961          			else if (Ret & I2C_SEND_END) // already send all data
    962          			{
    963          				// If no need to wait for data from Slave
    964          				if(TransferCfg->rx_count >= (TransferCfg->rx_length)) 
    965          				{
    966          					break;
    967          				}
    968          				else
    969          				{
    970          					I2C_Start(I2Cx);
    971          				}
    972          			}
    973          			else if (Ret & I2C_RECV_END) // already receive all data
    974          			{
    975          				break;
    976          			}
    977                       		CodeStatus = I2Cx->I2STAT & I2C_STAT_CODE_BITMASK;
    978          		}
    979          		return SUCCESS;
    980          error:
    981          		return ERROR;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xE032             B.N      ??I2C_MasterTransferData_5
   \                     ??I2C_MasterTransferData_4: (+1)
   \   00000066   0xE7E1             B.N      ??I2C_MasterTransferData_1
   \                     ??I2C_MasterTransferData_3: (+1)
   \   00000068   0xF019 0x0F03      TST      R9,#0x3
   \   0000006C   0xD003             BEQ.N    ??I2C_MasterTransferData_6
   \                     ??I2C_MasterTransferData_7: (+1)
   \   0000006E   0x6820             LDR      R0,[R4, #+0]
   \   00000070   0x0700             LSLS     R0,R0,#+28
   \   00000072   0xD40E             BMI.N    ??I2C_MasterTransferData_8
   \   00000074   0xE7FB             B.N      ??I2C_MasterTransferData_7
   \                     ??I2C_MasterTransferData_6: (+1)
   \   00000076   0xEA5F 0x7009      LSLS     R0,R9,#+28
   \   0000007A   0xD507             BPL.N    ??I2C_MasterTransferData_9
   \   0000007C   0x69A8             LDR      R0,[R5, #+24]
   \   0000007E   0x6969             LDR      R1,[R5, #+20]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD20B             BCS.N    ??I2C_MasterTransferData_10
   \                     ??I2C_MasterTransferData_11: (+1)
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       I2C_Start
   \   0000008A   0xE002             B.N      ??I2C_MasterTransferData_8
   \                     ??I2C_MasterTransferData_9: (+1)
   \   0000008C   0xEA5F 0x60C9      LSLS     R0,R9,#+27
   \   00000090   0xD404             BMI.N    ??I2C_MasterTransferData_10
   \                     ??I2C_MasterTransferData_8: (+1)
   \   00000092   0x6860             LDR      R0,[R4, #+4]
   \   00000094   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000098   0x4680             MOV      R8,R0
   \   0000009A   0xE7CF             B.N      ??I2C_MasterTransferData_2
   \                     ??I2C_MasterTransferData_10: (+1)
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE015             B.N      ??I2C_MasterTransferData_5
    982          	}
    983          
    984          	else if (Opt == I2C_TRANSFER_INTERRUPT)
   \                     ??I2C_MasterTransferData_0: (+1)
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0x2E01             CMP      R6,#+1
   \   000000A4   0xD111             BNE.N    ??I2C_MasterTransferData_12
    985          	{
    986          		// Setup tx_rx data, callback and interrupt handler
    987          		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
   \   000000A6   0x....             LDR.N    R0,??DataTable18_6
   \   000000A8   0xF840 0x5037      STR      R5,[R0, R7, LSL #+3]
    988          
    989          		// Set direction phase, write first
    990          		i2cdat[i2cId].dir = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x....             LDR.N    R1,??DataTable18_6
   \   000000B0   0xEB11 0x01C7      ADDS     R1,R1,R7, LSL #+3
   \   000000B4   0x6048             STR      R0,[R1, #+4]
    991          
    992          		/* First Start condition -------------------------------------------------------------- */
    993          		// Reset STA, STO, SI
    994          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC|I2C_I2CONCLR_STOC|I2C_I2CONCLR_STAC;
   \   000000B6   0x2038             MOVS     R0,#+56
   \   000000B8   0x61A0             STR      R0,[R4, #+24]
    995          		I2Cx->I2CONSET = I2C_I2CONSET_STA;
   \   000000BA   0x2020             MOVS     R0,#+32
   \   000000BC   0x6020             STR      R0,[R4, #+0]
    996          
    997          		I2C_IntCmd(I2Cx, TRUE);
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x0020             MOVS     R0,R4
   \   000000C2   0x.... 0x....      BL       I2C_IntCmd
    998          
    999          		return (SUCCESS);
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xE000             B.N      ??I2C_MasterTransferData_5
   1000          	}
   1001          
   1002          	return ERROR;
   \                     ??I2C_MasterTransferData_12: (+1)
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??I2C_MasterTransferData_5: (+1)
   \   000000CC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1003          }
   1004          
   1005          /*********************************************************************//**
   1006           * @brief 		Receive and Transmit data in slave mode
   1007           * @param[in]	I2Cx			I2C peripheral selected, should be
   1008           *    			- LPC_I2C0
   1009           * 				- LPC_I2C1
   1010           * 				- LPC_I2C2
   1011           * @param[in]	TransferCfg		Pointer to a I2C_S_SETUP_Type structure that
   1012           * 								contains specified information about the
   1013           * 								configuration for master transfer.
   1014           * @param[in]	Opt				I2C_TRANSFER_OPT_Type type that selected for
   1015           * 								interrupt or polling mode.
   1016           * @return 		SUCCESS or ERROR
   1017           *
   1018           * Note:
   1019           * The mode of slave's operation depends on the command sent from master on
   1020           * the I2C bus. If the master send a SLA+W command, this sub-routine will
   1021           * use receive data length and receive data pointer. If the master send a SLA+R
   1022           * command, this sub-routine will use transmit data length and transmit data
   1023           * pointer.
   1024           * If the master issue an repeat start command or a stop command, the slave will
   1025           * enable an time out condition, during time out condition, if there's no activity
   1026           * on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W),
   1027           * the slave then switch to relevant operation mode. The time out should be used
   1028           * because the return status code can not show difference from stop and repeat
   1029           * start command in slave operation.
   1030           * In case of the expected data length from master is greater than data length
   1031           * that slave can support:
   1032           * - In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR
   1033           * value.
   1034           * - In case of writing operation (from master): slave will ignore remain data from master.
   1035           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1036          Status I2C_SlaveTransferData(LPC_I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
   1037          								I2C_TRANSFER_OPT_Type Opt)
   1038          {
   \                     I2C_SlaveTransferData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1039          	int32_t   Ret = I2C_OK;
   \   0000000A   0x2700             MOVS     R7,#+0
   1040          	
   1041          	uint32_t CodeStatus;
   1042          	uint32_t timeout;
   1043          	int32_t time_en;
   1044          	uint32_t i2cId = I2C_getNum(I2Cx);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       I2C_getNum
   \   00000012   0x4682             MOV      R10,R0
   1045          	// Reset I2C setup value to default state
   1046          	TransferCfg->tx_count = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x60A8             STR      R0,[R5, #+8]
   1047          	TransferCfg->rx_count = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6168             STR      R0,[R5, #+20]
   1048          	TransferCfg->status = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x61A8             STR      R0,[R5, #+24]
   1049          
   1050          	// Polling option
   1051          	if (Opt == I2C_TRANSFER_POLLING)
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0x2E00             CMP      R6,#+0
   \   00000024   0xD138             BNE.N    ??I2C_SlaveTransferData_0
   1052          	{
   1053          		/* Set AA bit to ACK command on I2C bus */
   1054          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x6020             STR      R0,[R4, #+0]
   1055          		
   1056          		/* Clear SI bit to be ready ... */
   1057          		I2Cx->I2CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC|I2C_I2CONCLR_STOC);
   \   0000002A   0x2038             MOVS     R0,#+56
   \   0000002C   0x61A0             STR      R0,[R4, #+24]
   1058          
   1059          		time_en = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x4681             MOV      R9,R0
   1060          		timeout = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4683             MOV      R11,R0
   1061          
   1062          		while (1)
   1063          		{
   1064          			/* Check SI flag ready */
   1065          			if (I2Cx->I2CONSET & I2C_I2CONSET_SI)
   \                     ??I2C_SlaveTransferData_1: (+1)
   \   00000036   0x6820             LDR      R0,[R4, #+0]
   \   00000038   0x0700             LSLS     R0,R0,#+28
   \   0000003A   0xD51D             BPL.N    ??I2C_SlaveTransferData_2
   1066          			{
   1067          				time_en = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x4681             MOV      R9,R0
   1068          
   1069          				CodeStatus = (I2Cx->I2STAT & I2C_STAT_CODE_BITMASK);
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF010 0x00F8      ANDS     R0,R0,#0xF8
   \   00000046   0x4680             MOV      R8,R0
   1070          
   1071          				Ret = I2C_SlaveHanleStates(I2Cx, CodeStatus, TransferCfg);
   \   00000048   0x002A             MOVS     R2,R5
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       I2C_SlaveHanleStates
   \   00000052   0x0007             MOVS     R7,R0
   1072          				if(I2C_CheckError(Ret))
   \   00000054   0x00F8             LSLS     R0,R7,#+3
   \   00000056   0xD505             BPL.N    ??I2C_SlaveTransferData_3
   1073          				{
   1074          					goto s_error;
   1075          				}
   1076          				else if(Ret & I2C_STA_STO_RECV)
   1077          				{
   1078          					time_en = 1;
   1079          					timeout = 0;
   1080          				}
   1081                          else if (Ret & I2C_SEND_END)
   1082                          {
   1083                              goto s_end_stage;
   1084                          }
   1085          			}
   1086          			else if (time_en)
   1087          			{
   1088          				if (timeout++ > I2C_SLAVE_TIME_OUT)
   1089          				{
   1090          					// it's really a stop condition, goto end stage
   1091          					goto s_end_stage;
   1092          				}
   1093          			}
   1094          		}
   1095          
   1096          s_end_stage:
   1097          		/* Clear AA bit to disable ACK on I2C bus */
   1098          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   1099          
   1100          		// Check if there's no error during operation
   1101          		// Update status
   1102          		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
   1103          		return SUCCESS;
   1104          
   1105          s_error:
   1106          		/* Clear AA bit to disable ACK on I2C bus */
   1107          		I2Cx->I2CONCLR = I2C_I2CONCLR_AAC;
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0x61A0             STR      R0,[R4, #+24]
   1108          
   1109          		// Update status
   1110          		TransferCfg->status = CodeStatus;
   \   0000005C   0xF8C5 0x8018      STR      R8,[R5, #+24]
   1111          		return ERROR;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE02F             B.N      ??I2C_SlaveTransferData_4
   \                     ??I2C_SlaveTransferData_3: (+1)
   \   00000064   0x06B8             LSLS     R0,R7,#+26
   \   00000066   0xD504             BPL.N    ??I2C_SlaveTransferData_5
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x4681             MOV      R9,R0
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0xE7E1             B.N      ??I2C_SlaveTransferData_1
   \                     ??I2C_SlaveTransferData_5: (+1)
   \   00000072   0x0738             LSLS     R0,R7,#+28
   \   00000074   0xD5DF             BPL.N    ??I2C_SlaveTransferData_1
   \   00000076   0xE008             B.N      ??I2C_SlaveTransferData_6
   \                     ??I2C_SlaveTransferData_2: (+1)
   \   00000078   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000007C   0xD0DB             BEQ.N    ??I2C_SlaveTransferData_1
   \   0000007E   0x4658             MOV      R0,R11
   \   00000080   0xF110 0x0B01      ADDS     R11,R0,#+1
   \   00000084   0xF1B0 0x1F01      CMP      R0,#+65537
   \   00000088   0xD3D5             BCC.N    ??I2C_SlaveTransferData_1
   \                     ??I2C_SlaveTransferData_6: (+1)
   \   0000008A   0x2004             MOVS     R0,#+4
   \   0000008C   0x61A0             STR      R0,[R4, #+24]
   \   0000008E   0xF458 0x6080      ORRS     R0,R8,#0x400
   \   00000092   0x61A8             STR      R0,[R5, #+24]
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0xE015             B.N      ??I2C_SlaveTransferData_4
   1112          	}
   1113          
   1114          	else if (Opt == I2C_TRANSFER_INTERRUPT)
   \                     ??I2C_SlaveTransferData_0: (+1)
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x2E01             CMP      R6,#+1
   \   0000009C   0xD111             BNE.N    ??I2C_SlaveTransferData_7
   1115          	{
   1116          		// Setup tx_rx data, callback and interrupt handler
   1117          		i2cdat[i2cId].txrx_setup = (uint32_t) TransferCfg;
   \   0000009E   0x....             LDR.N    R0,??DataTable18_6
   \   000000A0   0xF840 0x503A      STR      R5,[R0, R10, LSL #+3]
   1118          
   1119          		// Set direction phase, read first
   1120          		i2cdat[i2cId].dir = 1;
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0x....             LDR.N    R1,??DataTable18_6
   \   000000A8   0xEB11 0x01CA      ADDS     R1,R1,R10, LSL #+3
   \   000000AC   0x6048             STR      R0,[R1, #+4]
   1121          
   1122          		// Enable AA
   1123          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   000000AE   0x2004             MOVS     R0,#+4
   \   000000B0   0x6020             STR      R0,[R4, #+0]
   1124          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   000000B2   0x2028             MOVS     R0,#+40
   \   000000B4   0x61A0             STR      R0,[R4, #+24]
   1125          		I2C_IntCmd(I2Cx, TRUE);
   \   000000B6   0x2101             MOVS     R1,#+1
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       I2C_IntCmd
   1126          
   1127          		return (SUCCESS);
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0xE000             B.N      ??I2C_SlaveTransferData_4
   1128          	}
   1129          
   1130          	return ERROR;
   \                     ??I2C_SlaveTransferData_7: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \                     ??I2C_SlaveTransferData_4: (+1)
   \   000000C4   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1131          }
   1132          
   1133          /*********************************************************************//**
   1134           * @brief		Set Own slave address in I2C peripheral corresponding to
   1135           * 				parameter specified in OwnSlaveAddrConfigStruct.
   1136           * @param[in]	I2Cx	I2C peripheral selected, should be
   1137           *    			- LPC_I2C0
   1138           * 				- LPC_I2C1
   1139           * 				- LPC_I2C2
   1140           * @param[in]	OwnSlaveAddrConfigStruct	Pointer to a I2C_OWNSLAVEADDR_CFG_Type
   1141           * 				structure that contains the configuration information for the
   1142          *               specified I2C slave address.
   1143           * @return 		None
   1144           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1145          void I2C_SetOwnSlaveAddr(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
   1146          {
   \                     I2C_SetOwnSlaveAddr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1147          	uint32_t tmp;
   1148          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   00000012   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??I2C_SetOwnSlaveAddr_0
   \   00000018   0xF240 0x417C      MOVW     R1,#+1148
   \   0000001C   0x....             LDR.N    R0,??DataTable18_5
   \   0000001E   0x.... 0x....      BL       check_failed
   1149          	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct->SlaveAddrChannel));
   \                     ??I2C_SetOwnSlaveAddr_0: (+1)
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0x2804             CMP      R0,#+4
   \   00000026   0xDB04             BLT.N    ??I2C_SetOwnSlaveAddr_1
   \   00000028   0xF240 0x417D      MOVW     R1,#+1149
   \   0000002C   0x....             LDR.N    R0,??DataTable18_5
   \   0000002E   0x.... 0x....      BL       check_failed
   1150          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct->GeneralCallState));
   \                     ??I2C_SetOwnSlaveAddr_1: (+1)
   \   00000032   0x78A8             LDRB     R0,[R5, #+2]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD007             BEQ.N    ??I2C_SetOwnSlaveAddr_2
   \   00000038   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD004             BEQ.N    ??I2C_SetOwnSlaveAddr_2
   \   0000003E   0xF240 0x417E      MOVW     R1,#+1150
   \   00000042   0x....             LDR.N    R0,??DataTable18_5
   \   00000044   0x.... 0x....      BL       check_failed
   1151          
   1152          	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
   1153          			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
   \                     ??I2C_SetOwnSlaveAddr_2: (+1)
   \   00000048   0x78A8             LDRB     R0,[R5, #+2]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD101             BNE.N    ??I2C_SetOwnSlaveAddr_3
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??I2C_SetOwnSlaveAddr_4
   \                     ??I2C_SetOwnSlaveAddr_3: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??I2C_SetOwnSlaveAddr_4: (+1)
   \   00000054   0x7869             LDRB     R1,[R5, #+1]
   \   00000056   0xEA50 0x0041      ORRS     R0,R0,R1, LSL #+1
   \   0000005A   0xB2C6             UXTB     R6,R0            ;; ZeroExt  R6,R0,#+24,#+24
   1154          	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
   \   0000005C   0x7828             LDRB     R0,[R5, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD005             BEQ.N    ??I2C_SetOwnSlaveAddr_5
   \   00000062   0x2802             CMP      R0,#+2
   \   00000064   0xD00F             BEQ.N    ??I2C_SetOwnSlaveAddr_6
   \   00000066   0xD308             BCC.N    ??I2C_SetOwnSlaveAddr_7
   \   00000068   0x2803             CMP      R0,#+3
   \   0000006A   0xD012             BEQ.N    ??I2C_SetOwnSlaveAddr_8
   \   0000006C   0xE016             B.N      ??I2C_SetOwnSlaveAddr_9
   1155          	{
   1156          	case 0:
   1157          		I2Cx->I2ADR0 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_5: (+1)
   \   0000006E   0x60E6             STR      R6,[R4, #+12]
   1158          		I2Cx->I2MASK0 = I2C_I2MASK_MASK((uint32_t) \
   1159          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000070   0x78E8             LDRB     R0,[R5, #+3]
   \   00000072   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000076   0x6320             STR      R0,[R4, #+48]
   1160          		break;
   \   00000078   0xE010             B.N      ??I2C_SetOwnSlaveAddr_9
   1161          	case 1:
   1162          		I2Cx->I2ADR1 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_7: (+1)
   \   0000007A   0x6226             STR      R6,[R4, #+32]
   1163          		I2Cx->I2MASK1 = I2C_I2MASK_MASK((uint32_t) \
   1164          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   0000007C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000007E   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000082   0x6360             STR      R0,[R4, #+52]
   1165          		break;
   \   00000084   0xE00A             B.N      ??I2C_SetOwnSlaveAddr_9
   1166          	case 2:
   1167          		I2Cx->I2ADR2 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_6: (+1)
   \   00000086   0x6266             STR      R6,[R4, #+36]
   1168          		I2Cx->I2MASK2 = I2C_I2MASK_MASK((uint32_t) \
   1169          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000088   0x78E8             LDRB     R0,[R5, #+3]
   \   0000008A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000008E   0x63A0             STR      R0,[R4, #+56]
   1170          		break;
   \   00000090   0xE004             B.N      ??I2C_SetOwnSlaveAddr_9
   1171          	case 3:
   1172          		I2Cx->I2ADR3 = tmp;
   \                     ??I2C_SetOwnSlaveAddr_8: (+1)
   \   00000092   0x62A6             STR      R6,[R4, #+40]
   1173          		I2Cx->I2MASK3 = I2C_I2MASK_MASK((uint32_t) \
   1174          				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
   \   00000094   0x78E8             LDRB     R0,[R5, #+3]
   \   00000096   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000009A   0x63E0             STR      R0,[R4, #+60]
   1175          		break;
   1176          	}
   1177          }
   \                     ??I2C_SetOwnSlaveAddr_9: (+1)
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
   1178          
   1179          
   1180          /*********************************************************************//**
   1181           * @brief		Configures functionality in I2C monitor mode
   1182           * @param[in]	I2Cx	I2C peripheral selected, should be
   1183           *   			- LPC_I2C0
   1184           * 				- LPC_I2C1
   1185           * 				- LPC_I2C2
   1186           * @param[in]	MonitorCfgType Monitor Configuration type, should be:
   1187           * 				- I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch'
   1188           * 				the clock line (hold it low) until it has had time to
   1189           * 				respond to an I2C interrupt.
   1190           * 				- I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1'
   1191           * 				and the I2C is in monitor mode, an interrupt will be
   1192           * 				generated on ANY address received.
   1193           * @param[in]	NewState New State of this function, should be:
   1194           * 				- ENABLE: Enable this function.
   1195           * 				- DISABLE: Disable this function.
   1196           * @return		None
   1197           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1198          void I2C_MonitorModeConfig(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
   1199          {
   \                     I2C_MonitorModeConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1200          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000008   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00A             BEQ.N    ??I2C_MonitorModeConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD007             BEQ.N    ??I2C_MonitorModeConfig_0
   \   00000014   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD004             BEQ.N    ??I2C_MonitorModeConfig_0
   \   0000001A   0xF44F 0x6196      MOV      R1,#+1200
   \   0000001E   0x....             LDR.N    R0,??DataTable18_5
   \   00000020   0x.... 0x....      BL       check_failed
   1201          	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
   1202          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??I2C_MonitorModeConfig_0: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD007             BEQ.N    ??I2C_MonitorModeConfig_1
   \   0000002A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002C   0x2E01             CMP      R6,#+1
   \   0000002E   0xD004             BEQ.N    ??I2C_MonitorModeConfig_1
   \   00000030   0xF240 0x41B2      MOVW     R1,#+1202
   \   00000034   0x....             LDR.N    R0,??DataTable18_5
   \   00000036   0x.... 0x....      BL       check_failed
   1203          
   1204          	if (NewState == ENABLE)
   \                     ??I2C_MonitorModeConfig_1: (+1)
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD103             BNE.N    ??I2C_MonitorModeConfig_2
   1205          	{
   1206          		I2Cx->MMCTRL |= MonitorCfgType;
   \   00000040   0x69E0             LDR      R0,[R4, #+28]
   \   00000042   0x4328             ORRS     R0,R5,R0
   \   00000044   0x61E0             STR      R0,[R4, #+28]
   \   00000046   0xE005             B.N      ??I2C_MonitorModeConfig_3
   1207          	}
   1208          	else
   1209          	{
   1210          		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeConfig_2: (+1)
   \   00000048   0x69E0             LDR      R0,[R4, #+28]
   \   0000004A   0x43E9             MVNS     R1,R5
   \   0000004C   0xF011 0x0107      ANDS     R1,R1,#0x7
   \   00000050   0x4008             ANDS     R0,R1,R0
   \   00000052   0x61E0             STR      R0,[R4, #+28]
   1211          	}
   1212          }
   \                     ??I2C_MonitorModeConfig_3: (+1)
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   1213          
   1214          
   1215          /*********************************************************************//**
   1216           * @brief		Enable/Disable I2C monitor mode
   1217           * @param[in]	I2Cx	I2C peripheral selected, should be
   1218           *    			- LPC_I2C0
   1219           * 				- LPC_I2C1
   1220           * 				- LPC_I2C2
   1221           * @param[in]	NewState New State of this function, should be:
   1222           * 				- ENABLE: Enable monitor mode.
   1223           * 				- DISABLE: Disable monitor mode.
   1224           * @return		None
   1225           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1226          void I2C_MonitorModeCmd(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)
   1227          {
   \                     I2C_MonitorModeCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1228          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000006   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00A             BEQ.N    ??I2C_MonitorModeCmd_0
   \   0000000C   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD007             BEQ.N    ??I2C_MonitorModeCmd_0
   \   00000012   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??I2C_MonitorModeCmd_0
   \   00000018   0xF240 0x41CC      MOVW     R1,#+1228
   \   0000001C   0x....             LDR.N    R0,??DataTable18_5
   \   0000001E   0x.... 0x....      BL       check_failed
   1229          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??I2C_MonitorModeCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD007             BEQ.N    ??I2C_MonitorModeCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD004             BEQ.N    ??I2C_MonitorModeCmd_1
   \   0000002E   0xF240 0x41CD      MOVW     R1,#+1229
   \   00000032   0x....             LDR.N    R0,??DataTable18_5
   \   00000034   0x.... 0x....      BL       check_failed
   1230          
   1231          	if (NewState == ENABLE)
   \                     ??I2C_MonitorModeCmd_1: (+1)
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD108             BNE.N    ??I2C_MonitorModeCmd_2
   1232          	{
   1233          		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
   \   0000003E   0x69E0             LDR      R0,[R4, #+28]
   \   00000040   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000044   0x61E0             STR      R0,[R4, #+28]
   1234          		I2Cx->I2CONSET = I2C_I2CONSET_AA;
   \   00000046   0x2004             MOVS     R0,#+4
   \   00000048   0x6020             STR      R0,[R4, #+0]
   1235          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
   \   0000004A   0x2028             MOVS     R0,#+40
   \   0000004C   0x61A0             STR      R0,[R4, #+24]
   \   0000004E   0xE005             B.N      ??I2C_MonitorModeCmd_3
   1236          	}
   1237          	else
   1238          	{
   1239          		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
   \                     ??I2C_MonitorModeCmd_2: (+1)
   \   00000050   0x69E0             LDR      R0,[R4, #+28]
   \   00000052   0xF010 0x0006      ANDS     R0,R0,#0x6
   \   00000056   0x61E0             STR      R0,[R4, #+28]
   1240          		I2Cx->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_AAC;
   \   00000058   0x202C             MOVS     R0,#+44
   \   0000005A   0x61A0             STR      R0,[R4, #+24]
   1241          	}
   1242          	I2C_MonitorBufferIndex = 0;
   \                     ??I2C_MonitorModeCmd_3: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x....             LDR.N    R1,??DataTable18_9
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1243          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1244          
   1245          
   1246          /*********************************************************************//**
   1247           * @brief		Get data from I2C data buffer in monitor mode.
   1248           * @param[in]	I2Cx	I2C peripheral selected, should be
   1249           *    			- LPC_I2C0
   1250           * 				- LPC_I2C1
   1251           * 				- LPC_I2C2
   1252           * @return		None
   1253           * Note:	In monitor mode, the I2C module may lose the ability to stretch
   1254           * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
   1255           * the processor will have a limited amount of time to read the contents of
   1256           * the data received on the bus. If the processor reads the I2DAT shift
   1257           * register, as it ordinarily would, it could have only one bit-time to
   1258           * respond to the interrupt before the received data is overwritten by
   1259           * new data.
   1260           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1261          uint8_t I2C_MonitorGetDatabuffer(LPC_I2C_TypeDef *I2Cx)
   1262          {
   \                     I2C_MonitorGetDatabuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1263          	CHECK_PARAM(PARAM_I2Cx(I2Cx));
   \   00000004   0x....             LDR.N    R0,??DataTable18_2  ;; 0x4001c000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD00A             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   0000000A   0x....             LDR.N    R0,??DataTable18_3  ;; 0x4005c000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD007             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   00000010   0x....             LDR.N    R0,??DataTable18_4  ;; 0x400a0000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??I2C_MonitorGetDatabuffer_0
   \   00000016   0xF240 0x41EF      MOVW     R1,#+1263
   \   0000001A   0x....             LDR.N    R0,??DataTable18_5
   \   0000001C   0x.... 0x....      BL       check_failed
   1264          	return ((uint8_t)(I2Cx->I2DATA_BUFFER));
   \                     ??I2C_MonitorGetDatabuffer_0: (+1)
   \   00000020   0x6AE0             LDR      R0,[R4, #+44]
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
   1265          }
   1266          
   1267          /*********************************************************************//**
   1268           * @brief		Get data from I2C data buffer in monitor mode.
   1269           * @param[in]	I2Cx	I2C peripheral selected, should be
   1270           *    			- LPC_I2C0
   1271           * 				- LPC_I2C1
   1272           * 				- LPC_I2C2
   1273           * @return		None
   1274           * Note:	In monitor mode, the I2C module may lose the ability to stretch
   1275           * the clock (stall the bus) if the ENA_SCL bit is not set. This means that
   1276           * the processor will have a limited amount of time to read the contents of
   1277           * the data received on the bus. If the processor reads the I2DAT shift
   1278           * register, as it ordinarily would, it could have only one bit-time to
   1279           * respond to the interrupt before the received data is overwritten by
   1280           * new data.
   1281           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1282          BOOL_8 I2C_MonitorHandler(LPC_I2C_TypeDef *I2Cx, uint8_t *buffer, uint32_t size)
   1283          {
   \                     I2C_MonitorHandler: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0003             MOVS     R3,R0
   1284          	BOOL_8 ret=FALSE;
   \   00000004   0x2000             MOVS     R0,#+0
   1285          
   1286          	I2Cx->I2CONCLR = I2C_I2CONCLR_SIC;
   \   00000006   0x2408             MOVS     R4,#+8
   \   00000008   0x619C             STR      R4,[R3, #+24]
   1287          
   1288          	buffer[I2C_MonitorBufferIndex] = (uint8_t)(I2Cx->I2DATA_BUFFER);
   \   0000000A   0x6ADC             LDR      R4,[R3, #+44]
   \   0000000C   0x....             LDR.N    R5,??DataTable18_9
   \   0000000E   0x682D             LDR      R5,[R5, #+0]
   \   00000010   0x546C             STRB     R4,[R5, R1]
   1289          	I2C_MonitorBufferIndex++;
   \   00000012   0x....             LDR.N    R4,??DataTable18_9
   \   00000014   0x6824             LDR      R4,[R4, #+0]
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \   00000018   0x....             LDR.N    R5,??DataTable18_9
   \   0000001A   0x602C             STR      R4,[R5, #+0]
   1290          	if(I2C_MonitorBufferIndex >= size)
   \   0000001C   0x....             LDR.N    R4,??DataTable18_9
   \   0000001E   0x6824             LDR      R4,[R4, #+0]
   \   00000020   0x4294             CMP      R4,R2
   \   00000022   0xD301             BCC.N    ??I2C_MonitorHandler_0
   1291          	{
   1292          		ret = TRUE;
   \   00000024   0x2401             MOVS     R4,#+1
   \   00000026   0x0020             MOVS     R0,R4
   1293          	}
   1294          	return ret;
   \                     ??I2C_MonitorHandler_0: (+1)
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0x4770             BX       LR               ;; return
   1295          }
   1296          /*********************************************************************//**
   1297           * @brief 		Get status of Master Transfer
   1298           * @param[in]	I2Cx	I2C peripheral selected, should be:
   1299           *  			- LPC_I2C0
   1300           * 				- LPC_I2C1
   1301           * 				- LPC_I2C2
   1302           * @return 		Master transfer status, could be:
   1303           * 				- TRUE	master transfer completed
   1304           * 				- FALSE master transfer have not completed yet
   1305           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1306          uint32_t I2C_MasterTransferComplete(LPC_I2C_TypeDef *I2Cx)
   1307          {
   \                     I2C_MasterTransferComplete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1308          	uint32_t retval, tmp;
   1309          	tmp = I2C_getNum(I2Cx);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       I2C_getNum
   \   0000000A   0x0006             MOVS     R6,R0
   1310          	retval = I2C_MasterComplete[tmp];
   \   0000000C   0x....             LDR.N    R0,??DataTable18_7
   \   0000000E   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000012   0x0005             MOVS     R5,R0
   1311          	I2C_MasterComplete[tmp] = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable18_7
   \   00000018   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   1312          	return retval;
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   1313          }
   1314          
   1315          /*********************************************************************//**
   1316           * @brief 		Get status of Slave Transfer
   1317           * @param[in]	I2Cx	I2C peripheral selected, should be:
   1318           * 				- LPC_I2C0
   1319           * 				- LPC_I2C1
   1320           * 				- LPC_I2C2
   1321           * @return 		Complete status, could be: TRUE/FALSE
   1322           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1323          uint32_t I2C_SlaveTransferComplete(LPC_I2C_TypeDef *I2Cx)
   1324          {
   \                     I2C_SlaveTransferComplete: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1325          	uint32_t retval, tmp;
   1326          	tmp = I2C_getNum(I2Cx);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       I2C_getNum
   \   0000000A   0x0006             MOVS     R6,R0
   1327          	retval = I2C_SlaveComplete[tmp];
   \   0000000C   0x....             LDR.N    R0,??DataTable18_8
   \   0000000E   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000012   0x0005             MOVS     R5,R0
   1328          	I2C_SlaveComplete[tmp] = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable18_8
   \   00000018   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   1329          	return retval;
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
   1330          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x4001C000         DC32     0x4001c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x4005C000         DC32     0x4005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x400A0000         DC32     0x400a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x........         DC32     i2cdat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x........         DC32     I2C_MasterComplete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     I2C_SlaveComplete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     I2C_MonitorBufferIndex

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0xCD          DC8 30H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H, 0BFH
   \              0xB3 0xBC    
   \              0xC6 0xC4    
   \              0xA3 0xBF    
   \   00000018   0xE9 0x5C          DC8 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000020   0x72 0x65          DC8 72H, 65H, 5CH, 43H, 53H, 42H, 5CH, 73H
   \              0x5C 0x43    
   \              0x53 0x42    
   \              0x5C 0x73    
   \   00000028   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH, 70H
   \              0x72 0x63    
   \              0x65 0x5C    
   \              0x6C 0x70    
   \   00000030   0x63 0x31          DC8 63H, 31H, 37H, 78H, 78H, 5FH, 69H, 32H
   \              0x37 0x78    
   \              0x78 0x5F    
   \              0x69 0x32    
   \   00000038   0x63 0x2E          DC8 63H, 2EH, 63H, 0
   \              0x63 0x00    
   1331          
   1332          
   1333          
   1334          /**
   1335           * @}
   1336           */
   1337          
   1338          #endif /* _I2C */
   1339          
   1340          /**
   1341           * @}
   1342           */
   1343          
   1344          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   I2C_Cmd
        16   -> check_failed
       8   I2C_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
       0   I2C_GetByte
      16   I2C_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> CLKPWR_SetPCLKDiv
        16   -> I2C_SetClock
        16   -> check_failed
      16   I2C_IntCmd
        16   -> NVIC_DisableIRQ
        16   -> NVIC_EnableIRQ
      24   I2C_MasterHandler
        24   -> I2C_IntCmd
        24   -> I2C_MasterHanleStates
        24   -> I2C_getNum
      32   I2C_MasterHanleStates
        32   -> I2C_GetByte
        32   -> I2C_SendByte
        32   -> I2C_Stop
      16   I2C_MasterTransferComplete
        16   -> I2C_getNum
      32   I2C_MasterTransferData
        32   -> I2C_IntCmd
        32   -> I2C_MasterHanleStates
        32   -> I2C_Start
        32   -> I2C_getNum
       8   I2C_MonitorGetDatabuffer
         8   -> check_failed
       8   I2C_MonitorHandler
      16   I2C_MonitorModeCmd
        16   -> check_failed
      16   I2C_MonitorModeConfig
        16   -> check_failed
       0   I2C_SendByte
      16   I2C_SetClock
        16   -> CLKPWR_GetPCLK
        16   -> check_failed
      16   I2C_SetOwnSlaveAddr
        16   -> check_failed
      32   I2C_SlaveHandler
        32   -> I2C_IntCmd
        32   -> I2C_SlaveHanleStates
        32   -> I2C_getNum
      16   I2C_SlaveHanleStates
      16   I2C_SlaveTransferComplete
        16   -> I2C_getNum
      40   I2C_SlaveTransferData
        40   -> I2C_IntCmd
        40   -> I2C_SlaveHanleStates
        40   -> I2C_getNum
       0   I2C_Start
       0   I2C_Stop
       0   I2C_getNum
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      60  ?_0
      98  I2C_Cmd
     102  I2C_DeInit
      32  I2C_GetByte
     140  I2C_Init
     108  I2C_IntCmd
      12  I2C_MasterComplete
     152  I2C_MasterHandler
     360  I2C_MasterHanleStates
      32  I2C_MasterTransferComplete
     208  I2C_MasterTransferData
       4  I2C_MonitorBufferIndex
      38  I2C_MonitorGetDatabuffer
      46  I2C_MonitorHandler
     100  I2C_MonitorModeCmd
      86  I2C_MonitorModeConfig
      58  I2C_SendByte
     116  I2C_SetClock
     158  I2C_SetOwnSlaveAddr
      12  I2C_SlaveComplete
     150  I2C_SlaveHandler
     330  I2C_SlaveHanleStates
      32  I2C_SlaveTransferComplete
     200  I2C_SlaveTransferData
      26  I2C_Start
      20  I2C_Stop
      44  I2C_getNum
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      24  i2cdat

 
    52 bytes in section .bss
    60 bytes in section .rodata
 2 720 bytes in section .text
 
 2 720 bytes of CODE  memory
    60 bytes of CONST memory
    52 bytes of DATA  memory

Errors: none
Warnings: none
