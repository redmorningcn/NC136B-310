###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/Aug/2017  10:56:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_uart.c
#    Command line =  
#        "F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_uart.c" -lCN
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -I "F:\iar\NC136B-310 统计模块\Application\Library\csnr_package_deal\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_uart.lst
#    Object file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_uart.o
#
###############################################################################

F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_uart.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_uart.c			2011-06-06
      3          *//**
      4          * @file		lpc17xx_uart.c
      5          * @brief	Contains all functions support for UART firmware library
      6          * 			on LPC17xx
      7          * @version	3.2
      8          * @date		25. July. 2011
      9          * @author	NXP MCU SW Application Team
     10          *
     11          * Copyright(C) 2011, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          * Permission to use, copy, modify, and distribute this software and its
     26          * documentation is hereby granted, under NXP Semiconductors'
     27          * relevant copyright in the software, without fee, provided that it
     28          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     29          * copyright, permission, and disclaimer notice must appear in all copies of
     30          * this code.
     31          **********************************************************************/
     32          
     33          /* Peripheral group ----------------------------------------------------------- */
     34          /** @addtogroup UART
     35           * @{
     36           */
     37          
     38          /* Includes ------------------------------------------------------------------- */
     39          #include "lpc17xx_uart.h"
     40          #include "lpc17xx_clkpwr.h"
     41          
     42          /* If this source file built with example, the LPC17xx FW library configuration
     43           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     44           * otherwise the default FW library configuration file must be included instead
     45           */
     46          #ifdef __BUILD_WITH_EXAMPLE__
     47          #include "lpc17xx_libcfg.h"
     48          #else
     49          #include "lpc17xx_libcfg_default.h"
     50          #endif /* __BUILD_WITH_EXAMPLE__ */
     51          
     52          
     53          #ifdef _UART
     54          
     55          /* Private Functions ---------------------------------------------------------- */
     56          
     57          static Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate);
     58          
     59          
     60          /*********************************************************************//**
     61           * @brief		Determines best dividers to get a target clock rate
     62           * @param[in]	UARTx	Pointer to selected UART peripheral, should be:
     63           * 				- LPC_UART0: UART0 peripheral
     64           * 				- LPC_UART1: UART1 peripheral
     65           * 				- LPC_UART2: UART2 peripheral
     66           * 				- LPC_UART3: UART3 peripheral
     67           * @param[in]	baudrate Desired UART baud rate.
     68           * @return 		Error status, could be:
     69           * 				- SUCCESS
     70           * 				- ERROR
     71           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     72          static Status uart_set_divisors(LPC_UART_TypeDef *UARTx, uint32_t baudrate)
     73          {
   \                     uart_set_divisors: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
     74          	Status errorStatus = ERROR;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0008      STRB     R0,[SP, #+8]
     75          
     76          	uint32_t uClk;
     77          	uint32_t d, m, bestd, bestm, tmp;
     78          	uint64_t best_divisor, divisor;
     79          	uint32_t current_error, best_error;
     80          	uint32_t recalcbaud;
     81          
     82          	/* get UART block clock */
     83          	if (UARTx == (LPC_UART_TypeDef *)LPC_UART0)
   \   0000000C   0x980B             LDR      R0,[SP, #+44]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable13  ;; 0x4000c000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD104             BNE.N    ??uart_set_divisors_0
     84          	{
     85          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART0);
   \   00000016   0x2006             MOVS     R0,#+6
   \   00000018   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000001C   0x9005             STR      R0,[SP, #+20]
   \   0000001E   0xE01C             B.N      ??uart_set_divisors_1
     86          	}
     87          	else if (UARTx == (LPC_UART_TypeDef *)LPC_UART1)
   \                     ??uart_set_divisors_0: (+1)
   \   00000020   0x980B             LDR      R0,[SP, #+44]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40010000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD104             BNE.N    ??uart_set_divisors_2
     88          	{
     89          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART1);
   \   0000002A   0x2008             MOVS     R0,#+8
   \   0000002C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000030   0x9005             STR      R0,[SP, #+20]
   \   00000032   0xE012             B.N      ??uart_set_divisors_1
     90          	}
     91          	else if (UARTx == LPC_UART2)
   \                     ??uart_set_divisors_2: (+1)
   \   00000034   0x980B             LDR      R0,[SP, #+44]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable13_1  ;; 0x40098000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD104             BNE.N    ??uart_set_divisors_3
     92          	{
     93          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART2);
   \   0000003E   0x2030             MOVS     R0,#+48
   \   00000040   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000044   0x9005             STR      R0,[SP, #+20]
   \   00000046   0xE008             B.N      ??uart_set_divisors_1
     94          	}
     95          	else if (UARTx == LPC_UART3)
   \                     ??uart_set_divisors_3: (+1)
   \   00000048   0x980B             LDR      R0,[SP, #+44]
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable13_2  ;; 0x4009c000
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD103             BNE.N    ??uart_set_divisors_1
     96          	{
     97          		uClk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_UART3);
   \   00000052   0x2032             MOVS     R0,#+50
   \   00000054   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000058   0x9005             STR      R0,[SP, #+20]
     98          	}
     99          
    100          
    101          	/* In the Uart IP block, baud rate is calculated using FDR and DLL-DLM registers
    102          	* The formula is :
    103          	* BaudRate= uClk * (mulFracDiv/(mulFracDiv+dividerAddFracDiv) / (16 * (DLL)
    104          	* It involves floating point calculations. That's the reason the formulae are adjusted with
    105          	* Multiply and divide method.*/
    106          	/* The value of mulFracDiv and dividerAddFracDiv should comply to the following expressions:
    107          	* 0 < mulFracDiv <= 15, 0 <= dividerAddFracDiv <= 15 */
    108          	best_error = 0xFFFFFFFF; /* Worst case */
   \                     ??uart_set_divisors_1: (+1)
   \   0000005A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000005E   0x9003             STR      R0,[SP, #+12]
    109          	bestd = 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9006             STR      R0,[SP, #+24]
    110          	bestm = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x9004             STR      R0,[SP, #+16]
    111          	best_divisor = 0;
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
    112          	for (m = 1 ; m <= 15 ;m++)
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x4683             MOV      R11,R0
   \                     ??uart_set_divisors_4: (+1)
   \   00000074   0xF1BB 0x0F10      CMP      R11,#+16
   \   00000078   0xD243             BCS.N    ??uart_set_divisors_5
    113          	{
    114          		for (d = 0 ; d < m ; d++)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x4682             MOV      R10,R0
   \                     ??uart_set_divisors_6: (+1)
   \   0000007E   0x45DA             CMP      R10,R11
   \   00000080   0xD239             BCS.N    ??uart_set_divisors_7
    115          		{
    116          		  divisor = ((uint64_t)uClk<<28)*m/(baudrate*(m+d));
   \   00000082   0xF8DD 0x8014      LDR      R8,[SP, #+20]
   \   00000086   0xF05F 0x0900      MOVS     R9,#+0
   \   0000008A   0xEA5F 0x7909      LSLS     R9,R9,#+28
   \   0000008E   0xEA49 0x1918      ORR      R9,R9,R8, LSR #+4
   \   00000092   0xEA5F 0x7808      LSLS     R8,R8,#+28
   \   00000096   0x465A             MOV      R2,R11
   \   00000098   0x2300             MOVS     R3,#+0
   \   0000009A   0xFBA2 0x0108      UMULL    R0,R1,R2,R8
   \   0000009E   0xFB02 0x1109      MLA      R1,R2,R9,R1
   \   000000A2   0xFB03 0x1108      MLA      R1,R3,R8,R1
   \   000000A6   0x9A0C             LDR      R2,[SP, #+48]
   \   000000A8   0xEB1A 0x030B      ADDS     R3,R10,R11
   \   000000AC   0x435A             MULS     R2,R3,R2
   \   000000AE   0x2300             MOVS     R3,#+0
   \   000000B0   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000B4   0x0004             MOVS     R4,R0
   \   000000B6   0x000D             MOVS     R5,R1
    117          		  current_error = divisor & 0xFFFFFFFF;
   \   000000B8   0x0027             MOVS     R7,R4
    118          
    119          		  tmp = divisor>>32;
   \   000000BA   0x002E             MOVS     R6,R5
    120          
    121          		  /* Adjust error */
    122          		  if(current_error > ((uint32_t)1<<31)){
   \   000000BC   0xF1B7 0x4F00      CMP      R7,#-2147483648
   \   000000C0   0xD901             BLS.N    ??uart_set_divisors_8
    123          			current_error = -current_error;
   \   000000C2   0x427F             RSBS     R7,R7,#+0
    124          			tmp++;
   \   000000C4   0x1C76             ADDS     R6,R6,#+1
    125          			}
    126          
    127          		  if(tmp<1 || tmp>65536) /* Out of range */
   \                     ??uart_set_divisors_8: (+1)
   \   000000C6   0x2E00             CMP      R6,#+0
   \   000000C8   0xD002             BEQ.N    ??uart_set_divisors_9
   \   000000CA   0xF1B6 0x1F01      CMP      R6,#+65537
   \   000000CE   0xD300             BCC.N    ??uart_set_divisors_10
    128          		  continue;
   \                     ??uart_set_divisors_9: (+1)
   \   000000D0   0xE00E             B.N      ??uart_set_divisors_11
    129          
    130          		  if( current_error < best_error){
   \                     ??uart_set_divisors_10: (+1)
   \   000000D2   0x9803             LDR      R0,[SP, #+12]
   \   000000D4   0x4287             CMP      R7,R0
   \   000000D6   0xD20B             BCS.N    ??uart_set_divisors_11
    131          			best_error = current_error;
   \   000000D8   0x9703             STR      R7,[SP, #+12]
    132          			best_divisor = tmp;
   \   000000DA   0x0030             MOVS     R0,R6
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0xE9CD 0x0108      STRD     R0,R1,[SP, #+32]
    133          			bestd = d;
   \   000000E2   0xF8CD 0xA018      STR      R10,[SP, #+24]
    134          			bestm = m;
   \   000000E6   0xF8CD 0xB010      STR      R11,[SP, #+16]
    135          			if(best_error == 0) break;
   \   000000EA   0x9803             LDR      R0,[SP, #+12]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD002             BEQ.N    ??uart_set_divisors_7
    136          			}
    137          		} /* end of inner for loop */
   \                     ??uart_set_divisors_11: (+1)
   \   000000F0   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000F4   0xE7C3             B.N      ??uart_set_divisors_6
    138          
    139          		if (best_error == 0)
   \                     ??uart_set_divisors_7: (+1)
   \   000000F6   0x9803             LDR      R0,[SP, #+12]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD002             BEQ.N    ??uart_set_divisors_5
    140          		  break;
    141          	} /* end of outer for loop  */
   \                     ??uart_set_divisors_12: (+1)
   \   000000FC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000100   0xE7B8             B.N      ??uart_set_divisors_4
    142          
    143          	if(best_divisor == 0) return ERROR; /* can not find best match */
   \                     ??uart_set_divisors_5: (+1)
   \   00000102   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000106   0x2900             CMP      R1,#+0
   \   00000108   0xD103             BNE.N    ??uart_set_divisors_13
   \   0000010A   0x2800             CMP      R0,#+0
   \   0000010C   0xD101             BNE.N    ??uart_set_divisors_13
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0xE077             B.N      ??uart_set_divisors_14
    144          
    145          	recalcbaud = (uClk>>4) * bestm/(best_divisor * (bestm + bestd));
   \                     ??uart_set_divisors_13: (+1)
   \   00000112   0x9805             LDR      R0,[SP, #+20]
   \   00000114   0x0900             LSRS     R0,R0,#+4
   \   00000116   0x9904             LDR      R1,[SP, #+16]
   \   00000118   0x4348             MULS     R0,R1,R0
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000120   0xE9DD 0x8908      LDRD     R8,R9,[SP, #+32]
   \   00000124   0x9804             LDR      R0,[SP, #+16]
   \   00000126   0x9906             LDR      R1,[SP, #+24]
   \   00000128   0x1808             ADDS     R0,R1,R0
   \   0000012A   0x2100             MOVS     R1,#+0
   \   0000012C   0xFBA0 0x2308      UMULL    R2,R3,R0,R8
   \   00000130   0xFB00 0x3309      MLA      R3,R0,R9,R3
   \   00000134   0xFB01 0x3308      MLA      R3,R1,R8,R3
   \   00000138   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   0000013C   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000140   0x9007             STR      R0,[SP, #+28]
    146          
    147          	/* reuse best_error to evaluate baud error*/
    148          	if(baudrate>recalcbaud) best_error = baudrate - recalcbaud;
   \   00000142   0x9807             LDR      R0,[SP, #+28]
   \   00000144   0x990C             LDR      R1,[SP, #+48]
   \   00000146   0x4288             CMP      R0,R1
   \   00000148   0xD204             BCS.N    ??uart_set_divisors_15
   \   0000014A   0x980C             LDR      R0,[SP, #+48]
   \   0000014C   0x9907             LDR      R1,[SP, #+28]
   \   0000014E   0x1A40             SUBS     R0,R0,R1
   \   00000150   0x9003             STR      R0,[SP, #+12]
   \   00000152   0xE003             B.N      ??uart_set_divisors_16
    149          	else best_error = recalcbaud -baudrate;
   \                     ??uart_set_divisors_15: (+1)
   \   00000154   0x9807             LDR      R0,[SP, #+28]
   \   00000156   0x990C             LDR      R1,[SP, #+48]
   \   00000158   0x1A40             SUBS     R0,R0,R1
   \   0000015A   0x9003             STR      R0,[SP, #+12]
    150          
    151          	best_error = best_error * 100 / baudrate;
   \                     ??uart_set_divisors_16: (+1)
   \   0000015C   0x9803             LDR      R0,[SP, #+12]
   \   0000015E   0x2164             MOVS     R1,#+100
   \   00000160   0x4348             MULS     R0,R1,R0
   \   00000162   0x990C             LDR      R1,[SP, #+48]
   \   00000164   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000168   0x9003             STR      R0,[SP, #+12]
    152          
    153          	if (best_error < UART_ACCEPTED_BAUDRATE_ERROR)
   \   0000016A   0x9803             LDR      R0,[SP, #+12]
   \   0000016C   0x2803             CMP      R0,#+3
   \   0000016E   0xD246             BCS.N    ??uart_set_divisors_17
    154          		{
    155          			if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000170   0x980B             LDR      R0,[SP, #+44]
   \   00000172   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x40010000
   \   00000176   0x4288             CMP      R0,R1
   \   00000178   0xD11F             BNE.N    ??uart_set_divisors_18
    156          			{
    157          				((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   0000017A   0x980B             LDR      R0,[SP, #+44]
   \   0000017C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000017E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000182   0x990B             LDR      R1,[SP, #+44]
   \   00000184   0x7308             STRB     R0,[R1, #+12]
    158          				((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
   \   00000186   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   0000018A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000018C   0x0A00             LSRS     R0,R0,#+8
   \   0000018E   0x990B             LDR      R1,[SP, #+44]
   \   00000190   0x7108             STRB     R0,[R1, #+4]
    159          				((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
   \   00000192   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   00000196   0x990B             LDR      R1,[SP, #+44]
   \   00000198   0x7008             STRB     R0,[R1, #+0]
    160          				/* Then reset DLAB bit */
    161          				((LPC_UART1_TypeDef *)UARTx)->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   0000019A   0x980B             LDR      R0,[SP, #+44]
   \   0000019C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000019E   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000001A2   0x990B             LDR      R1,[SP, #+44]
   \   000001A4   0x7308             STRB     R0,[R1, #+12]
    162          				((LPC_UART1_TypeDef *)UARTx)->FDR = (UART_FDR_MULVAL(bestm) \
    163          						| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   000001A6   0x9804             LDR      R0,[SP, #+16]
   \   000001A8   0x9906             LDR      R1,[SP, #+24]
   \   000001AA   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000001AE   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   000001B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B4   0x990B             LDR      R1,[SP, #+44]
   \   000001B6   0x6288             STR      R0,[R1, #+40]
   \   000001B8   0xE01E             B.N      ??uart_set_divisors_19
    164          			}
    165          			else
    166          			{
    167          				UARTx->LCR |= UART_LCR_DLAB_EN;
   \                     ??uart_set_divisors_18: (+1)
   \   000001BA   0x980B             LDR      R0,[SP, #+44]
   \   000001BC   0x7B00             LDRB     R0,[R0, #+12]
   \   000001BE   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000001C2   0x990B             LDR      R1,[SP, #+44]
   \   000001C4   0x7308             STRB     R0,[R1, #+12]
    168          				UARTx->/*DLIER.*/DLM = UART_LOAD_DLM(best_divisor);
   \   000001C6   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   000001CA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000001CC   0x0A00             LSRS     R0,R0,#+8
   \   000001CE   0x990B             LDR      R1,[SP, #+44]
   \   000001D0   0x7108             STRB     R0,[R1, #+4]
    169          				UARTx->/*RBTHDLR.*/DLL = UART_LOAD_DLL(best_divisor);
   \   000001D2   0xE9DD 0x0108      LDRD     R0,R1,[SP, #+32]
   \   000001D6   0x990B             LDR      R1,[SP, #+44]
   \   000001D8   0x7008             STRB     R0,[R1, #+0]
    170          				/* Then reset DLAB bit */
    171          				UARTx->LCR &= (~UART_LCR_DLAB_EN) & UART_LCR_BITMASK;
   \   000001DA   0x980B             LDR      R0,[SP, #+44]
   \   000001DC   0x7B00             LDRB     R0,[R0, #+12]
   \   000001DE   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000001E2   0x990B             LDR      R1,[SP, #+44]
   \   000001E4   0x7308             STRB     R0,[R1, #+12]
    172          				UARTx->FDR = (UART_FDR_MULVAL(bestm) \
    173          						| UART_FDR_DIVADDVAL(bestd)) & UART_FDR_BITMASK;
   \   000001E6   0x9804             LDR      R0,[SP, #+16]
   \   000001E8   0x9906             LDR      R1,[SP, #+24]
   \   000001EA   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   000001EE   0xEA51 0x1000      ORRS     R0,R1,R0, LSL #+4
   \   000001F2   0x990B             LDR      R1,[SP, #+44]
   \   000001F4   0xF881 0x0028      STRB     R0,[R1, #+40]
    174          			}
    175          			errorStatus = SUCCESS;
   \                     ??uart_set_divisors_19: (+1)
   \   000001F8   0x2001             MOVS     R0,#+1
   \   000001FA   0xF88D 0x0008      STRB     R0,[SP, #+8]
    176          		}
    177          
    178          		return errorStatus;
   \                     ??uart_set_divisors_17: (+1)
   \   000001FE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \                     ??uart_set_divisors_14: (+1)
   \   00000202   0xB00D             ADD      SP,SP,#+52
   \   00000204   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    179          }
    180          
    181          /* End of Private Functions ---------------------------------------------------- */
    182          
    183          
    184          /* Public Functions ----------------------------------------------------------- */
    185          /** @addtogroup UART_Public_Functions
    186           * @{
    187           */
    188          /* UART Init/DeInit functions -------------------------------------------------*/
    189          /********************************************************************//**
    190           * @brief		Initializes the UARTx peripheral according to the specified
    191           *               parameters in the UART_ConfigStruct.
    192           * @param[in]	UARTx	UART peripheral selected, should be:
    193           *   			- LPC_UART0: UART0 peripheral
    194           * 				- LPC_UART1: UART1 peripheral
    195           * 				- LPC_UART2: UART2 peripheral
    196           * 				- LPC_UART3: UART3 peripheral
    197           * @param[in]	UART_ConfigStruct Pointer to a UART_CFG_Type structure
    198          *                    that contains the configuration information for the
    199          *                    specified UART peripheral.
    200           * @return 		None
    201           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    202          void UART_Init(LPC_UART_TypeDef *UARTx, UART_CFG_Type *UART_ConfigStruct)
    203          {
   \                     UART_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    204          	uint32_t tmp;
    205          
    206          	// For debug mode
    207          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD010             BEQ.N    ??UART_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00C             BEQ.N    ??UART_Init_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD008             BEQ.N    ??UART_Init_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD004             BEQ.N    ??UART_Init_0
   \   00000026   0x21CF             MOVS     R1,#+207
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
    208          	CHECK_PARAM(PARAM_UART_DATABIT(UART_ConfigStruct->Databits));
   \                     ??UART_Init_0: (+1)
   \   00000030   0x7968             LDRB     R0,[R5, #+5]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD00D             BEQ.N    ??UART_Init_1
   \   00000036   0x7968             LDRB     R0,[R5, #+5]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD00A             BEQ.N    ??UART_Init_1
   \   0000003C   0x7968             LDRB     R0,[R5, #+5]
   \   0000003E   0x2802             CMP      R0,#+2
   \   00000040   0xD007             BEQ.N    ??UART_Init_1
   \   00000042   0x7968             LDRB     R0,[R5, #+5]
   \   00000044   0x2803             CMP      R0,#+3
   \   00000046   0xD004             BEQ.N    ??UART_Init_1
   \   00000048   0x21D0             MOVS     R1,#+208
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000004E   0x.... 0x....      BL       check_failed
    209          	CHECK_PARAM(PARAM_UART_STOPBIT(UART_ConfigStruct->Stopbits));
   \                     ??UART_Init_1: (+1)
   \   00000052   0x79A8             LDRB     R0,[R5, #+6]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD007             BEQ.N    ??UART_Init_2
   \   00000058   0x79A8             LDRB     R0,[R5, #+6]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD004             BEQ.N    ??UART_Init_2
   \   0000005E   0x21D1             MOVS     R1,#+209
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000064   0x.... 0x....      BL       check_failed
    210          	CHECK_PARAM(PARAM_UART_PARITY(UART_ConfigStruct->Parity));
   \                     ??UART_Init_2: (+1)
   \   00000068   0x7928             LDRB     R0,[R5, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD010             BEQ.N    ??UART_Init_3
   \   0000006E   0x7928             LDRB     R0,[R5, #+4]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD00D             BEQ.N    ??UART_Init_3
   \   00000074   0x7928             LDRB     R0,[R5, #+4]
   \   00000076   0x2802             CMP      R0,#+2
   \   00000078   0xD00A             BEQ.N    ??UART_Init_3
   \   0000007A   0x7928             LDRB     R0,[R5, #+4]
   \   0000007C   0x2803             CMP      R0,#+3
   \   0000007E   0xD007             BEQ.N    ??UART_Init_3
   \   00000080   0x7928             LDRB     R0,[R5, #+4]
   \   00000082   0x2804             CMP      R0,#+4
   \   00000084   0xD004             BEQ.N    ??UART_Init_3
   \   00000086   0x21D2             MOVS     R1,#+210
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000008C   0x.... 0x....      BL       check_failed
    211          
    212          #ifdef _UART0
    213          	if(UARTx == (LPC_UART_TypeDef *)LPC_UART0)
   \                     ??UART_Init_3: (+1)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000094   0x4284             CMP      R4,R0
   \   00000096   0xD103             BNE.N    ??UART_Init_4
    214          	{
    215          		/* Set up clock and power for UART module */
    216          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, ENABLE);
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x2008             MOVS     R0,#+8
   \   0000009C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    217          	}
    218          #endif
    219          
    220          #ifdef _UART1
    221          	if(((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_Init_4: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   000000A4   0x4284             CMP      R4,R0
   \   000000A6   0xD103             BNE.N    ??UART_Init_5
    222          	{
    223          		/* Set up clock and power for UART module */
    224          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, ENABLE);
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x2010             MOVS     R0,#+16
   \   000000AC   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    225          	}
    226          #endif
    227          
    228          #ifdef _UART2
    229          	if(UARTx == LPC_UART2)
   \                     ??UART_Init_5: (+1)
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   000000B4   0x4284             CMP      R4,R0
   \   000000B6   0xD104             BNE.N    ??UART_Init_6
    230          	{
    231          		/* Set up clock and power for UART module */
    232          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, ENABLE);
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0xF05F 0x7080      MOVS     R0,#+16777216
   \   000000BE   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    233          	}
    234          #endif
    235          
    236          #ifdef _UART3
    237          	if(UARTx == LPC_UART3)
   \                     ??UART_Init_6: (+1)
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   000000C6   0x4284             CMP      R4,R0
   \   000000C8   0xD104             BNE.N    ??UART_Init_7
    238          	{
    239          		/* Set up clock and power for UART module */
    240          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, ENABLE);
   \   000000CA   0x2101             MOVS     R1,#+1
   \   000000CC   0xF05F 0x7000      MOVS     R0,#+33554432
   \   000000D0   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    241          	}
    242          #endif
    243          
    244          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_Init_7: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   000000D8   0x4284             CMP      R4,R0
   \   000000DA   0xD128             BNE.N    ??UART_Init_8
    245          	{
    246          		/* FIFOs are empty */
    247          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN \
    248          				| UART_FCR_RX_RS | UART_FCR_TX_RS);
   \   000000DC   0x2007             MOVS     R0,#+7
   \   000000DE   0x7220             STRB     R0,[R4, #+8]
    249          		// Disable FIFO
    250          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x7220             STRB     R0,[R4, #+8]
    251          
    252          		// Dummy reading
    253          		while (((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_RDR)
   \                     ??UART_Init_9: (+1)
   \   000000E4   0x7D20             LDRB     R0,[R4, #+20]
   \   000000E6   0x07C0             LSLS     R0,R0,#+31
   \   000000E8   0xD502             BPL.N    ??UART_Init_10
    254          		{
    255          			tmp = ((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR;
   \   000000EA   0x7820             LDRB     R0,[R4, #+0]
   \   000000EC   0x0006             MOVS     R6,R0
   \   000000EE   0xE7F9             B.N      ??UART_Init_9
    256          		}
    257          
    258          		((LPC_UART1_TypeDef *)UARTx)->TER = UART_TER_TXEN;
   \                     ??UART_Init_10: (+1)
   \   000000F0   0x2080             MOVS     R0,#+128
   \   000000F2   0xF884 0x0030      STRB     R0,[R4, #+48]
    259          		// Wait for current transmit complete
    260          		while (!(((LPC_UART1_TypeDef *)UARTx)->LSR & UART_LSR_THRE));
   \                     ??UART_Init_11: (+1)
   \   000000F6   0x7D20             LDRB     R0,[R4, #+20]
   \   000000F8   0x0680             LSLS     R0,R0,#+26
   \   000000FA   0xD5FC             BPL.N    ??UART_Init_11
    261          		// Disable Tx
    262          		((LPC_UART1_TypeDef *)UARTx)->TER = 0;
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0xF884 0x0030      STRB     R0,[R4, #+48]
    263          
    264          		// Disable interrupt
    265          		((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER = 0;
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x6060             STR      R0,[R4, #+4]
    266          		// Set LCR to default state
    267          		((LPC_UART1_TypeDef *)UARTx)->LCR = 0;
   \   00000106   0x2000             MOVS     R0,#+0
   \   00000108   0x7320             STRB     R0,[R4, #+12]
    268          		// Set ACR to default state
    269          		((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6220             STR      R0,[R4, #+32]
    270          		// Set Modem Control to default state
    271          		((LPC_UART1_TypeDef *)UARTx)->MCR = 0;
   \   0000010E   0x2000             MOVS     R0,#+0
   \   00000110   0x7420             STRB     R0,[R4, #+16]
    272          		// Set RS485 control to default state
    273          		((LPC_UART1_TypeDef *)UARTx)->RS485CTRL = 0;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF884 0x004C      STRB     R0,[R4, #+76]
    274          		// Set RS485 delay timer to default state
    275          		((LPC_UART1_TypeDef *)UARTx)->RS485DLY = 0;
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF884 0x0054      STRB     R0,[R4, #+84]
    276          		// Set RS485 addr match to default state
    277          		((LPC_UART1_TypeDef *)UARTx)->ADRMATCH = 0;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF884 0x0050      STRB     R0,[R4, #+80]
    278          		//Dummy Reading to Clear Status
    279          		tmp = ((LPC_UART1_TypeDef *)UARTx)->MSR;
   \   00000124   0x7E20             LDRB     R0,[R4, #+24]
   \   00000126   0x0006             MOVS     R6,R0
    280          		tmp = ((LPC_UART1_TypeDef *)UARTx)->LSR;
   \   00000128   0x7D20             LDRB     R0,[R4, #+20]
   \   0000012A   0x0006             MOVS     R6,R0
   \   0000012C   0xE01A             B.N      ??UART_Init_12
    281          	}
    282          	else
    283          	{
    284          		/* FIFOs are empty */
    285          		UARTx->/*IIFCR.*/FCR = ( UART_FCR_FIFO_EN | UART_FCR_RX_RS | UART_FCR_TX_RS);
   \                     ??UART_Init_8: (+1)
   \   0000012E   0x2007             MOVS     R0,#+7
   \   00000130   0x7220             STRB     R0,[R4, #+8]
    286          		// Disable FIFO
    287          		UARTx->/*IIFCR.*/FCR = 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0x7220             STRB     R0,[R4, #+8]
    288          
    289          		// Dummy reading
    290          		while (UARTx->LSR & UART_LSR_RDR)
   \                     ??UART_Init_13: (+1)
   \   00000136   0x7D20             LDRB     R0,[R4, #+20]
   \   00000138   0x07C0             LSLS     R0,R0,#+31
   \   0000013A   0xD502             BPL.N    ??UART_Init_14
    291          		{
    292          			tmp = UARTx->/*RBTHDLR.*/RBR;
   \   0000013C   0x7820             LDRB     R0,[R4, #+0]
   \   0000013E   0x0006             MOVS     R6,R0
   \   00000140   0xE7F9             B.N      ??UART_Init_13
    293          		}
    294          
    295          		UARTx->TER = UART_TER_TXEN;
   \                     ??UART_Init_14: (+1)
   \   00000142   0x2080             MOVS     R0,#+128
   \   00000144   0xF884 0x0030      STRB     R0,[R4, #+48]
    296          		// Wait for current transmit complete
    297          		while (!(UARTx->LSR & UART_LSR_THRE));
   \                     ??UART_Init_15: (+1)
   \   00000148   0x7D20             LDRB     R0,[R4, #+20]
   \   0000014A   0x0680             LSLS     R0,R0,#+26
   \   0000014C   0xD5FC             BPL.N    ??UART_Init_15
    298          		// Disable Tx
    299          		UARTx->TER = 0;
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xF884 0x0030      STRB     R0,[R4, #+48]
    300          
    301          		// Disable interrupt
    302          		UARTx->/*DLIER.*/IER = 0;
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x6060             STR      R0,[R4, #+4]
    303          		// Set LCR to default state
    304          		UARTx->LCR = 0;
   \   00000158   0x2000             MOVS     R0,#+0
   \   0000015A   0x7320             STRB     R0,[R4, #+12]
    305          		// Set ACR to default state
    306          		UARTx->ACR = 0;
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x6220             STR      R0,[R4, #+32]
    307          		// Dummy reading
    308          		tmp = UARTx->LSR;
   \   00000160   0x7D20             LDRB     R0,[R4, #+20]
   \   00000162   0x0006             MOVS     R6,R0
    309          	}
    310          
    311          	if (UARTx == LPC_UART3)
   \                     ??UART_Init_12: (+1)
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000168   0x4284             CMP      R4,R0
   \   0000016A   0xD102             BNE.N    ??UART_Init_16
    312          	{
    313          		// Set IrDA to default state
    314          		UARTx->ICR = 0;
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0xF884 0x0024      STRB     R0,[R4, #+36]
    315          	}
    316          
    317          	// Set Line Control register ----------------------------
    318          
    319          	uart_set_divisors(UARTx, (UART_ConfigStruct->Baud_rate));
   \                     ??UART_Init_16: (+1)
   \   00000172   0x6829             LDR      R1,[R5, #+0]
   \   00000174   0x0020             MOVS     R0,R4
   \   00000176   0x.... 0x....      BL       uart_set_divisors
    320          
    321          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   0000017A   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   0000017E   0x4284             CMP      R4,R0
   \   00000180   0xD104             BNE.N    ??UART_Init_17
    322          	{
    323          		tmp = (((LPC_UART1_TypeDef *)UARTx)->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) \
    324          				& UART_LCR_BITMASK;
   \   00000182   0x7B20             LDRB     R0,[R4, #+12]
   \   00000184   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000188   0x0006             MOVS     R6,R0
   \   0000018A   0xE003             B.N      ??UART_Init_18
    325          	}
    326          	else
    327          	{
    328          		tmp = (UARTx->LCR & (UART_LCR_DLAB_EN | UART_LCR_BREAK_EN)) & UART_LCR_BITMASK;
   \                     ??UART_Init_17: (+1)
   \   0000018C   0x7B20             LDRB     R0,[R4, #+12]
   \   0000018E   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   00000192   0x0006             MOVS     R6,R0
    329          	}
    330          
    331          	switch (UART_ConfigStruct->Databits){
   \                     ??UART_Init_18: (+1)
   \   00000194   0x7968             LDRB     R0,[R5, #+5]
   \   00000196   0x2800             CMP      R0,#+0
   \   00000198   0xD003             BEQ.N    ??UART_Init_19
   \   0000019A   0x2802             CMP      R0,#+2
   \   0000019C   0xD005             BEQ.N    ??UART_Init_20
   \   0000019E   0xD301             BCC.N    ??UART_Init_21
   \   000001A0   0xE006             B.N      ??UART_Init_22
    332          	case UART_DATABIT_5:
    333          		tmp |= UART_LCR_WLEN5;
    334          		break;
   \                     ??UART_Init_19: (+1)
   \   000001A2   0xE007             B.N      ??UART_Init_23
    335          	case UART_DATABIT_6:
    336          		tmp |= UART_LCR_WLEN6;
   \                     ??UART_Init_21: (+1)
   \   000001A4   0xF056 0x0601      ORRS     R6,R6,#0x1
    337          		break;
   \   000001A8   0xE004             B.N      ??UART_Init_23
    338          	case UART_DATABIT_7:
    339          		tmp |= UART_LCR_WLEN7;
   \                     ??UART_Init_20: (+1)
   \   000001AA   0xF056 0x0602      ORRS     R6,R6,#0x2
    340          		break;
   \   000001AE   0xE001             B.N      ??UART_Init_23
    341          	case UART_DATABIT_8:
    342          	default:
    343          		tmp |= UART_LCR_WLEN8;
   \                     ??UART_Init_22: (+1)
   \   000001B0   0xF056 0x0603      ORRS     R6,R6,#0x3
    344          		break;
    345          	}
    346          
    347          	if (UART_ConfigStruct->Parity == UART_PARITY_NONE)
   \                     ??UART_Init_23: (+1)
   \   000001B4   0x7928             LDRB     R0,[R5, #+4]
   \   000001B6   0x2800             CMP      R0,#+0
   \   000001B8   0xD015             BEQ.N    ??UART_Init_24
    348          	{
    349          		// Do nothing...
    350          	}
    351          	else
    352          	{
    353          		tmp |= UART_LCR_PARITY_EN;
   \   000001BA   0xF056 0x0608      ORRS     R6,R6,#0x8
    354          		switch (UART_ConfigStruct->Parity)
   \   000001BE   0x7928             LDRB     R0,[R5, #+4]
   \   000001C0   0x2801             CMP      R0,#+1
   \   000001C2   0xD006             BEQ.N    ??UART_Init_25
   \   000001C4   0xD30F             BCC.N    ??UART_Init_26
   \   000001C6   0x2803             CMP      R0,#+3
   \   000001C8   0xD007             BEQ.N    ??UART_Init_27
   \   000001CA   0xD303             BCC.N    ??UART_Init_28
   \   000001CC   0x2804             CMP      R0,#+4
   \   000001CE   0xD007             BEQ.N    ??UART_Init_29
   \   000001D0   0xE009             B.N      ??UART_Init_26
    355          		{
    356          		case UART_PARITY_ODD:
    357          			tmp |= UART_LCR_PARITY_ODD;
    358          			break;
   \                     ??UART_Init_25: (+1)
   \   000001D2   0xE008             B.N      ??UART_Init_24
    359          
    360          		case UART_PARITY_EVEN:
    361          			tmp |= UART_LCR_PARITY_EVEN;
   \                     ??UART_Init_28: (+1)
   \   000001D4   0xF056 0x0610      ORRS     R6,R6,#0x10
    362          			break;
   \   000001D8   0xE005             B.N      ??UART_Init_24
    363          
    364          		case UART_PARITY_SP_1:
    365          			tmp |= UART_LCR_PARITY_F_1;
   \                     ??UART_Init_27: (+1)
   \   000001DA   0xF056 0x0620      ORRS     R6,R6,#0x20
    366          			break;
   \   000001DE   0xE002             B.N      ??UART_Init_24
    367          
    368          		case UART_PARITY_SP_0:
    369          			tmp |= UART_LCR_PARITY_F_0;
   \                     ??UART_Init_29: (+1)
   \   000001E0   0xF056 0x0630      ORRS     R6,R6,#0x30
    370          			break;
   \   000001E4   0xE7FF             B.N      ??UART_Init_24
    371          		default:
    372          			break;
    373          		}
    374          	}
    375          
    376          	switch (UART_ConfigStruct->Stopbits){
   \                     ??UART_Init_26: (+1)
   \                     ??UART_Init_24: (+1)
   \   000001E6   0x79A8             LDRB     R0,[R5, #+6]
   \   000001E8   0x2801             CMP      R0,#+1
   \   000001EA   0xD102             BNE.N    ??UART_Init_30
    377          	case UART_STOPBIT_2:
    378          		tmp |= UART_LCR_STOPBIT_SEL;
   \   000001EC   0xF056 0x0604      ORRS     R6,R6,#0x4
    379          		break;
   \   000001F0   0xE7FF             B.N      ??UART_Init_31
    380          	case UART_STOPBIT_1:
    381          	default:
    382          		// Do no thing
    383          		break;
    384          	}
    385          
    386          
    387          	// Write back to LCR, configure FIFO and Disable Tx
    388          	if (((LPC_UART1_TypeDef *)UARTx) ==  LPC_UART1)
   \                     ??UART_Init_30: (+1)
   \                     ??UART_Init_31: (+1)
   \   000001F2   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   000001F6   0x4284             CMP      R4,R0
   \   000001F8   0xD101             BNE.N    ??UART_Init_32
    389          	{
    390          		((LPC_UART1_TypeDef *)UARTx)->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \   000001FA   0x7326             STRB     R6,[R4, #+12]
   \   000001FC   0xE000             B.N      ??UART_Init_33
    391          	}
    392          	else
    393          	{
    394          		UARTx->LCR = (uint8_t)(tmp & UART_LCR_BITMASK);
   \                     ??UART_Init_32: (+1)
   \   000001FE   0x7326             STRB     R6,[R4, #+12]
    395          	}
    396          }
   \                     ??UART_Init_33: (+1)
   \   00000200   0xBD70             POP      {R4-R6,PC}       ;; return
    397          
    398          /*********************************************************************//**
    399           * @brief		De-initializes the UARTx peripheral registers to their
    400           *                  default reset values.
    401           * @param[in]	UARTx	UART peripheral selected, should be:
    402           *   			- LPC_UART0: UART0 peripheral
    403           * 				- LPC_UART1: UART1 peripheral
    404           * 				- LPC_UART2: UART2 peripheral
    405           * 				- LPC_UART3: UART3 peripheral
    406           * @return 		None
    407           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    408          void UART_DeInit(LPC_UART_TypeDef* UARTx)
    409          {
   \                     UART_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    410          	// For debug mode
    411          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_DeInit_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_DeInit_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_DeInit_0
   \   00000024   0xF240 0x119B      MOVW     R1,#+411
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
    412          
    413          	UART_TxCmd(UARTx, DISABLE);
   \                     ??UART_DeInit_0: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0x.... 0x....      BL       UART_TxCmd
    414          
    415          #ifdef _UART0
    416          	if (UARTx == (LPC_UART_TypeDef *)LPC_UART0)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   0000003C   0x4284             CMP      R4,R0
   \   0000003E   0xD103             BNE.N    ??UART_DeInit_1
    417          	{
    418          		/* Set up clock and power for UART module */
    419          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART0, DISABLE);
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    420          	}
    421          #endif
    422          
    423          #ifdef _UART1
    424          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_DeInit_1: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   0000004C   0x4284             CMP      R4,R0
   \   0000004E   0xD103             BNE.N    ??UART_DeInit_2
    425          	{
    426          		/* Set up clock and power for UART module */
    427          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART1, DISABLE);
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x2010             MOVS     R0,#+16
   \   00000054   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    428          	}
    429          #endif
    430          
    431          #ifdef _UART2
    432          	if (UARTx == LPC_UART2)
   \                     ??UART_DeInit_2: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   0000005C   0x4284             CMP      R4,R0
   \   0000005E   0xD104             BNE.N    ??UART_DeInit_3
    433          	{
    434          		/* Set up clock and power for UART module */
    435          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART2, DISABLE);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000066   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    436          	}
    437          #endif
    438          
    439          #ifdef _UART3
    440          	if (UARTx == LPC_UART3)
   \                     ??UART_DeInit_3: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable19_1  ;; 0x4009c000
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD104             BNE.N    ??UART_DeInit_4
    441          	{
    442          		/* Set up clock and power for UART module */
    443          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCUART3, DISABLE);
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xF05F 0x7000      MOVS     R0,#+33554432
   \   00000078   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    444          	}
    445          #endif
    446          }
   \                     ??UART_DeInit_4: (+1)
   \   0000007C   0xBD10             POP      {R4,PC}          ;; return
    447          
    448          /*****************************************************************************//**
    449          * @brief		Fills each UART_InitStruct member with its default value:
    450          * 				- 9600 bps
    451          * 				- 8-bit data
    452          * 				- 1 Stopbit
    453          * 				- None Parity
    454          * @param[in]	UART_InitStruct Pointer to a UART_CFG_Type structure
    455          *                    which will be initialized.
    456          * @return		None
    457          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    458          void UART_ConfigStructInit(UART_CFG_Type *UART_InitStruct)
    459          {
    460          	UART_InitStruct->Baud_rate = 9600;
   \                     UART_ConfigStructInit: (+1)
   \   00000000   0xF44F 0x5116      MOV      R1,#+9600
   \   00000004   0x6001             STR      R1,[R0, #+0]
    461          	UART_InitStruct->Databits = UART_DATABIT_8;
   \   00000006   0x2103             MOVS     R1,#+3
   \   00000008   0x7141             STRB     R1,[R0, #+5]
    462          	UART_InitStruct->Parity = UART_PARITY_NONE;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7101             STRB     R1,[R0, #+4]
    463          	UART_InitStruct->Stopbits = UART_STOPBIT_1;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7181             STRB     R1,[R0, #+6]
    464          }
   \   00000012   0x4770             BX       LR               ;; return
    465          
    466          /* UART Send/Recieve functions -------------------------------------------------*/
    467          /*********************************************************************//**
    468           * @brief		Transmit a single data through UART peripheral
    469           * @param[in]	UARTx	UART peripheral selected, should be:
    470           *   			- LPC_UART0: UART0 peripheral
    471           * 				- LPC_UART1: UART1 peripheral
    472           * 				- LPC_UART2: UART2 peripheral
    473           * 				- LPC_UART3: UART3 peripheral
    474           * @param[in]	Data	Data to transmit (must be 8-bit long)
    475           * @return 		None
    476           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    477          void UART_SendByte(LPC_UART_TypeDef* UARTx, uint8_t Data)
    478          {
   \                     UART_SendByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    479          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD011             BEQ.N    ??UART_SendByte_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00D             BEQ.N    ??UART_SendByte_0
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD009             BEQ.N    ??UART_SendByte_0
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD005             BEQ.N    ??UART_SendByte_0
   \   00000026   0xF240 0x11DF      MOVW     R1,#+479
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002E   0x.... 0x....      BL       check_failed
    480          
    481          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_SendByte_0: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD101             BNE.N    ??UART_SendByte_1
    482          	{
    483          		((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
   \   0000003A   0x7025             STRB     R5,[R4, #+0]
   \   0000003C   0xE000             B.N      ??UART_SendByte_2
    484          	}
    485          	else
    486          	{
    487          		UARTx->/*RBTHDLR.*/THR = Data & UART_THR_MASKBIT;
   \                     ??UART_SendByte_1: (+1)
   \   0000003E   0x7025             STRB     R5,[R4, #+0]
    488          	}
    489          }
   \                     ??UART_SendByte_2: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    490          
    491          
    492          /*********************************************************************//**
    493           * @brief		Receive a single data from UART peripheral
    494           * @param[in]	UARTx	UART peripheral selected, should be:
    495           *  			- LPC_UART0: UART0 peripheral
    496           * 				- LPC_UART1: UART1 peripheral
    497           * 				- LPC_UART2: UART2 peripheral
    498           * 				- LPC_UART3: UART3 peripheral
    499           * @return 		Data received
    500           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    501          uint8_t UART_ReceiveByte(LPC_UART_TypeDef* UARTx)
    502          {
   \                     UART_ReceiveByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    503          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_ReceiveByte_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_ReceiveByte_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_ReceiveByte_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_ReceiveByte_0
   \   00000024   0xF240 0x11F7      MOVW     R1,#+503
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
    504          
    505          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ReceiveByte_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD101             BNE.N    ??UART_ReceiveByte_1
    506          	{
    507          		return (((LPC_UART1_TypeDef *)UARTx)->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
   \   00000038   0x7820             LDRB     R0,[R4, #+0]
   \   0000003A   0xE000             B.N      ??UART_ReceiveByte_2
    508          	}
    509          	else
    510          	{
    511          		return (UARTx->/*RBTHDLR.*/RBR & UART_RBR_MASKBIT);
   \                     ??UART_ReceiveByte_1: (+1)
   \   0000003C   0x7820             LDRB     R0,[R4, #+0]
   \                     ??UART_ReceiveByte_2: (+1)
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    512          	}
    513          }
    514          
    515          /*********************************************************************//**
    516           * @brief		Send a block of data via UART peripheral
    517           * @param[in]	UARTx	Selected UART peripheral used to send data, should be:
    518           *   			- LPC_UART0: UART0 peripheral
    519           * 				- LPC_UART1: UART1 peripheral
    520           * 				- LPC_UART2: UART2 peripheral
    521           * 				- LPC_UART3: UART3 peripheral
    522           * @param[in]	txbuf 	Pointer to Transmit buffer
    523           * @param[in]	buflen 	Length of Transmit buffer
    524           * @param[in] 	flag 	Flag used in  UART transfer, should be
    525           * 						NONE_BLOCKING or BLOCKING
    526           * @return 		Number of bytes sent.
    527           *
    528           * Note: when using UART in BLOCKING mode, a time-out condition is used
    529           * via defined symbol UART_BLOCKING_TIMEOUT.
    530           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    531          uint32_t UART_Send(LPC_UART_TypeDef *UARTx, uint8_t *txbuf,
    532          		uint32_t buflen, TRANSFER_BLOCK_Type flag)
    533          {
   \                     UART_Send: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x0015             MOVS     R5,R2
   \   00000008   0x001E             MOVS     R6,R3
    534          	uint32_t bToSend, bSent, timeOut, fifo_cnt;
    535          	uint8_t *pChar = txbuf;
   \   0000000A   0xF8DD 0xB000      LDR      R11,[SP, #+0]
    536          
    537          	bToSend = buflen;
   \   0000000E   0x002F             MOVS     R7,R5
    538          
    539          	// blocking mode
    540          	if (flag == BLOCKING) {
   \   00000010   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000012   0x2E01             CMP      R6,#+1
   \   00000014   0xD126             BNE.N    ??UART_Send_0
    541          		bSent = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4680             MOV      R8,R0
    542          		while (bToSend){
   \                     ??UART_Send_1: (+1)
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD03D             BEQ.N    ??UART_Send_2
    543          			timeOut = UART_BLOCKING_TIMEOUT;
   \   0000001E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000022   0x4681             MOV      R9,R0
    544          			// Wait for THR empty with timeout
    545          			while (!(UARTx->LSR & UART_LSR_THRE)) {
   \                     ??UART_Send_3: (+1)
   \   00000024   0x7D20             LDRB     R0,[R4, #+20]
   \   00000026   0x0680             LSLS     R0,R0,#+26
   \   00000028   0xD405             BMI.N    ??UART_Send_4
    546          				if (timeOut == 0) break;
   \   0000002A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002E   0xD002             BEQ.N    ??UART_Send_4
    547          				timeOut--;
   \                     ??UART_Send_5: (+1)
   \   00000030   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   00000034   0xE7F6             B.N      ??UART_Send_3
    548          			}
    549          			// Time out!
    550          			if(timeOut == 0) break;
   \                     ??UART_Send_4: (+1)
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD02E             BEQ.N    ??UART_Send_2
    551          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_6: (+1)
   \   0000003C   0x2010             MOVS     R0,#+16
   \   0000003E   0x4682             MOV      R10,R0
    552          			while (fifo_cnt && bToSend){
   \                     ??UART_Send_7: (+1)
   \   00000040   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000044   0xD0E9             BEQ.N    ??UART_Send_1
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD0E7             BEQ.N    ??UART_Send_1
    553          				UART_SendByte(UARTx, (*pChar++));
   \   0000004A   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0x.... 0x....      BL       UART_SendByte
   \   00000054   0xF11B 0x0B01      ADDS     R11,R11,#+1
    554          				fifo_cnt--;
   \   00000058   0xF1BA 0x0A01      SUBS     R10,R10,#+1
    555          				bToSend--;
   \   0000005C   0x1E7F             SUBS     R7,R7,#+1
    556          				bSent++;
   \   0000005E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000062   0xE7ED             B.N      ??UART_Send_7
    557          			}
    558          		}
    559          	}
    560          	// None blocking mode
    561          	else {
    562          		bSent = 0;
   \                     ??UART_Send_0: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x4680             MOV      R8,R0
    563          		while (bToSend) {
   \                     ??UART_Send_8: (+1)
   \   00000068   0x2F00             CMP      R7,#+0
   \   0000006A   0xD016             BEQ.N    ??UART_Send_2
    564          			if (!(UARTx->LSR & UART_LSR_THRE)){
   \   0000006C   0x7D20             LDRB     R0,[R4, #+20]
   \   0000006E   0x0680             LSLS     R0,R0,#+26
   \   00000070   0xD513             BPL.N    ??UART_Send_2
    565          				break;
    566          			}
    567          			fifo_cnt = UART_TX_FIFO_SIZE;
   \                     ??UART_Send_9: (+1)
   \   00000072   0x2010             MOVS     R0,#+16
   \   00000074   0x4682             MOV      R10,R0
    568          			while (fifo_cnt && bToSend) {
   \                     ??UART_Send_10: (+1)
   \   00000076   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000007A   0xD0F5             BEQ.N    ??UART_Send_8
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD0F3             BEQ.N    ??UART_Send_8
    569          				UART_SendByte(UARTx, (*pChar++));
   \   00000080   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       UART_SendByte
   \   0000008A   0xF11B 0x0B01      ADDS     R11,R11,#+1
    570          				bToSend--;
   \   0000008E   0x1E7F             SUBS     R7,R7,#+1
    571          				fifo_cnt--;
   \   00000090   0xF1BA 0x0A01      SUBS     R10,R10,#+1
    572          				bSent++;
   \   00000094   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000098   0xE7ED             B.N      ??UART_Send_10
    573          			}
    574          		}
    575          	}
    576          	return bSent;
   \                     ??UART_Send_2: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    577          }
    578          
    579          /*********************************************************************//**
    580           * @brief		Receive a block of data via UART peripheral
    581           * @param[in]	UARTx	Selected UART peripheral used to send data,
    582           * 				should be:
    583           *   			- LPC_UART0: UART0 peripheral
    584           * 				- LPC_UART1: UART1 peripheral
    585           * 				- LPC_UART2: UART2 peripheral
    586           * 				- LPC_UART3: UART3 peripheral
    587           * @param[out]	rxbuf 	Pointer to Received buffer
    588           * @param[in]	buflen 	Length of Received buffer
    589           * @param[in] 	flag 	Flag mode, should be NONE_BLOCKING or BLOCKING
    590          
    591           * @return 		Number of bytes received
    592           *
    593           * Note: when using UART in BLOCKING mode, a time-out condition is used
    594           * via defined symbol UART_BLOCKING_TIMEOUT.
    595           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    596          uint32_t UART_Receive(LPC_UART_TypeDef *UARTx, uint8_t *rxbuf, \
    597          		uint32_t buflen, TRANSFER_BLOCK_Type flag)
    598          {
   \                     UART_Receive: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    599          	uint32_t bToRecv, bRecv, timeOut;
    600          	uint8_t *pChar = rxbuf;
   \   0000000C   0x46AB             MOV      R11,R5
    601          
    602          	bToRecv = buflen;
   \   0000000E   0x46B0             MOV      R8,R6
    603          
    604          	// Blocking mode
    605          	if (flag == BLOCKING) {
   \   00000010   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000012   0x2F01             CMP      R7,#+1
   \   00000014   0xD11F             BNE.N    ??UART_Receive_0
    606          		bRecv = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x4681             MOV      R9,R0
    607          		while (bToRecv){
   \                     ??UART_Receive_1: (+1)
   \   0000001A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001E   0xD02E             BEQ.N    ??UART_Receive_2
    608          			timeOut = UART_BLOCKING_TIMEOUT;
   \   00000020   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000024   0x4682             MOV      R10,R0
    609          			while (!(UARTx->LSR & UART_LSR_RDR)){
   \                     ??UART_Receive_3: (+1)
   \   00000026   0x7D20             LDRB     R0,[R4, #+20]
   \   00000028   0x07C0             LSLS     R0,R0,#+31
   \   0000002A   0xD405             BMI.N    ??UART_Receive_4
    610          				if (timeOut == 0) break;
   \   0000002C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000030   0xD002             BEQ.N    ??UART_Receive_4
    611          				timeOut--;
   \                     ??UART_Receive_5: (+1)
   \   00000032   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000036   0xE7F6             B.N      ??UART_Receive_3
    612          			}
    613          			// Time out!
    614          			if(timeOut == 0) break;
   \                     ??UART_Receive_4: (+1)
   \   00000038   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003C   0xD01F             BEQ.N    ??UART_Receive_2
    615          			// Get data from the buffer
    616          			(*pChar++) = UART_ReceiveByte(UARTx);
   \                     ??UART_Receive_6: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       UART_ReceiveByte
   \   00000044   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000048   0xF11B 0x0B01      ADDS     R11,R11,#+1
    617          			bToRecv--;
   \   0000004C   0xF1B8 0x0801      SUBS     R8,R8,#+1
    618          			bRecv++;
   \   00000050   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000054   0xE7E1             B.N      ??UART_Receive_1
    619          		}
    620          	}
    621          	// None blocking mode
    622          	else {
    623          		bRecv = 0;
   \                     ??UART_Receive_0: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x4681             MOV      R9,R0
    624          		while (bToRecv) {
   \                     ??UART_Receive_7: (+1)
   \   0000005A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000005E   0xD00E             BEQ.N    ??UART_Receive_2
    625          			if (!(UARTx->LSR & UART_LSR_RDR)) {
   \   00000060   0x7D20             LDRB     R0,[R4, #+20]
   \   00000062   0x07C0             LSLS     R0,R0,#+31
   \   00000064   0xD50B             BPL.N    ??UART_Receive_2
    626          				break;
    627          			} else {
    628          				(*pChar++) = UART_ReceiveByte(UARTx);
   \                     ??UART_Receive_8: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x.... 0x....      BL       UART_ReceiveByte
   \   0000006C   0xF88B 0x0000      STRB     R0,[R11, #+0]
   \   00000070   0xF11B 0x0B01      ADDS     R11,R11,#+1
    629          				bRecv++;
   \   00000074   0xF119 0x0901      ADDS     R9,R9,#+1
    630          				bToRecv--;
   \   00000078   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   0000007C   0xE7ED             B.N      ??UART_Receive_7
    631          			}
    632          		}
    633          	}
    634          	return bRecv;
   \                     ??UART_Receive_2: (+1)
   \   0000007E   0x4648             MOV      R0,R9
   \   00000080   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    635          }
    636          
    637          /*********************************************************************//**
    638           * @brief		Force BREAK character on UART line, output pin UARTx TXD is
    639          				forced to logic 0.
    640           * @param[in]	UARTx	UART peripheral selected, should be:
    641           *  			- LPC_UART0: UART0 peripheral
    642           * 				- LPC_UART1: UART1 peripheral
    643           * 				- LPC_UART2: UART2 peripheral
    644           * 				- LPC_UART3: UART3 peripheral
    645           * @return 		None
    646           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    647          void UART_ForceBreak(LPC_UART_TypeDef* UARTx)
    648          {
   \                     UART_ForceBreak: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    649          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_ForceBreak_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_ForceBreak_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_ForceBreak_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_ForceBreak_0
   \   00000024   0xF240 0x2189      MOVW     R1,#+649
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
    650          
    651          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ForceBreak_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD104             BNE.N    ??UART_ForceBreak_1
    652          	{
    653          		((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_BREAK_EN;
   \   00000038   0x7B20             LDRB     R0,[R4, #+12]
   \   0000003A   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   0000003E   0x7320             STRB     R0,[R4, #+12]
   \   00000040   0xE003             B.N      ??UART_ForceBreak_2
    654          	}
    655          	else
    656          	{
    657          		UARTx->LCR |= UART_LCR_BREAK_EN;
   \                     ??UART_ForceBreak_1: (+1)
   \   00000042   0x7B20             LDRB     R0,[R4, #+12]
   \   00000044   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000048   0x7320             STRB     R0,[R4, #+12]
    658          	}
    659          }
   \                     ??UART_ForceBreak_2: (+1)
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    660          
    661          
    662          /********************************************************************//**
    663           * @brief 		Enable or disable specified UART interrupt.
    664           * @param[in]	UARTx	UART peripheral selected, should be
    665           *  			- LPC_UART0: UART0 peripheral
    666           * 				- LPC_UART1: UART1 peripheral
    667           * 				- LPC_UART2: UART2 peripheral
    668           * 				- LPC_UART3: UART3 peripheral
    669           * @param[in]	UARTIntCfg	Specifies the interrupt flag,
    670           * 				should be one of the following:
    671          				- UART_INTCFG_RBR 	:  RBR Interrupt enable
    672          				- UART_INTCFG_THRE 	:  THR Interrupt enable
    673          				- UART_INTCFG_RLS 	:  RX line status interrupt enable
    674          				- UART1_INTCFG_MS	:  Modem status interrupt enable (UART1 only)
    675          				- UART1_INTCFG_CTS	:  CTS1 signal transition interrupt enable (UART1 only)
    676          				- UART_INTCFG_ABEO 	:  Enables the end of auto-baud interrupt
    677          				- UART_INTCFG_ABTO 	:  Enables the auto-baud time-out interrupt
    678           * @param[in]	NewState New state of specified UART interrupt type,
    679           * 				should be:
    680           * 				- ENALBE: Enable this UART interrupt type.
    681          * 				- DISALBE: Disable this UART interrupt type.
    682           * @return 		None
    683           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    684          void UART_IntConfig(LPC_UART_TypeDef *UARTx, UART_INT_Type UARTIntCfg, FunctionalState NewState)
    685          {
   \                     UART_IntConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    686          	uint32_t tmp;
    687          
    688          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD011             BEQ.N    ??UART_IntConfig_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD00D             BEQ.N    ??UART_IntConfig_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD009             BEQ.N    ??UART_IntConfig_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD005             BEQ.N    ??UART_IntConfig_0
   \   00000028   0xF44F 0x712C      MOV      R1,#+688
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000030   0x.... 0x....      BL       check_failed
    689          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IntConfig_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD008             BEQ.N    ??UART_IntConfig_1
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD005             BEQ.N    ??UART_IntConfig_1
   \   00000040   0xF240 0x21B1      MOVW     R1,#+689
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000048   0x.... 0x....      BL       check_failed
    690          
    691          	switch(UARTIntCfg){
   \                     ??UART_IntConfig_1: (+1)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD009             BEQ.N    ??UART_IntConfig_2
   \   00000052   0x2D02             CMP      R5,#+2
   \   00000054   0xD00D             BEQ.N    ??UART_IntConfig_3
   \   00000056   0xD309             BCC.N    ??UART_IntConfig_4
   \   00000058   0x2D04             CMP      R5,#+4
   \   0000005A   0xD010             BEQ.N    ??UART_IntConfig_5
   \   0000005C   0xD30C             BCC.N    ??UART_IntConfig_6
   \   0000005E   0x2D06             CMP      R5,#+6
   \   00000060   0xD014             BEQ.N    ??UART_IntConfig_7
   \   00000062   0xD30F             BCC.N    ??UART_IntConfig_8
   \   00000064   0xE015             B.N      ??UART_IntConfig_9
    692          		case UART_INTCFG_RBR:
    693          			tmp = UART_IER_RBRINT_EN;
   \                     ??UART_IntConfig_2: (+1)
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x0007             MOVS     R7,R0
    694          			break;
   \   0000006A   0xE012             B.N      ??UART_IntConfig_9
    695          		case UART_INTCFG_THRE:
    696          			tmp = UART_IER_THREINT_EN;
   \                     ??UART_IntConfig_4: (+1)
   \   0000006C   0x2002             MOVS     R0,#+2
   \   0000006E   0x0007             MOVS     R7,R0
    697          			break;
   \   00000070   0xE00F             B.N      ??UART_IntConfig_9
    698          		case UART_INTCFG_RLS:
    699          			tmp = UART_IER_RLSINT_EN;
   \                     ??UART_IntConfig_3: (+1)
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0x0007             MOVS     R7,R0
    700          			break;
   \   00000076   0xE00C             B.N      ??UART_IntConfig_9
    701          		case UART1_INTCFG_MS:
    702          			tmp = UART1_IER_MSINT_EN;
   \                     ??UART_IntConfig_6: (+1)
   \   00000078   0x2008             MOVS     R0,#+8
   \   0000007A   0x0007             MOVS     R7,R0
    703          			break;
   \   0000007C   0xE009             B.N      ??UART_IntConfig_9
    704          		case UART1_INTCFG_CTS:
    705          			tmp = UART1_IER_CTSINT_EN;
   \                     ??UART_IntConfig_5: (+1)
   \   0000007E   0x2080             MOVS     R0,#+128
   \   00000080   0x0007             MOVS     R7,R0
    706          			break;
   \   00000082   0xE006             B.N      ??UART_IntConfig_9
    707          		case UART_INTCFG_ABEO:
    708          			tmp = UART_IER_ABEOINT_EN;
   \                     ??UART_IntConfig_8: (+1)
   \   00000084   0xF44F 0x7080      MOV      R0,#+256
   \   00000088   0x0007             MOVS     R7,R0
    709          			break;
   \   0000008A   0xE002             B.N      ??UART_IntConfig_9
    710          		case UART_INTCFG_ABTO:
    711          			tmp = UART_IER_ABTOINT_EN;
   \                     ??UART_IntConfig_7: (+1)
   \   0000008C   0xF44F 0x7000      MOV      R0,#+512
   \   00000090   0x0007             MOVS     R7,R0
    712          			break;
    713          	}
    714          
    715          	if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART_IntConfig_9: (+1)
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000096   0x4284             CMP      R4,R0
   \   00000098   0xD11B             BNE.N    ??UART_IntConfig_10
    716          	{
    717          		CHECK_PARAM((PARAM_UART_INTCFG(UARTIntCfg)) || (PARAM_UART1_INTCFG(UARTIntCfg)));
   \   0000009A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009C   0x2D00             CMP      R5,#+0
   \   0000009E   0xD02D             BEQ.N    ??UART_IntConfig_11
   \   000000A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A2   0x2D01             CMP      R5,#+1
   \   000000A4   0xD02A             BEQ.N    ??UART_IntConfig_11
   \   000000A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A8   0x2D02             CMP      R5,#+2
   \   000000AA   0xD027             BEQ.N    ??UART_IntConfig_11
   \   000000AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000AE   0x2D05             CMP      R5,#+5
   \   000000B0   0xD024             BEQ.N    ??UART_IntConfig_11
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x2D06             CMP      R5,#+6
   \   000000B6   0xD021             BEQ.N    ??UART_IntConfig_11
   \   000000B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BA   0x2D03             CMP      R5,#+3
   \   000000BC   0xD01E             BEQ.N    ??UART_IntConfig_11
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2D04             CMP      R5,#+4
   \   000000C2   0xD01B             BEQ.N    ??UART_IntConfig_11
   \   000000C4   0xF240 0x21CD      MOVW     R1,#+717
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000CC   0x.... 0x....      BL       check_failed
   \   000000D0   0xE014             B.N      ??UART_IntConfig_11
    718          	}
    719          	else
    720          	{
    721          		CHECK_PARAM(PARAM_UART_INTCFG(UARTIntCfg));
   \                     ??UART_IntConfig_10: (+1)
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD011             BEQ.N    ??UART_IntConfig_11
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0x2D01             CMP      R5,#+1
   \   000000DC   0xD00E             BEQ.N    ??UART_IntConfig_11
   \   000000DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E0   0x2D02             CMP      R5,#+2
   \   000000E2   0xD00B             BEQ.N    ??UART_IntConfig_11
   \   000000E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E6   0x2D05             CMP      R5,#+5
   \   000000E8   0xD008             BEQ.N    ??UART_IntConfig_11
   \   000000EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EC   0x2D06             CMP      R5,#+6
   \   000000EE   0xD005             BEQ.N    ??UART_IntConfig_11
   \   000000F0   0xF240 0x21D1      MOVW     R1,#+721
   \   000000F4   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000F8   0x.... 0x....      BL       check_failed
    722          	}
    723          
    724          	if (NewState == ENABLE)
   \                     ??UART_IntConfig_11: (+1)
   \   000000FC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000FE   0x2E01             CMP      R6,#+1
   \   00000100   0xD10B             BNE.N    ??UART_IntConfig_12
    725          	{
    726          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000106   0x4284             CMP      R4,R0
   \   00000108   0xD103             BNE.N    ??UART_IntConfig_13
    727          		{
    728          			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER |= tmp;
   \   0000010A   0x6860             LDR      R0,[R4, #+4]
   \   0000010C   0x4338             ORRS     R0,R7,R0
   \   0000010E   0x6060             STR      R0,[R4, #+4]
   \   00000110   0xE014             B.N      ??UART_IntConfig_14
    729          		}
    730          		else
    731          		{
    732          			UARTx->/*DLIER.*/IER |= tmp;
   \                     ??UART_IntConfig_13: (+1)
   \   00000112   0x6860             LDR      R0,[R4, #+4]
   \   00000114   0x4338             ORRS     R0,R7,R0
   \   00000116   0x6060             STR      R0,[R4, #+4]
   \   00000118   0xE010             B.N      ??UART_IntConfig_14
    733          		}
    734          	}
    735          	else
    736          	{
    737          		if ((LPC_UART1_TypeDef *) UARTx == LPC_UART1)
   \                     ??UART_IntConfig_12: (+1)
   \   0000011A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD106             BNE.N    ??UART_IntConfig_15
    738          		{
    739          			((LPC_UART1_TypeDef *)UARTx)->/*DLIER.*/IER &= (~tmp) & UART1_IER_BITMASK;
   \   00000122   0x6860             LDR      R0,[R4, #+4]
   \   00000124   0xF240 0x318F      MOVW     R1,#+911
   \   00000128   0x43B9             BICS     R1,R1,R7
   \   0000012A   0x4008             ANDS     R0,R1,R0
   \   0000012C   0x6060             STR      R0,[R4, #+4]
   \   0000012E   0xE005             B.N      ??UART_IntConfig_14
    740          		}
    741          		else
    742          		{
    743          			UARTx->/*DLIER.*/IER &= (~tmp) & UART_IER_BITMASK;
   \                     ??UART_IntConfig_15: (+1)
   \   00000130   0x6860             LDR      R0,[R4, #+4]
   \   00000132   0xF240 0x3107      MOVW     R1,#+775
   \   00000136   0x43B9             BICS     R1,R1,R7
   \   00000138   0x4008             ANDS     R0,R1,R0
   \   0000013A   0x6060             STR      R0,[R4, #+4]
    744          		}
    745          	}
    746          }
   \                     ??UART_IntConfig_14: (+1)
   \   0000013C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    747          
    748          
    749          /********************************************************************//**
    750           * @brief 		Get current value of Line Status register in UART peripheral.
    751           * @param[in]	UARTx	UART peripheral selected, should be:
    752           *  			- LPC_UART0: UART0 peripheral
    753           * 				- LPC_UART1: UART1 peripheral
    754           * 				- LPC_UART2: UART2 peripheral
    755           * 				- LPC_UART3: UART3 peripheral
    756           * @return		Current value of Line Status register in UART peripheral.
    757           * Note:	The return value of this function must be ANDed with each member in
    758           * 			UART_LS_Type enumeration to determine current flag status
    759           * 			corresponding to each Line status type. Because some flags in
    760           * 			Line Status register will be cleared after reading, the next reading
    761           * 			Line Status register could not be correct. So this function used to
    762           * 			read Line status register in one time only, then the return value
    763           * 			used to check all flags.
    764           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    765          uint8_t UART_GetLineStatus(LPC_UART_TypeDef* UARTx)
    766          {
   \                     UART_GetLineStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    767          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD011             BEQ.N    ??UART_GetLineStatus_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00D             BEQ.N    ??UART_GetLineStatus_0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD009             BEQ.N    ??UART_GetLineStatus_0
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable13_2  ;; 0x4009c000
   \   00000020   0x4284             CMP      R4,R0
   \   00000022   0xD005             BEQ.N    ??UART_GetLineStatus_0
   \   00000024   0xF240 0x21FF      MOVW     R1,#+767
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
    768          
    769          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_GetLineStatus_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD104             BNE.N    ??UART_GetLineStatus_1
    770          	{
    771          		return ((((LPC_UART1_TypeDef *)LPC_UART1)->LSR) & UART_LSR_BITMASK);
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40010014
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xE000             B.N      ??UART_GetLineStatus_2
    772          	}
    773          	else
    774          	{
    775          		return ((UARTx->LSR) & UART_LSR_BITMASK);
   \                     ??UART_GetLineStatus_1: (+1)
   \   00000042   0x7D20             LDRB     R0,[R4, #+20]
   \                     ??UART_GetLineStatus_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    776          	}
    777          }
    778          
    779          /********************************************************************//**
    780           * @brief 		Get Interrupt Identification value
    781           * @param[in]	UARTx	UART peripheral selected, should be:
    782           *  			- LPC_UART0: UART0 peripheral
    783           * 				- LPC_UART1: UART1 peripheral
    784           * 				- LPC_UART2: UART2 peripheral
    785           * 				- LPC_UART3: UART3 peripheral
    786           * @return		Current value of UART UIIR register in UART peripheral.
    787           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    788          uint32_t UART_GetIntId(LPC_UART_TypeDef* UARTx)
    789          {
   \                     UART_GetIntId: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    790          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00F             BEQ.N    ??UART_GetIntId_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00B             BEQ.N    ??UART_GetIntId_0
   \   00000014   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40098000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD008             BEQ.N    ??UART_GetIntId_0
   \   0000001A   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD005             BEQ.N    ??UART_GetIntId_0
   \   00000020   0xF240 0x3116      MOVW     R1,#+790
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000028   0x.... 0x....      BL       check_failed
    791          	return (UARTx->IIR & 0x03CF);
   \                     ??UART_GetIntId_0: (+1)
   \   0000002C   0x68A0             LDR      R0,[R4, #+8]
   \   0000002E   0xF240 0x31CF      MOVW     R1,#+975
   \   00000032   0x4008             ANDS     R0,R1,R0
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
    792          }
    793          
    794          /*********************************************************************//**
    795           * @brief		Check whether if UART is busy or not
    796           * @param[in]	UARTx	UART peripheral selected, should be:
    797           *  			- LPC_UART0: UART0 peripheral
    798           * 				- LPC_UART1: UART1 peripheral
    799           * 				- LPC_UART2: UART2 peripheral
    800           * 				- LPC_UART3: UART3 peripheral
    801           * @return		RESET if UART is not busy, otherwise return SET.
    802           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    803          FlagStatus UART_CheckBusy(LPC_UART_TypeDef *UARTx)
    804          {
   \                     UART_CheckBusy: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    805          	if (UARTx->LSR & UART_LSR_TEMT){
   \   00000002   0x7D08             LDRB     R0,[R1, #+20]
   \   00000004   0x0640             LSLS     R0,R0,#+25
   \   00000006   0xD501             BPL.N    ??UART_CheckBusy_0
    806          		return RESET;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE000             B.N      ??UART_CheckBusy_1
    807          	} else {
    808          		return SET;
   \                     ??UART_CheckBusy_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \                     ??UART_CheckBusy_1: (+1)
   \   0000000E   0x4770             BX       LR               ;; return
    809          	}
    810          }
    811          
    812          
    813          /*********************************************************************//**
    814           * @brief		Configure FIFO function on selected UART peripheral
    815           * @param[in]	UARTx	UART peripheral selected, should be:
    816           *  			- LPC_UART0: UART0 peripheral
    817           * 				- LPC_UART1: UART1 peripheral
    818           * 				- LPC_UART2: UART2 peripheral
    819           * 				- LPC_UART3: UART3 peripheral
    820           * @param[in]	FIFOCfg	Pointer to a UART_FIFO_CFG_Type Structure that
    821           * 						contains specified information about FIFO configuration
    822           * @return 		none
    823           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    824          void UART_FIFOConfig(LPC_UART_TypeDef *UARTx, UART_FIFO_CFG_Type *FIFOCfg)
    825          {
   \                     UART_FIFOConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    826          	uint8_t tmp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    827          
    828          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00F             BEQ.N    ??UART_FIFOConfig_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00B             BEQ.N    ??UART_FIFOConfig_0
   \   00000016   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD008             BEQ.N    ??UART_FIFOConfig_0
   \   0000001C   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD005             BEQ.N    ??UART_FIFOConfig_0
   \   00000022   0xF44F 0x714F      MOV      R1,#+828
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000002A   0x.... 0x....      BL       check_failed
    829          	CHECK_PARAM(PARAM_UART_FIFO_LEVEL(FIFOCfg->FIFO_Level));
   \                     ??UART_FIFOConfig_0: (+1)
   \   0000002E   0x78E8             LDRB     R0,[R5, #+3]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD00E             BEQ.N    ??UART_FIFOConfig_1
   \   00000034   0x78E8             LDRB     R0,[R5, #+3]
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD00B             BEQ.N    ??UART_FIFOConfig_1
   \   0000003A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD008             BEQ.N    ??UART_FIFOConfig_1
   \   00000040   0x78E8             LDRB     R0,[R5, #+3]
   \   00000042   0x2803             CMP      R0,#+3
   \   00000044   0xD005             BEQ.N    ??UART_FIFOConfig_1
   \   00000046   0xF240 0x313D      MOVW     R1,#+829
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000004E   0x.... 0x....      BL       check_failed
    830          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_DMAMode));
   \                     ??UART_FIFOConfig_1: (+1)
   \   00000052   0x78A8             LDRB     R0,[R5, #+2]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD008             BEQ.N    ??UART_FIFOConfig_2
   \   00000058   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD005             BEQ.N    ??UART_FIFOConfig_2
   \   0000005E   0xF240 0x313E      MOVW     R1,#+830
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000066   0x.... 0x....      BL       check_failed
    831          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetRxBuf));
   \                     ??UART_FIFOConfig_2: (+1)
   \   0000006A   0x7828             LDRB     R0,[R5, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD008             BEQ.N    ??UART_FIFOConfig_3
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD005             BEQ.N    ??UART_FIFOConfig_3
   \   00000076   0xF240 0x313F      MOVW     R1,#+831
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000007E   0x.... 0x....      BL       check_failed
    832          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(FIFOCfg->FIFO_ResetTxBuf));
   \                     ??UART_FIFOConfig_3: (+1)
   \   00000082   0x7868             LDRB     R0,[R5, #+1]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD008             BEQ.N    ??UART_FIFOConfig_4
   \   00000088   0x7868             LDRB     R0,[R5, #+1]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD005             BEQ.N    ??UART_FIFOConfig_4
   \   0000008E   0xF44F 0x7150      MOV      R1,#+832
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000096   0x.... 0x....      BL       check_failed
    833          
    834          	tmp |= UART_FCR_FIFO_EN;
   \                     ??UART_FIFOConfig_4: (+1)
   \   0000009A   0xF056 0x0601      ORRS     R6,R6,#0x1
    835          	switch (FIFOCfg->FIFO_Level){
   \   0000009E   0x78E8             LDRB     R0,[R5, #+3]
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD003             BEQ.N    ??UART_FIFOConfig_5
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD005             BEQ.N    ??UART_FIFOConfig_6
   \   000000A8   0xD301             BCC.N    ??UART_FIFOConfig_7
   \   000000AA   0xE006             B.N      ??UART_FIFOConfig_8
    836          	case UART_FIFO_TRGLEV0:
    837          		tmp |= UART_FCR_TRG_LEV0;
    838          		break;
   \                     ??UART_FIFOConfig_5: (+1)
   \   000000AC   0xE007             B.N      ??UART_FIFOConfig_9
    839          	case UART_FIFO_TRGLEV1:
    840          		tmp |= UART_FCR_TRG_LEV1;
   \                     ??UART_FIFOConfig_7: (+1)
   \   000000AE   0xF056 0x0640      ORRS     R6,R6,#0x40
    841          		break;
   \   000000B2   0xE004             B.N      ??UART_FIFOConfig_9
    842          	case UART_FIFO_TRGLEV2:
    843          		tmp |= UART_FCR_TRG_LEV2;
   \                     ??UART_FIFOConfig_6: (+1)
   \   000000B4   0xF056 0x0680      ORRS     R6,R6,#0x80
    844          		break;
   \   000000B8   0xE001             B.N      ??UART_FIFOConfig_9
    845          	case UART_FIFO_TRGLEV3:
    846          	default:
    847          		tmp |= UART_FCR_TRG_LEV3;
   \                     ??UART_FIFOConfig_8: (+1)
   \   000000BA   0xF056 0x06C0      ORRS     R6,R6,#0xC0
    848          		break;
    849          	}
    850          
    851          	if (FIFOCfg->FIFO_ResetTxBuf == ENABLE)
   \                     ??UART_FIFOConfig_9: (+1)
   \   000000BE   0x7868             LDRB     R0,[R5, #+1]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD101             BNE.N    ??UART_FIFOConfig_10
    852          	{
    853          		tmp |= UART_FCR_TX_RS;
   \   000000C4   0xF056 0x0604      ORRS     R6,R6,#0x4
    854          	}
    855          	if (FIFOCfg->FIFO_ResetRxBuf == ENABLE)
   \                     ??UART_FIFOConfig_10: (+1)
   \   000000C8   0x7828             LDRB     R0,[R5, #+0]
   \   000000CA   0x2801             CMP      R0,#+1
   \   000000CC   0xD101             BNE.N    ??UART_FIFOConfig_11
    856          	{
    857          		tmp |= UART_FCR_RX_RS;
   \   000000CE   0xF056 0x0602      ORRS     R6,R6,#0x2
    858          	}
    859          	if (FIFOCfg->FIFO_DMAMode == ENABLE)
   \                     ??UART_FIFOConfig_11: (+1)
   \   000000D2   0x78A8             LDRB     R0,[R5, #+2]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD101             BNE.N    ??UART_FIFOConfig_12
    860          	{
    861          		tmp |= UART_FCR_DMAMODE_SEL;
   \   000000D8   0xF056 0x0608      ORRS     R6,R6,#0x8
    862          	}
    863          
    864          
    865          	//write to FIFO control register
    866          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_FIFOConfig_12: (+1)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   000000E0   0x4284             CMP      R4,R0
   \   000000E2   0xD103             BNE.N    ??UART_FIFOConfig_13
    867          	{
    868          		((LPC_UART1_TypeDef *)UARTx)->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
   \   000000E4   0xF016 0x00CF      ANDS     R0,R6,#0xCF
   \   000000E8   0x7220             STRB     R0,[R4, #+8]
   \   000000EA   0xE002             B.N      ??UART_FIFOConfig_14
    869          	}
    870          	else
    871          	{
    872          		UARTx->/*IIFCR.*/FCR = tmp & UART_FCR_BITMASK;
   \                     ??UART_FIFOConfig_13: (+1)
   \   000000EC   0xF016 0x00CF      ANDS     R0,R6,#0xCF
   \   000000F0   0x7220             STRB     R0,[R4, #+8]
    873          	}
    874          }
   \                     ??UART_FIFOConfig_14: (+1)
   \   000000F2   0xBD70             POP      {R4-R6,PC}       ;; return
    875          
    876          /*****************************************************************************//**
    877          * @brief		Fills each UART_FIFOInitStruct member with its default value:
    878          * 				- FIFO_DMAMode = DISABLE
    879          * 				- FIFO_Level = UART_FIFO_TRGLEV0
    880          * 				- FIFO_ResetRxBuf = ENABLE
    881          * 				- FIFO_ResetTxBuf = ENABLE
    882          * 				- FIFO_State = ENABLE
    883          
    884          * @param[in]	UART_FIFOInitStruct Pointer to a UART_FIFO_CFG_Type structure
    885          *                    which will be initialized.
    886          * @return		None
    887          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    888          void UART_FIFOConfigStructInit(UART_FIFO_CFG_Type *UART_FIFOInitStruct)
    889          {
    890          	UART_FIFOInitStruct->FIFO_DMAMode = DISABLE;
   \                     UART_FIFOConfigStructInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7081             STRB     R1,[R0, #+2]
    891          	UART_FIFOInitStruct->FIFO_Level = UART_FIFO_TRGLEV0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x70C1             STRB     R1,[R0, #+3]
    892          	UART_FIFOInitStruct->FIFO_ResetRxBuf = ENABLE;
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
    893          	UART_FIFOInitStruct->FIFO_ResetTxBuf = ENABLE;
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
    894          }
   \   00000010   0x4770             BX       LR               ;; return
    895          
    896          
    897          /*********************************************************************//**
    898           * @brief		Start/Stop Auto Baudrate activity
    899           * @param[in]	UARTx	UART peripheral selected, should be
    900           *   			- LPC_UART0: UART0 peripheral
    901           * 				- LPC_UART1: UART1 peripheral
    902           * 				- LPC_UART2: UART2 peripheral
    903           * 				- LPC_UART3: UART3 peripheral
    904           * @param[in]	ABConfigStruct	A pointer to UART_AB_CFG_Type structure that
    905           * 								contains specified information about UART
    906           * 								auto baudrate configuration
    907           * @param[in]	NewState New State of Auto baudrate activity, should be:
    908           * 				- ENABLE: Start this activity
    909           *				- DISABLE: Stop this activity
    910           * Note:		Auto-baudrate mode enable bit will be cleared once this mode
    911           * 				completed.
    912           * @return 		none
    913           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    914          void UART_ABCmd(LPC_UART_TypeDef *UARTx, UART_AB_CFG_Type *ABConfigStruct, \
    915          				FunctionalState NewState)
    916          {
   \                     UART_ABCmd: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    917          	uint32_t tmp;
    918          
    919          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable13  ;; 0x4000c000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD00E             BEQ.N    ??UART_ABCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD00A             BEQ.N    ??UART_ABCmd_0
   \   00000016   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40098000
   \   00000018   0x4284             CMP      R4,R0
   \   0000001A   0xD007             BEQ.N    ??UART_ABCmd_0
   \   0000001C   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   0000001E   0x4284             CMP      R4,R0
   \   00000020   0xD004             BEQ.N    ??UART_ABCmd_0
   \   00000022   0xF240 0x3197      MOVW     R1,#+919
   \   00000026   0x....             LDR.N    R0,??DataTable16_1
   \   00000028   0x.... 0x....      BL       check_failed
    920          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_ABCmd_0: (+1)
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD007             BEQ.N    ??UART_ABCmd_1
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x2E01             CMP      R6,#+1
   \   00000036   0xD004             BEQ.N    ??UART_ABCmd_1
   \   00000038   0xF44F 0x7166      MOV      R1,#+920
   \   0000003C   0x....             LDR.N    R0,??DataTable16_1
   \   0000003E   0x.... 0x....      BL       check_failed
    921          
    922          	tmp = 0;
   \                     ??UART_ABCmd_1: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
    923          	if (NewState == ENABLE) {
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD109             BNE.N    ??UART_ABCmd_2
    924          		if (ABConfigStruct->ABMode == UART_AUTOBAUD_MODE1){
   \   0000004C   0x7828             LDRB     R0,[R5, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xD101             BNE.N    ??UART_ABCmd_3
    925          			tmp |= UART_ACR_MODE;
   \   00000052   0xF057 0x0702      ORRS     R7,R7,#0x2
    926          		}
    927          		if (ABConfigStruct->AutoRestart == ENABLE){
   \                     ??UART_ABCmd_3: (+1)
   \   00000056   0x7868             LDRB     R0,[R5, #+1]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xD101             BNE.N    ??UART_ABCmd_2
    928          			tmp |= UART_ACR_AUTO_RESTART;
   \   0000005C   0xF057 0x0704      ORRS     R7,R7,#0x4
    929          		}
    930          	}
    931          
    932          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ABCmd_2: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xD117             BNE.N    ??UART_ABCmd_4
    933          	{
    934          		if (NewState == ENABLE)
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0x2E01             CMP      R6,#+1
   \   0000006C   0xD111             BNE.N    ??UART_ABCmd_5
    935          		{
    936          			// Clear DLL and DLM value
    937          			((LPC_UART1_TypeDef *)UARTx)->LCR |= UART_LCR_DLAB_EN;
   \   0000006E   0x7B20             LDRB     R0,[R4, #+12]
   \   00000070   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000074   0x7320             STRB     R0,[R4, #+12]
    938          			((LPC_UART1_TypeDef *)UARTx)->DLL = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x7020             STRB     R0,[R4, #+0]
    939          			((LPC_UART1_TypeDef *)UARTx)->DLM = 0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x7120             STRB     R0,[R4, #+4]
    940          			((LPC_UART1_TypeDef *)UARTx)->LCR &= ~UART_LCR_DLAB_EN;
   \   0000007E   0x7B20             LDRB     R0,[R4, #+12]
   \   00000080   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   00000084   0x7320             STRB     R0,[R4, #+12]
    941          			// FDR value must be reset to default value
    942          			((LPC_UART1_TypeDef *)UARTx)->FDR = 0x10;
   \   00000086   0x2010             MOVS     R0,#+16
   \   00000088   0x62A0             STR      R0,[R4, #+40]
    943          			((LPC_UART1_TypeDef *)UARTx)->ACR = UART_ACR_START | tmp;
   \   0000008A   0xF057 0x0001      ORRS     R0,R7,#0x1
   \   0000008E   0x6220             STR      R0,[R4, #+32]
   \   00000090   0xE01A             B.N      ??UART_ABCmd_6
    944          		}
    945          		else
    946          		{
    947          			((LPC_UART1_TypeDef *)UARTx)->ACR = 0;
   \                     ??UART_ABCmd_5: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x6220             STR      R0,[R4, #+32]
   \   00000096   0xE017             B.N      ??UART_ABCmd_6
    948          		}
    949          	}
    950          	else
    951          	{
    952          		if (NewState == ENABLE)
   \                     ??UART_ABCmd_4: (+1)
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x2E01             CMP      R6,#+1
   \   0000009C   0xD112             BNE.N    ??UART_ABCmd_7
    953          		{
    954          			// Clear DLL and DLM value
    955          			UARTx->LCR |= UART_LCR_DLAB_EN;
   \   0000009E   0x7B20             LDRB     R0,[R4, #+12]
   \   000000A0   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   000000A4   0x7320             STRB     R0,[R4, #+12]
    956          			UARTx->DLL = 0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7020             STRB     R0,[R4, #+0]
    957          			UARTx->DLM = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x7120             STRB     R0,[R4, #+4]
    958          			UARTx->LCR &= ~UART_LCR_DLAB_EN;
   \   000000AE   0x7B20             LDRB     R0,[R4, #+12]
   \   000000B0   0xF010 0x007F      ANDS     R0,R0,#0x7F
   \   000000B4   0x7320             STRB     R0,[R4, #+12]
    959          			// FDR value must be reset to default value
    960          			UARTx->FDR = 0x10;
   \   000000B6   0x2010             MOVS     R0,#+16
   \   000000B8   0xF884 0x0028      STRB     R0,[R4, #+40]
    961          			UARTx->ACR = UART_ACR_START | tmp;
   \   000000BC   0xF057 0x0001      ORRS     R0,R7,#0x1
   \   000000C0   0x6220             STR      R0,[R4, #+32]
   \   000000C2   0xE001             B.N      ??UART_ABCmd_6
    962          		}
    963          		else
    964          		{
    965          			UARTx->ACR = 0;
   \                     ??UART_ABCmd_7: (+1)
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x6220             STR      R0,[R4, #+32]
    966          		}
    967          	}
    968          }
   \                     ??UART_ABCmd_6: (+1)
   \   000000C8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    969          
    970          /*********************************************************************//**
    971           * @brief		Clear Autobaud Interrupt Pending
    972           * @param[in]	UARTx	UART peripheral selected, should be
    973           *   			- LPC_UART0: UART0 peripheral
    974           * 				- LPC_UART1: UART1 peripheral
    975           * 				- LPC_UART2: UART2 peripheral
    976           * 				- LPC_UART3: UART3 peripheral
    977           * @param[in]	ABIntType	type of auto-baud interrupt, should be:
    978           * 				- UART_AUTOBAUD_INTSTAT_ABEO: End of Auto-baud interrupt
    979           * 				- UART_AUTOBAUD_INTSTAT_ABTO: Auto-baud time out interrupt
    980           * @return 		none
    981           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    982          void UART_ABClearIntPending(LPC_UART_TypeDef *UARTx, UART_ABEO_Type ABIntType)
    983          {
   \                     UART_ABClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    984          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00E             BEQ.N    ??UART_ABClearIntPending_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00A             BEQ.N    ??UART_ABClearIntPending_0
   \   00000014   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40098000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??UART_ABClearIntPending_0
   \   0000001A   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD004             BEQ.N    ??UART_ABClearIntPending_0
   \   00000020   0xF44F 0x7176      MOV      R1,#+984
   \   00000024   0x....             LDR.N    R0,??DataTable16_1
   \   00000026   0x.... 0x....      BL       check_failed
    985          	if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_ABClearIntPending_0: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   0000002E   0x4284             CMP      R4,R0
   \   00000030   0xD104             BNE.N    ??UART_ABClearIntPending_1
    986          	{
    987          		UARTx->ACR |= ABIntType;
   \   00000032   0x6A20             LDR      R0,[R4, #+32]
   \   00000034   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000036   0x4328             ORRS     R0,R5,R0
   \   00000038   0x6220             STR      R0,[R4, #+32]
   \   0000003A   0xE003             B.N      ??UART_ABClearIntPending_2
    988          	}
    989          	else
    990          		UARTx->ACR |= ABIntType;
   \                     ??UART_ABClearIntPending_1: (+1)
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0xB22D             SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
   \   00000040   0x4328             ORRS     R0,R5,R0
   \   00000042   0x6220             STR      R0,[R4, #+32]
    991          }
   \                     ??UART_ABClearIntPending_2: (+1)
   \   00000044   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    992          
    993          /*********************************************************************//**
    994           * @brief		Enable/Disable transmission on UART TxD pin
    995           * @param[in]	UARTx	UART peripheral selected, should be:
    996           *   			- LPC_UART0: UART0 peripheral
    997           * 				- LPC_UART1: UART1 peripheral
    998           * 				- LPC_UART2: UART2 peripheral
    999           * 				- LPC_UART3: UART3 peripheral
   1000           * @param[in]	NewState New State of Tx transmission function, should be:
   1001           * 				- ENABLE: Enable this function
   1002          				- DISABLE: Disable this function
   1003           * @return none
   1004           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1005          void UART_TxCmd(LPC_UART_TypeDef *UARTx, FunctionalState NewState)
   1006          {
   \                     UART_TxCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1007          	CHECK_PARAM(PARAM_UARTx(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable13  ;; 0x4000c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD00E             BEQ.N    ??UART_TxCmd_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD00A             BEQ.N    ??UART_TxCmd_0
   \   00000014   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40098000
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD007             BEQ.N    ??UART_TxCmd_0
   \   0000001A   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   0000001C   0x4284             CMP      R4,R0
   \   0000001E   0xD004             BEQ.N    ??UART_TxCmd_0
   \   00000020   0xF240 0x31EF      MOVW     R1,#+1007
   \   00000024   0x....             LDR.N    R0,??DataTable16_1
   \   00000026   0x.... 0x....      BL       check_failed
   1008          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_TxCmd_0: (+1)
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD007             BEQ.N    ??UART_TxCmd_1
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD004             BEQ.N    ??UART_TxCmd_1
   \   00000036   0xF44F 0x717C      MOV      R1,#+1008
   \   0000003A   0x....             LDR.N    R0,??DataTable16_1
   \   0000003C   0x.... 0x....      BL       check_failed
   1009          
   1010          	if (NewState == ENABLE)
   \                     ??UART_TxCmd_1: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D01             CMP      R5,#+1
   \   00000044   0xD111             BNE.N    ??UART_TxCmd_2
   1011          	{
   1012          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   0000004A   0x4284             CMP      R4,R0
   \   0000004C   0xD106             BNE.N    ??UART_TxCmd_3
   1013          		{
   1014          			((LPC_UART1_TypeDef *)UARTx)->TER |= UART_TER_TXEN;
   \   0000004E   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000052   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000056   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   0000005A   0xE015             B.N      ??UART_TxCmd_4
   1015          		}
   1016          		else
   1017          		{
   1018          			UARTx->TER |= UART_TER_TXEN;
   \                     ??UART_TxCmd_3: (+1)
   \   0000005C   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000060   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000064   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   00000068   0xE00E             B.N      ??UART_TxCmd_4
   1019          		}
   1020          	}
   1021          	else
   1022          	{
   1023          		if (((LPC_UART1_TypeDef *)UARTx) == LPC_UART1)
   \                     ??UART_TxCmd_2: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable19  ;; 0x40010000
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD105             BNE.N    ??UART_TxCmd_5
   1024          		{
   1025          			((LPC_UART1_TypeDef *)UARTx)->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \   00000072   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF884 0x0030      STRB     R0,[R4, #+48]
   \   0000007C   0xE004             B.N      ??UART_TxCmd_4
   1026          		}
   1027          		else
   1028          		{
   1029          			UARTx->TER &= (~UART_TER_TXEN) & UART_TER_BITMASK;
   \                     ??UART_TxCmd_5: (+1)
   \   0000007E   0xF894 0x0030      LDRB     R0,[R4, #+48]
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xF884 0x0030      STRB     R0,[R4, #+48]
   1030          		}
   1031          	}
   1032          }
   \                     ??UART_TxCmd_4: (+1)
   \   00000088   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1033          
   1034          /* UART IrDA functions ---------------------------------------------------*/
   1035          
   1036          #ifdef _UART3
   1037          
   1038          /*********************************************************************//**
   1039           * @brief		Enable or disable inverting serial input function of IrDA
   1040           * 				on UART peripheral.
   1041           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1042           * @param[in]	NewState New state of inverting serial input, should be:
   1043           * 				- ENABLE: Enable this function.
   1044           * 				- DISABLE: Disable this function.
   1045           * @return none
   1046           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1047          void UART_IrDAInvtInputCmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
   1048          {
   \                     UART_IrDAInvtInputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1049          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable13_2  ;; 0x4009c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??UART_IrDAInvtInputCmd_0
   \   0000000C   0xF240 0x4119      MOVW     R1,#+1049
   \   00000010   0x....             LDR.N    R0,??DataTable16_1
   \   00000012   0x.... 0x....      BL       check_failed
   1050          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IrDAInvtInputCmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??UART_IrDAInvtInputCmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??UART_IrDAInvtInputCmd_1
   \   00000022   0xF240 0x411A      MOVW     R1,#+1050
   \   00000026   0x....             LDR.N    R0,??DataTable16_1
   \   00000028   0x.... 0x....      BL       check_failed
   1051          
   1052          	if (NewState == ENABLE)
   \                     ??UART_IrDAInvtInputCmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD106             BNE.N    ??UART_IrDAInvtInputCmd_2
   1053          	{
   1054          		UARTx->ICR |= UART_ICR_IRDAINV;
   \   00000032   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000036   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003A   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   0000003E   0xE008             B.N      ??UART_IrDAInvtInputCmd_3
   1055          	}
   1056          	else if (NewState == DISABLE)
   \                     ??UART_IrDAInvtInputCmd_2: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD105             BNE.N    ??UART_IrDAInvtInputCmd_3
   1057          	{
   1058          		UARTx->ICR &= (~UART_ICR_IRDAINV) & UART_ICR_BITMASK;
   \   00000046   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000004A   0xF010 0x003D      ANDS     R0,R0,#0x3D
   \   0000004E   0xF884 0x0024      STRB     R0,[R4, #+36]
   1059          	}
   1060          }
   \                     ??UART_IrDAInvtInputCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1061          
   1062          
   1063          /*********************************************************************//**
   1064           * @brief		Enable or disable IrDA function on UART peripheral.
   1065           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1066           * @param[in]	NewState New state of IrDA function, should be:
   1067           * 				- ENABLE: Enable this function.
   1068           * 				- DISABLE: Disable this function.
   1069           * @return none
   1070           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1071          void UART_IrDACmd(LPC_UART_TypeDef* UARTx, FunctionalState NewState)
   1072          {
   \                     UART_IrDACmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1073          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable19_1  ;; 0x4009c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??UART_IrDACmd_0
   \   0000000C   0xF240 0x4131      MOVW     R1,#+1073
   \   00000010   0x....             LDR.N    R0,??DataTable16_1
   \   00000012   0x.... 0x....      BL       check_failed
   1074          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_IrDACmd_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??UART_IrDACmd_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??UART_IrDACmd_1
   \   00000022   0xF240 0x4132      MOVW     R1,#+1074
   \   00000026   0x....             LDR.N    R0,??DataTable16_1
   \   00000028   0x.... 0x....      BL       check_failed
   1075          
   1076          	if (NewState == ENABLE)
   \                     ??UART_IrDACmd_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D01             CMP      R5,#+1
   \   00000030   0xD106             BNE.N    ??UART_IrDACmd_2
   1077          	{
   1078          		UARTx->ICR |= UART_ICR_IRDAEN;
   \   00000032   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000036   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003A   0xF884 0x0024      STRB     R0,[R4, #+36]
   \   0000003E   0xE005             B.N      ??UART_IrDACmd_3
   1079          	}
   1080          	else
   1081          	{
   1082          		UARTx->ICR &= (~UART_ICR_IRDAEN) & UART_ICR_BITMASK;
   \                     ??UART_IrDACmd_2: (+1)
   \   00000040   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   00000044   0xF010 0x003E      ANDS     R0,R0,#0x3E
   \   00000048   0xF884 0x0024      STRB     R0,[R4, #+36]
   1083          	}
   1084          }
   \                     ??UART_IrDACmd_3: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1085          
   1086          
   1087          /*********************************************************************//**
   1088           * @brief		Configure Pulse divider for IrDA function on UART peripheral.
   1089           * @param[in]	UARTx UART peripheral selected, should be LPC_UART3 (only)
   1090           * @param[in]	PulseDiv Pulse Divider value from Peripheral clock,
   1091           * 				should be one of the following:
   1092          				- UART_IrDA_PULSEDIV2 	: Pulse width = 2 * Tpclk
   1093          				- UART_IrDA_PULSEDIV4 	: Pulse width = 4 * Tpclk
   1094          				- UART_IrDA_PULSEDIV8 	: Pulse width = 8 * Tpclk
   1095          				- UART_IrDA_PULSEDIV16 	: Pulse width = 16 * Tpclk
   1096          				- UART_IrDA_PULSEDIV32 	: Pulse width = 32 * Tpclk
   1097          				- UART_IrDA_PULSEDIV64 	: Pulse width = 64 * Tpclk
   1098          				- UART_IrDA_PULSEDIV128 : Pulse width = 128 * Tpclk
   1099          				- UART_IrDA_PULSEDIV256 : Pulse width = 256 * Tpclk
   1100          
   1101           * @return none
   1102           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1103          void UART_IrDAPulseDivConfig(LPC_UART_TypeDef *UARTx, UART_IrDA_PULSE_Type PulseDiv)
   1104          {
   \                     UART_IrDAPulseDivConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1105          	uint32_t tmp, tmp1;
   1106          	CHECK_PARAM(PARAM_UART_IrDA(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable19_1  ;; 0x4009c000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??UART_IrDAPulseDivConfig_0
   \   0000000C   0xF240 0x4152      MOVW     R1,#+1106
   \   00000010   0x....             LDR.N    R0,??DataTable16_1
   \   00000012   0x.... 0x....      BL       check_failed
   1107          	CHECK_PARAM(PARAM_UART_IrDA_PULSEDIV(PulseDiv));
   \                     ??UART_IrDAPulseDivConfig_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD019             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD016             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D02             CMP      R5,#+2
   \   00000026   0xD013             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D03             CMP      R5,#+3
   \   0000002C   0xD010             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xD00D             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x2D05             CMP      R5,#+5
   \   00000038   0xD00A             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D06             CMP      R5,#+6
   \   0000003E   0xD007             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D07             CMP      R5,#+7
   \   00000044   0xD004             BEQ.N    ??UART_IrDAPulseDivConfig_1
   \   00000046   0xF240 0x4153      MOVW     R1,#+1107
   \   0000004A   0x....             LDR.N    R0,??DataTable16_1
   \   0000004C   0x.... 0x....      BL       check_failed
   1108          
   1109          	tmp1 = UART_ICR_PULSEDIV(PulseDiv);
   \                     ??UART_IrDAPulseDivConfig_1: (+1)
   \   00000050   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000052   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000056   0x00C0             LSLS     R0,R0,#+3
   \   00000058   0x0007             MOVS     R7,R0
   1110          	tmp = UARTx->ICR & (~UART_ICR_PULSEDIV(7));
   \   0000005A   0xF894 0x0024      LDRB     R0,[R4, #+36]
   \   0000005E   0xF030 0x0038      BICS     R0,R0,#0x38
   \   00000062   0x0006             MOVS     R6,R0
   1111          	tmp |= tmp1 | UART_ICR_FIXPULSE_EN;
   \   00000064   0xF057 0x0004      ORRS     R0,R7,#0x4
   \   00000068   0x4306             ORRS     R6,R0,R6
   1112          	UARTx->ICR = tmp & UART_ICR_BITMASK;
   \   0000006A   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   0000006E   0xF884 0x0024      STRB     R0,[R4, #+36]
   1113          }
   \   00000072   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1114          
   1115          #endif
   1116          
   1117          
   1118          /* UART1 FullModem function ---------------------------------------------*/
   1119          
   1120          #ifdef _UART1
   1121          
   1122          /*********************************************************************//**
   1123           * @brief		Force pin DTR/RTS corresponding to given state (Full modem mode)
   1124           * @param[in]	UARTx	LPC_UART1 (only)
   1125           * @param[in]	Pin	Pin that NewState will be applied to, should be:
   1126           * 				- UART1_MODEM_PIN_DTR: DTR pin.
   1127           * 				- UART1_MODEM_PIN_RTS: RTS pin.
   1128           * @param[in]	NewState New State of DTR/RTS pin, should be:
   1129           * 				- INACTIVE: Force the pin to inactive signal.
   1130          				- ACTIVE: Force the pin to active signal.
   1131           * @return none
   1132           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1133          void UART_FullModemForcePinState(LPC_UART1_TypeDef *UARTx, UART_MODEM_PIN_Type Pin, \
   1134          							UART1_SignalState NewState)
   1135          {
   \                     UART_FullModemForcePinState: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1136          	uint8_t tmp = 0;
   \   00000008   0x2700             MOVS     R7,#+0
   1137          
   1138          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   0000000A   0x....             LDR.N    R0,??DataTable16  ;; 0x40010000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??UART_FullModemForcePinState_0
   \   00000010   0xF240 0x4172      MOVW     R1,#+1138
   \   00000014   0x....             LDR.N    R0,??DataTable16_1
   \   00000016   0x.... 0x....      BL       check_failed
   1139          	CHECK_PARAM(PARAM_UART1_MODEM_PIN(Pin));
   \                     ??UART_FullModemForcePinState_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD007             BEQ.N    ??UART_FullModemForcePinState_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??UART_FullModemForcePinState_1
   \   00000026   0xF240 0x4173      MOVW     R1,#+1139
   \   0000002A   0x....             LDR.N    R0,??DataTable16_1
   \   0000002C   0x.... 0x....      BL       check_failed
   1140          	CHECK_PARAM(PARAM_UART1_SIGNALSTATE(NewState));
   \                     ??UART_FullModemForcePinState_1: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD007             BEQ.N    ??UART_FullModemForcePinState_2
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD004             BEQ.N    ??UART_FullModemForcePinState_2
   \   0000003C   0xF240 0x4174      MOVW     R1,#+1140
   \   00000040   0x....             LDR.N    R0,??DataTable16_1
   \   00000042   0x.... 0x....      BL       check_failed
   1141          
   1142          	switch (Pin){
   \                     ??UART_FullModemForcePinState_2: (+1)
   \   00000046   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD002             BEQ.N    ??UART_FullModemForcePinState_3
   \   0000004C   0x2D01             CMP      R5,#+1
   \   0000004E   0xD003             BEQ.N    ??UART_FullModemForcePinState_4
   \   00000050   0xE005             B.N      ??UART_FullModemForcePinState_5
   1143          	case UART1_MODEM_PIN_DTR:
   1144          		tmp = UART1_MCR_DTR_CTRL;
   \                     ??UART_FullModemForcePinState_3: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x0007             MOVS     R7,R0
   1145          		break;
   \   00000056   0xE002             B.N      ??UART_FullModemForcePinState_6
   1146          	case UART1_MODEM_PIN_RTS:
   1147          		tmp = UART1_MCR_RTS_CTRL;
   \                     ??UART_FullModemForcePinState_4: (+1)
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x0007             MOVS     R7,R0
   1148          		break;
   \   0000005C   0xE7FF             B.N      ??UART_FullModemForcePinState_6
   1149          	default:
   1150          		break;
   1151          	}
   1152          
   1153          	if (NewState == ACTIVE){
   \                     ??UART_FullModemForcePinState_5: (+1)
   \                     ??UART_FullModemForcePinState_6: (+1)
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E01             CMP      R6,#+1
   \   00000062   0xD103             BNE.N    ??UART_FullModemForcePinState_7
   1154          		UARTx->MCR |= tmp;
   \   00000064   0x7C20             LDRB     R0,[R4, #+16]
   \   00000066   0x4338             ORRS     R0,R7,R0
   \   00000068   0x7420             STRB     R0,[R4, #+16]
   \   0000006A   0xE005             B.N      ??UART_FullModemForcePinState_8
   1155          	} else {
   1156          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemForcePinState_7: (+1)
   \   0000006C   0x7C20             LDRB     R0,[R4, #+16]
   \   0000006E   0x43F9             MVNS     R1,R7
   \   00000070   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000074   0x4008             ANDS     R0,R1,R0
   \   00000076   0x7420             STRB     R0,[R4, #+16]
   1157          	}
   1158          }
   \                     ??UART_FullModemForcePinState_8: (+1)
   \   00000078   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1159          
   1160          
   1161          /*********************************************************************//**
   1162           * @brief		Configure Full Modem mode for UART peripheral
   1163           * @param[in]	UARTx	LPC_UART1 (only)
   1164           * @param[in]	Mode Full Modem mode, should be:
   1165           * 				- UART1_MODEM_MODE_LOOPBACK: Loop back mode.
   1166           * 				- UART1_MODEM_MODE_AUTO_RTS: Auto-RTS mode.
   1167           * 				- UART1_MODEM_MODE_AUTO_CTS: Auto-CTS mode.
   1168           * @param[in]	NewState New State of this mode, should be:
   1169           * 				- ENABLE: Enable this mode.
   1170          				- DISABLE: Disable this mode.
   1171           * @return none
   1172           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1173          void UART_FullModemConfigMode(LPC_UART1_TypeDef *UARTx, UART_MODEM_MODE_Type Mode, \
   1174          							FunctionalState NewState)
   1175          {
   \                     UART_FullModemConfigMode: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1176          	uint8_t tmp;
   1177          
   1178          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000008   0x....             LDR.N    R0,??DataTable19  ;; 0x40010000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??UART_FullModemConfigMode_0
   \   0000000E   0xF240 0x419A      MOVW     R1,#+1178
   \   00000012   0x....             LDR.N    R0,??DataTable19_3
   \   00000014   0x.... 0x....      BL       check_failed
   1179          	CHECK_PARAM(PARAM_UART1_MODEM_MODE(Mode));
   \                     ??UART_FullModemConfigMode_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD00A             BEQ.N    ??UART_FullModemConfigMode_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD007             BEQ.N    ??UART_FullModemConfigMode_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD004             BEQ.N    ??UART_FullModemConfigMode_1
   \   0000002A   0xF240 0x419B      MOVW     R1,#+1179
   \   0000002E   0x....             LDR.N    R0,??DataTable19_3
   \   00000030   0x.... 0x....      BL       check_failed
   1180          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??UART_FullModemConfigMode_1: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD007             BEQ.N    ??UART_FullModemConfigMode_2
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0x2E01             CMP      R6,#+1
   \   0000003E   0xD004             BEQ.N    ??UART_FullModemConfigMode_2
   \   00000040   0xF240 0x419C      MOVW     R1,#+1180
   \   00000044   0x....             LDR.N    R0,??DataTable19_3
   \   00000046   0x.... 0x....      BL       check_failed
   1181          
   1182          	switch(Mode){
   \                     ??UART_FullModemConfigMode_2: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD003             BEQ.N    ??UART_FullModemConfigMode_3
   \   00000050   0x2D02             CMP      R5,#+2
   \   00000052   0xD007             BEQ.N    ??UART_FullModemConfigMode_4
   \   00000054   0xD303             BCC.N    ??UART_FullModemConfigMode_5
   \   00000056   0xE008             B.N      ??UART_FullModemConfigMode_6
   1183          	case UART1_MODEM_MODE_LOOPBACK:
   1184          		tmp = UART1_MCR_LOOPB_EN;
   \                     ??UART_FullModemConfigMode_3: (+1)
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x0007             MOVS     R7,R0
   1185          		break;
   \   0000005C   0xE005             B.N      ??UART_FullModemConfigMode_7
   1186          	case UART1_MODEM_MODE_AUTO_RTS:
   1187          		tmp = UART1_MCR_AUTO_RTS_EN;
   \                     ??UART_FullModemConfigMode_5: (+1)
   \   0000005E   0x2040             MOVS     R0,#+64
   \   00000060   0x0007             MOVS     R7,R0
   1188          		break;
   \   00000062   0xE002             B.N      ??UART_FullModemConfigMode_7
   1189          	case UART1_MODEM_MODE_AUTO_CTS:
   1190          		tmp = UART1_MCR_AUTO_CTS_EN;
   \                     ??UART_FullModemConfigMode_4: (+1)
   \   00000064   0x2080             MOVS     R0,#+128
   \   00000066   0x0007             MOVS     R7,R0
   1191          		break;
   \   00000068   0xE7FF             B.N      ??UART_FullModemConfigMode_7
   1192          	default:
   1193          		break;
   1194          	}
   1195          
   1196          	if (NewState == ENABLE)
   \                     ??UART_FullModemConfigMode_6: (+1)
   \                     ??UART_FullModemConfigMode_7: (+1)
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0x2E01             CMP      R6,#+1
   \   0000006E   0xD103             BNE.N    ??UART_FullModemConfigMode_8
   1197          	{
   1198          		UARTx->MCR |= tmp;
   \   00000070   0x7C20             LDRB     R0,[R4, #+16]
   \   00000072   0x4338             ORRS     R0,R7,R0
   \   00000074   0x7420             STRB     R0,[R4, #+16]
   \   00000076   0xE005             B.N      ??UART_FullModemConfigMode_9
   1199          	}
   1200          	else
   1201          	{
   1202          		UARTx->MCR &= (~tmp) & UART1_MCR_BITMASK;
   \                     ??UART_FullModemConfigMode_8: (+1)
   \   00000078   0x7C20             LDRB     R0,[R4, #+16]
   \   0000007A   0x43F9             MVNS     R1,R7
   \   0000007C   0xF011 0x01F3      ANDS     R1,R1,#0xF3
   \   00000080   0x4008             ANDS     R0,R1,R0
   \   00000082   0x7420             STRB     R0,[R4, #+16]
   1203          	}
   1204          }
   \                     ??UART_FullModemConfigMode_9: (+1)
   \   00000084   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   1205          
   1206          
   1207          /*********************************************************************//**
   1208           * @brief		Get current status of modem status register
   1209           * @param[in]	UARTx	LPC_UART1 (only)
   1210           * @return 		Current value of modem status register
   1211           * Note:	The return value of this function must be ANDed with each member
   1212           * 			UART_MODEM_STAT_type enumeration to determine current flag status
   1213           * 			corresponding to each modem flag status. Because some flags in
   1214           * 			modem status register will be cleared after reading, the next reading
   1215           * 			modem register could not be correct. So this function used to
   1216           * 			read modem status register in one time only, then the return value
   1217           * 			used to check all flags.
   1218           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1219          uint8_t UART_FullModemGetStatus(LPC_UART1_TypeDef *UARTx)
   1220          {
   \                     UART_FullModemGetStatus: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1221          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000004   0x....             LDR.N    R0,??DataTable19  ;; 0x40010000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??UART_FullModemGetStatus_0
   \   0000000A   0xF240 0x41C5      MOVW     R1,#+1221
   \   0000000E   0x....             LDR.N    R0,??DataTable19_3
   \   00000010   0x.... 0x....      BL       check_failed
   1222          	return ((UARTx->MSR) & UART1_MSR_BITMASK);
   \                     ??UART_FullModemGetStatus_0: (+1)
   \   00000014   0x7E20             LDRB     R0,[R4, #+24]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   1223          }
   1224          
   1225          
   1226          /* UART RS485 functions --------------------------------------------------------------*/
   1227          
   1228          /*********************************************************************//**
   1229           * @brief		Configure UART peripheral in RS485 mode according to the specified
   1230          *               parameters in the RS485ConfigStruct.
   1231           * @param[in]	UARTx	LPC_UART1 (only)
   1232           * @param[in]	RS485ConfigStruct Pointer to a UART1_RS485_CTRLCFG_Type structure
   1233          *                    that contains the configuration information for specified UART
   1234          *                    in RS485 mode.
   1235           * @return		None
   1236           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1237          void UART_RS485Config(LPC_UART1_TypeDef *UARTx, UART1_RS485_CTRLCFG_Type *RS485ConfigStruct)
   1238          {
   \                     UART_RS485Config: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1239          	uint32_t tmp;
   1240          
   1241          	CHECK_PARAM(PARAM_UART1_MODEM(UARTx));
   \   00000006   0x....             LDR.N    R0,??DataTable19  ;; 0x40010000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??UART_RS485Config_0
   \   0000000C   0xF240 0x41D9      MOVW     R1,#+1241
   \   00000010   0x....             LDR.N    R0,??DataTable19_3
   \   00000012   0x.... 0x....      BL       check_failed
   1242          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoAddrDetect_State));
   \                     ??UART_RS485Config_0: (+1)
   \   00000016   0x78A8             LDRB     R0,[R5, #+2]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??UART_RS485Config_1
   \   0000001C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD004             BEQ.N    ??UART_RS485Config_1
   \   00000022   0xF240 0x41DA      MOVW     R1,#+1242
   \   00000026   0x....             LDR.N    R0,??DataTable19_3
   \   00000028   0x.... 0x....      BL       check_failed
   1243          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->AutoDirCtrl_State));
   \                     ??UART_RS485Config_1: (+1)
   \   0000002C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD007             BEQ.N    ??UART_RS485Config_2
   \   00000032   0x78E8             LDRB     R0,[R5, #+3]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD004             BEQ.N    ??UART_RS485Config_2
   \   00000038   0xF240 0x41DB      MOVW     R1,#+1243
   \   0000003C   0x....             LDR.N    R0,??DataTable19_3
   \   0000003E   0x.... 0x....      BL       check_failed
   1244          	CHECK_PARAM(PARAM_UART1_RS485_CFG_DELAYVALUE(RS485ConfigStruct->DelayValue));
   \                     ??UART_RS485Config_2: (+1)
   \   00000042   0x79E8             LDRB     R0,[R5, #+7]
   \   00000044   0x28FF             CMP      R0,#+255
   \   00000046   0xD104             BNE.N    ??UART_RS485Config_3
   \   00000048   0xF240 0x41DC      MOVW     R1,#+1244
   \   0000004C   0x....             LDR.N    R0,??DataTable19_3
   \   0000004E   0x.... 0x....      BL       check_failed
   1245          	CHECK_PARAM(PARAM_SETSTATE(RS485ConfigStruct->DirCtrlPol_Level));
   \                     ??UART_RS485Config_3: (+1)
   \   00000052   0x7968             LDRB     R0,[R5, #+5]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD007             BEQ.N    ??UART_RS485Config_4
   \   00000058   0x7968             LDRB     R0,[R5, #+5]
   \   0000005A   0x2801             CMP      R0,#+1
   \   0000005C   0xD004             BEQ.N    ??UART_RS485Config_4
   \   0000005E   0xF240 0x41DD      MOVW     R1,#+1245
   \   00000062   0x....             LDR.N    R0,??DataTable19_3
   \   00000064   0x.... 0x....      BL       check_failed
   1246          	CHECK_PARAM(PARAM_UART_RS485_DIRCTRL_PIN(RS485ConfigStruct->DirCtrlPin));
   \                     ??UART_RS485Config_4: (+1)
   \   00000068   0x7928             LDRB     R0,[R5, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD007             BEQ.N    ??UART_RS485Config_5
   \   0000006E   0x7928             LDRB     R0,[R5, #+4]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD004             BEQ.N    ??UART_RS485Config_5
   \   00000074   0xF240 0x41DE      MOVW     R1,#+1246
   \   00000078   0x....             LDR.N    R0,??DataTable19_3
   \   0000007A   0x.... 0x....      BL       check_failed
   1247          	CHECK_PARAM(PARAM_UART1_RS485_CFG_MATCHADDRVALUE(RS485ConfigStruct->MatchAddrValue));
   \                     ??UART_RS485Config_5: (+1)
   \   0000007E   0x79A8             LDRB     R0,[R5, #+6]
   \   00000080   0x28FF             CMP      R0,#+255
   \   00000082   0xD104             BNE.N    ??UART_RS485Config_6
   \   00000084   0xF240 0x41DF      MOVW     R1,#+1247
   \   00000088   0x....             LDR.N    R0,??DataTable19_3
   \   0000008A   0x.... 0x....      BL       check_failed
   1248          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->NormalMultiDropMode_State));
   \                     ??UART_RS485Config_6: (+1)
   \   0000008E   0x7828             LDRB     R0,[R5, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD007             BEQ.N    ??UART_RS485Config_7
   \   00000094   0x7828             LDRB     R0,[R5, #+0]
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD004             BEQ.N    ??UART_RS485Config_7
   \   0000009A   0xF44F 0x619C      MOV      R1,#+1248
   \   0000009E   0x....             LDR.N    R0,??DataTable19_3
   \   000000A0   0x.... 0x....      BL       check_failed
   1249          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(RS485ConfigStruct->Rx_State));
   \                     ??UART_RS485Config_7: (+1)
   \   000000A4   0x7868             LDRB     R0,[R5, #+1]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD007             BEQ.N    ??UART_RS485Config_8
   \   000000AA   0x7868             LDRB     R0,[R5, #+1]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xD004             BEQ.N    ??UART_RS485Config_8
   \   000000B0   0xF240 0x41E1      MOVW     R1,#+1249
   \   000000B4   0x....             LDR.N    R0,??DataTable19_3
   \   000000B6   0x.... 0x....      BL       check_failed
   1250          
   1251          	tmp = 0;
   \                     ??UART_RS485Config_8: (+1)
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x0006             MOVS     R6,R0
   1252          	// If Auto Direction Control is enabled -  This function is used in Master mode
   1253          	if (RS485ConfigStruct->AutoDirCtrl_State == ENABLE)
   \   000000BE   0x78E8             LDRB     R0,[R5, #+3]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD10E             BNE.N    ??UART_RS485Config_9
   1254          	{
   1255          		tmp |= UART1_RS485CTRL_DCTRL_EN;
   \   000000C4   0xF056 0x0610      ORRS     R6,R6,#0x10
   1256          
   1257          		// Set polar
   1258          		if (RS485ConfigStruct->DirCtrlPol_Level == SET)
   \   000000C8   0x7968             LDRB     R0,[R5, #+5]
   \   000000CA   0x2801             CMP      R0,#+1
   \   000000CC   0xD101             BNE.N    ??UART_RS485Config_10
   1259          		{
   1260          			tmp |= UART1_RS485CTRL_OINV_1;
   \   000000CE   0xF056 0x0620      ORRS     R6,R6,#0x20
   1261          		}
   1262          
   1263          		// Set pin according to
   1264          		if (RS485ConfigStruct->DirCtrlPin == UART1_RS485_DIRCTRL_DTR)
   \                     ??UART_RS485Config_10: (+1)
   \   000000D2   0x7928             LDRB     R0,[R5, #+4]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD101             BNE.N    ??UART_RS485Config_11
   1265          		{
   1266          			tmp |= UART1_RS485CTRL_SEL_DTR;
   \   000000D8   0xF056 0x0608      ORRS     R6,R6,#0x8
   1267          		}
   1268          
   1269          		// Fill delay time
   1270          		UARTx->RS485DLY = RS485ConfigStruct->DelayValue & UART1_RS485DLY_BITMASK;
   \                     ??UART_RS485Config_11: (+1)
   \   000000DC   0x79E8             LDRB     R0,[R5, #+7]
   \   000000DE   0xF884 0x0054      STRB     R0,[R4, #+84]
   1271          	}
   1272          
   1273          	// MultiDrop mode is enable
   1274          	if (RS485ConfigStruct->NormalMultiDropMode_State == ENABLE)
   \                     ??UART_RS485Config_9: (+1)
   \   000000E2   0x7828             LDRB     R0,[R5, #+0]
   \   000000E4   0x2801             CMP      R0,#+1
   \   000000E6   0xD101             BNE.N    ??UART_RS485Config_12
   1275          	{
   1276          		tmp |= UART1_RS485CTRL_NMM_EN;
   \   000000E8   0xF056 0x0601      ORRS     R6,R6,#0x1
   1277          	}
   1278          
   1279          	// Auto Address Detect function
   1280          	if (RS485ConfigStruct->AutoAddrDetect_State == ENABLE)
   \                     ??UART_RS485Config_12: (+1)
   \   000000EC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000EE   0x2801             CMP      R0,#+1
   \   000000F0   0xD104             BNE.N    ??UART_RS485Config_13
   1281          	{
   1282          		tmp |= UART1_RS485CTRL_AADEN;
   \   000000F2   0xF056 0x0604      ORRS     R6,R6,#0x4
   1283          		// Fill Match Address
   1284          		UARTx->ADRMATCH = RS485ConfigStruct->MatchAddrValue & UART1_RS485ADRMATCH_BITMASK;
   \   000000F6   0x79A8             LDRB     R0,[R5, #+6]
   \   000000F8   0xF884 0x0050      STRB     R0,[R4, #+80]
   1285          	}
   1286          
   1287          
   1288          	// Receiver is disable
   1289          	if (RS485ConfigStruct->Rx_State == DISABLE)
   \                     ??UART_RS485Config_13: (+1)
   \   000000FC   0x7868             LDRB     R0,[R5, #+1]
   \   000000FE   0x2800             CMP      R0,#+0
   \   00000100   0xD101             BNE.N    ??UART_RS485Config_14
   1290          	{
   1291          		tmp |= UART1_RS485CTRL_RX_DIS;
   \   00000102   0xF056 0x0602      ORRS     R6,R6,#0x2
   1292          	}
   1293          
   1294          	// write back to RS485 control register
   1295          	UARTx->RS485CTRL = tmp & UART1_RS485CTRL_BITMASK;
   \                     ??UART_RS485Config_14: (+1)
   \   00000106   0xF016 0x003F      ANDS     R0,R6,#0x3F
   \   0000010A   0xF884 0x004C      STRB     R0,[R4, #+76]
   1296          
   1297          	// Enable Parity function and leave parity in stick '0' parity as default
   1298          	UARTx->LCR |= (UART_LCR_PARITY_F_0 | UART_LCR_PARITY_EN);
   \   0000010E   0x7B20             LDRB     R0,[R4, #+12]
   \   00000110   0xF050 0x0038      ORRS     R0,R0,#0x38
   \   00000114   0x7320             STRB     R0,[R4, #+12]
   1299          }
   \   00000116   0xBD70             POP      {R4-R6,PC}       ;; return
   1300          
   1301          /*********************************************************************//**
   1302           * @brief		Enable/Disable receiver in RS485 module in UART1
   1303           * @param[in]	UARTx	LPC_UART1 (only)
   1304           * @param[in]	NewState	New State of command, should be:
   1305           * 							- ENABLE: Enable this function.
   1306           * 							- DISABLE: Disable this function.
   1307           * @return		None
   1308           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1309          void UART_RS485ReceiverCmd(LPC_UART1_TypeDef *UARTx, FunctionalState NewState)
   1310          {
   1311          	if (NewState == ENABLE){
   \                     UART_RS485ReceiverCmd: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD106             BNE.N    ??UART_RS485ReceiverCmd_0
   1312          		UARTx->RS485CTRL &= ~UART1_RS485CTRL_RX_DIS;
   \   00000006   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   0000000A   0xF012 0x02FD      ANDS     R2,R2,#0xFD
   \   0000000E   0xF880 0x204C      STRB     R2,[R0, #+76]
   \   00000012   0xE005             B.N      ??UART_RS485ReceiverCmd_1
   1313          	} else {
   1314          		UARTx->RS485CTRL |= UART1_RS485CTRL_RX_DIS;
   \                     ??UART_RS485ReceiverCmd_0: (+1)
   \   00000014   0xF890 0x204C      LDRB     R2,[R0, #+76]
   \   00000018   0xF052 0x0202      ORRS     R2,R2,#0x2
   \   0000001C   0xF880 0x204C      STRB     R2,[R0, #+76]
   1315          	}
   1316          }
   \                     ??UART_RS485ReceiverCmd_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
   1317          
   1318          /*********************************************************************//**
   1319           * @brief		Send data on RS485 bus with specified parity stick value (9-bit mode).
   1320           * @param[in]	UARTx	LPC_UART1 (only)
   1321           * @param[in]	pDatFrm 	Pointer to data frame.
   1322           * @param[in]	size		Size of data.
   1323           * @param[in]	ParityStick	Parity Stick value, should be 0 or 1.
   1324           * @return		None
   1325           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1326          uint32_t UART_RS485Send(LPC_UART1_TypeDef *UARTx, uint8_t *pDatFrm, \
   1327          					uint32_t size, uint8_t ParityStick)
   1328          {
   \                     UART_RS485Send: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   1329          	uint8_t tmp, save;
   1330          	uint32_t cnt;
   1331          
   1332          	if (ParityStick){
   \   0000000C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000E   0x2F00             CMP      R7,#+0
   \   00000010   0xD013             BEQ.N    ??UART_RS485Send_0
   1333          		save = tmp = UARTx->LCR & UART_LCR_BITMASK;
   \   00000012   0x7B20             LDRB     R0,[R4, #+12]
   \   00000014   0x4682             MOV      R10,R0
   \   00000016   0x46D0             MOV      R8,R10
   1334          		tmp &= ~(UART_LCR_PARITY_EVEN);
   \   00000018   0xF01A 0x0AEF      ANDS     R10,R10,#0xEF
   1335          		UARTx->LCR = tmp;
   \   0000001C   0xF884 0xA00C      STRB     R10,[R4, #+12]
   1336          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \   00000020   0x2301             MOVS     R3,#+1
   \   00000022   0x0032             MOVS     R2,R6
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       UART_Send
   \   0000002C   0x4681             MOV      R9,R0
   1337          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_1: (+1)
   \   0000002E   0x7D20             LDRB     R0,[R4, #+20]
   \   00000030   0x0640             LSLS     R0,R0,#+25
   \   00000032   0xD5FC             BPL.N    ??UART_RS485Send_1
   1338          		UARTx->LCR = save;
   \   00000034   0xF884 0x800C      STRB     R8,[R4, #+12]
   \   00000038   0xE009             B.N      ??UART_RS485Send_2
   1339          	} else {
   1340          		cnt = UART_Send((LPC_UART_TypeDef *)UARTx, pDatFrm, size, BLOCKING);
   \                     ??UART_RS485Send_0: (+1)
   \   0000003A   0x2301             MOVS     R3,#+1
   \   0000003C   0x0032             MOVS     R2,R6
   \   0000003E   0x0029             MOVS     R1,R5
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       UART_Send
   \   00000046   0x4681             MOV      R9,R0
   1341          		while (!(UARTx->LSR & UART_LSR_TEMT));
   \                     ??UART_RS485Send_3: (+1)
   \   00000048   0x7D20             LDRB     R0,[R4, #+20]
   \   0000004A   0x0640             LSLS     R0,R0,#+25
   \   0000004C   0xD5FC             BPL.N    ??UART_RS485Send_3
   1342          	}
   1343          	return cnt;
   \                     ??UART_RS485Send_2: (+1)
   \   0000004E   0x4648             MOV      R0,R9
   \   00000050   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1344          }
   1345          
   1346          /*********************************************************************//**
   1347           * @brief		Send Slave address frames on RS485 bus.
   1348           * @param[in]	UARTx	LPC_UART1 (only)
   1349           * @param[in]	SlvAddr Slave Address.
   1350           * @return		None
   1351           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1352          void UART_RS485SendSlvAddr(LPC_UART1_TypeDef *UARTx, uint8_t SlvAddr)
   1353          {
   \                     UART_RS485SendSlvAddr: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1354          	UART_RS485Send(UARTx, &SlvAddr, 1, 1);
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA901             ADD      R1,SP,#+4
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       UART_RS485Send
   1355          }
   \   00000010   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1356          
   1357          /*********************************************************************//**
   1358           * @brief		Send Data frames on RS485 bus.
   1359           * @param[in]	UARTx	LPC_UART1 (only)
   1360           * @param[in]	pData Pointer to data to be sent.
   1361           * @param[in]	size Size of data frame to be sent.
   1362           * @return		None
   1363           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1364          uint32_t UART_RS485SendData(LPC_UART1_TypeDef *UARTx, uint8_t *pData, uint32_t size)
   1365          {
   \                     UART_RS485SendData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1366          	return (UART_RS485Send(UARTx, pData, size, 0));
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0032             MOVS     R2,R6
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       UART_RS485Send
   \   00000014   0xBD70             POP      {R4-R6,PC}       ;; return
   1367          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40010014         DC32     0x40010014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0x20          DC8 30H, 20H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H
   \              0xCD 0xB3    
   \              0xBC 0xC6    
   \              0xC4 0xA3    
   \   00000018   0xBF 0xE9          DC8 0BFH, 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H
   \              0x5C 0x53    
   \              0x6F 0x66    
   \              0x74 0x77    
   \   00000020   0x61 0x72          DC8 61H, 72H, 65H, 5CH, 43H, 53H, 42H, 5CH
   \              0x65 0x5C    
   \              0x43 0x53    
   \              0x42 0x5C    
   \   00000028   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x6C    
   \   00000030   0x70 0x63          DC8 70H, 63H, 31H, 37H, 78H, 78H, 5FH, 75H
   \              0x31 0x37    
   \              0x78 0x78    
   \              0x5F 0x75    
   \   00000038   0x61 0x72          DC8 61H, 72H, 74H, 2EH, 63H, 0
   \              0x74 0x2E    
   \              0x63 0x00    
   \   0000003E   0x00 0x00          DC8 0, 0
   1368          
   1369          #endif /* _UART1 */
   1370          
   1371          #endif /* _UART */
   1372          
   1373          /**
   1374           * @}
   1375           */
   1376          
   1377          /**
   1378           * @}
   1379           */
   1380          /* --------------------------------- End Of File ------------------------------ */
   1381          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   UART_ABClearIntPending
        16   -> check_failed
      24   UART_ABCmd
        24   -> check_failed
       0   UART_CheckBusy
       0   UART_ConfigStructInit
       8   UART_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> UART_TxCmd
         8   -> check_failed
      16   UART_FIFOConfig
        16   -> check_failed
       0   UART_FIFOConfigStructInit
       8   UART_ForceBreak
         8   -> check_failed
      24   UART_FullModemConfigMode
        24   -> check_failed
      24   UART_FullModemForcePinState
        24   -> check_failed
       8   UART_FullModemGetStatus
         8   -> check_failed
       8   UART_GetIntId
         8   -> check_failed
       8   UART_GetLineStatus
         8   -> check_failed
      16   UART_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> check_failed
        16   -> uart_set_divisors
      24   UART_IntConfig
        24   -> check_failed
      16   UART_IrDACmd
        16   -> check_failed
      16   UART_IrDAInvtInputCmd
        16   -> check_failed
      24   UART_IrDAPulseDivConfig
        24   -> check_failed
      16   UART_RS485Config
        16   -> check_failed
       0   UART_RS485ReceiverCmd
      32   UART_RS485Send
        32   -> UART_Send
      16   UART_RS485SendData
        16   -> UART_RS485Send
      16   UART_RS485SendSlvAddr
        16   -> UART_RS485Send
      40   UART_Receive
        40   -> UART_ReceiveByte
       8   UART_ReceiveByte
         8   -> check_failed
      40   UART_Send
        40   -> UART_SendByte
      16   UART_SendByte
        16   -> check_failed
      16   UART_TxCmd
        16   -> check_failed
      88   uart_set_divisors
        88   -> CLKPWR_GetPCLK
        88 __aeabi_uldivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
      64  ?_0
      70  UART_ABClearIntPending
     202  UART_ABCmd
      16  UART_CheckBusy
      20  UART_ConfigStructInit
     126  UART_DeInit
     244  UART_FIFOConfig
      18  UART_FIFOConfigStructInit
      76  UART_ForceBreak
     134  UART_FullModemConfigMode
     122  UART_FullModemForcePinState
      24  UART_FullModemGetStatus
      54  UART_GetIntId
      70  UART_GetLineStatus
     514  UART_Init
     318  UART_IntConfig
      78  UART_IrDACmd
      84  UART_IrDAInvtInputCmd
     116  UART_IrDAPulseDivConfig
     280  UART_RS485Config
      34  UART_RS485ReceiverCmd
      84  UART_RS485Send
      22  UART_RS485SendData
      18  UART_RS485SendSlvAddr
     132  UART_Receive
      64  UART_ReceiveByte
     160  UART_Send
      66  UART_SendByte
     138  UART_TxCmd
     520  uart_set_divisors

 
    64 bytes in section .rodata
 3 840 bytes in section .text
 
 3 840 bytes of CODE  memory
    64 bytes of CONST memory

Errors: none
Warnings: none
