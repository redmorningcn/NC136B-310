###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/Aug/2017  10:56:47
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_ssp.c
#    Command line =  
#        "F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_ssp.c" -lCN
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -I "F:\iar\NC136B-310 统计模块\Application\Library\csnr_package_deal\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_ssp.lst
#    Object file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_ssp.o
#
###############################################################################

F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_ssp.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_ssp.c				2010-06-18
      3          *//**
      4          * @file		lpc17xx_ssp.c
      5          * @brief	Contains all functions support for SSP firmware library on LPC17xx
      6          * @version	3.0
      7          * @date		18. June. 2010
      8          * @author	NXP MCU SW Application Team
      9          *
     10          * Copyright(C) 2010, NXP Semiconductor
     11          * All rights reserved.
     12          *
     13          ***********************************************************************
     14          * Software that is described herein is for illustrative purposes only
     15          * which provides customers with programming information regarding the
     16          * products. This software is supplied "AS IS" without any warranties.
     17          * NXP Semiconductors assumes no responsibility or liability for the
     18          * use of the software, conveys no license or title under any patent,
     19          * copyright, or mask work right to the product. NXP Semiconductors
     20          * reserves the right to make changes in the software without
     21          * notification. NXP Semiconductors also make no representation or
     22          * warranty that such application will be suitable for the specified
     23          * use without further testing or modification.
     24          * Permission to use, copy, modify, and distribute this software and its
     25          * documentation is hereby granted, under NXP Semiconductors'
     26          * relevant copyright in the software, without fee, provided that it
     27          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     28          * copyright, permission, and disclaimer notice must appear in all copies of
     29          * this code.
     30          **********************************************************************/
     31          
     32          /* Peripheral group ----------------------------------------------------------- */
     33          /** @addtogroup SSP
     34           * @{
     35           */
     36          
     37          /* Includes ------------------------------------------------------------------- */
     38          #include "lpc17xx_ssp.h"
     39          #include "lpc17xx_clkpwr.h"
     40          
     41          
     42          /* If this source file built with example, the LPC17xx FW library configuration
     43           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     44           * otherwise the default FW library configuration file must be included instead
     45           */
     46          #ifdef __BUILD_WITH_EXAMPLE__
     47          #include "lpc17xx_libcfg.h"
     48          #else
     49          #include "lpc17xx_libcfg_default.h"
     50          #endif /* __BUILD_WITH_EXAMPLE__ */
     51          
     52          
     53          #ifdef _SSP
     54          
     55          /* Public Functions ----------------------------------------------------------- */
     56          /** @addtogroup SSP_Public_Functions
     57           * @{
     58           */
     59          static void setSSPclock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock);
     60          
     61          /*********************************************************************//**
     62           * @brief 		Setup clock rate for SSP device
     63           * @param[in] 	SSPx	SSP peripheral definition, should be:
     64           * 						- LPC_SSP0: SSP0 peripheral
     65           * 						- LPC_SSP1: SSP1 peripheral
     66           * @param[in]	target_clock : clock of SSP (Hz)
     67           * @return 		None
     68           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     69          static void setSSPclock (LPC_SSP_TypeDef *SSPx, uint32_t target_clock)
     70          {
   \                     setSSPclock: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
     71              uint32_t prescale, cr0_div, cmp_clk, ssp_clk;
     72          
     73              CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD008             BEQ.N    ??setSSPclock_0
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000014   0x4284             CMP      R4,R0
   \   00000016   0xD004             BEQ.N    ??setSSPclock_0
   \   00000018   0x2149             MOVS     R1,#+73
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001E   0x.... 0x....      BL       check_failed
     74          
     75              /* The SSP clock is derived from the (main system oscillator / 2),
     76                 so compute the best divider from that clock */
     77              if (SSPx == LPC_SSP0){
   \                     ??setSSPclock_0: (+1)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000026   0x4284             CMP      R4,R0
   \   00000028   0xD104             BNE.N    ??setSSPclock_1
     78              	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP0);
   \   0000002A   0x202A             MOVS     R0,#+42
   \   0000002C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0xE009             B.N      ??setSSPclock_2
     79              } else if (SSPx == LPC_SSP1) {
   \                     ??setSSPclock_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD104             BNE.N    ??setSSPclock_3
     80              	ssp_clk = CLKPWR_GetPCLK (CLKPWR_PCLKSEL_SSP1);
   \   0000003C   0x2014             MOVS     R0,#+20
   \   0000003E   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000042   0x4681             MOV      R9,R0
   \   00000044   0xE000             B.N      ??setSSPclock_2
     81              } else {
     82              	return;
   \                     ??setSSPclock_3: (+1)
   \   00000046   0xE020             B.N      ??setSSPclock_4
     83              }
     84          
     85          	/* Find closest divider to get at or under the target frequency.
     86          	   Use smallest prescale possible and rely on the divider to get
     87          	   the closest target frequency */
     88          	cr0_div = 0;
   \                     ??setSSPclock_2: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x0007             MOVS     R7,R0
     89          	cmp_clk = 0xFFFFFFFF;
   \   0000004C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000050   0x4680             MOV      R8,R0
     90          	prescale = 2;
   \   00000052   0x2002             MOVS     R0,#+2
   \   00000054   0x0006             MOVS     R6,R0
     91          	while (cmp_clk > target_clock)
   \                     ??setSSPclock_5: (+1)
   \   00000056   0x4545             CMP      R5,R8
   \   00000058   0xD20D             BCS.N    ??setSSPclock_6
     92          	{
     93          		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
   \   0000005A   0x1C78             ADDS     R0,R7,#+1
   \   0000005C   0x4370             MULS     R0,R6,R0
   \   0000005E   0xFBB9 0xF0F0      UDIV     R0,R9,R0
   \   00000062   0x4680             MOV      R8,R0
     94          		if (cmp_clk > target_clock)
   \   00000064   0x4545             CMP      R5,R8
   \   00000066   0xD2F6             BCS.N    ??setSSPclock_5
     95          		{
     96          			cr0_div++;
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
     97          			if (cr0_div > 0xFF)
   \   0000006A   0x2FFF             CMP      R7,#+255
   \   0000006C   0xD9F3             BLS.N    ??setSSPclock_5
     98          			{
     99          				cr0_div = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x0007             MOVS     R7,R0
    100          				prescale += 2;
   \   00000072   0x1CB6             ADDS     R6,R6,#+2
   \   00000074   0xE7EF             B.N      ??setSSPclock_5
    101          			}
    102          		}
    103          	}
    104          
    105              /* Write computed prescaler and divider back to register */
    106              SSPx->CR0 &= (~SSP_CR0_SCR(0xFF)) & SSP_CR0_BITMASK;
   \                     ??setSSPclock_6: (+1)
   \   00000076   0x6820             LDR      R0,[R4, #+0]
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x6020             STR      R0,[R4, #+0]
    107              SSPx->CR0 |= (SSP_CR0_SCR(cr0_div)) & SSP_CR0_BITMASK;
   \   0000007C   0x6820             LDR      R0,[R4, #+0]
   \   0000007E   0x0239             LSLS     R1,R7,#+8
   \   00000080   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000082   0x4308             ORRS     R0,R1,R0
   \   00000084   0x6020             STR      R0,[R4, #+0]
    108              SSPx->CPSR = prescale & SSP_CPSR_BITMASK;
   \   00000086   0xB2F0             UXTB     R0,R6            ;; ZeroExt  R0,R6,#+24,#+24
   \   00000088   0x6120             STR      R0,[R4, #+16]
    109          }
   \                     ??setSSPclock_4: (+1)
   \   0000008A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    110          
    111          /**
    112           * @}
    113           */
    114          
    115          /* Public Functions ----------------------------------------------------------- */
    116          /** @addtogroup SSP_Public_Functions
    117           * @{
    118           */
    119          
    120          /********************************************************************//**
    121           * @brief		Initializes the SSPx peripheral according to the specified
    122          *               parameters in the SSP_ConfigStruct.
    123           * @param[in]	SSPx	SSP peripheral selected, should be:
    124           * 				 		- LPC_SSP0: SSP0 peripheral
    125           * 						- LPC_SSP1: SSP1 peripheral
    126           * @param[in]	SSP_ConfigStruct Pointer to a SSP_CFG_Type structure
    127          *                    that contains the configuration information for the
    128          *                    specified SSP peripheral.
    129           * @return 		None
    130           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          void SSP_Init(LPC_SSP_TypeDef *SSPx, SSP_CFG_Type *SSP_ConfigStruct)
    132          {
   \                     SSP_Init: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    133          	uint32_t tmp;
    134          
    135          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD008             BEQ.N    ??SSP_Init_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SSP_Init_0
   \   00000016   0x2187             MOVS     R1,#+135
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001C   0x.... 0x....      BL       check_failed
    136          
    137          	if(SSPx == LPC_SSP0) {
   \                     ??SSP_Init_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000024   0x4284             CMP      R4,R0
   \   00000026   0xD105             BNE.N    ??SSP_Init_1
    138          		/* Set up clock and power for SSP0 module */
    139          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, ENABLE);
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000002E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000032   0xE00A             B.N      ??SSP_Init_2
    140          	} else if(SSPx == LPC_SSP1) {
   \                     ??SSP_Init_1: (+1)
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000038   0x4284             CMP      R4,R0
   \   0000003A   0xD105             BNE.N    ??SSP_Init_3
    141          		/* Set up clock and power for SSP1 module */
    142          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, ENABLE);
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000042   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000046   0xE000             B.N      ??SSP_Init_2
    143          	} else {
    144          		return;
   \                     ??SSP_Init_3: (+1)
   \   00000048   0xE012             B.N      ??SSP_Init_4
    145          	}
    146          
    147          	/* Configure SSP, interrupt is disable, LoopBack mode is disable,
    148          	 * SSP is disable, Slave output is disable as default
    149          	 */
    150          	tmp = ((SSP_ConfigStruct->CPHA) | (SSP_ConfigStruct->CPOL) \
    151          		| (SSP_ConfigStruct->FrameFormat) | (SSP_ConfigStruct->Databit))
    152          		& SSP_CR0_BITMASK;
   \                     ??SSP_Init_2: (+1)
   \   0000004A   0x6868             LDR      R0,[R5, #+4]
   \   0000004C   0x68A9             LDR      R1,[R5, #+8]
   \   0000004E   0x4308             ORRS     R0,R1,R0
   \   00000050   0x6929             LDR      R1,[R5, #+16]
   \   00000052   0x4308             ORRS     R0,R1,R0
   \   00000054   0x6829             LDR      R1,[R5, #+0]
   \   00000056   0x4308             ORRS     R0,R1,R0
   \   00000058   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005A   0x0006             MOVS     R6,R0
    153          	// write back to SSP control register
    154          	SSPx->CR0 = tmp;
   \   0000005C   0x6026             STR      R6,[R4, #+0]
    155          
    156          	tmp = SSP_ConfigStruct->Mode & SSP_CR1_BITMASK;
   \   0000005E   0x7B28             LDRB     R0,[R5, #+12]
   \   00000060   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000064   0x0006             MOVS     R6,R0
    157          	// Write back to CR1
    158          	SSPx->CR1 = tmp;
   \   00000066   0x6066             STR      R6,[R4, #+4]
    159          
    160          	// Set clock rate for SSP peripheral
    161          	setSSPclock(SSPx, SSP_ConfigStruct->ClockRate);
   \   00000068   0x6969             LDR      R1,[R5, #+20]
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x.... 0x....      BL       setSSPclock
    162          }
   \                     ??SSP_Init_4: (+1)
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    163          
    164          /*********************************************************************//**
    165           * @brief		De-initializes the SSPx peripheral registers to their
    166          *                  default reset values.
    167           * @param[in]	SSPx	SSP peripheral selected, should be:
    168           * 				 		- LPC_SSP0: SSP0 peripheral
    169           * 						- LPC_SSP1: SSP1 peripheral
    170           * @return 		None
    171           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    172          void SSP_DeInit(LPC_SSP_TypeDef* SSPx)
    173          {
   \                     SSP_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    174          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??SSP_DeInit_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_DeInit_0
   \   00000014   0x21AE             MOVS     R1,#+174
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001A   0x.... 0x....      BL       check_failed
    175          
    176          	if (SSPx == LPC_SSP0){
   \                     ??SSP_DeInit_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000022   0x4284             CMP      R4,R0
   \   00000024   0xD105             BNE.N    ??SSP_DeInit_1
    177          		/* Set up clock and power for SSP0 module */
    178          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP0, DISABLE);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000002C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
   \   00000030   0xE008             B.N      ??SSP_DeInit_2
    179          	} else if (SSPx == LPC_SSP1) {
   \                     ??SSP_DeInit_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000036   0x4284             CMP      R4,R0
   \   00000038   0xD104             BNE.N    ??SSP_DeInit_2
    180          		/* Set up clock and power for SSP1 module */
    181          		CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCSSP1, DISABLE);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0xF44F 0x6080      MOV      R0,#+1024
   \   00000040   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    182          	}
    183          }
   \                     ??SSP_DeInit_2: (+1)
   \   00000044   0xBD10             POP      {R4,PC}          ;; return
    184          
    185          /*****************************************************************************//**
    186          * @brief		Get data size bit selected
    187          * @param[in]	SSPx pointer to LPC_SSP_TypeDef structure, should be:
    188          * 				- LPC_SSP0: SSP0 peripheral
    189          * 				- LPC_SSP1: SSP1 peripheral
    190          * @return		Data size, could be:
    191          *				- SSP_DATABIT_4: 4 bit transfer
    192          *				- SSP_DATABIT_5: 5 bit transfer
    193          *				...
    194          *				- SSP_DATABIT_16: 16 bit transfer
    195          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    196          uint8_t SSP_GetDataSize(LPC_SSP_TypeDef* SSPx)
    197          {
   \                     SSP_GetDataSize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    198          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD008             BEQ.N    ??SSP_GetDataSize_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_GetDataSize_0
   \   00000014   0x21C6             MOVS     R1,#+198
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001A   0x.... 0x....      BL       check_failed
    199          	return (SSPx->CR0 & (0xF));
   \                     ??SSP_GetDataSize_0: (+1)
   \   0000001E   0x6820             LDR      R0,[R4, #+0]
   \   00000020   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    200          }
    201          
    202          /*****************************************************************************//**
    203          * @brief		Fills each SSP_InitStruct member with its default value:
    204          * 				- CPHA = SSP_CPHA_FIRST
    205          * 				- CPOL = SSP_CPOL_HI
    206          * 				- ClockRate = 1000000
    207          * 				- Databit = SSP_DATABIT_8
    208          * 				- Mode = SSP_MASTER_MODE
    209          * 				- FrameFormat = SSP_FRAME_SSP
    210          * @param[in]	SSP_InitStruct Pointer to a SSP_CFG_Type structure
    211          *                    which will be initialized.
    212          * @return		None
    213          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          void SSP_ConfigStructInit(SSP_CFG_Type *SSP_InitStruct)
    215          {
    216          	SSP_InitStruct->CPHA = SSP_CPHA_SECOND;	
   \                     SSP_ConfigStructInit: (+1)
   \   00000000   0x2180             MOVS     R1,#+128
   \   00000002   0x6041             STR      R1,[R0, #+4]
    217          	SSP_InitStruct->CPOL = SSP_CPOL_LO;
   \   00000004   0x2140             MOVS     R1,#+64
   \   00000006   0x6081             STR      R1,[R0, #+8]
    218          	SSP_InitStruct->ClockRate = 1000000;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16_3  ;; 0xf4240
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    219          	//SSP_InitStruct->ClockRate = 500000;
    220          	SSP_InitStruct->Databit = SSP_DATABIT_8;
   \   0000000E   0x2107             MOVS     R1,#+7
   \   00000010   0x6001             STR      R1,[R0, #+0]
    221          	SSP_InitStruct->Mode = SSP_MASTER_MODE;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
    222          	SSP_InitStruct->FrameFormat = SSP_FRAME_SPI;
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6101             STR      R1,[R0, #+16]
    223          }
   \   0000001A   0x4770             BX       LR               ;; return
    224          
    225          
    226          /*********************************************************************//**
    227           * @brief		Enable or disable SSP peripheral's operation
    228           * @param[in]	SSPx	SSP peripheral, should be:
    229           * 				- LPC_SSP0: SSP0 peripheral
    230           * 				- LPC_SSP1: SSP1 peripheral
    231           * @param[in]	NewState New State of SSPx peripheral's operation
    232           * @return 		none
    233           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          void SSP_Cmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    235          {
   \                     SSP_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    236          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD008             BEQ.N    ??SSP_Cmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD004             BEQ.N    ??SSP_Cmd_0
   \   00000016   0x21EC             MOVS     R1,#+236
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001C   0x.... 0x....      BL       check_failed
    237          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_Cmd_0: (+1)
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D00             CMP      R5,#+0
   \   00000024   0xD007             BEQ.N    ??SSP_Cmd_1
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D01             CMP      R5,#+1
   \   0000002A   0xD004             BEQ.N    ??SSP_Cmd_1
   \   0000002C   0x21ED             MOVS     R1,#+237
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000032   0x.... 0x....      BL       check_failed
    238          
    239          	if (NewState == ENABLE)
   \                     ??SSP_Cmd_1: (+1)
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x2D01             CMP      R5,#+1
   \   0000003A   0xD104             BNE.N    ??SSP_Cmd_2
    240          	{
    241          		SSPx->CR1 |= SSP_CR1_SSP_EN;
   \   0000003C   0x6860             LDR      R0,[R4, #+4]
   \   0000003E   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000042   0x6060             STR      R0,[R4, #+4]
   \   00000044   0xE003             B.N      ??SSP_Cmd_3
    242          	}
    243          	else
    244          	{
    245          		SSPx->CR1 &= (~SSP_CR1_SSP_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_Cmd_2: (+1)
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0xF010 0x000D      ANDS     R0,R0,#0xD
   \   0000004C   0x6060             STR      R0,[R4, #+4]
    246          	}
    247          }
   \                     ??SSP_Cmd_3: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    248          
    249          /*********************************************************************//**
    250           * @brief		Enable or disable Loop Back mode function in SSP peripheral
    251           * @param[in]	SSPx	SSP peripheral selected, should be:
    252           *  					- LPC_SSP0: SSP0 peripheral
    253           * 						- LPC_SSP1: SSP1 peripheral
    254           * @param[in]	NewState	New State of Loop Back mode, should be:
    255           * 							- ENABLE: Enable this function
    256           * 							- DISABLE: Disable this function
    257           * @return 		None
    258           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    259          void SSP_LoopBackCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    260          {
   \                     SSP_LoopBackCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    261          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_LoopBackCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_LoopBackCmd_0
   \   00000016   0xF240 0x1105      MOVW     R1,#+261
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001E   0x.... 0x....      BL       check_failed
    262          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_LoopBackCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SSP_LoopBackCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SSP_LoopBackCmd_1
   \   0000002E   0xF44F 0x7183      MOV      R1,#+262
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000036   0x.... 0x....      BL       check_failed
    263          
    264          	if (NewState == ENABLE)
   \                     ??SSP_LoopBackCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD104             BNE.N    ??SSP_LoopBackCmd_2
    265          	{
    266          		SSPx->CR1 |= SSP_CR1_LBM_EN;
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x6060             STR      R0,[R4, #+4]
   \   00000048   0xE003             B.N      ??SSP_LoopBackCmd_3
    267          	}
    268          	else
    269          	{
    270          		SSPx->CR1 &= (~SSP_CR1_LBM_EN) & SSP_CR1_BITMASK;
   \                     ??SSP_LoopBackCmd_2: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0xF010 0x000E      ANDS     R0,R0,#0xE
   \   00000050   0x6060             STR      R0,[R4, #+4]
    271          	}
    272          }
   \                     ??SSP_LoopBackCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    273          
    274          /*********************************************************************//**
    275           * @brief		Enable or disable Slave Output function in SSP peripheral
    276           * @param[in]	SSPx	SSP peripheral selected, should be:
    277           * 						- LPC_SSP0: SSP0 peripheral
    278           * 						- LPC_SSP1: SSP1 peripheral
    279           * @param[in]	NewState	New State of Slave Output function, should be:
    280           * 							- ENABLE: Slave Output in normal operation
    281           * 							- DISABLE: Slave Output is disabled. This blocks
    282           * 							SSP controller from driving the transmit data
    283           * 							line (MISO)
    284           * Note: 		This function is available when SSP peripheral in Slave mode
    285           * @return 		None
    286           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    287          void SSP_SlaveOutputCmd(LPC_SSP_TypeDef* SSPx, FunctionalState NewState)
    288          {
   \                     SSP_SlaveOutputCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    289          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_SlaveOutputCmd_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_SlaveOutputCmd_0
   \   00000016   0xF240 0x1121      MOVW     R1,#+289
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001E   0x.... 0x....      BL       check_failed
    290          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_SlaveOutputCmd_0: (+1)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD008             BEQ.N    ??SSP_SlaveOutputCmd_1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD005             BEQ.N    ??SSP_SlaveOutputCmd_1
   \   0000002E   0xF44F 0x7191      MOV      R1,#+290
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000036   0x.... 0x....      BL       check_failed
    291          
    292          	if (NewState == ENABLE)
   \                     ??SSP_SlaveOutputCmd_1: (+1)
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2D01             CMP      R5,#+1
   \   0000003E   0xD104             BNE.N    ??SSP_SlaveOutputCmd_2
    293          	{
    294          		SSPx->CR1 &= (~SSP_CR1_SO_DISABLE) & SSP_CR1_BITMASK;
   \   00000040   0x6860             LDR      R0,[R4, #+4]
   \   00000042   0xF010 0x0007      ANDS     R0,R0,#0x7
   \   00000046   0x6060             STR      R0,[R4, #+4]
   \   00000048   0xE003             B.N      ??SSP_SlaveOutputCmd_3
    295          	}
    296          	else
    297          	{
    298          		SSPx->CR1 |= SSP_CR1_SO_DISABLE;
   \                     ??SSP_SlaveOutputCmd_2: (+1)
   \   0000004A   0x6860             LDR      R0,[R4, #+4]
   \   0000004C   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000050   0x6060             STR      R0,[R4, #+4]
    299          	}
    300          }
   \                     ??SSP_SlaveOutputCmd_3: (+1)
   \   00000052   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    301          
    302          
    303          
    304          /*********************************************************************//**
    305           * @brief		Transmit a single data through SSPx peripheral
    306           * @param[in]	SSPx	SSP peripheral selected, should be:
    307           * 						- LPC_SSP0: SSP0 peripheral
    308           * 						- LPC_SSP1: SSP1 peripheral
    309           * @param[in]	Data	Data to transmit (must be 16 or 8-bit long,
    310           * 						this depend on SSP data bit number configured)
    311           * @return 		none
    312           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    313          void SSP_SendData(LPC_SSP_TypeDef* SSPx, uint16_t Data)
    314          {
   \                     SSP_SendData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    315          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD009             BEQ.N    ??SSP_SendData_0
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD005             BEQ.N    ??SSP_SendData_0
   \   00000016   0xF240 0x113B      MOVW     R1,#+315
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001E   0x.... 0x....      BL       check_failed
    316          
    317          	SSPx->DR = SSP_DR_BITMASK(Data);
   \                     ??SSP_SendData_0: (+1)
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x60A5             STR      R5,[R4, #+8]
    318          }
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    319          
    320          
    321          
    322          /*********************************************************************//**
    323           * @brief		Receive a single data from SSPx peripheral
    324           * @param[in]	SSPx	SSP peripheral selected, should be
    325           * 						- LPC_SSP0: SSP0 peripheral
    326           * 						- LPC_SSP1: SSP1 peripheral
    327           * @return 		Data received (16-bit long)
    328           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    329          uint16_t SSP_ReceiveData(LPC_SSP_TypeDef* SSPx)
    330          {
   \                     SSP_ReceiveData: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    331          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD009             BEQ.N    ??SSP_ReceiveData_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD005             BEQ.N    ??SSP_ReceiveData_0
   \   00000014   0xF240 0x114B      MOVW     R1,#+331
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001C   0x.... 0x....      BL       check_failed
    332          
    333          	return ((uint16_t) (SSP_DR_BITMASK(SSPx->DR)));
   \                     ??SSP_ReceiveData_0: (+1)
   \   00000020   0x68A0             LDR      R0,[R4, #+8]
   \   00000022   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    334          }
    335          
    336          /*********************************************************************//**
    337           * @brief 		SSP Read write data function
    338           * @param[in]	SSPx 	Pointer to SSP peripheral, should be
    339           * 						- LPC_SSP0: SSP0 peripheral
    340           * 						- LPC_SSP1: SSP1 peripheral
    341           * @param[in]	dataCfg	Pointer to a SSP_DATA_SETUP_Type structure that
    342           * 						contains specified information about transmit
    343           * 						data configuration.
    344           * @param[in]	xfType	Transfer type, should be:
    345           * 						- SSP_TRANSFER_POLLING: Polling mode
    346           * 						- SSP_TRANSFER_INTERRUPT: Interrupt mode
    347           * @return 		Actual Data length has been transferred in polling mode.
    348           * 				In interrupt mode, always return (0)
    349           * 				Return (-1) if error.
    350           * Note: This function can be used in both master and slave mode.
    351           ***********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    352          int32_t SSP_ReadWrite (LPC_SSP_TypeDef *SSPx, SSP_DATA_SETUP_Type *dataCfg, \
    353          						SSP_TRANSFER_Type xfType)
    354          {
   \                     SSP_ReadWrite: (+1)
   \   00000000   0xE92D 0x4FF4      PUSH     {R2,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x468B             MOV      R11,R1
    355          	uint8_t *rdata8;
    356              uint8_t *wdata8;
    357          	uint16_t *rdata16;
    358              uint16_t *wdata16;
    359              uint32_t stat;
    360              uint32_t tmp;
    361              int32_t dataword;
    362          
    363              dataCfg->rx_cnt = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8CB 0x000C      STR      R0,[R11, #+12]
    364              dataCfg->tx_cnt = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8CB 0x0004      STR      R0,[R11, #+4]
    365              dataCfg->status = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8CB 0x0014      STR      R0,[R11, #+20]
    366          
    367          
    368          	/* Clear all remaining data in RX FIFO */
    369          	while (SSPx->SR & SSP_SR_RNE){
   \                     ??SSP_ReadWrite_0: (+1)
   \   0000001C   0x68E0             LDR      R0,[R4, #+12]
   \   0000001E   0x0740             LSLS     R0,R0,#+29
   \   00000020   0xD504             BPL.N    ??SSP_ReadWrite_1
    370          		tmp = (uint32_t) SSP_ReceiveData(SSPx);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       SSP_ReceiveData
   \   00000028   0x0005             MOVS     R5,R0
   \   0000002A   0xE7F7             B.N      ??SSP_ReadWrite_0
    371          	}
    372          
    373          	// Clear status
    374          	SSPx->ICR = SSP_ICR_BITMASK;
   \                     ??SSP_ReadWrite_1: (+1)
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x6220             STR      R0,[R4, #+32]
    375          	if(SSP_GetDataSize(SSPx)>SSP_DATABIT_8)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       SSP_GetDataSize
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xD302             BCC.N    ??SSP_ReadWrite_2
    376          		dataword = 1;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0xE001             B.N      ??SSP_ReadWrite_3
    377          	else dataword = 0;
   \                     ??SSP_ReadWrite_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x0006             MOVS     R6,R0
    378          
    379          	// Polling mode ----------------------------------------------------------------------
    380          	if (xfType == SSP_TRANSFER_POLLING){
   \                     ??SSP_ReadWrite_3: (+1)
   \   00000044   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xF040 0x80A3      BNE.W    ??SSP_ReadWrite_4
    381          		if (dataword == 0){
   \   0000004E   0x2E00             CMP      R6,#+0
   \   00000050   0xD106             BNE.N    ??SSP_ReadWrite_5
    382          			rdata8 = (uint8_t *)dataCfg->rx_data;
   \   00000052   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000056   0x4681             MOV      R9,R0
    383          			wdata8 = (uint8_t *)dataCfg->tx_data;
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0xE005             B.N      ??SSP_ReadWrite_6
    384          		} else {
    385          			rdata16 = (uint16_t *)dataCfg->rx_data;
   \                     ??SSP_ReadWrite_5: (+1)
   \   00000060   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000064   0x4682             MOV      R10,R0
    386          			wdata16 = (uint16_t *)dataCfg->tx_data;
   \   00000066   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000006A   0x4680             MOV      R8,R0
    387          		}
    388          		while ((dataCfg->tx_cnt < dataCfg->length) || (dataCfg->rx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_6: (+1)
   \   0000006C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000070   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD305             BCC.N    ??SSP_ReadWrite_7
   \   00000078   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000007C   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000080   0x4288             CMP      R0,R1
   \   00000082   0xD273             BCS.N    ??SSP_ReadWrite_8
    389          			if ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_7: (+1)
   \   00000084   0x68E0             LDR      R0,[R4, #+12]
   \   00000086   0x0780             LSLS     R0,R0,#+30
   \   00000088   0xD53A             BPL.N    ??SSP_ReadWrite_9
   \   0000008A   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   0000008E   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xD234             BCS.N    ??SSP_ReadWrite_9
    390          				// Write data to buffer
    391          				if(dataCfg->tx_data == NULL){
   \   00000096   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD116             BNE.N    ??SSP_ReadWrite_10
    392          					if (dataword == 0){
   \   0000009E   0x2E00             CMP      R6,#+0
   \   000000A0   0xD109             BNE.N    ??SSP_ReadWrite_11
    393          						SSP_SendData(SSPx, 0xFF);
   \   000000A2   0x21FF             MOVS     R1,#+255
   \   000000A4   0x0020             MOVS     R0,R4
   \   000000A6   0x.... 0x....      BL       SSP_SendData
    394          						dataCfg->tx_cnt++;
   \   000000AA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000B4   0xE024             B.N      ??SSP_ReadWrite_9
    395          					} else {
    396          						SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_11: (+1)
   \   000000B6   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000BA   0x0020             MOVS     R0,R4
   \   000000BC   0x.... 0x....      BL       SSP_SendData
    397          						dataCfg->tx_cnt += 2;
   \   000000C0   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000C4   0x1C80             ADDS     R0,R0,#+2
   \   000000C6   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000CA   0xE019             B.N      ??SSP_ReadWrite_9
    398          					}
    399          				} else {
    400          					if (dataword == 0){
   \                     ??SSP_ReadWrite_10: (+1)
   \   000000CC   0x2E00             CMP      R6,#+0
   \   000000CE   0xD10B             BNE.N    ??SSP_ReadWrite_12
    401          						SSP_SendData(SSPx, *wdata8);
   \   000000D0   0x7839             LDRB     R1,[R7, #+0]
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       SSP_SendData
    402          						wdata8++;
   \   000000DA   0x1C7F             ADDS     R7,R7,#+1
    403          						dataCfg->tx_cnt++;
   \   000000DC   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000000E6   0xE00B             B.N      ??SSP_ReadWrite_9
    404          					} else {
    405          						SSP_SendData(SSPx, *wdata16);
   \                     ??SSP_ReadWrite_12: (+1)
   \   000000E8   0xF8B8 0x1000      LDRH     R1,[R8, #+0]
   \   000000EC   0x0020             MOVS     R0,R4
   \   000000EE   0x.... 0x....      BL       SSP_SendData
    406          						wdata16++;
   \   000000F2   0xF118 0x0802      ADDS     R8,R8,#+2
    407          						dataCfg->tx_cnt += 2;
   \   000000F6   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000000FA   0x1C80             ADDS     R0,R0,#+2
   \   000000FC   0xF8CB 0x0004      STR      R0,[R11, #+4]
    408          					}
    409          				}
    410          			}
    411          
    412          			// Check overrun error
    413          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_9: (+1)
   \   00000100   0x69A0             LDR      R0,[R4, #+24]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x07C0             LSLS     R0,R0,#+31
   \   00000106   0xD507             BPL.N    ??SSP_ReadWrite_13
    414          				// save status and return
    415          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   00000108   0x9800             LDR      R0,[SP, #+0]
   \   0000010A   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   0000010E   0xF8CB 0x0014      STR      R0,[R11, #+20]
    416          				return (-1);
   \   00000112   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000116   0xE0D5             B.N      ??SSP_ReadWrite_14
    417          			}
    418          
    419          			// Check for any data available in RX FIFO
    420          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_13: (+1)
   \   00000118   0x68E0             LDR      R0,[R4, #+12]
   \   0000011A   0x0740             LSLS     R0,R0,#+29
   \   0000011C   0xD5A6             BPL.N    ??SSP_ReadWrite_6
   \   0000011E   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000122   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   00000126   0x4288             CMP      R0,R1
   \   00000128   0xD2A0             BCS.N    ??SSP_ReadWrite_6
    421          				// Read data from SSP data
    422          				tmp = SSP_ReceiveData(SSPx);
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x.... 0x....      BL       SSP_ReceiveData
   \   00000130   0x0005             MOVS     R5,R0
    423          
    424          				// Store data to destination
    425          				if (dataCfg->rx_data != NULL)
   \   00000132   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000136   0x2800             CMP      R0,#+0
   \   00000138   0xD00A             BEQ.N    ??SSP_ReadWrite_15
    426          				{
    427          					if (dataword == 0){
   \   0000013A   0x2E00             CMP      R6,#+0
   \   0000013C   0xD104             BNE.N    ??SSP_ReadWrite_16
    428          						*(rdata8) = (uint8_t) tmp;
   \   0000013E   0xF889 0x5000      STRB     R5,[R9, #+0]
    429          						rdata8++;
   \   00000142   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000146   0xE003             B.N      ??SSP_ReadWrite_15
    430          					} else {
    431          						*(rdata16) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_16: (+1)
   \   00000148   0xF8AA 0x5000      STRH     R5,[R10, #+0]
    432          						rdata16++;
   \   0000014C   0xF11A 0x0A02      ADDS     R10,R10,#+2
    433          					}
    434          //					printfcom0("\r\n 1 tmp %x",tmp);
    435          
    436          				}
    437          				// Increase counter
    438          				if (dataword == 0){
   \                     ??SSP_ReadWrite_15: (+1)
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD105             BNE.N    ??SSP_ReadWrite_17
    439          					dataCfg->rx_cnt++;
   \   00000154   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000158   0x1C40             ADDS     R0,R0,#+1
   \   0000015A   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   0000015E   0xE7DB             B.N      ??SSP_ReadWrite_13
    440          				} else {
    441          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_17: (+1)
   \   00000160   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000164   0x1C80             ADDS     R0,R0,#+2
   \   00000166   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   0000016A   0xE7D5             B.N      ??SSP_ReadWrite_13
    442          				}
    443          			}
    444          		}
    445          
    446          		// save status
    447          		dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_8: (+1)
   \   0000016C   0xF44F 0x7080      MOV      R0,#+256
   \   00000170   0xF8CB 0x0014      STR      R0,[R11, #+20]
    448          
    449          		if (dataCfg->tx_data != NULL){
   \   00000174   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   00000178   0x2800             CMP      R0,#+0
   \   0000017A   0xD002             BEQ.N    ??SSP_ReadWrite_18
    450          			return dataCfg->tx_cnt;
   \   0000017C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000180   0xE0A0             B.N      ??SSP_ReadWrite_14
    451          		} else if (dataCfg->rx_data != NULL){
   \                     ??SSP_ReadWrite_18: (+1)
   \   00000182   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000186   0x2800             CMP      R0,#+0
   \   00000188   0xD002             BEQ.N    ??SSP_ReadWrite_19
    452          			return dataCfg->rx_cnt;
   \   0000018A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000018E   0xE099             B.N      ??SSP_ReadWrite_14
    453          		} else {
    454          			return (0);
   \                     ??SSP_ReadWrite_19: (+1)
   \   00000190   0x2000             MOVS     R0,#+0
   \   00000192   0xE097             B.N      ??SSP_ReadWrite_14
    455          		}
    456          	}
    457          
    458          	// Interrupt mode ----------------------------------------------------------------------
    459          	else if (xfType == SSP_TRANSFER_INTERRUPT){
   \                     ??SSP_ReadWrite_4: (+1)
   \   00000194   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xF040 0x8091      BNE.W    ??SSP_ReadWrite_20
    460          
    461          		while ((SSPx->SR & SSP_SR_TNF) && (dataCfg->tx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_21: (+1)
   \   0000019E   0x68E0             LDR      R0,[R4, #+12]
   \   000001A0   0x0780             LSLS     R0,R0,#+30
   \   000001A2   0xD578             BPL.N    ??SSP_ReadWrite_22
   \   000001A4   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001A8   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000001AC   0x4288             CMP      R0,R1
   \   000001AE   0xD272             BCS.N    ??SSP_ReadWrite_22
    462          			// Write data to buffer
    463          			if(dataCfg->tx_data == NULL){
   \   000001B0   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001B4   0x2800             CMP      R0,#+0
   \   000001B6   0xD116             BNE.N    ??SSP_ReadWrite_23
    464          				if (dataword == 0){
   \   000001B8   0x2E00             CMP      R6,#+0
   \   000001BA   0xD109             BNE.N    ??SSP_ReadWrite_24
    465          					SSP_SendData(SSPx, 0xFF);
   \   000001BC   0x21FF             MOVS     R1,#+255
   \   000001BE   0x0020             MOVS     R0,R4
   \   000001C0   0x.... 0x....      BL       SSP_SendData
    466          					dataCfg->tx_cnt++;
   \   000001C4   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001C8   0x1C40             ADDS     R0,R0,#+1
   \   000001CA   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000001CE   0xE02A             B.N      ??SSP_ReadWrite_25
    467          				} else {
    468          					SSP_SendData(SSPx, 0xFFFF);
   \                     ??SSP_ReadWrite_24: (+1)
   \   000001D0   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000001D4   0x0020             MOVS     R0,R4
   \   000001D6   0x.... 0x....      BL       SSP_SendData
    469          					dataCfg->tx_cnt += 2;
   \   000001DA   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000001DE   0x1C80             ADDS     R0,R0,#+2
   \   000001E0   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   000001E4   0xE01F             B.N      ??SSP_ReadWrite_25
    470          				}
    471          			} else {
    472          				if (dataword == 0){
   \                     ??SSP_ReadWrite_23: (+1)
   \   000001E6   0x2E00             CMP      R6,#+0
   \   000001E8   0xD10F             BNE.N    ??SSP_ReadWrite_26
    473          					SSP_SendData(SSPx, (*(uint8_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \   000001EA   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   000001EE   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   000001F2   0x5C09             LDRB     R1,[R1, R0]
   \   000001F4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001F6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000001F8   0x0020             MOVS     R0,R4
   \   000001FA   0x.... 0x....      BL       SSP_SendData
    474          					dataCfg->tx_cnt++;
   \   000001FE   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000202   0x1C40             ADDS     R0,R0,#+1
   \   00000204   0xF8CB 0x0004      STR      R0,[R11, #+4]
   \   00000208   0xE00D             B.N      ??SSP_ReadWrite_25
    475          				} else {
    476          					SSP_SendData(SSPx, (*(uint16_t *)((uint32_t)dataCfg->tx_data + dataCfg->tx_cnt)));
   \                     ??SSP_ReadWrite_26: (+1)
   \   0000020A   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000020E   0xF8DB 0x1004      LDR      R1,[R11, #+4]
   \   00000212   0x5A09             LDRH     R1,[R1, R0]
   \   00000214   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000216   0x0020             MOVS     R0,R4
   \   00000218   0x.... 0x....      BL       SSP_SendData
    477          					dataCfg->tx_cnt += 2;
   \   0000021C   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   00000220   0x1C80             ADDS     R0,R0,#+2
   \   00000222   0xF8CB 0x0004      STR      R0,[R11, #+4]
    478          				}
    479          			}
    480          
    481          			// Check error
    482          			if ((stat = SSPx->RIS) & SSP_RIS_ROR){
   \                     ??SSP_ReadWrite_25: (+1)
   \   00000226   0x69A0             LDR      R0,[R4, #+24]
   \   00000228   0x9000             STR      R0,[SP, #+0]
   \   0000022A   0x07C0             LSLS     R0,R0,#+31
   \   0000022C   0xD507             BPL.N    ??SSP_ReadWrite_27
    483          				// save status and return
    484          				dataCfg->status = stat | SSP_STAT_ERROR;
   \   0000022E   0x9800             LDR      R0,[SP, #+0]
   \   00000230   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000234   0xF8CB 0x0014      STR      R0,[R11, #+20]
    485          				return (-1);
   \   00000238   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000023C   0xE042             B.N      ??SSP_ReadWrite_14
    486          			}
    487          
    488          			// Check for any data available in RX FIFO
    489          			while ((SSPx->SR & SSP_SR_RNE) && (dataCfg->rx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_27: (+1)
   \   0000023E   0x68E0             LDR      R0,[R4, #+12]
   \   00000240   0x0740             LSLS     R0,R0,#+29
   \   00000242   0xD5AC             BPL.N    ??SSP_ReadWrite_21
   \   00000244   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000248   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000024C   0x4288             CMP      R0,R1
   \   0000024E   0xD2A6             BCS.N    ??SSP_ReadWrite_21
    490          				// Read data from SSP data
    491          				tmp = SSP_ReceiveData(SSPx);
   \   00000250   0x0020             MOVS     R0,R4
   \   00000252   0x.... 0x....      BL       SSP_ReceiveData
   \   00000256   0x0005             MOVS     R5,R0
    492          
    493          				// Store data to destination
    494          				if (dataCfg->rx_data != NULL)
   \   00000258   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   0000025C   0x2800             CMP      R0,#+0
   \   0000025E   0xD00C             BEQ.N    ??SSP_ReadWrite_28
    495          				{
    496          					if (dataword == 0){
   \   00000260   0x2E00             CMP      R6,#+0
   \   00000262   0xD105             BNE.N    ??SSP_ReadWrite_29
    497          						*(uint8_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint8_t) tmp;
   \   00000264   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000268   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   0000026C   0x540D             STRB     R5,[R1, R0]
   \   0000026E   0xE004             B.N      ??SSP_ReadWrite_28
    498          					} else {
    499          						*(uint16_t *)((uint32_t)dataCfg->rx_data + dataCfg->rx_cnt) = (uint16_t) tmp;
   \                     ??SSP_ReadWrite_29: (+1)
   \   00000270   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000274   0xF8DB 0x100C      LDR      R1,[R11, #+12]
   \   00000278   0x520D             STRH     R5,[R1, R0]
    500          					}
    501          				}
    502          				// Increase counter
    503          				if (dataword == 0){
   \                     ??SSP_ReadWrite_28: (+1)
   \   0000027A   0x2E00             CMP      R6,#+0
   \   0000027C   0xD105             BNE.N    ??SSP_ReadWrite_30
    504          					dataCfg->rx_cnt++;
   \   0000027E   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   00000282   0x1C40             ADDS     R0,R0,#+1
   \   00000284   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000288   0xE7D9             B.N      ??SSP_ReadWrite_27
    505          				} else {
    506          					dataCfg->rx_cnt += 2;
   \                     ??SSP_ReadWrite_30: (+1)
   \   0000028A   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000028E   0x1C80             ADDS     R0,R0,#+2
   \   00000290   0xF8CB 0x000C      STR      R0,[R11, #+12]
   \   00000294   0xE7D3             B.N      ??SSP_ReadWrite_27
    507          				}
    508          			}
    509          		}
    510          
    511          		// If there more data to sent or receive
    512          		if ((dataCfg->rx_cnt < dataCfg->length) || (dataCfg->tx_cnt < dataCfg->length)){
   \                     ??SSP_ReadWrite_22: (+1)
   \   00000296   0xF8DB 0x000C      LDR      R0,[R11, #+12]
   \   0000029A   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   0000029E   0x4288             CMP      R0,R1
   \   000002A0   0xD305             BCC.N    ??SSP_ReadWrite_31
   \   000002A2   0xF8DB 0x0004      LDR      R0,[R11, #+4]
   \   000002A6   0xF8DB 0x1010      LDR      R1,[R11, #+16]
   \   000002AA   0x4288             CMP      R0,R1
   \   000002AC   0xD202             BCS.N    ??SSP_ReadWrite_32
    513          			// Enable all interrupt
    514          			SSPx->IMSC = SSP_IMSC_BITMASK;
   \                     ??SSP_ReadWrite_31: (+1)
   \   000002AE   0x200F             MOVS     R0,#+15
   \   000002B0   0x6160             STR      R0,[R4, #+20]
   \   000002B2   0xE003             B.N      ??SSP_ReadWrite_33
    515          		} else {
    516          			// Save status
    517          			dataCfg->status = SSP_STAT_DONE;
   \                     ??SSP_ReadWrite_32: (+1)
   \   000002B4   0xF44F 0x7080      MOV      R0,#+256
   \   000002B8   0xF8CB 0x0014      STR      R0,[R11, #+20]
    518          		}
    519          		return (0);
   \                     ??SSP_ReadWrite_33: (+1)
   \   000002BC   0x2000             MOVS     R0,#+0
   \   000002BE   0xE001             B.N      ??SSP_ReadWrite_14
    520          	}
    521          
    522          	return (-1);
   \                     ??SSP_ReadWrite_20: (+1)
   \   000002C0   0xF05F 0x30FF      MOVS     R0,#-1
   \                     ??SSP_ReadWrite_14: (+1)
   \   000002C4   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    523          }
    524          
    525          /*********************************************************************//**
    526           * @brief		Checks whether the specified SSP status flag is set or not
    527           * @param[in]	SSPx	SSP peripheral selected, should be:
    528           * 		 				- LPC_SSP0: SSP0 peripheral
    529           * 						- LPC_SSP1: SSP1 peripheral
    530           * @param[in]	FlagType	Type of flag to check status, should be one
    531           * 							of following:
    532           *							- SSP_STAT_TXFIFO_EMPTY: TX FIFO is empty
    533           *							- SSP_STAT_TXFIFO_NOTFULL: TX FIFO is not full
    534           *							- SSP_STAT_RXFIFO_NOTEMPTY: RX FIFO is not empty
    535           *							- SSP_STAT_RXFIFO_FULL: RX FIFO is full
    536           *							- SSP_STAT_BUSY: SSP peripheral is busy
    537           * @return		New State of specified SSP status flag
    538           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    539          FlagStatus SSP_GetStatus(LPC_SSP_TypeDef* SSPx, uint32_t FlagType)
    540          {
   \                     SSP_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    541          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetStatus_0
   \   00000012   0xF240 0x211D      MOVW     R1,#+541
   \   00000016   0x....             LDR.N    R0,??DataTable16_2
   \   00000018   0x.... 0x....      BL       check_failed
    542          	CHECK_PARAM(PARAM_SSP_STAT(FlagType));
   \                     ??SSP_GetStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00C             BEQ.N    ??SSP_GetStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD00A             BEQ.N    ??SSP_GetStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD008             BEQ.N    ??SSP_GetStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD006             BEQ.N    ??SSP_GetStatus_1
   \   0000002C   0x2D10             CMP      R5,#+16
   \   0000002E   0xD004             BEQ.N    ??SSP_GetStatus_1
   \   00000030   0xF240 0x211E      MOVW     R1,#+542
   \   00000034   0x....             LDR.N    R0,??DataTable16_2
   \   00000036   0x.... 0x....      BL       check_failed
    543          
    544          	return ((SSPx->SR & FlagType) ? SET : RESET);
   \                     ??SSP_GetStatus_1: (+1)
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x4228             TST      R0,R5
   \   0000003E   0xD001             BEQ.N    ??SSP_GetStatus_2
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE000             B.N      ??SSP_GetStatus_3
   \                     ??SSP_GetStatus_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetStatus_3: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    545          }
    546          
    547          /*********************************************************************//**
    548           * @brief		Enable or disable specified interrupt type in SSP peripheral
    549           * @param[in]	SSPx	SSP peripheral selected, should be:
    550           * 						- LPC_SSP0: SSP0 peripheral
    551           * 						- LPC_SSP1: SSP1 peripheral
    552           * @param[in]	IntType	Interrupt type in SSP peripheral, should be:
    553           * 				- SSP_INTCFG_ROR: Receive Overrun interrupt
    554           * 				- SSP_INTCFG_RT: Receive Time out interrupt
    555           * 				- SSP_INTCFG_RX: RX FIFO is at least half full interrupt
    556           * 				- SSP_INTCFG_TX: TX FIFO is at least half empty interrupt
    557           * @param[in]	NewState New State of specified interrupt type, should be:
    558           * 				- ENABLE: Enable this interrupt type
    559           * 				- DISABLE: Disable this interrupt type
    560           * @return		None
    561           * Note: We can enable/disable multi-interrupt type by OR multi value
    562           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void SSP_IntConfig(LPC_SSP_TypeDef *SSPx, uint32_t IntType, FunctionalState NewState)
    564          {
   \                     SSP_IntConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    565          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SSP_IntConfig_0
   \   0000000E   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_IntConfig_0
   \   00000014   0xF240 0x2135      MOVW     R1,#+565
   \   00000018   0x....             LDR.N    R0,??DataTable16_2
   \   0000001A   0x.... 0x....      BL       check_failed
    566          
    567          	if (NewState == ENABLE)
   \                     ??SSP_IntConfig_0: (+1)
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x2E01             CMP      R6,#+1
   \   00000022   0xD103             BNE.N    ??SSP_IntConfig_1
    568          	{
    569          		SSPx->IMSC |= IntType;
   \   00000024   0x6960             LDR      R0,[R4, #+20]
   \   00000026   0x4328             ORRS     R0,R5,R0
   \   00000028   0x6160             STR      R0,[R4, #+20]
   \   0000002A   0xE005             B.N      ??SSP_IntConfig_2
    570          	}
    571          	else
    572          	{
    573          		SSPx->IMSC &= (~IntType) & SSP_IMSC_BITMASK;
   \                     ??SSP_IntConfig_1: (+1)
   \   0000002C   0x6960             LDR      R0,[R4, #+20]
   \   0000002E   0x43E9             MVNS     R1,R5
   \   00000030   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000034   0x4008             ANDS     R0,R1,R0
   \   00000036   0x6160             STR      R0,[R4, #+20]
    574          	}
    575          }
   \                     ??SSP_IntConfig_2: (+1)
   \   00000038   0xBD70             POP      {R4-R6,PC}       ;; return
    576          
    577          /*********************************************************************//**
    578           * @brief	Check whether the specified Raw interrupt status flag is
    579           * 			set or not
    580           * @param[in]	SSPx	SSP peripheral selected, should be:
    581           * 						- LPC_SSP0: SSP0 peripheral
    582           * 						- LPC_SSP1: SSP1 peripheral
    583           * @param[in]	RawIntType	Raw Interrupt Type, should be:
    584           * 				- SSP_INTSTAT_RAW_ROR: Receive Overrun interrupt
    585           * 				- SSP_INTSTAT_RAW_RT: Receive Time out interrupt
    586           * 				- SSP_INTSTAT_RAW_RX: RX FIFO is at least half full interrupt
    587           * 				- SSP_INTSTAT_RAW_TX: TX FIFO is at least half empty interrupt
    588           * @return	New State of specified Raw interrupt status flag in SSP peripheral
    589           * Note: Enabling/Disabling specified interrupt in SSP peripheral does not
    590           * 		effect to Raw Interrupt Status flag.
    591           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    592          IntStatus SSP_GetRawIntStatus(LPC_SSP_TypeDef *SSPx, uint32_t RawIntType)
    593          {
   \                     SSP_GetRawIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    594          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetRawIntStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetRawIntStatus_0
   \   00000012   0xF240 0x2152      MOVW     R1,#+594
   \   00000016   0x....             LDR.N    R0,??DataTable16_2
   \   00000018   0x.... 0x....      BL       check_failed
    595          	CHECK_PARAM(PARAM_SSP_INTSTAT_RAW(RawIntType));
   \                     ??SSP_GetRawIntStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00A             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD008             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD006             BEQ.N    ??SSP_GetRawIntStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD004             BEQ.N    ??SSP_GetRawIntStatus_1
   \   0000002C   0xF240 0x2153      MOVW     R1,#+595
   \   00000030   0x....             LDR.N    R0,??DataTable16_2
   \   00000032   0x.... 0x....      BL       check_failed
    596          
    597          	return ((SSPx->RIS & RawIntType) ? SET : RESET);
   \                     ??SSP_GetRawIntStatus_1: (+1)
   \   00000036   0x69A0             LDR      R0,[R4, #+24]
   \   00000038   0x4228             TST      R0,R5
   \   0000003A   0xD001             BEQ.N    ??SSP_GetRawIntStatus_2
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??SSP_GetRawIntStatus_3
   \                     ??SSP_GetRawIntStatus_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetRawIntStatus_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    598          }
    599          
    600          /*********************************************************************//**
    601           * @brief		Get Raw Interrupt Status register
    602           * @param[in]	SSPx	SSP peripheral selected, should be:
    603           * 						- LPC_SSP0: SSP0 peripheral
    604           * 						- LPC_SSP1: SSP1 peripheral
    605           * @return		Raw Interrupt Status (RIS) register value
    606           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    607          uint32_t SSP_GetRawIntStatusReg(LPC_SSP_TypeDef *SSPx)
    608          {
   \                     SSP_GetRawIntStatusReg: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    609          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000004   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD007             BEQ.N    ??SSP_GetRawIntStatusReg_0
   \   0000000A   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??SSP_GetRawIntStatusReg_0
   \   00000010   0xF240 0x2161      MOVW     R1,#+609
   \   00000014   0x....             LDR.N    R0,??DataTable16_2
   \   00000016   0x.... 0x....      BL       check_failed
    610          	return (SSPx->RIS);
   \                     ??SSP_GetRawIntStatusReg_0: (+1)
   \   0000001A   0x69A0             LDR      R0,[R4, #+24]
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    611          }
    612          
    613          /*********************************************************************//**
    614           * @brief	Check whether the specified interrupt status flag is
    615           * 			set or not
    616           * @param[in]	SSPx	SSP peripheral selected, should be:
    617           * 						- LPC_SSP0: SSP0 peripheral
    618           * 						- LPC_SSP1: SSP1 peripheral
    619           * @param[in]	IntType	Raw Interrupt Type, should be:
    620           * 				- SSP_INTSTAT_ROR: Receive Overrun interrupt
    621           * 				- SSP_INTSTAT_RT: Receive Time out interrupt
    622           * 				- SSP_INTSTAT_RX: RX FIFO is at least half full interrupt
    623           * 				- SSP_INTSTAT_TX: TX FIFO is at least half empty interrupt
    624           * @return	New State of specified interrupt status flag in SSP peripheral
    625           * Note: Enabling/Disabling specified interrupt in SSP peripheral effects
    626           * 			to Interrupt Status flag.
    627           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    628          IntStatus SSP_GetIntStatus (LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    629          {
   \                     SSP_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    630          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_GetIntStatus_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_GetIntStatus_0
   \   00000012   0xF240 0x2176      MOVW     R1,#+630
   \   00000016   0x....             LDR.N    R0,??DataTable16_2
   \   00000018   0x.... 0x....      BL       check_failed
    631          	CHECK_PARAM(PARAM_SSP_INTSTAT(IntType));
   \                     ??SSP_GetIntStatus_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD00A             BEQ.N    ??SSP_GetIntStatus_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD008             BEQ.N    ??SSP_GetIntStatus_1
   \   00000024   0x2D04             CMP      R5,#+4
   \   00000026   0xD006             BEQ.N    ??SSP_GetIntStatus_1
   \   00000028   0x2D08             CMP      R5,#+8
   \   0000002A   0xD004             BEQ.N    ??SSP_GetIntStatus_1
   \   0000002C   0xF240 0x2177      MOVW     R1,#+631
   \   00000030   0x....             LDR.N    R0,??DataTable16_2
   \   00000032   0x.... 0x....      BL       check_failed
    632          
    633          	return ((SSPx->MIS & IntType) ? SET :RESET);
   \                     ??SSP_GetIntStatus_1: (+1)
   \   00000036   0x69E0             LDR      R0,[R4, #+28]
   \   00000038   0x4228             TST      R0,R5
   \   0000003A   0xD001             BEQ.N    ??SSP_GetIntStatus_2
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0xE000             B.N      ??SSP_GetIntStatus_3
   \                     ??SSP_GetIntStatus_2: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??SSP_GetIntStatus_3: (+1)
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    634          }
    635          
    636          /*********************************************************************//**
    637           * @brief				Clear specified interrupt pending in SSP peripheral
    638           * @param[in]	SSPx	SSP peripheral selected, should be:
    639           *  					- LPC_SSP0: SSP0 peripheral
    640           * 						- LPC_SSP1: SSP1 peripheral
    641           * @param[in]	IntType	Interrupt pending to clear, should be:
    642           * 						- SSP_INTCLR_ROR: clears the "frame was received when
    643           * 						RxFIFO was full" interrupt.
    644           * 						- SSP_INTCLR_RT: clears the "Rx FIFO was not empty and
    645           * 						has not been read for a timeout period" interrupt.
    646           * @return		None
    647           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    648          void SSP_ClearIntPending(LPC_SSP_TypeDef *SSPx, uint32_t IntType)
    649          {
   \                     SSP_ClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    650          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000006   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD007             BEQ.N    ??SSP_ClearIntPending_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??SSP_ClearIntPending_0
   \   00000012   0xF240 0x218A      MOVW     R1,#+650
   \   00000016   0x....             LDR.N    R0,??DataTable16_2
   \   00000018   0x.... 0x....      BL       check_failed
    651          	CHECK_PARAM(PARAM_SSP_INTCLR(IntType));
   \                     ??SSP_ClearIntPending_0: (+1)
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD006             BEQ.N    ??SSP_ClearIntPending_1
   \   00000020   0x2D02             CMP      R5,#+2
   \   00000022   0xD004             BEQ.N    ??SSP_ClearIntPending_1
   \   00000024   0xF240 0x218B      MOVW     R1,#+651
   \   00000028   0x....             LDR.N    R0,??DataTable16_2
   \   0000002A   0x.... 0x....      BL       check_failed
    652          
    653          	SSPx->ICR = IntType;
   \                     ??SSP_ClearIntPending_1: (+1)
   \   0000002E   0x6225             STR      R5,[R4, #+32]
    654          }
   \   00000030   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    655          
    656          /*********************************************************************//**
    657           * @brief				Enable/Disable DMA function for SSP peripheral
    658           * @param[in]	SSPx	SSP peripheral selected, should be:
    659           *  					- LPC_SSP0: SSP0 peripheral
    660           * 						- LPC_SSP1: SSP1 peripheral
    661           * @param[in]	DMAMode	Type of DMA, should be:
    662           * 						- SSP_DMA_TX: DMA for the transmit FIFO
    663           * 						- SSP_DMA_RX: DMA for the Receive FIFO
    664           * @param[in]	NewState	New State of DMA function on SSP peripheral,
    665           * 						should be:
    666           * 						- ENALBE: Enable this function
    667           * 						- DISABLE: Disable this function
    668           * @return		None
    669           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    670          void SSP_DMACmd(LPC_SSP_TypeDef *SSPx, uint32_t DMAMode, FunctionalState NewState)
    671          {
   \                     SSP_DMACmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    672          	CHECK_PARAM(PARAM_SSPx(SSPx));
   \   00000008   0x....             LDR.N    R0,??DataTable16  ;; 0x40088000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD007             BEQ.N    ??SSP_DMACmd_0
   \   0000000E   0x....             LDR.N    R0,??DataTable16_1  ;; 0x40030000
   \   00000010   0x4284             CMP      R4,R0
   \   00000012   0xD004             BEQ.N    ??SSP_DMACmd_0
   \   00000014   0xF44F 0x7128      MOV      R1,#+672
   \   00000018   0x....             LDR.N    R0,??DataTable16_2
   \   0000001A   0x.... 0x....      BL       check_failed
    673          	CHECK_PARAM(PARAM_SSP_DMA(DMAMode));
   \                     ??SSP_DMACmd_0: (+1)
   \   0000001E   0x2D02             CMP      R5,#+2
   \   00000020   0xD006             BEQ.N    ??SSP_DMACmd_1
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD004             BEQ.N    ??SSP_DMACmd_1
   \   00000026   0xF240 0x21A1      MOVW     R1,#+673
   \   0000002A   0x....             LDR.N    R0,??DataTable16_2
   \   0000002C   0x.... 0x....      BL       check_failed
    674          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??SSP_DMACmd_1: (+1)
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD007             BEQ.N    ??SSP_DMACmd_2
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2E01             CMP      R6,#+1
   \   0000003A   0xD004             BEQ.N    ??SSP_DMACmd_2
   \   0000003C   0xF240 0x21A2      MOVW     R1,#+674
   \   00000040   0x....             LDR.N    R0,??DataTable16_2
   \   00000042   0x.... 0x....      BL       check_failed
    675          
    676          	if (NewState == ENABLE)
   \                     ??SSP_DMACmd_2: (+1)
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x2E01             CMP      R6,#+1
   \   0000004A   0xD103             BNE.N    ??SSP_DMACmd_3
    677          	{
    678          		SSPx->DMACR |= DMAMode;
   \   0000004C   0x6A60             LDR      R0,[R4, #+36]
   \   0000004E   0x4328             ORRS     R0,R5,R0
   \   00000050   0x6260             STR      R0,[R4, #+36]
   \   00000052   0xE005             B.N      ??SSP_DMACmd_4
    679          	}
    680          	else
    681          	{
    682          		SSPx->DMACR &= (~DMAMode) & SSP_DMA_BITMASK;
   \                     ??SSP_DMACmd_3: (+1)
   \   00000054   0x6A60             LDR      R0,[R4, #+36]
   \   00000056   0x43E9             MVNS     R1,R5
   \   00000058   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   0000005C   0x4008             ANDS     R0,R1,R0
   \   0000005E   0x6260             STR      R0,[R4, #+36]
    683          	}
    684          }
   \                     ??SSP_DMACmd_4: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40088000         DC32     0x40088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x40030000         DC32     0x40030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0x20          DC8 30H, 20H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H
   \              0xCD 0xB3    
   \              0xBC 0xC6    
   \              0xC4 0xA3    
   \   00000018   0xBF 0xE9          DC8 0BFH, 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H
   \              0x5C 0x53    
   \              0x6F 0x66    
   \              0x74 0x77    
   \   00000020   0x61 0x72          DC8 61H, 72H, 65H, 5CH, 43H, 53H, 42H, 5CH
   \              0x65 0x5C    
   \              0x43 0x53    
   \              0x42 0x5C    
   \   00000028   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x6C    
   \   00000030   0x70 0x63          DC8 70H, 63H, 31H, 37H, 78H, 78H, 5FH, 73H
   \              0x31 0x37    
   \              0x78 0x78    
   \              0x5F 0x73    
   \   00000038   0x73 0x70          DC8 73H, 70H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    685          
    686          /**
    687           * @}
    688           */
    689          
    690          #endif /* _SSP */
    691          
    692          /**
    693           * @}
    694           */
    695          
    696          /* --------------------------------- End Of File ------------------------------ */
    697          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   SSP_ClearIntPending
        16   -> check_failed
      16   SSP_Cmd
        16   -> check_failed
       0   SSP_ConfigStructInit
      16   SSP_DMACmd
        16   -> check_failed
       8   SSP_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
       8   SSP_GetDataSize
         8   -> check_failed
      16   SSP_GetIntStatus
        16   -> check_failed
      16   SSP_GetRawIntStatus
        16   -> check_failed
       8   SSP_GetRawIntStatusReg
         8   -> check_failed
      16   SSP_GetStatus
        16   -> check_failed
      16   SSP_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> check_failed
        16   -> setSSPclock
      16   SSP_IntConfig
        16   -> check_failed
      16   SSP_LoopBackCmd
        16   -> check_failed
      48   SSP_ReadWrite
        48   -> SSP_GetDataSize
        48   -> SSP_ReceiveData
        48   -> SSP_SendData
       8   SSP_ReceiveData
         8   -> check_failed
      16   SSP_SendData
        16   -> check_failed
      16   SSP_SlaveOutputCmd
        16   -> check_failed
      32   setSSPclock
        32   -> CLKPWR_GetPCLK
        32   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
      64  ?_0
      50  SSP_ClearIntPending
      80  SSP_Cmd
      28  SSP_ConfigStructInit
      98  SSP_DMACmd
      70  SSP_DeInit
      38  SSP_GetDataSize
      70  SSP_GetIntStatus
      70  SSP_GetRawIntStatus
      30  SSP_GetRawIntStatusReg
      74  SSP_GetStatus
     114  SSP_Init
      58  SSP_IntConfig
      84  SSP_LoopBackCmd
     712  SSP_ReadWrite
      38  SSP_ReceiveData
      40  SSP_SendData
      84  SSP_SlaveOutputCmd
     142  setSSPclock

 
    64 bytes in section .rodata
 1 896 bytes in section .text
 
 1 896 bytes of CODE  memory
    64 bytes of CONST memory

Errors: none
Warnings: none
