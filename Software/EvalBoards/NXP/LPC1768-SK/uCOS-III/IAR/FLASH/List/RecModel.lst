###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       26/Sep/2017  15:08:25
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Application\Library\DataDeal\RecModel.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Application\Library\DataDeal\RecModel.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\RecModel.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\RecModel.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Application\Library\DataDeal\RecModel.c
      1          //#include    "config.h" 
      2          //#include	"Globe.h"
      3          //#include    "stdio.h" 
      4          //#include    "stdarg.h" 
      5          //#include    "string.h"
      6          //#include    "math.h"
      7          //#include    "stdlib.h"
      8          //#include    "DipMath.h"
      9          //#include    "FramStore.h"
     10          //#include    "HardDrive.h"
     11          //#include    "CpuDrive.h"
     12          //#include    "Tax2.h"
     13          //#include    "OperateCard.h"
     14          
     15          
     16          #include <includes.h>

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char const *, int)
   \                     strchr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strchr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     17          
     18          //--------------------------------------------------------------------------------
     19          // 名    称：  	stcModPot     StringToWord(char   *String,char FlgChar,int  WordNum)
     20          // 功    能:    主函数
     21          // 入口参数：
     22          // 出口参数：
     23          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     24          stcModPot     StringToWord(char   *String,char FlgChar,int  WordNum)
     25          {
   \                     StringToWord: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB0E4             SUB      SP,SP,#+400
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
     26              char    StringTmp[128];
     27              char    *WordPos;
     28              char    WordStr[128];
     29              char    StrTmpBuf[128];
     30              int     WordLen,OtherLen;
     31              int     i;
     32              stcModPot	sModPot;
     33          
     34              strcpy(StringTmp,String);
   \   0000000A   0x9964             LDR      R1,[SP, #+400]
   \   0000000C   0xA843             ADD      R0,SP,#+268
   \   0000000E   0x.... 0x....      BL       strcpy
     35          
     36              for(i = 0; i < WordNum-1;i++)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x0007             MOVS     R7,R0
   \                     ??StringToWord_0: (+1)
   \   00000016   0x1E68             SUBS     R0,R5,#+1
   \   00000018   0x4287             CMP      R7,R0
   \   0000001A   0xDA39             BGE.N    ??StringToWord_1
     37              {
     38          //		SysFastHoldTast();
     39          //201400		    
     40                  WordPos =  (char *)strchr(StringTmp, FlgChar);
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xA843             ADD      R0,SP,#+268
   \   00000022   0x.... 0x....      BL       strchr
   \   00000026   0x9001             STR      R0,[SP, #+4]
     41                      
     42                  WordLen =  (WordPos - StringTmp);
   \   00000028   0x9801             LDR      R0,[SP, #+4]
   \   0000002A   0xA943             ADD      R1,SP,#+268
   \   0000002C   0x1A40             SUBS     R0,R0,R1
   \   0000002E   0x0006             MOVS     R6,R0
     43          
     44                  OtherLen = strlen(StringTmp) - WordLen;
   \   00000030   0xA843             ADD      R0,SP,#+268
   \   00000032   0x.... 0x....      BL       strlen
   \   00000036   0x1B80             SUBS     R0,R0,R6
   \   00000038   0x4683             MOV      R11,R0
     45          
     46                  memcpy(WordStr,StringTmp,WordLen);
   \   0000003A   0xF50D 0x7886      ADD      R8,SP,#+268
   \   0000003E   0xF10D 0x098C      ADD      R9,SP,#+140
   \   00000042   0x0032             MOVS     R2,R6
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x.... 0x....      BL       __aeabi_memcpy
     47          
     48                  WordStr[WordLen] = '\0';
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xA923             ADD      R1,SP,#+140
   \   00000050   0x5470             STRB     R0,[R6, R1]
     49                  
     50                  memcpy(StrTmpBuf,&StringTmp[WordLen+1],OtherLen);
   \   00000052   0xA843             ADD      R0,SP,#+268
   \   00000054   0x1830             ADDS     R0,R6,R0
   \   00000056   0x1C40             ADDS     R0,R0,#+1
   \   00000058   0x9002             STR      R0,[SP, #+8]
   \   0000005A   0xF10D 0x090C      ADD      R9,SP,#+12
   \   0000005E   0x465A             MOV      R2,R11
   \   00000060   0x9902             LDR      R1,[SP, #+8]
   \   00000062   0x4648             MOV      R0,R9
   \   00000064   0x.... 0x....      BL       __aeabi_memcpy
     51          
     52                  memcpy(StringTmp,StrTmpBuf,OtherLen);
   \   00000068   0xF10D 0x090C      ADD      R9,SP,#+12
   \   0000006C   0xF50D 0x7A86      ADD      R10,SP,#+268
   \   00000070   0x465A             MOV      R2,R11
   \   00000072   0x4649             MOV      R1,R9
   \   00000074   0x4650             MOV      R0,R10
   \   00000076   0x.... 0x....      BL       __aeabi_memcpy
     53          
     54                  StringTmp[OtherLen] = '\0';
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xA943             ADD      R1,SP,#+268
   \   0000007E   0xF80B 0x0001      STRB     R0,[R11, R1]
     55                  
     56                  sModPot.HigVal = atoi(WordStr);
   \   00000082   0xA823             ADD      R0,SP,#+140
   \   00000084   0x.... 0x....      BL       atoi
   \   00000088   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     57              }
   \   0000008C   0x1C7F             ADDS     R7,R7,#+1
   \   0000008E   0xE7C2             B.N      ??StringToWord_0
     58              
     59              sModPot.DipVal = atoi(StringTmp);
   \                     ??StringToWord_1: (+1)
   \   00000090   0xA843             ADD      R0,SP,#+268
   \   00000092   0x.... 0x....      BL       atoi
   \   00000096   0xF8AD 0x0002      STRH     R0,[SP, #+2]
     60          
     61              return   sModPot;
   \   0000009A   0x9800             LDR      R0,[SP, #+0]
   \   0000009C   0xB065             ADD      SP,SP,#+404
   \   0000009E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
     62          }
     63          
     64          //--------------------------------------------------------------------------------
     65          // 名    称：  	void	GetOilModel(uint8 *Buf,uint16	Len)
     66          // 功    能:    取油箱模型
     67          // 入口参数：
     68          // 出口参数：
     69          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     70          uint8	GetCOM0ModelComplex(stcModelComplex *sModelComplex,uint8 *Buf,uint16	Len)
     71          {
   \                     GetCOM0ModelComplex: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0A7             SUB      SP,SP,#+156
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
     72          	char 		ModelFlgString[] = {"通过串口通信设置油箱模型"};
   \   0000000C   0xA820             ADD      R0,SP,#+128
   \   0000000E   0x....             LDR.N    R1,??DataTable0
   \   00000010   0x221C             MOVS     R2,#+28
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy4
     73          	char		LineString[128];
     74          
     75          	uint32		CharNum = 0,LineCharNum = 0,Line = 0;		
   \   00000016   0x2700             MOVS     R7,#+0
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
   \   0000001C   0xF05F 0x0900      MOVS     R9,#+0
     76          	uint8		ModelFlg = 0;
   \   00000020   0xF05F 0x0A00      MOVS     R10,#+0
     77          		
     78          	////printfcom0("\r\nGetCOM0ModelComplex(stcModelComplex *sModelComplex,uint8 *Buf,uint16	Len)" );
     79          	
     80          	while(CharNum < Len)
   \                     ??GetCOM0ModelComplex_0: (+1)
   \   00000024   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000026   0x42B7             CMP      R7,R6
   \   00000028   0xD24F             BCS.N    ??GetCOM0ModelComplex_1
     81          	{
     82          		//SysHoldTast();
     83          		
     84          		if(Buf[CharNum] != 0x0d && Buf[CharNum] != 0x0a)
   \   0000002A   0x5D78             LDRB     R0,[R7, R5]
   \   0000002C   0x280D             CMP      R0,#+13
   \   0000002E   0xD009             BEQ.N    ??GetCOM0ModelComplex_2
   \   00000030   0x5D78             LDRB     R0,[R7, R5]
   \   00000032   0x280A             CMP      R0,#+10
   \   00000034   0xD006             BEQ.N    ??GetCOM0ModelComplex_2
     85          		{
     86          			LineString[LineCharNum++] = Buf[CharNum];
   \   00000036   0x5D78             LDRB     R0,[R7, R5]
   \   00000038   0x4669             MOV      R1,SP
   \   0000003A   0xF808 0x0001      STRB     R0,[R8, R1]
   \   0000003E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000042   0xE040             B.N      ??GetCOM0ModelComplex_3
     87          		}
     88          		else if(Buf[CharNum] == 0x0a)
   \                     ??GetCOM0ModelComplex_2: (+1)
   \   00000044   0x5D78             LDRB     R0,[R7, R5]
   \   00000046   0x280A             CMP      R0,#+10
   \   00000048   0xD13D             BNE.N    ??GetCOM0ModelComplex_3
     89          		{
     90          			LineString[LineCharNum] = '\0';
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0xF808 0x0001      STRB     R0,[R8, R1]
     91          				
     92          			if(ModelFlg == 1)
   \   00000052   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000056   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000005A   0xD128             BNE.N    ??GetCOM0ModelComplex_4
     93          			{
     94          				if(Line == 1)
   \   0000005C   0xF1B9 0x0F01      CMP      R9,#+1
   \   00000060   0xD104             BNE.N    ??GetCOM0ModelComplex_5
     95          				{
     96          					sModelComplex->ModelNum = atoi(LineString);
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x.... 0x....      BL       atoi
   \   00000068   0xF884 0x0194      STRB     R0,[R4, #+404]
     97          				}
     98          					
     99          				if(Line == 2)
   \                     ??GetCOM0ModelComplex_5: (+1)
   \   0000006C   0xF1B9 0x0F02      CMP      R9,#+2
   \   00000070   0xD104             BNE.N    ??GetCOM0ModelComplex_6
    100          				{
    101          			    	sModelComplex->PotNum = atoi(LineString);
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x.... 0x....      BL       atoi
   \   00000078   0xF8A4 0x0190      STRH     R0,[R4, #+400]
    102          				}
    103          						
    104          				if(Line == 3)
   \                     ??GetCOM0ModelComplex_6: (+1)
   \   0000007C   0xF1B9 0x0F03      CMP      R9,#+3
   \   00000080   0xD104             BNE.N    ??GetCOM0ModelComplex_7
    105          				{
    106          					sModelComplex->StartHight = atoi(LineString);
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       atoi
   \   00000088   0xF8A4 0x0192      STRH     R0,[R4, #+402]
    107          				}
    108          					  
    109          				if(Line > 3)
   \                     ??GetCOM0ModelComplex_7: (+1)
   \   0000008C   0xF1B9 0x0F04      CMP      R9,#+4
   \   00000090   0xD30B             BCC.N    ??GetCOM0ModelComplex_8
    110          				{
    111          					uint8	LineTmp;
    112          					
    113          					LineTmp = Line - 4;
   \   00000092   0x4648             MOV      R0,R9
   \   00000094   0x1F00             SUBS     R0,R0,#+4
   \   00000096   0x4683             MOV      R11,R0
    114          					
    115          		  			sModelComplex->sModPot[LineTmp] = StringToWord(LineString,',',2);
   \   00000098   0x2202             MOVS     R2,#+2
   \   0000009A   0x212C             MOVS     R1,#+44
   \   0000009C   0x4668             MOV      R0,SP
   \   0000009E   0x.... 0x....      BL       StringToWord
   \   000000A2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A6   0xF844 0x002B      STR      R0,[R4, R11, LSL #+2]
    116          		  			
    117          		  		}
    118          		  		
    119          		  		Line++;
   \                     ??GetCOM0ModelComplex_8: (+1)
   \   000000AA   0xF119 0x0901      ADDS     R9,R9,#+1
    120          			}
    121          		
    122          			if(!strcmp(LineString,ModelFlgString))
   \                     ??GetCOM0ModelComplex_4: (+1)
   \   000000AE   0xA920             ADD      R1,SP,#+128
   \   000000B0   0x4668             MOV      R0,SP
   \   000000B2   0x.... 0x....      BL       strcmp
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD103             BNE.N    ??GetCOM0ModelComplex_9
    123          	      	{
    124          	      	    ModelFlg = 1;
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x4682             MOV      R10,R0
    125          	      	    
    126          	      	    Line = 1;
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x4681             MOV      R9,R0
    127          	      	}
    128          	      	
    129          	      	LineCharNum = 0;
   \                     ??GetCOM0ModelComplex_9: (+1)
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x4680             MOV      R8,R0
    130                	}
    131                	
    132                	CharNum++;	
   \                     ??GetCOM0ModelComplex_3: (+1)
   \   000000C6   0x1C7F             ADDS     R7,R7,#+1
   \   000000C8   0xE7AC             B.N      ??GetCOM0ModelComplex_0
    133          	}
    134          	
    135          	return	Line;
   \                     ??GetCOM0ModelComplex_1: (+1)
   \   000000CA   0x4648             MOV      R0,R9
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0xB027             ADD      SP,SP,#+156
   \   000000D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    136          }
    137          
    138          
    139          //--------------------------------------------------------------------------------
    140          // 名    称：  	void	GetOilModel(uint8 *Buf,uint16	Len)
    141          // 功    能:    取油箱模型
    142          // 入口参数：
    143          // 出口参数：
    144          //-------------------------------------------------------------------------------
    145          //uint8	StoreCOM0Model(stcModelComplex	sModelComplex)
    146          //{
    147          //	static	stcModelCard		sModelCard;
    148          //	uint16	CrcCheck;
    149          //	uint16	RecerveNum = 0;
    150          //	
    151          //	//ReadOilBoxModel((stcModelCard * )&sModelCard);
    152          //				
    153          //	//CrcCheck = GetCrc16Check((uint8 *)&sModelCard,sizeof(stcModelCard) - 2);
    154          //		
    155          //	//if(CrcCheck == sModelCard.CrcCheck)				//校验和相等,有原来的模型		
    156          //	{			
    157          //
    158          //	}
    159          //	//else
    160          //	{
    161          //		if(sModelComplex.PotNum < sizeof(sModelCard.sModelSemple[0].sModPot) / sizeof(stcModPot))
    162          //		{
    163          //			stcModelComplexTostcModelSemple((stcModelSemple *)&sModelCard.sModelSemple[0],
    164          //					(stcModelComplex *)&sModelComplex);
    165          //		}
    166          //		else if(sModelComplex.PotNum < sizeof(sModelCard.sModel[0].sModPot) / sizeof(stcModPot))
    167          //		{
    168          //			stcModelComplexTostcModel((stcModel * )&sModelCard.sModel[0],(stcModelComplex	*)&sModelComplex);
    169          //		}
    170          //		else
    171          //		{
    172          //			while(sModelComplex.PotNum > RecerveNum*(sizeof(sModelCard.sModel[0].sModPot) / sizeof(stcModPot)))
    173          //			{
    174          //				stcModelComplexToMulstcModel((stcModel * )&sModelCard.sModel[RecerveNum],
    175          //					(stcModelComplex	*)&sModelComplex,RecerveNum);
    176          //	
    177          //				RecerveNum++;
    178          //				//SysHoldTast();
    179          //			}
    180          //		}
    181          //	}
    182          //	
    183          //	CrcCheck = GetCrc16Check((uint8 *)&sModelCard,sizeof(stcModelCard) - 2);
    184          //
    185          //	sModelCard.CrcCheck = CrcCheck;
    186          //	
    187          //	StoreOilBoxModel((stcModelCard * )&sModelCard);
    188          //
    189          //	return	0;
    190          //}
    191          
    192          extern	 stcCardFlg		l_sCardFlg;

   \                                 In section .bss, align 4
    193          stcModelCard			l_sModelCard={0};
   \                     l_sModelCard:
   \   00000000                      DS8 5956
    194          
    195          
    196          #define		CARD_DATA_ADDR		5120			//IC卡 数据起始地址
    197          #define		CARD_FLG_ADDR		0				//IC卡 标识起始地址
    198          
    199          //--------------------------------------------------------------------------------
    200          // 名    称：  	void	COM0SendCardFlg(void)
    201          // 功    能:    取油箱模型
    202          // 入口参数：
    203          // 出口参数：
    204          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    205          void	COM0SendCardFlg(void)
    206          {
    207          /*
    208          	static	stcCardFlg		sCardFlg;
    209          	
    210          	while(1)
    211          	{
    212          		DelayX10ms(200);
    213          		while(GetPlugFlg() == PLUG_IN_CARD)
    214          		{
    215          			while(!PlugICCard())
    216          			{;}	
    217          
    218          			ReadCard(CARD_FLG_ADDR,(uint8 *)&sCardFlg,sizeof(stcCardFlg));	
    219          			
    220          			ReadCard(CARD_DATA_ADDR,(uint8 *)&l_sModelCard,sizeof(l_sModelCard));	
    221          			
    222          			SendCOM0((uint8 *)&sCardFlg,sizeof(stcCardFlg));
    223          			
    224          			SendCOM0((uint8 *)&l_sModelCard,sizeof(l_sModelCard));
    225          			
    226          			DelayX10ms(500);
    227          		}
    228          	}
    229          */
    230          }	
   \                     COM0SendCardFlg: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    231          
    232          //--------------------------------------------------------------------------------
    233          // 名    称：  	void	COM0GetModelCard(void)
    234          // 功    能:    取油箱模型
    235          // 入口参数：
    236          // 出口参数：
    237          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    238          void	COM0GetModelCard(void)
    239          {
    240          
    241          /*	static	uint32	Time;
    242          	static	uint8	Buf[16*1024];
    243          	static	stcCardFlg		sCardFlg;
    244          	uint16	Crc16;
    245          
    246          	uint16	Reclen;
    247          	uint32	StoreDataLen = 0;
    248          */	
    249          /*
    250          	DelayX10ms(200);
    251          	while(GetPlugFlg() == PLUG_IN_CARD)
    252          	{
    253          		while(!PlugICCard())
    254          		{;}	
    255          
    256          		ReadCard(CARD_FLG_ADDR,(uint8 *)&sCardFlg,sizeof(stcCardFlg));	
    257          		
    258          		ReadCard(CARD_DATA_ADDR,(uint8 *)&l_sModelCard,sizeof(l_sModelCard));	
    259          		
    260          		//SendCOM0((uint8 *)&sCardFlg,sizeof(stcCardFlg));
    261          		
    262          		//SendCOM0((uint8 *)&sCardFlg,sizeof(l_sModelCard));
    263          		
    264          		DelayX10ms(500);
    265          	}
    266          */	
    267          /*
    268          	CloseTax2();
    269          	OpenCOM0Tax(19200);
    270          	
    271          	DelayX10ms(10);											//等30S
    272          
    273          	Reclen 	= ReadCOM0(Buf,16*1024);
    274          	
    275          	DisplaySet(60,1,"SEND");
    276          	DisplaySet(60,1,"    ");
    277          
    278          	//printfcom0("\r\nstcCardFlg = %d",sizeof(stcCardFlg));
    279          	//printfcom0("\r\nl_sModelCard = %d",sizeof(l_sModelCard));
    280          	
    281          	while(1)																
    282          	{
    283          		ClaerDisplaySet();												//清显示缓冲区
    284          
    285          		DisplaySet(100,1,"SEND");
    286          		
    287          		Reclen = GetCOM0DataLen();
    288          		
    289          		StoreDataLen = 0;
    290          
    291          		while(!Reclen)												//串口是否有数据接受,无数据等待
    292          		{
    293          			Reclen = GetCOM0DataLen();
    294          		}
    295          
    296          		Time  	= GetSysTime();			
    297          		
    298          		DisplaySet(100,1,"RECD");
    299          		
    300          		//while(1)
    301          		{
    302          			while( Reclen )												//没有数据就退出
    303          			{
    304          				if(GetSysTime() - Time > 10)							//1秒取一次数据
    305          				{
    306          					Time = GetSysTime();
    307          
    308          					Reclen 	= ReadCOM0(&Buf[StoreDataLen],16*1024 - StoreDataLen);
    309          			
    310          					StoreDataLen += Reclen;
    311          					
    312          					//printfcom0("\r\nReclen = %d,StoreDataLen = %d",Reclen,StoreDataLen);
    313          				}
    314          				
    315          				DelayX10ms(10);											//等30S
    316          				////printfcom0("\r\nGetSysTime() = %d",GetSysTime());
    317          			}
    318          		}
    319          					
    320          		memcpy((uint8 *)&sCardFlg,Buf,sizeof(sCardFlg));			//取IC卡标志页
    321          		
    322          		memcpy((uint8 *)&l_sModelCard,&Buf[sizeof(sCardFlg)],sizeof(l_sModelCard));	
    323          																	//取模型卡		
    324          		Crc16	= GetCrc16Check((uint8 *)&sCardFlg,sizeof(sCardFlg) - 2);
    325          
    326          		//printfcom0("\r\nCrc16 = %d",Crc16);
    327          
    328          		if(Crc16 == sCardFlg.CrcCheck)								//校验接受校验是否正确
    329          		{
    330          			//printfcom0("\r\nCrc16 == sCardFlg.CrcCheck");
    331          
    332          			memcpy((uint8 *)&l_sCardFlg,(uint8 *)&sCardFlg,sizeof(sCardFlg));
    333          			
    334          			OperationCOM0ModelCard();
    335          			
    336          			DelayX10ms(1000);
    337          
    338          		}
    339          		else
    340          		{
    341          			DisplaySet(100,1,"COME");
    342          		}
    343          	
    344          		DelayX10ms(200);
    345          
    346          				
    347          	}
    348          		*/
    349          }
   \                     COM0GetModelCard: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    350           			
    351          
    352          //--------------------------------------------------------------------------------
    353          // 名    称：  	void	COM0SetModel(void)
    354          // 功    能:    取油箱模型
    355          // 入口参数：
    356          // 出口参数：
    357          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    358          void	COM0SetModel(void)
    359          {
    360          /*
    361          	static	uint8		Buf[256*10];
    362          	static	stcModelComplex	sModelComplex;
    363          	uint16			Reclen;
    364          	
    365          	Reclen = ReadCOM0(Buf,256*10);
    366          	
    367          	if(Reclen)
    368          	{
    369          		////printfcom0("\r\nReclen = %d",Reclen );
    370          		if(GetCOM0ModelComplex((stcModelComplex *)&sModelComplex,Buf,Reclen))
    371          		{
    372          			////printfcom0("\r\nStoreCOM0Model(sModelComplex);" );
    373          
    374          			StoreCOM0Model(sModelComplex);					//存数据
    375          			
    376          			//printfcom0("\r\n油箱模型输入完成！;" );
    377          		}
    378          	}
    379          	
    380          	DelayX10ms(500);										//等30S
    381          */
    382          }
   \                     COM0SetModel: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0xCD 0xA8          DC8 "\315\250\271\375\264\256\277\332\315\250\320\305\311\350\326\303\323\315\317\344\304\243\320\315"
   \              0xB9 0xFD    
   \              0xB4 0xAE    
   \              0xBF 0xDA    
   \              0xCD 0xA8    
   \              0xD0 0xC5    
   \              0xC9 0xE8    
   \              0xD6 0xC3    
   \              0xD3 0xCD    
   \              0xCF 0xE4    
   \              0xC4 0xA3    
   \              0xD0 0xCD    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   COM0GetModelCard
       0   COM0SendCardFlg
       0   COM0SetModel
     192   GetCOM0ModelComplex
       192   -> StringToWord
       192   -> __aeabi_memcpy4
       192   -> atoi
       192   -> strcmp
     440   StringToWord
       440   -> __aeabi_memcpy
       440   -> atoi
       440   -> strchr
       440   -> strcpy
       440   -> strlen
      16   strchr
        16   -> __iar_Strchr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      28  ?_0
       2  COM0GetModelCard
       2  COM0SendCardFlg
       2  COM0SetModel
     212  GetCOM0ModelComplex
     162  StringToWord
    5956  l_sModelCard
      16  strchr

 
 5 956 bytes in section .bss
    28 bytes in section .rodata
   400 bytes in section .text
 
   384 bytes of CODE  memory (+ 16 bytes shared)
    28 bytes of CONST memory
 5 956 bytes of DATA  memory

Errors: none
Warnings: none
