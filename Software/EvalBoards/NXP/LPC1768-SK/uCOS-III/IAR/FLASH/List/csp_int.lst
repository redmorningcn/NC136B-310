###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       07/Sep/2017  21:02:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_int.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_int.c
#        -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\csp_int.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\csp_int.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_int.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/CSP
      4          *                                        Chip Support Package
      5          *
      6          *                            (c) Copyright 2010; Micrium, Inc.; Weston, FL
      7          *                         (c) Copyright 2003-2010; Micrium, Inc.; Weston, FL
      8          *
      9          *               All rights reserved. Protected by international copyright laws.
     10          *
     11          *               uC/CSP is provided in source form to registered licensees ONLY.  It is
     12          *               illegal to distribute this source code to any third party unless you receive
     13          *               written permission by an authorized Micrium representative.  Knowledge of
     14          *               the source code may NOT be used to develop a similar product.
     15          *
     16          *               Please help us continue to provide the Embedded community with the finest
     17          *               software available.  Your honesty is greatly appreciated.
     18          *
     19          *               You can contact us at www.micrium.com.
     20          *********************************************************************************************************
     21          */
     22          
     23          /*
     24          *********************************************************************************************************
     25          *
     26          *                                         INTERRUPT MANAGEMENT
     27          *                                            NXP  LPC17XX
     28          *
     29          * Filename      : csp_int.c
     30          * Version       : V1.00
     31          * Programmer(s) : FT
     32          *********************************************************************************************************
     33          * Note(s)       : 
     34          *********************************************************************************************************
     35          */
     36          
     37          
     38          /*
     39          *********************************************************************************************************
     40          *                                            INCLUDE FILES
     41          *********************************************************************************************************
     42          */
     43          
     44          #define    CSP_INT_MODULE
     45          #include   <csp.h>
     46          
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                          DEFAULT CONFIGURATION
     51          *********************************************************************************************************
     52          */
     53          
     54          #ifndef  CSP_DEV_USB_OTG_EN
     55          #define  CSP_DEV_USB_OTG_EN                  DEF_DISABLED
     56          #endif
     57          
     58          
     59          /*
     60          *********************************************************************************************************
     61          *                                            LOCAL DEFINES
     62          *********************************************************************************************************
     63          */
     64           
     65                                                                          /* ------------ USB STATUS REGISTER DEFINES ----------- */
     66          #define  CSP_INT_REG_USBINTST                   ( *(CPU_REG32 *)(0x400FC1C0))
     67          
     68          #define  CSP_INT_BIT_USBINTST_INT_REQ_LP        DEF_BIT_00      /* USB Low priority request  (Device)                   */
     69          #define  CSP_INT_BIT_USBINTST_INT_REQ_HP        DEF_BIT_01      /* USB High priority request (Device)                   */
     70          #define  CSP_INT_BIT_USBINTST_INT_REQ_DMA       DEF_BIT_02      /* USB DMA Request (Device)                             */
     71          #define  CSP_INT_BIT_USBINTST_INT_HOST          DEF_BIT_03      /* USB Host interrupt                                   */
     72          #define  CSP_INT_BIT_USBINTST_INT_ATX           DEF_BIT_04      /* USB ATX interrupt                                    */
     73          #define  CSP_INT_BIT_USBINTST_INT_OTG           DEF_BIT_05      /* USB OTG interrupt                                    */
     74          #define  CSP_INT_BIT_USBINTST_INT_I2C           DEF_BIT_06      /* USB I2C interrupt                                    */
     75          #define  CSP_INT_BIT_USBINTST_INT_NEED_CLK      DEF_BIT_08      /* USB Need clock interrupt                             */
     76          
     77                                                                          /* USB Device interrupt bit-field                       */
     78          #define  CSP_INT_BIT_USBINTST_INT_DEV          (CSP_INT_BIT_USBINTST_INT_REQ_LP  | \
     79                                                          CSP_INT_BIT_USBINTST_INT_REQ_HP  | \
     80                                                          CSP_INT_BIT_USBINTST_INT_REQ_DMA)
     81          
     82          /*
     83          *********************************************************************************************************
     84          *                                           LOCAL CONSTANTS
     85          *********************************************************************************************************
     86          */
     87          
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                           LOCAL DATA TYPES
     93          *********************************************************************************************************
     94          */
     95          
     96          
     97          /*
     98          *********************************************************************************************************
     99          *                                            LOCAL TABLES
    100          *********************************************************************************************************
    101          */
    102          
    103          /*
    104          *********************************************************************************************************
    105          *                                     INTERRUPT VECTOR TABLE
    106          *
    107          * Note(s) (1) 'CSP_MainVectTbl[]' store all the interrupts handlers for the external interrupts
    108          *             on the LPC17xx devices.
    109          *
    110          *         (2) 'CSP_USB_VectTbl[]' store all the interrupts handlers for the shared USB global interrupt 
    111          *              handler.
    112          *
    113          *              (a) USB shared handler is only enable for parts that have an OTG controller. 
    114          *********************************************************************************************************
    115          */
    116                                                                          /* NVIC external interrupts vector table               */

   \                                 In section .bss, align 4
    117          static  CSP_INT_VECT  CSP_MainVectTbl[CSP_INT_SRC_NBR_MAX]; 
   \                     CSP_MainVectTbl:
   \   00000000                      DS8 560
    118          
    119          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    120                                                                          /* USB Interrupt vector table                         */

   \                                 In section .bss, align 4
    121          static  CSP_INT_VECT  CSP_USB_VectTbl[CSP_INT_USB_SRC_MAX_NBR]; 
   \                     CSP_USB_VectTbl:
   \   00000000                      DS8 80
    122          #endif
    123          
    124          /*
    125          *********************************************************************************************************
    126          *                                       LOCAL GLOBAL VARIABLES
    127          *********************************************************************************************************
    128          */
    129          
    130          
    131          /*
    132          *********************************************************************************************************
    133          *                                            LOCAL MACRO's
    134          *********************************************************************************************************
    135          */
    136          
    137          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    138          #define  CSP_INT_USB_DISPATCH(p_int_vect,      \
    139                                        usb_stat,        \
    140                                        usb_stat_msk,    \
    141                                        usb_src_nbr)              {    if (DEF_BIT_IS_SET_ANY((usb_stat), (usb_stat_msk))) {        \
    142                                                                            (p_int_vect) = &CSP_USB_VectTbl[(usb_src_nbr)];         \
    143                                                                            CSP_IntVectDeref((p_int_vect));                         \
    144                                                                       }                                                            \
    145                                                                   }
    146          #else
    147          #define  CSP_INT_USB_DISPATCH(p_int_vect,      \
    148                                        usb_stat,        \
    149                                        usb_stat_msk,    \
    150                                        usb_src_nbr)  
    151          #endif
    152          
    153           
    154          
    155          
    156          /*
    157          *********************************************************************************************************
    158          *                                      LOCAL FUNCTION PROTOTYPES
    159          *********************************************************************************************************
    160          */
    161          
    162          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    163          static  void  CSP_IntUSB_Handler    (void *p_arg);
    164          #endif
    165          
    166          /*
    167          *********************************************************************************************************
    168          *                                     LOCAL CONFIGURATION ERRORS
    169          *********************************************************************************************************
    170          */
    171          
    172          
    173          /*
    174          *********************************************************************************************************
    175          *********************************************************************************************************
    176          *                                           LOCAL FUNCTIONS
    177          *********************************************************************************************************
    178          *********************************************************************************************************
    179          */
    180          
    181          
    182          /*
    183          *********************************************************************************************************
    184          *                                            CSP_IntClr()
    185          *
    186          * Description : Clear an interrupt source on a specific interrupt controller.
    187          *
    188          * Argument(s) : int_ctrl   Interrupt controller number (see note #1).
    189          *
    190          *               src_nbr    Interrupt source number (see note #2). 
    191          *
    192          * Return(s)   : None.
    193          *
    194          * Caller(s)   : Application.
    195          *
    196          * Note(s)     : (1) Interrupt controllers numbers identifiers can be found in 'csp_grp.h' 
    197          * 
    198          *                       CSP_INT_CTRL_NBR_XX'  where 'XX" is the name of the interrupt controller.
    199          *
    200          *               (2) Interrupt source identifiers can be found in 'csp_grp.h' as CSP_INT
    201          *
    202          *                       CSP_INT_SRC_NBR_XX      where XX is the peripheral or interrupt source name.
    203          *                                               Main interrupt controller only.
    204          * 
    205          *                       CSP_INT_XX_SRC_NBR_YY   where xx is the name of the interrupt controller or shared 
    206          *                                               handler and YY is the peripheral or source name.
    207          * 
    208          *               (3) The pending status can be only cleared  for the NVIC's external sources.
    209          *
    210          *                   (a) The pending status cannot be cleared in a source from a a shared interrupt 
    211          *                       handler.
    212          *********************************************************************************************************
    213          */
    214          

   \                                 In section .text, align 2, keep-with-next
    215          void  CSP_IntClr (CSP_DEV_NBR  int_ctrl,
    216                            CSP_DEV_NBR  src_nbr)                  
    217          {
   \                     CSP_IntClr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    218              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    219                  (src_nbr   < CSP_INT_SRC_NBR_MAX  )) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD107             BNE.N    ??CSP_IntClr_0
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D23             CMP      R5,#+35
   \   00000010   0xDA04             BGE.N    ??CSP_IntClr_0
    220                  CPU_IntSrcPendClr(src_nbr + CPU_INT_EXT0);
   \   00000012   0xF115 0x0010      ADDS     R0,R5,#+16
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       CPU_IntSrcPendClr
    221              }
    222          }
   \                     ??CSP_IntClr_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    223          
    224          
    225          /*
    226          *********************************************************************************************************
    227          *                                          CSP_IntDis()
    228          *
    229          * Description : Disable an interrupt source from a specific interrupt controller.
    230          *
    231          * Argument(s) : int_ctrl   Interrupt controller number. (see 'CSP_IntClr()' note #1).
    232          *
    233          *               src_nbr    Interrupt source number. (see 'CSP_IntClr()' note #2).
    234          *
    235          * Return(s)   : None.
    236          *
    237          * Caller(s)   : Application.
    238          *
    239          * Note(s)     : (1) Only the NVIC's external sources can be disabled.
    240          *********************************************************************************************************
    241          */
    242          

   \                                 In section .text, align 2, keep-with-next
    243          void  CSP_IntDis (CSP_DEV_NBR  int_ctrl,
    244                            CSP_DEV_NBR  src_nbr)                   
    245          {   
   \                     CSP_IntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    246              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    247                  (src_nbr   < CSP_INT_SRC_NBR_MAX  )) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD107             BNE.N    ??CSP_IntDis_0
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D23             CMP      R5,#+35
   \   00000010   0xDA04             BGE.N    ??CSP_IntDis_0
    248                  CPU_IntSrcDis(src_nbr + CPU_INT_EXT0);
   \   00000012   0xF115 0x0010      ADDS     R0,R5,#+16
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       CPU_IntSrcDis
    249              }
    250          }
   \                     ??CSP_IntDis_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    251          
    252          
    253          /*
    254          *********************************************************************************************************
    255          *                                          CSP_IntDisAll()
    256          *
    257          * Description : Disable all interrupts on a specific interrupt controller.
    258          *
    259          * Argument(s) : int_ctrl   Interrupt controller number. (see 'CSP_IntClr()' note #1).
    260          *
    261          * Return(s)   : None.
    262          *
    263          * Caller(s)   : Application.
    264          *
    265          * Note(s)     : None.
    266          *********************************************************************************************************
    267          */
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void  CSP_IntDisAll (CSP_DEV_NBR  int_ctrl) 
    270          {
   \                     CSP_IntDisAll: (+1)
   \   00000000   0xB410             PUSH     {R4}
    271              CSP_DEV_NBR  int_src;
    272              CSP_DEV_NBR  int_src_grp;
    273             
    274              if (int_ctrl == CSP_INT_CTRL_NBR_MAIN) {
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD10F             BNE.N    ??CSP_IntDisAll_0
    275                  int_src     = 0u;
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x0019             MOVS     R1,R3
    276                  int_src_grp = 0u;
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x001A             MOVS     R2,R3
    277                  while (int_src < CSP_INT_SRC_NBR_MAX) {
   \                     ??CSP_IntDisAll_1: (+1)
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x2923             CMP      R1,#+35
   \   00000014   0xDA08             BGE.N    ??CSP_IntDisAll_0
    278                      CPU_REG_NVIC_CLREN(int_src_grp) = DEF_BIT_FIELD(32u, 0u);
   \   00000016   0xF05F 0x33FF      MOVS     R3,#-1
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x....             LDR.N    R4,??DataTable6  ;; 0xe000e180
   \   0000001E   0xF844 0x3022      STR      R3,[R4, R2, LSL #+2]
    279                      int_src_grp++;
   \   00000022   0x1C52             ADDS     R2,R2,#+1
    280                      int_src += 32u;
   \   00000024   0x3120             ADDS     R1,R1,#+32
   \   00000026   0xE7F3             B.N      ??CSP_IntDisAll_1
    281                  }
    282              }    
    283          }
   \                     ??CSP_IntDisAll_0: (+1)
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    284          
    285          
    286          /*
    287          *********************************************************************************************************
    288          *                                          CSP_IntEn()
    289          *
    290          * Description : Enable an interrupt source on a specific interrupt controller.
    291          *
    292          * Argument(s) : int_ctrl   Interrupt controller number. (see 'CSP_IntClr()' note #1).
    293          *
    294          *               src_nbr    Interrupt source number. (see 'CSP_IntClr()' note #2).
    295          *
    296          * Return(s)   : None.
    297          *
    298          * Caller(s)   : Application.
    299          *
    300          * Note(s)     : None.
    301          *********************************************************************************************************
    302          */
    303          

   \                                 In section .text, align 2, keep-with-next
    304          void  CSP_IntEn (CSP_DEV_NBR  int_ctrl,
    305                           CSP_DEV_NBR  src_nbr)                 
    306          {
   \                     CSP_IntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    307              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    308                  (src_nbr   < CSP_INT_SRC_NBR_MAX  )) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD107             BNE.N    ??CSP_IntEn_0
   \   0000000C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000E   0x2D23             CMP      R5,#+35
   \   00000010   0xDA04             BGE.N    ??CSP_IntEn_0
    309                  CPU_IntSrcEn(src_nbr + CPU_INT_EXT0);
   \   00000012   0xF115 0x0010      ADDS     R0,R5,#+16
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       CPU_IntSrcEn
    310              }
    311          }
   \                     ??CSP_IntEn_0: (+1)
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    312          
    313          
    314          /*
    315          *********************************************************************************************************
    316          *                                          CSP_IntInit()
    317          *
    318          * Description : Initiailze all interrupt controllers.
    319          *                   (1) Disable all interrupts.
    320          *                   (2) Clear all pending interrupts.
    321          *                   (3) Initialize all vector interrupt tables.
    322          *                   (4) Install all shared interrupt handlers. 
    323          *
    324          * Argument(s) : None.
    325          *
    326          * Return(s)   : None.
    327          *
    328          * Caller(s)   : Application.
    329          *
    330          * Note(s)     : None.
    331          *********************************************************************************************************
    332          */
    333          

   \                                 In section .text, align 2, keep-with-next
    334          void  CSP_IntInit  (void)
    335          {
   \                     CSP_IntInit: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    336              CPU_INT08U     src_nbr;
    337              CSP_INT_VECT  *p_int_vect;
    338              CPU_SR_ALLOC();
   \   00000002   0x2500             MOVS     R5,#+0
    339              
    340              
    341              p_int_vect = &CSP_MainVectTbl[0];
   \   00000004   0x....             LDR.N    R0,??DataTable6_1
   \   00000006   0x0004             MOVS     R4,R0
    342          
    343              for (src_nbr = 0u; src_nbr < CSP_INT_SRC_NBR_MAX; src_nbr++) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0006             MOVS     R6,R0
   \                     ??CSP_IntInit_0: (+1)
   \   0000000C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000000E   0x2E23             CMP      R6,#+35
   \   00000010   0xDA1D             BGE.N    ??CSP_IntInit_1
    344                  CPU_IntSrcDis(src_nbr + CPU_INT_EXT0);                           /* Disable external interrupts.                         */
   \   00000012   0xF116 0x0010      ADDS     R0,R6,#+16
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x.... 0x....      BL       CPU_IntSrcDis
    345                  CPU_IntSrcPendClr(src_nbr + CPU_INT_EXT0);
   \   0000001C   0xF116 0x0010      ADDS     R0,R6,#+16
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x.... 0x....      BL       CPU_IntSrcPendClr
    346                  p_int_vect = &CSP_MainVectTbl[src_nbr];
   \   00000026   0x....             LDR.N    R0,??DataTable6_1
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0xEB10 0x1006      ADDS     R0,R0,R6, LSL #+4
   \   0000002E   0x0004             MOVS     R4,R0
    347          
    348                  CPU_CRITICAL_ENTER();     
   \   00000030   0x.... 0x....      BL       CPU_SR_Save
   \   00000034   0x0005             MOVS     R5,R0
   \   00000036   0x.... 0x....      BL       CPU_IntDisMeasStart
    349                  CSP_IntVectClr(p_int_vect);                             /* Initialize main vector table entry.                  */
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       CSP_IntVectClr
    350                  CPU_CRITICAL_EXIT();        
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
    351              }
   \   0000004A   0x1C76             ADDS     R6,R6,#+1
   \   0000004C   0xE7DE             B.N      ??CSP_IntInit_0
    352          
    353          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)    
    354              for (src_nbr = 0u; src_nbr < CSP_INT_USB_SRC_MAX_NBR; src_nbr++ ) {
   \                     ??CSP_IntInit_1: (+1)
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x0006             MOVS     R6,R0
   \                     ??CSP_IntInit_2: (+1)
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x2E05             CMP      R6,#+5
   \   00000056   0xDA13             BGE.N    ??CSP_IntInit_3
    355                  
    356                  p_int_vect = &CSP_USB_VectTbl[src_nbr];
   \   00000058   0x....             LDR.N    R0,??DataTable6_2
   \   0000005A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005C   0xEB10 0x1006      ADDS     R0,R0,R6, LSL #+4
   \   00000060   0x0004             MOVS     R4,R0
    357          
    358                  CPU_CRITICAL_ENTER();                                   /* Initialize USB shared handler the vector table.      */
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x0005             MOVS     R5,R0
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStart
    359                  CSP_IntVectClr(p_int_vect);
   \   0000006C   0x0020             MOVS     R0,R4
   \   0000006E   0x.... 0x....      BL       CSP_IntVectClr
    360                  CPU_CRITICAL_EXIT();
   \   00000072   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000076   0x0028             MOVS     R0,R5
   \   00000078   0x.... 0x....      BL       CPU_SR_Restore
    361              }
   \   0000007C   0x1C76             ADDS     R6,R6,#+1
   \   0000007E   0xE7E8             B.N      ??CSP_IntInit_2
    362          #endif    
    363                                                                          /* Install the USB shared handler.                      */
    364              src_nbr    = CSP_INT_SRC_NBR_USB_00;
   \                     ??CSP_IntInit_3: (+1)
   \   00000080   0x2018             MOVS     R0,#+24
   \   00000082   0x0006             MOVS     R6,R0
    365              p_int_vect = &CSP_MainVectTbl[src_nbr];
   \   00000084   0x....             LDR.N    R0,??DataTable6_1
   \   00000086   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000088   0xEB10 0x1006      ADDS     R0,R0,R6, LSL #+4
   \   0000008C   0x0004             MOVS     R4,R0
    366          
    367              CPU_CRITICAL_ENTER();    
   \   0000008E   0x.... 0x....      BL       CPU_SR_Save
   \   00000092   0x0005             MOVS     R5,R0
   \   00000094   0x.... 0x....      BL       CPU_IntDisMeasStart
    368              CSP_IntVectSet((CSP_INT_VECT *)p_int_vect,
    369                             (CPU_FNCT_PTR  )CSP_IntUSB_Handler,
    370                             (void *        )0);    
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x.... 0x....      ADR.W    R1,CSP_IntUSB_Handler
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       CSP_IntVectSet
    371              CPU_CRITICAL_EXIT();       
   \   000000A4   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A8   0x0028             MOVS     R0,R5
   \   000000AA   0x.... 0x....      BL       CPU_SR_Restore
    372          }
   \   000000AE   0xBD70             POP      {R4-R6,PC}       ;; return
    373          
    374          
    375          /*
    376          *********************************************************************************************************
    377          *                                          CSP_IntUSB_Handler()
    378          *
    379          * Description : USB ISR handler.            
    380          *
    381          * Argument(s) : p_arg    Interrupt ISR argument (not used)
    382          *
    383          * Return(s)   : None.
    384          *
    385          * Caller(s)   : This is an ISR.
    386          *
    387          * Note(s)     : (1) This funtion dispatch a Interrupt service routine for everyinterrupt line of 
    388          *                   the NVIC's USB channel.
    389          *********************************************************************************************************
    390          */
    391          
    392          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    393          static  void  CSP_IntUSB_Handler (void  *p_arg)
    394          {
   \                     CSP_IntUSB_Handler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
    395              CSP_INT_VECT   *p_int_vect;
    396              CPU_INT32U      usb_int_stat;
    397          
    398              
    399              p_arg        = p_arg;    
    400              usb_int_stat = CSP_INT_REG_USBINTST;
   \   00000004   0x....             LDR.N    R0,??DataTable6_3  ;; 0x400fc1c0
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x0005             MOVS     R5,R0
    401          
    402              CSP_INT_USB_DISPATCH(p_int_vect,
    403                                   usb_int_stat,
    404                                   CSP_INT_BIT_USBINTST_INT_DEV, 
    405                                   CSP_INT_USB_SRC_NBR_DEV);
   \   0000000A   0xF015 0x0F07      TST      R5,#0x7
   \   0000000E   0xD004             BEQ.N    ??CSP_IntUSB_Handler_0
   \   00000010   0x....             LDR.N    R0,??DataTable6_2
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x.... 0x....      BL       CSP_IntVectDeref
    406          
    407              CSP_INT_USB_DISPATCH(p_int_vect,
    408                                   usb_int_stat,
    409                                   CSP_INT_BIT_USBINTST_INT_HOST, 
    410                                   CSP_INT_USB_SRC_NBR_HOST);
   \                     ??CSP_IntUSB_Handler_0: (+1)
   \   0000001A   0x0728             LSLS     R0,R5,#+28
   \   0000001C   0xD504             BPL.N    ??CSP_IntUSB_Handler_1
   \   0000001E   0x....             LDR.N    R0,??DataTable6_4
   \   00000020   0x0004             MOVS     R4,R0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       CSP_IntVectDeref
    411          
    412              CSP_INT_USB_DISPATCH(p_int_vect,
    413                                   usb_int_stat,
    414                                   CSP_INT_BIT_USBINTST_INT_ATX, 
    415                                   CSP_INT_USB_SRC_NBR_ATX);
   \                     ??CSP_IntUSB_Handler_1: (+1)
   \   00000028   0x06E8             LSLS     R0,R5,#+27
   \   0000002A   0xD504             BPL.N    ??CSP_IntUSB_Handler_2
   \   0000002C   0x....             LDR.N    R0,??DataTable6_5
   \   0000002E   0x0004             MOVS     R4,R0
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x.... 0x....      BL       CSP_IntVectDeref
    416          
    417              CSP_INT_USB_DISPATCH(p_int_vect,
    418                                   usb_int_stat,
    419                                   CSP_INT_BIT_USBINTST_INT_OTG, 
    420                                   CSP_INT_USB_SRC_NBR_OTG);
   \                     ??CSP_IntUSB_Handler_2: (+1)
   \   00000036   0x06A8             LSLS     R0,R5,#+26
   \   00000038   0xD504             BPL.N    ??CSP_IntUSB_Handler_3
   \   0000003A   0x....             LDR.N    R0,??DataTable6_6
   \   0000003C   0x0004             MOVS     R4,R0
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       CSP_IntVectDeref
    421          
    422              CSP_INT_USB_DISPATCH(p_int_vect,
    423                                   usb_int_stat,
    424                                   CSP_INT_BIT_USBINTST_INT_I2C, 
    425                                   CSP_INT_USB_SRC_NBR_I2C);
   \                     ??CSP_IntUSB_Handler_3: (+1)
   \   00000044   0x0668             LSLS     R0,R5,#+25
   \   00000046   0xD504             BPL.N    ??CSP_IntUSB_Handler_4
   \   00000048   0x....             LDR.N    R0,??DataTable6_7
   \   0000004A   0x0004             MOVS     R4,R0
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       CSP_IntVectDeref
    426          }
   \                     ??CSP_IntUSB_Handler_4: (+1)
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    427          #endif
    428          
    429          
    430          /*
    431          *********************************************************************************************************
    432          *                                          CSP_IntSrcCfg()
    433          *
    434          * Description : Configure an interrupt source.
    435          *
    436          * Argument(s) : int_ctrl   Interrupt controller number. (see 'CSP_IntClr()' note #1).
    437          *
    438          *               src_nbr    Interrupt source number. (see 'CSP_IntClr()' note #2).
    439          *
    440          *               src_prio   Interrupt source priority.
    441          *
    442          *               src_pol    Interrupt source polarity:
    443          *                              CSP_INT_POL_LEVEL_HIGH           Interrupt is activated on a high level.
    444          *                              CSP_INT_POL_LEVEL_LOW            Interrupt is activated on a low level.
    445          * 
    446          *                              CSP_INT_POL_EDGE_RISING          Interrupt is activated on the rising edge.
    447          *                              CSP_INT_POL_EDGE_FALLING         Interrupt is activated on the falling edge.
    448          *                              CSP_INT_POL_EDGE_BOTH            Interrupt is activated on both edges.       
    449          *
    450          *
    451          * Return(s)   : DEF_OK,    if the interrupt source was configured
    452          *               DEF_FAIL,  otherwise.
    453          *
    454          * Note(s)     : (1) Interrupt source priority is determined by the interrupt controller implementation.
    455          *                   The maximum and minimum values are defined in the family definition file 'csp_grp.h'
    456          *
    457          * Note(s)     : None.
    458          *********************************************************************************************************
    459          */
    460          

   \                                 In section .text, align 2, keep-with-next
    461          CPU_BOOLEAN  CSP_IntSrcCfg (CSP_DEV_NBR  int_ctrl,
    462                                      CSP_DEV_NBR  src_nbr,
    463                                      CSP_OPT      src_prio,
    464                                      CSP_OPT      src_pol)
    465          
    466          {
   \                     CSP_IntSrcCfg: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    467              CPU_BOOLEAN  err;
    468              
    469              err = DEF_FAIL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4680             MOV      R8,R0
    470              
    471              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    472                  (src_nbr   < CSP_INT_SRC_NBR_MAX  ) && 
    473                  (src_prio  < 0xFF                 )) {
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD10D             BNE.N    ??CSP_IntSrcCfg_0
   \   00000016   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000018   0x2D23             CMP      R5,#+35
   \   0000001A   0xDA0A             BGE.N    ??CSP_IntSrcCfg_0
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x2EFF             CMP      R6,#+255
   \   00000020   0xDA07             BGE.N    ??CSP_IntSrcCfg_0
    474                  CPU_IntSrcPrioSet(src_nbr + 16u, CPU_INT_EXT0);
   \   00000022   0x2110             MOVS     R1,#+16
   \   00000024   0xF115 0x0010      ADDS     R0,R5,#+16
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       CPU_IntSrcPrioSet
    475                  err = DEF_OK;
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x4680             MOV      R8,R0
    476              }
    477              
    478              return (err);
   \                     ??CSP_IntSrcCfg_0: (+1)
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    479          }
    480          
    481          
    482          /*
    483          *********************************************************************************************************
    484          *                                          CSP_IntVectReg()
    485          *
    486          * Description : Register an interrupt service routine handler for a specific interrupt controller.
    487          *
    488          * Argument(s) : int_ctrl    Interrupt controller number. (see 'CSP_IntClr()' note #1).
    489          *
    490          *               src_nbr     Interrupt source number. (see 'CSP_IntClr()' note #2).
    491          *
    492          *               isr_fnct    Pointer to the interrupt service routine (ISR).
    493          *
    494          *               p_arg       Pointer to the argument of the interrupt service routine (ISR).
    495          *
    496          * Return(s)   : DEF_OK,    If the vector was registered successfully.
    497          *               DEF_FAIL,  otherwise.
    498          *               
    499          * Caller(s)   : Application.
    500          *
    501          * Note(s)     : None.
    502          *********************************************************************************************************
    503          */
    504          

   \                                 In section .text, align 2, keep-with-next
    505          CPU_BOOLEAN  CSP_IntVectReg (CSP_DEV_NBR    int_ctrl,
    506                                       CSP_DEV_NBR    src_nbr,
    507                                       CPU_FNCT_PTR   isr_fnct,
    508                                       void          *p_arg)
    509          {
   \                     CSP_IntVectReg: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    510              CSP_INT_VECT  *p_int_vect;
    511              CPU_SR_ALLOC();
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    512          
    513          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)    
    514              if (isr_fnct == (CPU_FNCT_PTR)0) {
   \   00000010   0x0030             MOVS     R0,R6
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??CSP_IntVectReg_0
    515                  return (DEF_FAIL);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE033             B.N      ??CSP_IntVectReg_1
    516              }
    517              
    518              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    519                  (src_nbr  >= CSP_INT_SRC_NBR_MAX  )) {
   \                     ??CSP_IntVectReg_0: (+1)
   \   0000001A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   0x2C00             CMP      R4,#+0
   \   0000001E   0xD104             BNE.N    ??CSP_IntVectReg_2
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0x2D23             CMP      R5,#+35
   \   00000024   0xDB01             BLT.N    ??CSP_IntVectReg_2
    520                  return (DEF_FAIL);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE02B             B.N      ??CSP_IntVectReg_1
    521              }
    522          
    523          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    524              if ((int_ctrl == CSP_INT_CTRL_NBR_USB) &&
    525                  (src_nbr  >= CSP_INT_SRC_NBR_MAX  )) {
   \                     ??CSP_IntVectReg_2: (+1)
   \   0000002A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002C   0x2C01             CMP      R4,#+1
   \   0000002E   0xD104             BNE.N    ??CSP_IntVectReg_3
   \   00000030   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000032   0x2D23             CMP      R5,#+35
   \   00000034   0xDB01             BLT.N    ??CSP_IntVectReg_3
    526                  return (DEF_FAIL);
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE023             B.N      ??CSP_IntVectReg_1
    527              }
    528          #endif
    529          #endif    
    530              
    531              switch (int_ctrl) {
   \                     ??CSP_IntVectReg_3: (+1)
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD002             BEQ.N    ??CSP_IntVectReg_4
   \   00000040   0x2C01             CMP      R4,#+1
   \   00000042   0xD006             BEQ.N    ??CSP_IntVectReg_5
   \   00000044   0xE00B             B.N      ??CSP_IntVectReg_6
    532                  case CSP_INT_CTRL_NBR_MAIN:                             /* Install interrupt ISR in the NVIC's vector table.    */
    533                       p_int_vect = &CSP_MainVectTbl[src_nbr];
   \                     ??CSP_IntVectReg_4: (+1)
   \   00000046   0x....             LDR.N    R0,??DataTable6_1
   \   00000048   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004A   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   0000004E   0x4680             MOV      R8,R0
    534                       break;
   \   00000050   0xE007             B.N      ??CSP_IntVectReg_7
    535          
    536          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    537                  case CSP_INT_CTRL_NBR_USB:                              /* Install interrupt ISR in the USB's vector table.     */
    538                       p_int_vect = &CSP_USB_VectTbl[src_nbr];
   \                     ??CSP_IntVectReg_5: (+1)
   \   00000052   0x....             LDR.N    R0,??DataTable6_2
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   0000005A   0x4680             MOV      R8,R0
    539                       break;
   \   0000005C   0xE001             B.N      ??CSP_IntVectReg_7
    540          #endif
    541           
    542                  default:
    543                       return (DEF_FAIL);
   \                     ??CSP_IntVectReg_6: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE00F             B.N      ??CSP_IntVectReg_1
    544              }
    545          
    546              CPU_CRITICAL_ENTER();
   \                     ??CSP_IntVectReg_7: (+1)
   \   00000062   0x.... 0x....      BL       CPU_SR_Save
   \   00000066   0x4681             MOV      R9,R0
   \   00000068   0x.... 0x....      BL       CPU_IntDisMeasStart
    547              
    548              CSP_IntVectSet((CSP_INT_VECT *)p_int_vect,
    549                             (CPU_FNCT_PTR  )isr_fnct,
    550                             (void *        )p_arg);
   \   0000006C   0x003A             MOVS     R2,R7
   \   0000006E   0x0031             MOVS     R1,R6
   \   00000070   0x4640             MOV      R0,R8
   \   00000072   0x.... 0x....      BL       CSP_IntVectSet
    551          
    552              CPU_CRITICAL_EXIT();
   \   00000076   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007A   0x4648             MOV      R0,R9
   \   0000007C   0x.... 0x....      BL       CPU_SR_Restore
    553              
    554              return (DEF_OK);
   \   00000080   0x2001             MOVS     R0,#+1
   \                     ??CSP_IntVectReg_1: (+1)
   \   00000082   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    555          }
    556          
    557          
    558          /*
    559          *********************************************************************************************************
    560          *                                          CSP_IntVectUnreg()
    561          *
    562          * Description : Un-register an interrupt vector.
    563          *
    564          * Argument(s) : int_ctrl   Interrupt controller number. (see 'CSP_IntClr()' note #1).
    565          *
    566          *               src_nbr    Interrupt source number. (see 'CSP_IntClr()' note #2).
    567          *
    568          * Return(s)   : DEF_OK,     If the vector was unregistered successfully.
    569          *               DEF_FAIL,   otherwise.
    570          *
    571          * Caller(s)   : Application.
    572          *
    573          * Note(s)     : None.
    574          *********************************************************************************************************
    575          */
    576          

   \                                 In section .text, align 2, keep-with-next
    577          CPU_BOOLEAN  CSP_IntVectUnreg (CSP_DEV_NBR  int_ctrl,
    578                                         CSP_DEV_NBR  src_nbr)                         
    579          {
   \                     CSP_IntVectUnreg: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    580              CSP_INT_VECT  *p_int_vect;
    581              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    582          
    583          
    584          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)        
    585              if ((int_ctrl == CSP_INT_CTRL_NBR_MAIN) &&
    586                  (src_nbr  >= CSP_INT_SRC_NBR_MAX  )) {
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD104             BNE.N    ??CSP_IntVectUnreg_0
   \   0000000E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000010   0x2D23             CMP      R5,#+35
   \   00000012   0xDB01             BLT.N    ??CSP_IntVectUnreg_0
    587                  return (DEF_FAIL);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE029             B.N      ??CSP_IntVectUnreg_1
    588              }
    589          
    590          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    591              if ((int_ctrl == CSP_INT_CTRL_NBR_USB) &&
    592                  (src_nbr  >= CSP_INT_SRC_NBR_MAX  )) {
   \                     ??CSP_IntVectUnreg_0: (+1)
   \   00000018   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001A   0x2C01             CMP      R4,#+1
   \   0000001C   0xD104             BNE.N    ??CSP_IntVectUnreg_2
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x2D23             CMP      R5,#+35
   \   00000022   0xDB01             BLT.N    ??CSP_IntVectUnreg_2
    593                  return (DEF_FAIL);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE021             B.N      ??CSP_IntVectUnreg_1
    594              }
    595          #endif
    596          #endif    
    597              
    598              switch (int_ctrl) {
   \                     ??CSP_IntVectUnreg_2: (+1)
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD002             BEQ.N    ??CSP_IntVectUnreg_3
   \   0000002E   0x2C01             CMP      R4,#+1
   \   00000030   0xD006             BEQ.N    ??CSP_IntVectUnreg_4
   \   00000032   0xE00B             B.N      ??CSP_IntVectUnreg_5
    599                  case CSP_INT_CTRL_NBR_MAIN:                             /* Install interrupt ISR in the NVIC's vector table.    */
    600                       p_int_vect = &CSP_MainVectTbl[src_nbr];
   \                     ??CSP_IntVectUnreg_3: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable6_1
   \   00000036   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000038   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   0000003C   0x0006             MOVS     R6,R0
    601                       break;
   \   0000003E   0xE007             B.N      ??CSP_IntVectUnreg_6
    602          
    603          #if (CSP_DEV_USB_OTG_EN == DEF_ENABLED)
    604                  case CSP_INT_CTRL_NBR_USB:                              /* Install interrupt ISR in the USB's vector table.     */
    605                       p_int_vect = &CSP_USB_VectTbl[src_nbr];
   \                     ??CSP_IntVectUnreg_4: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable6_2
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   00000048   0x0006             MOVS     R6,R0
    606                       break;
   \   0000004A   0xE001             B.N      ??CSP_IntVectUnreg_6
    607          #endif
    608           
    609                  default:
    610                       return (DEF_FAIL);
   \                     ??CSP_IntVectUnreg_5: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE00D             B.N      ??CSP_IntVectUnreg_1
    611              }
    612          
    613              CPU_CRITICAL_ENTER();
   \                     ??CSP_IntVectUnreg_6: (+1)
   \   00000050   0x.... 0x....      BL       CPU_SR_Save
   \   00000054   0x0007             MOVS     R7,R0
   \   00000056   0x.... 0x....      BL       CPU_IntDisMeasStart
    614              
    615              CSP_IntVectClr(p_int_vect);                  
   \   0000005A   0x0030             MOVS     R0,R6
   \   0000005C   0x.... 0x....      BL       CSP_IntVectClr
    616                            
    617              CPU_CRITICAL_EXIT();
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
    618              
    619              return (DEF_OK);
   \   0000006A   0x2001             MOVS     R0,#+1
   \                     ??CSP_IntVectUnreg_1: (+1)
   \   0000006C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    620          }
    621          
    622          
    623          /*
    624          *********************************************************************************************************
    625          *                                          CSP_IntHandler()
    626          *
    627          * Description : Global interrupt handler.
    628          *
    629          * Argument(s) : None.
    630          *
    631          * Return(s)   : None.
    632          *
    633          * Caller(s)   : Application.
    634          *
    635          * Note(s)     : None.
    636          *********************************************************************************************************
    637          */
    638          

   \                                 In section .text, align 2, keep-with-next
    639          void  CSP_IntHandler (void)
    640          {
   \                     CSP_IntHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    641              CSP_INT_VECT  *p_int_vect;
    642              CSP_DEV_NBR    src_nbr;        
    643              CPU_INT32U     reg_val;
    644          
    645                                                                          /* Query the NVIC interrupt controller                 */
    646              reg_val  = (CPU_REG_NVIC_ICSR & CPU_MSK_NVIC_ICSR_VECT_ACTIVE);
   \   00000002   0x....             LDR.N    R0,??DataTable6_8  ;; 0xe000ed04
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x05C0             LSLS     R0,R0,#+23       ;; ZeroExtS R0,R0,#+23,#+23
   \   00000008   0x0DC0             LSRS     R0,R0,#+23
   \   0000000A   0x0006             MOVS     R6,R0
    647              src_nbr  = (CSP_DEV_NBR)reg_val -  CPU_INT_EXT0;
   \   0000000C   0x0030             MOVS     R0,R6
   \   0000000E   0x3810             SUBS     R0,R0,#+16
   \   00000010   0x0005             MOVS     R5,R0
    648              
    649              if (src_nbr < CSP_INT_SRC_NBR_MAX) {
   \   00000012   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000014   0x2D23             CMP      R5,#+35
   \   00000016   0xDA07             BGE.N    ??CSP_IntHandler_0
    650                  p_int_vect = &CSP_MainVectTbl[src_nbr];
   \   00000018   0x....             LDR.N    R0,??DataTable6_1
   \   0000001A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001C   0xEB10 0x1005      ADDS     R0,R0,R5, LSL #+4
   \   00000020   0x0004             MOVS     R4,R0
    651          
    652                  CSP_IntVectDeref(p_int_vect);                           /* Call Dereferencing funtion                          */
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       CSP_IntVectDeref
    653              }
    654          }
   \                     ??CSP_IntHandler_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    655          
    656          
    657          /*
    658          *********************************************************************************************************
    659          *                                       CSP_IntHandlerSrc()
    660          *
    661          * Description : Global interrupt handler.
    662          *
    663          * Argument(s) : src_nbr      Interrupt source number.
    664          *
    665          * Return(s)   : None.
    666          *
    667          * Caller(s)   : Application.
    668          *
    669          * Note(s)     : None.
    670          *********************************************************************************************************
    671          */
    672          

   \                                 In section .text, align 2, keep-with-next
    673          void  CSP_IntHandlerSrc (CSP_DEV_NBR  src_nbr)
    674          {
   \                     CSP_IntHandlerSrc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    675              CSP_INT_VECT  *p_int_vect;
    676          
    677              
    678              if (src_nbr < CSP_INT_SRC_NBR_MAX) {
   \   00000004   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000006   0x2C23             CMP      R4,#+35
   \   00000008   0xDA07             BGE.N    ??CSP_IntHandlerSrc_0
    679                  p_int_vect = &CSP_MainVectTbl[src_nbr];
   \   0000000A   0x....             LDR.N    R0,??DataTable6_1
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0xEB10 0x1004      ADDS     R0,R0,R4, LSL #+4
   \   00000012   0x0005             MOVS     R5,R0
    680          
    681                  CSP_IntVectDeref(p_int_vect);                           /* Call Dereferencing funtion                          */
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       CSP_IntVectDeref
    682              }
    683          }
   \                     ??CSP_IntHandlerSrc_0: (+1)
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     CSP_MainVectTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     CSP_USB_VectTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x400FC1C0         DC32     0x400fc1c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     CSP_USB_VectTbl+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     CSP_USB_VectTbl+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     CSP_USB_VectTbl+0x30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     CSP_USB_VectTbl+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CSP_IntClr
        16   -> CPU_IntSrcPendClr
      16   CSP_IntDis
        16   -> CPU_IntSrcDis
       4   CSP_IntDisAll
      16   CSP_IntEn
        16   -> CPU_IntSrcEn
      16   CSP_IntHandler
        16   -> CSP_IntVectDeref
      16   CSP_IntHandlerSrc
        16   -> CSP_IntVectDeref
      16   CSP_IntInit
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_IntSrcDis
        16   -> CPU_IntSrcPendClr
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> CSP_IntVectClr
        16   -> CSP_IntVectSet
      24   CSP_IntSrcCfg
        24   -> CPU_IntSrcPrioSet
      16   CSP_IntUSB_Handler
        16   -> CSP_IntVectDeref
      32   CSP_IntVectReg
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CSP_IntVectSet
      24   CSP_IntVectUnreg
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CSP_IntVectClr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
      30  CSP_IntClr
      30  CSP_IntDis
      44  CSP_IntDisAll
      30  CSP_IntEn
      42  CSP_IntHandler
      28  CSP_IntHandlerSrc
     176  CSP_IntInit
      58  CSP_IntSrcCfg
      84  CSP_IntUSB_Handler
     134  CSP_IntVectReg
     110  CSP_IntVectUnreg
     560  CSP_MainVectTbl
      80  CSP_USB_VectTbl

 
 640 bytes in section .bss
 802 bytes in section .text
 
 802 bytes of CODE memory
 640 bytes of DATA memory

Errors: none
Warnings: none
