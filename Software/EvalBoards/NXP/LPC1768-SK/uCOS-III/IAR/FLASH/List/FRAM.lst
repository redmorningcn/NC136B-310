###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       16/May/2017  06:32:51
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\DataDeal\FRAM.c
#    Command line =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\DataDeal\FRAM.c
#        -lCN
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\FRAM.lst
#    Object file  =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\FRAM.o
#
###############################################################################

F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\DataDeal\FRAM.c
      1          //#include    "config.h"   
      2          //#include    "CpuDrive.h"
      3          
      4          #include <includes.h>
      5          #include "IIC.h"
      6          					  
      7          //铁电参数
      8          #define		FRAM_SIZE               8192						         	//1024*8空间容量
      9          #define		FRAM_START_ADDR	        0x0000	                                //铁电的起始地址
     10          #define		FRAM_DIVICE_ADDR        0xa0	                                //铁电的设备地址
     11          #define		FRAM_END_ADDR	      	(FRAM_START_ADDR + FRAM_SIZE)	
     12          
     13          #define		FRMA_PROTECT			121//P121
     14          
     15          //------------------------------------------------------------------------
     16          //  名  称 ：void WriteSCL( uint8 temp )
     17          //  功  能 ：设置 SCL
     18          // 入口参数：无
     19          // 出口参数：无
     20          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     21          void WriteFRAM_PROTECT(uint8 temp)
     22          {
     23          //    IO1DIR_OUT(FRMA_PROTECT);    
     24          //    IO1PIN_W(temp,FRMA_PROTECT);
     25          }
   \                     WriteFRAM_PROTECT: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     26          
     27          //-------------------------------------------------------------------------------------------------------
     28          //函数名称:         WriteFM24CL16()
     29          //功    能:         对FM24CL16指定地址进行写数据
     30          //入口参数:         ADDR:       操作地址    地址：0 ~ sizeof(FM24CL16)
     31          //                  *DataBuf:   数据缓冲
     32          //                  Len:        数据长度
     33          //出口参数:         无
     34          //说明：            
     35          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     36          uint8 WriteFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
     37          {
   \                     WriteFM24CL64: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     38              uint32  i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
     39              uint8   SlaveAddr;                                      //从机地址
     40              uint16  AddrTemp = 0;                                   //地址缓存
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
     41              
     42              WriteFRAM_PROTECT(0);									//关写保护
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      BL       WriteFRAM_PROTECT
     43              
     44              AddrTemp = Addr;
   \   00000016   0x46A1             MOV      R9,R4
     45              AddrTemp += FRAM_START_ADDR;                            //计算地址
     46          
     47              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   00000018   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000001C   0xEB16 0x0009      ADDS     R0,R6,R9
   \   00000020   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000024   0xD901             BLS.N    ??WriteFM24CL64_0
     48              {
     49                  return  FALSE;                                      //地址未超阶
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE025             B.N      ??WriteFM24CL64_1
     50              }
     51                  
     52              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
   \                     ??WriteFM24CL64_0: (+1)
   \   0000002A   0x20A0             MOVS     R0,#+160
   \   0000002C   0x4680             MOV      R8,R0
     53              
     54              StartI2C();                                             //启动IIC总线
   \   0000002E   0x.... 0x....      BL       StartI2C
     55              
     56              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64地址
   \   00000032   0x4640             MOV      R0,R8
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      BL       WriteByteWithI2C
     57              CheckSlaveAckI2C();
   \   0000003A   0x.... 0x....      BL       CheckSlaveAckI2C
     58           
     59              WriteByteWithI2C(Addr >> 8);                            //写FM24CL64高位地址
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x0A00             LSRS     R0,R0,#+8
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x.... 0x....      BL       WriteByteWithI2C
     60              CheckSlaveAckI2C();
   \   0000004A   0x.... 0x....      BL       CheckSlaveAckI2C
     61              
     62              WriteByteWithI2C( Addr );                               //写FM24CL64低位地址
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       WriteByteWithI2C
     63              CheckSlaveAckI2C();     
   \   00000056   0x.... 0x....      BL       CheckSlaveAckI2C
     64            
     65              for(i = 0; i < DataBufLen; i++)                         //发送数据
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x0007             MOVS     R7,R0
   \                     ??WriteFM24CL64_2: (+1)
   \   0000005E   0x42B7             CMP      R7,R6
   \   00000060   0xD206             BCS.N    ??WriteFM24CL64_3
     66              {
     67                  WriteByteWithI2C(DataBuf[i]);                       //写数据
   \   00000062   0x5D78             LDRB     R0,[R7, R5]
   \   00000064   0x.... 0x....      BL       WriteByteWithI2C
     68                  CheckSlaveAckI2C();                                 //读从机应答信号
   \   00000068   0x.... 0x....      BL       CheckSlaveAckI2C
     69              }
   \   0000006C   0x1C7F             ADDS     R7,R7,#+1
   \   0000006E   0xE7F6             B.N      ??WriteFM24CL64_2
     70              
     71              StopI2C();                                              //停止IIC操作   
   \                     ??WriteFM24CL64_3: (+1)
   \   00000070   0x.... 0x....      BL       StopI2C
     72              
     73              return  TRUE;                                           //正确
   \   00000074   0x2001             MOVS     R0,#+1
   \                     ??WriteFM24CL64_1: (+1)
   \   00000076   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
     74          }
     75          
     76          //-------------------------------------------------------------------------------------------------------
     77          //函数名称:         ReadFM24CL16()
     78          //功    能:         读取FM24CL16指定地址进行数据
     79          //入口参数:         ADDR:       操作地址   地址：0 ~ sizeof(FM24CL16)
     80          //                  *DataBuf:   数据缓冲 
     81          //                  Len:        数据长度
     82          //出口参数:         无
     83          //说明：            
     84          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     85          uint8 ReadFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
     86          {
   \                     ReadFM24CL64: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
     87              uint32  i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
     88              uint8   SlaveAddr;                                      //从机地址
     89              uint16  AddrTemp;                                       //地址缓存
     90              
     91          	WriteFRAM_PROTECT(0);									//关写保护
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WriteFRAM_PROTECT
     92          
     93              AddrTemp = Addr;
   \   00000012   0x46A1             MOV      R9,R4
     94              
     95              AddrTemp += FRAM_START_ADDR;                            //计算地址
     96              
     97              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   00000014   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000018   0xEB16 0x0009      ADDS     R0,R6,R9
   \   0000001C   0xF5B0 0x5F00      CMP      R0,#+8192
   \   00000020   0xD901             BLS.N    ??ReadFM24CL64_0
     98              {
     99                  return  FALSE;                                      //地址未超阶
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE035             B.N      ??ReadFM24CL64_1
    100              }
    101              
    102              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
   \                     ??ReadFM24CL64_0: (+1)
   \   00000026   0x20A0             MOVS     R0,#+160
   \   00000028   0x4680             MOV      R8,R0
    103              
    104              StartI2C();                                             //启动IIC总线
   \   0000002A   0x.... 0x....      BL       StartI2C
    105              
    106              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64设备写地址
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x.... 0x....      BL       WriteByteWithI2C
    107              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000036   0x.... 0x....      BL       CheckSlaveAckI2C
    108              
    109              WriteByteWithI2C(Addr >> 8 );                           //写数据高位地址
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x0A00             LSRS     R0,R0,#+8
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x.... 0x....      BL       WriteByteWithI2C
    110              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000046   0x.... 0x....      BL       CheckSlaveAckI2C
    111              
    112              WriteByteWithI2C( Addr );                               //写数据低位地址
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       WriteByteWithI2C
    113              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000052   0x.... 0x....      BL       CheckSlaveAckI2C
    114                  
    115              SlaveAddr = (FRAM_DIVICE_ADDR)|(0x01);                  //求FM24CL64设备读地址
   \   00000056   0x20A1             MOVS     R0,#+161
   \   00000058   0x4680             MOV      R8,R0
    116              
    117              StartI2C();                                             //启动IIC总线
   \   0000005A   0x.... 0x....      BL       StartI2C
    118              
    119              WriteByteWithI2C(SlaveAddr);                            //写FM24CL16地址
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       WriteByteWithI2C
    120              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000066   0x.... 0x....      BL       CheckSlaveAckI2C
    121             
    122              for(i = 0; i < (DataBufLen -1); i++)                    //发送数据
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x0007             MOVS     R7,R0
   \                     ??ReadFM24CL64_2: (+1)
   \   0000006E   0x1E70             SUBS     R0,R6,#+1
   \   00000070   0x4287             CMP      R7,R0
   \   00000072   0xD206             BCS.N    ??ReadFM24CL64_3
    123              {
    124                  DataBuf[i] = ReadByteWithI2C();                     //写数据
   \   00000074   0x.... 0x....      BL       ReadByteWithI2C
   \   00000078   0x5578             STRB     R0,[R7, R5]
    125                  MasterAckI2C();                                     //主机应答从机
   \   0000007A   0x.... 0x....      BL       MasterAckI2C
    126              }
   \   0000007E   0x1C7F             ADDS     R7,R7,#+1
   \   00000080   0xE7F5             B.N      ??ReadFM24CL64_2
    127              DataBuf[i] = ReadByteWithI2C();                         //写数据
   \                     ??ReadFM24CL64_3: (+1)
   \   00000082   0x.... 0x....      BL       ReadByteWithI2C
   \   00000086   0x5578             STRB     R0,[R7, R5]
    128              
    129              MasterNoAckI2C();                                       //主机应答从机
   \   00000088   0x.... 0x....      BL       MasterNoAckI2C
    130              
    131              StopI2C();
   \   0000008C   0x.... 0x....      BL       StopI2C
    132              
    133              return  TRUE;                                           //正确
   \   00000090   0x2001             MOVS     R0,#+1
   \                     ??ReadFM24CL64_1: (+1)
   \   00000092   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    134          }
    135          
    136          //#endif
    137              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ReadFM24CL64
        32   -> CheckSlaveAckI2C
        32   -> MasterAckI2C
        32   -> MasterNoAckI2C
        32   -> ReadByteWithI2C
        32   -> StartI2C
        32   -> StopI2C
        32   -> WriteByteWithI2C
        32   -> WriteFRAM_PROTECT
      32   WriteFM24CL64
        32   -> CheckSlaveAckI2C
        32   -> StartI2C
        32   -> StopI2C
        32   -> WriteByteWithI2C
        32   -> WriteFRAM_PROTECT
       0   WriteFRAM_PROTECT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     150  ReadFM24CL64
     122  WriteFM24CL64
       2  WriteFRAM_PROTECT

 
 274 bytes in section .text
 
 274 bytes of CODE memory

Errors: none
Warnings: 1
