###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Aug/2017  16:25:16
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_rit.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_rit.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_rit.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_rit.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_rit.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_rit.c				2010-05-21
      3          *//**
      4          * @file		lpc17xx_rit.c
      5          * @brief	Contains all functions support for RIT firmware library on LPC17xx
      6          * @version	2.0
      7          * @date		21. May. 2010
      8          * @author	NXP MCU SW Application Team
      9          *
     10          * Copyright(C) 2010, NXP Semiconductor
     11          * All rights reserved.
     12          *
     13          ***********************************************************************
     14          * Software that is described herein is for illustrative purposes only
     15          * which provides customers with programming information regarding the
     16          * products. This software is supplied "AS IS" without any warranties.
     17          * NXP Semiconductors assumes no responsibility or liability for the
     18          * use of the software, conveys no license or title under any patent,
     19          * copyright, or mask work right to the product. NXP Semiconductors
     20          * reserves the right to make changes in the software without
     21          * notification. NXP Semiconductors also make no representation or
     22          * warranty that such application will be suitable for the specified
     23          * use without further testing or modification.
     24          * Permission to use, copy, modify, and distribute this software and its
     25          * documentation is hereby granted, under NXP Semiconductors'
     26          * relevant copyright in the software, without fee, provided that it
     27          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     28          * copyright, permission, and disclaimer notice must appear in all copies of
     29          * this code.
     30          **********************************************************************/
     31          
     32          /* Peripheral group ----------------------------------------------------------- */
     33          /** @addtogroup RIT
     34           * @{
     35           */
     36          
     37          /* Includes ------------------------------------------------------------------- */
     38          #include "lpc17xx_rit.h"
     39          #include "lpc17xx_clkpwr.h"
     40          
     41          /* If this source file built with example, the LPC17xx FW library configuration
     42           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     43           * otherwise the default FW library configuration file must be included instead
     44           */
     45          #ifdef __BUILD_WITH_EXAMPLE__
     46          #include "lpc17xx_libcfg.h"
     47          #else
     48          #include "lpc17xx_libcfg_default.h"
     49          #endif /* __BUILD_WITH_EXAMPLE__ */
     50          
     51          #ifdef _RIT
     52          
     53          /* Public Functions ----------------------------------------------------------- */
     54          /** @addtogroup RIT_Public_Functions
     55           * @{
     56           */
     57          
     58          /******************************************************************************//*
     59           * @brief 		Initial for RIT
     60           * 					- Turn on power and clock
     61           * 					- Setup default register values
     62           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
     63           * @return 		None
     64           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     65          void RIT_Init(LPC_RIT_TypeDef *RITx)
     66          {
   \                     RIT_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     67          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000004   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD003             BEQ.N    ??RIT_Init_0
   \   0000000A   0x2143             MOVS     R1,#+67
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x.... 0x....      BL       check_failed
     68          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, ENABLE);
   \                     ??RIT_Init_0: (+1)
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000018   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     69          	//Set up default register values
     70          	RITx->RICOMPVAL = 0xFFFFFFFF;
   \   0000001C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000020   0x6020             STR      R0,[R4, #+0]
     71          	RITx->RIMASK	= 0x00000000;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6060             STR      R0,[R4, #+4]
     72          	RITx->RICTRL	= 0x0C;
   \   00000026   0x200C             MOVS     R0,#+12
   \   00000028   0x7220             STRB     R0,[R4, #+8]
     73          	RITx->RICOUNTER	= 0x00000000;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x60E0             STR      R0,[R4, #+12]
     74          	// Turn on power and clock
     75          
     76          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
     77          /******************************************************************************//*
     78           * @brief 		DeInitial for RIT
     79           * 					- Turn off power and clock
     80           * 					- ReSetup default register values
     81           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
     82           * @return 		None
     83           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     84          void RIT_DeInit(LPC_RIT_TypeDef *RITx)
     85          {
   \                     RIT_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     86          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000004   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD003             BEQ.N    ??RIT_DeInit_0
   \   0000000A   0x2156             MOVS     R1,#+86
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x.... 0x....      BL       check_failed
     87          
     88          	// Turn off power and clock
     89          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCRIT, DISABLE);
   \                     ??RIT_DeInit_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF45F 0x3080      MOVS     R0,#+65536
   \   00000018   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     90          	//ReSetup default register values
     91          	RITx->RICOMPVAL = 0xFFFFFFFF;
   \   0000001C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000020   0x6020             STR      R0,[R4, #+0]
     92          	RITx->RIMASK	= 0x00000000;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6060             STR      R0,[R4, #+4]
     93          	RITx->RICTRL	= 0x0C;
   \   00000026   0x200C             MOVS     R0,#+12
   \   00000028   0x7220             STRB     R0,[R4, #+8]
     94          	RITx->RICOUNTER	= 0x00000000;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x60E0             STR      R0,[R4, #+12]
     95          }
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
     96          
     97          /******************************************************************************//*
     98           * @brief 		Set compare value, mask value and time counter value
     99           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
    100           * @param[in]	time_interval: timer interval value (ms)
    101           * @return 		None
    102           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          void RIT_TimerConfig(LPC_RIT_TypeDef *RITx, uint32_t time_interval)
    104          {
   \                     RIT_TimerConfig: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    105          	uint32_t clock_rate, cmp_value;
    106          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000006   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD003             BEQ.N    ??RIT_TimerConfig_0
   \   0000000C   0x216A             MOVS     R1,#+106
   \   0000000E   0x....             LDR.N    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       check_failed
    107          
    108          	// Get PCLK value of RIT
    109          	clock_rate = CLKPWR_GetPCLK(CLKPWR_PCLKSEL_RIT);
   \                     ??RIT_TimerConfig_0: (+1)
   \   00000014   0x203A             MOVS     R0,#+58
   \   00000016   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   0000001A   0x0006             MOVS     R6,R0
    110          
    111          	/* calculate compare value for RIT to generate interrupt at
    112          	 * specified time interval
    113          	 * COMPVAL = (RIT_PCLK * time_interval)/1000
    114          	 * (with time_interval unit is millisecond)
    115          	 */
    116          	cmp_value = (clock_rate /1000) * time_interval;
   \   0000001C   0xF44F 0x707A      MOV      R0,#+1000
   \   00000020   0xFBB6 0xF0F0      UDIV     R0,R6,R0
   \   00000024   0x4368             MULS     R0,R5,R0
   \   00000026   0x0007             MOVS     R7,R0
    117          	RITx->RICOMPVAL = cmp_value;
   \   00000028   0x6027             STR      R7,[R4, #+0]
    118          
    119          	/* Set timer enable clear bit to clear timer to 0 whenever
    120          	 * counter value equals the contents of RICOMPVAL
    121          	 */
    122          	RITx->RICTRL |= (1<<1);
   \   0000002A   0x7A20             LDRB     R0,[R4, #+8]
   \   0000002C   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000030   0x7220             STRB     R0,[R4, #+8]
    123          }
   \   00000032   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    124          
    125          
    126          /******************************************************************************//*
    127           * @brief 		Enable/Disable Timer
    128           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
    129           * @param[in]	NewState 	New State of this function
    130           * 					-ENABLE: Enable Timer
    131           * 					-DISABLE: Disable Timer
    132           * @return 		None
    133           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          void RIT_Cmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState)
    135          {
   \                     RIT_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    136          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000006   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD003             BEQ.N    ??RIT_Cmd_0
   \   0000000C   0x2188             MOVS     R1,#+136
   \   0000000E   0x....             LDR.N    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       check_failed
    137          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??RIT_Cmd_0: (+1)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD006             BEQ.N    ??RIT_Cmd_1
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD003             BEQ.N    ??RIT_Cmd_1
   \   00000020   0x2189             MOVS     R1,#+137
   \   00000022   0x....             LDR.N    R0,??DataTable5_1
   \   00000024   0x.... 0x....      BL       check_failed
    138          
    139          	//Enable or Disable Timer
    140          	if(NewState==ENABLE)
   \                     ??RIT_Cmd_1: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD104             BNE.N    ??RIT_Cmd_2
    141          	{
    142          		RITx->RICTRL |= RIT_CTRL_TEN;
   \   0000002E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000030   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000034   0x7220             STRB     R0,[R4, #+8]
   \   00000036   0xE003             B.N      ??RIT_Cmd_3
    143          	}
    144          	else
    145          	{
    146          		RITx->RICTRL &= ~RIT_CTRL_TEN;
   \                     ??RIT_Cmd_2: (+1)
   \   00000038   0x7A20             LDRB     R0,[R4, #+8]
   \   0000003A   0xF010 0x00F7      ANDS     R0,R0,#0xF7
   \   0000003E   0x7220             STRB     R0,[R4, #+8]
    147          	}
    148          }
   \                     ??RIT_Cmd_3: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    149          
    150          /******************************************************************************//*
    151           * @brief 		Timer Enable/Disable on debug
    152           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
    153           * @param[in]	NewState 	New State of this function
    154           * 					-ENABLE: The timer is halted whenever a hardware break condition occurs
    155           * 					-DISABLE: Hardware break has no effect on the timer operation
    156           * @return 		None
    157           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    158          void RIT_TimerDebugCmd(LPC_RIT_TypeDef *RITx, FunctionalState NewState)
    159          {
   \                     RIT_TimerDebugCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    160          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000006   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD003             BEQ.N    ??RIT_TimerDebugCmd_0
   \   0000000C   0x21A0             MOVS     R1,#+160
   \   0000000E   0x....             LDR.N    R0,??DataTable5_1
   \   00000010   0x.... 0x....      BL       check_failed
    161          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??RIT_TimerDebugCmd_0: (+1)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD006             BEQ.N    ??RIT_TimerDebugCmd_1
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D01             CMP      R5,#+1
   \   0000001E   0xD003             BEQ.N    ??RIT_TimerDebugCmd_1
   \   00000020   0x21A1             MOVS     R1,#+161
   \   00000022   0x....             LDR.N    R0,??DataTable5_1
   \   00000024   0x.... 0x....      BL       check_failed
    162          
    163          	//Timer Enable/Disable on break
    164          	if(NewState==ENABLE)
   \                     ??RIT_TimerDebugCmd_1: (+1)
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x2D01             CMP      R5,#+1
   \   0000002C   0xD104             BNE.N    ??RIT_TimerDebugCmd_2
    165          	{
    166          		RITx->RICTRL |= RIT_CTRL_ENBR;
   \   0000002E   0x7A20             LDRB     R0,[R4, #+8]
   \   00000030   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000034   0x7220             STRB     R0,[R4, #+8]
   \   00000036   0xE003             B.N      ??RIT_TimerDebugCmd_3
    167          	}
    168          	else
    169          	{
    170          		RITx->RICTRL &= ~RIT_CTRL_ENBR;
   \                     ??RIT_TimerDebugCmd_2: (+1)
   \   00000038   0x7A20             LDRB     R0,[R4, #+8]
   \   0000003A   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   0000003E   0x7220             STRB     R0,[R4, #+8]
    171          	}
    172          }
   \                     ??RIT_TimerDebugCmd_3: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    173          /******************************************************************************//*
    174           * @brief 		Check whether interrupt flag is set or not
    175           * @param[in]	RITx is RIT peripheral selected, should be: LPC_RIT
    176           * @return 		Current interrupt status, could be: SET/RESET
    177           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    178          IntStatus RIT_GetIntStatus(LPC_RIT_TypeDef *RITx)
    179          {
   \                     RIT_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    180          	IntStatus result;
    181          	CHECK_PARAM(PARAM_RITx(RITx));
   \   00000004   0x....             LDR.N    R0,??DataTable5  ;; 0x400b0000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD003             BEQ.N    ??RIT_GetIntStatus_0
   \   0000000A   0x21B5             MOVS     R1,#+181
   \   0000000C   0x....             LDR.N    R0,??DataTable5_1
   \   0000000E   0x.... 0x....      BL       check_failed
    182          	if((RITx->RICTRL&RIT_CTRL_INTEN)==1)	result= SET;
   \                     ??RIT_GetIntStatus_0: (+1)
   \   00000012   0x7A20             LDRB     R0,[R4, #+8]
   \   00000014   0x07C0             LSLS     R0,R0,#+31
   \   00000016   0xD508             BPL.N    ??RIT_GetIntStatus_1
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x0005             MOVS     R5,R0
    183          	else return RESET;
    184          	//clear interrupt flag
    185          	RITx->RICTRL |= RIT_CTRL_INTEN;
   \   0000001C   0x7A20             LDRB     R0,[R4, #+8]
   \   0000001E   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000022   0x7220             STRB     R0,[R4, #+8]
    186          	return result;
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE000             B.N      ??RIT_GetIntStatus_2
   \                     ??RIT_GetIntStatus_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \                     ??RIT_GetIntStatus_2: (+1)
   \   0000002C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    187          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x400B0000         DC32     0x400b0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0xCD          DC8 30H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H, 0BFH
   \              0xB3 0xBC    
   \              0xC6 0xC4    
   \              0xA3 0xBF    
   \   00000018   0xE9 0x5C          DC8 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000020   0x72 0x65          DC8 72H, 65H, 5CH, 43H, 53H, 42H, 5CH, 73H
   \              0x5C 0x43    
   \              0x53 0x42    
   \              0x5C 0x73    
   \   00000028   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH, 70H
   \              0x72 0x63    
   \              0x65 0x5C    
   \              0x6C 0x70    
   \   00000030   0x63 0x31          DC8 63H, 31H, 37H, 78H, 78H, 5FH, 72H, 69H
   \              0x37 0x78    
   \              0x78 0x5F    
   \              0x72 0x69    
   \   00000038   0x74 0x2E          DC8 74H, 2EH, 63H, 0
   \              0x63 0x00    
    188          
    189          /**
    190           * @}
    191           */
    192          
    193          #endif /* _RIT */
    194          
    195          /**
    196           * @}
    197           */
    198          
    199          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   RIT_Cmd
        16   -> check_failed
       8   RIT_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      16   RIT_GetIntStatus
        16   -> check_failed
       8   RIT_Init
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      24   RIT_TimerConfig
        24   -> CLKPWR_GetPCLK
        24   -> check_failed
      16   RIT_TimerDebugCmd
        16   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
      60  ?_0
      66  RIT_Cmd
      48  RIT_DeInit
      46  RIT_GetIntStatus
      48  RIT_Init
      52  RIT_TimerConfig
      66  RIT_TimerDebugCmd

 
  60 bytes in section .rodata
 334 bytes in section .text
 
 334 bytes of CODE  memory
  60 bytes of CONST memory

Errors: none
Warnings: none
