###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Aug/2017  16:25:17
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Cfg\Template\MB_DATA.C
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Cfg\Template\MB_DATA.C -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MB_DATA.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MB_DATA.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-MB\Cfg\Template\MB_DATA.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                         uC/MODBUS TARGET SPECIFIC DATA ACCESS FUNCTIONS (Template)
     19          *
     20          * Filename      : mb_data.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          
     28          
     29          #include <mb.h>
     30          #include <os.h>
     31          #include <app.h>
     32          //#include <bsp_time.h>
     33          //#include <bsp_eeprom.h>
     34          #include <includes.h>
     35          #include <global.h>
     36          
     37          /*******************************************************************************
     38          * 名    称： exchangeBytes
     39          * 功    能： 模拟的htons 或者 ntohs，如果系统支字节序更改可直接替换成系统函数
     40          * 入口参数： value
     41          * 出口参数： 更改过字节序的short数值
     42          * 作　 　者： 无名沈.
     43          * 创建日期： 2015-06-25
     44          * 修    改：
     45          * 修改日期：
     46          * 备    注：
     47          *******************************************************************************/
     48          //int16_t	exchangeBytes(int16_t	value)
     49          //{
     50          //	int16_t		tmp_value;
     51          //	uint8_t		*index_1, *index_2;
     52          //
     53          //	index_1 = (uint8_t *)&tmp_value;
     54          //	index_2 = (uint8_t *)&value;
     55          //
     56          //	*index_1 = *(index_2+1);
     57          //	*(index_1+1) = *index_2;
     58          //
     59          //	return tmp_value;
     60          //}
     61          
     62          #if MODBUS_CFG_SLAVE_EN == DEF_ENABLED

   \                                 In section .data, align 4
     63          StrMbData   mbData  = {MB_DATA_NBR_REGS, MB_DATA_NBR_COILS, 0,0,0};
   \                     mbData:
   \   00000000   0x007D 0x0020      DC16 125, 32
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000088   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000B8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000C8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000D8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000E8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000F8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     64          #endif
     65          /*$PAGE*/
     66          /*
     67          *********************************************************************************************************
     68          *                                     GET THE VALUE OF A SINGLE COIL
     69          *
     70          * Description: This function returns the value of a single coil.
     71          *              It is called by 'MBS_FC01_CoilRd()'.
     72          *              You must 'map' the 'coil' to the actual application's coil.
     73          *
     74          * Arguments  : coil     is the coil number that is being requested.
     75          *
     76          *              perr     is a pointer to an error code variable.  You must either return:
     77          *
     78          *                       MODBUS_ERR_NONE     the specified coil is valid and you are returning its value.
     79          *                       MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
     80          *                                           application (i.e. product).  YOUR product defines what the
     81          *                                           valid range of values is for the 'coil' argument.
     82          *
     83          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
     84          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
     85          *                 coils in your product.
     86          *********************************************************************************************************
     87          */
     88          
     89          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
     90          CPU_BOOLEAN  MB_CoilRd (CPU_INT16U   coil,
     91                                  CPU_INT16U  *perr)
     92          {
   \                     MB_CoilRd: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
     93              /***********************************************
     94              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
     95              */
     96          //    if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
     97              if ( sCtrl.Password != MB_DATA_ACC_PASSWORD ) {
   \   00000004   0x....             LDR.N    R0,??DataTable3
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0xF641 0x035D      MOVW     R3,#+6237
   \   0000000C   0x4298             CMP      R0,R3
   \   0000000E   0xD003             BEQ.N    ??MB_CoilRd_0
     98                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x8008             STRH     R0,[R1, #+0]
     99                  return 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE01E             B.N      ??MB_CoilRd_1
    100              }
    101              
    102              CPU_BOOLEAN     coil_val;
    103              CPU_INT16U      reg         = coil / 16;        // 获取当前寄存器
   \                     ??MB_CoilRd_0: (+1)
   \   00000018   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001A   0x2310             MOVS     R3,#+16
   \   0000001C   0xFB92 0xF3F3      SDIV     R3,R2,R3
    104              CPU_INT08U      bit         = coil % 16;        // 获取当前寄存器的位
   \   00000020   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000022   0x2510             MOVS     R5,#+16
   \   00000024   0xFB92 0xF4F5      SDIV     R4,R2,R5
   \   00000028   0xFB04 0x2415      MLS      R4,R4,R5,R2
    105              CPU_INT16U      reg_val;
    106              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
    107              //CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    108              
    109              CPU_INT16U *preg       = (CPU_INT16U *)& sCtrl;
   \   0000002C   0x....             LDR.N    R6,??DataTable3
    110              /***********************************************
    111              * 描述： 获取值
    112              */
    113              if ( reg < sizeof(sCtrl) / 2 ) {
   \   0000002E   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000030   0xF5B3 0x7F62      CMP      R3,#+904
   \   00000034   0xD806             BHI.N    ??MB_CoilRd_2
    114                  reg_val = preg[reg];
   \   00000036   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000038   0xF836 0x7013      LDRH     R7,[R6, R3, LSL #+1]
   \   0000003C   0x003D             MOVS     R5,R7
    115                  *perr = MODBUS_ERR_NONE;
   \   0000003E   0x2700             MOVS     R7,#+0
   \   00000040   0x800F             STRH     R7,[R1, #+0]
   \   00000042   0xE003             B.N      ??MB_CoilRd_3
    116              } else {
    117                  reg_val = 0;
   \                     ??MB_CoilRd_2: (+1)
   \   00000044   0x2700             MOVS     R7,#+0
   \   00000046   0x003D             MOVS     R5,R7
    118                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000048   0x2702             MOVS     R7,#+2
   \   0000004A   0x800F             STRH     R7,[R1, #+0]
    119              }
    120                  
    121              /***********************************************
    122              * 描述： 获取当前位的值
    123              */
    124              coil_val    = (CPU_BOOLEAN)(reg_val & ( 1 << bit ) );
   \                     ??MB_CoilRd_3: (+1)
   \   0000004C   0x2701             MOVS     R7,#+1
   \   0000004E   0x40A7             LSLS     R7,R7,R4
   \   00000050   0x402F             ANDS     R7,R7,R5
   \   00000052   0x0038             MOVS     R0,R7
    125          
    126              return (coil_val);
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MB_CoilRd_1: (+1)
   \   00000056   0xBCF0             POP      {R4-R7}
   \   00000058   0x4770             BX       LR               ;; return
    127          }
    128          #endif
    129          
    130          /*
    131          *********************************************************************************************************
    132          *                                     SET THE VALUE OF A SINGLE COIL
    133          *
    134          * Description: This function changes the value of a single coil.
    135          *              It is called by 'MBS_FC05_CoilWr()' and 'MBS_FC15_CoilWrMultiple()'.
    136          *              You must 'map' the 'coil' to the actual application's coil.
    137          *
    138          * Arguments  : coil      is the coil number that needs to be changed.
    139          *
    140          *              coil_val  is the desired value of the coil.  This value can be either DEF_TRUE or DEF_FALSE with
    141          *                        DEF_TRUE indicating an energized coil.
    142          *
    143          *              perr      is a pointer to an error code variable.  You must either return:
    144          *
    145          *                        MODBUS_ERR_NONE     the specified coil is valid and your code changed the value
    146          *                                            of the coil.
    147          *                        MODBUS_ERR_RANGE    the specified coil is an invalid coil number in your
    148          *                                            application (i.e. product).  YOUR product defines what the
    149          *                                            valid range of values is for the 'coil' argument.
    150          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    151          *
    152          * Note(s)    : 1) You can perform the mapping of coil number to application coils directly in this
    153          *                 function or via a table lookup.  A table lookup would make sense if you had a lot of
    154          *                 coils in your product.
    155          *********************************************************************************************************
    156          */
    157          
    158          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED) || \
    159              (MODBUS_CFG_FC15_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    160          void  MB_CoilWr (CPU_INT16U    coil,
    161                           CPU_BOOLEAN   coil_val,
    162                           CPU_INT16U   *perr)
    163          {
   \                     MB_CoilWr: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
    164              /***********************************************
    165              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    166              */
    167          //    if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
    168              if ( sCtrl.Password != MB_DATA_ACC_PASSWORD ) {
   \   0000000C   0x....             LDR.N    R0,??DataTable3
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0xF641 0x015D      MOVW     R1,#+6237
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD002             BEQ.N    ??MB_CoilWr_0
    169                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x8030             STRH     R0,[R6, #+0]
    170                  return;
   \   0000001C   0xE043             B.N      ??MB_CoilWr_1
    171              }
    172              
    173              (void)coil;
    174              (void)coil_val;
    175              CPU_SR          cpu_sr;
    176              CPU_INT16U      reg         = coil / 16;
   \                     ??MB_CoilWr_0: (+1)
   \   0000001E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0xFB94 0xF7F0      SDIV     R7,R4,R0
    177              CPU_INT08U      bit         = coil % 16;
   \   00000026   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   0x2010             MOVS     R0,#+16
   \   0000002A   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   0000002E   0xFB01 0x4110      MLS      R1,R1,R0,R4
   \   00000032   0xF88D 0x1000      STRB     R1,[SP, #+0]
    178              CPU_INT16U      reg_val     = 0;
   \   00000036   0xF05F 0x0900      MOVS     R9,#+0
    179              CPU_INT16U      temp;
    180          
    181              /***********************************************
    182              * 描述： 获取当前位
    183              */
    184              reg_val         |= coil_val << bit;
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000040   0xFA15 0xF000      LSLS     R0,R5,R0
   \   00000044   0xEA50 0x0909      ORRS     R9,R0,R9
    185              
    186              //CPU_INT16U      *preg       = (CPU_INT16U *) Ctrl.Para.buf2;
    187              CPU_INT16U *preg       = (CPU_INT16U *)& sCtrl; //首地址
   \   00000048   0x.... 0x....      LDR.W    R10,??DataTable3
    188              /***********************************************
    189              * 描述： 获取值
    190              */
    191              if ( reg < sizeof(sCtrl) / 2 ) {
   \   0000004C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004E   0xF5B7 0x7F62      CMP      R7,#+904
   \   00000052   0xD824             BHI.N    ??MB_CoilWr_2
    192                  /***********************************************
    193                  * 描述：
    194                  */
    195                  if ( reg < 127 ) {
   \   00000054   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000056   0x2F7F             CMP      R7,#+127
   \   00000058   0xDA1E             BGE.N    ??MB_CoilWr_3
    196                      int idx = reg - 0;
   \   0000005A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000005C   0x46BB             MOV      R11,R7
    197                      
    198                      CPU_CRITICAL_ENTER();
   \   0000005E   0x.... 0x....      BL       CPU_SR_Save
   \   00000062   0x9001             STR      R0,[SP, #+4]
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStart
    199                      temp          = preg[idx];
   \   00000068   0xF83A 0x001B      LDRH     R0,[R10, R11, LSL #+1]
   \   0000006C   0x4680             MOV      R8,R0
    200                      ( reg_val )   ? ( reg_val = reg_val | temp )
    201                          : ( reg_val =~reg_val & temp );
   \   0000006E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000072   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000076   0xD004             BEQ.N    ??MB_CoilWr_4
   \   00000078   0xEA58 0x0909      ORRS     R9,R8,R9
   \   0000007C   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000080   0xE003             B.N      ??MB_CoilWr_5
   \                     ??MB_CoilWr_4: (+1)
   \   00000082   0xEA38 0x0909      BICS     R9,R8,R9
   \   00000086   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
    202                          preg[idx]       = reg_val;
   \                     ??MB_CoilWr_5: (+1)
   \   0000008A   0xF82A 0x901B      STRH     R9,[R10, R11, LSL #+1]
    203                          CPU_CRITICAL_EXIT();
   \   0000008E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000092   0x9801             LDR      R0,[SP, #+4]
   \   00000094   0x.... 0x....      BL       CPU_SR_Restore
    204                  }
    205                  *perr = MODBUS_ERR_NONE;
   \                     ??MB_CoilWr_3: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x8030             STRH     R0,[R6, #+0]
   \   0000009C   0xE003             B.N      ??MB_CoilWr_6
    206              } else {
    207                  reg_val = 0;
   \                     ??MB_CoilWr_2: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4681             MOV      R9,R0
    208                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   000000A2   0x2002             MOVS     R0,#+2
   \   000000A4   0x8030             STRH     R0,[R6, #+0]
    209              }
    210          }
   \                     ??MB_CoilWr_6: (+1)
   \                     ??MB_CoilWr_1: (+1)
   \   000000A6   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
    211          #endif
    212          
    213          /*$PAGE*/
    214          /*
    215          *********************************************************************************************************
    216          *                                GET THE VALUE OF A SINGLE DISCRETE INPUT
    217          *
    218          * Description: This function reads the value of a single DI (DI means Discrete Input).
    219          *              It is called by 'MBS_FC02_DIRd()'.
    220          *              You must 'map' the 'di'  to the actual application's DI.
    221          *
    222          * Arguments  : di        is the Discrete Input number that needs to be read.
    223          *
    224          *              perr      is a pointer to an error code variable.  You must either return:
    225          *
    226          *                        MODBUS_ERR_NONE     the specified DI is valid and your code is returning its
    227          *                                            current value.
    228          *                        MODBUS_ERR_RANGE    the specified DI is an invalid Discrete Input number in your
    229          *                                            application (i.e. product).  YOUR product defines what the
    230          *                                            valid range of values is for the 'di' argument.
    231          *
    232          * Note(s)    : 1) You can perform the mapping of DI number to the application DIs directly in this function
    233          *                 or via a table lookup.  A table lookup would make sense if you had a lot of Discrete
    234          *                 Inputs in your product.
    235          *********************************************************************************************************
    236          */
    237          
    238          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    239          CPU_BOOLEAN  MB_DIRd (CPU_INT16U   di,
    240                                CPU_INT16U  *perr)
    241          {
    242              (void)di;
    243              *perr = MODBUS_ERR_NONE;
    244              return (DEF_FALSE);
    245          }
    246          #endif
    247          
    248          /*$PAGE*/
    249          /*
    250          *********************************************************************************************************
    251          *                               GET THE VALUE OF A SINGLE INPUT REGISTER
    252          *
    253          * Description: This function reads the value of a single Input Register.
    254          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is BELOW the value set by
    255          *              the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    256          *              You must 'map' the Input Register to the actual application's corresponding integer register.
    257          *
    258          * Arguments  : reg       is the Input Register number that needs to be read.
    259          *
    260          *              perr      is a pointer to an error code variable.  You must either return:
    261          *
    262          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    263          *                                            returning its current value.
    264          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    265          *                                            application (i.e. product).  YOUR product defines what the
    266          *                                            valid range of values is for the 'reg' argument.
    267          *
    268          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    269          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    270          *                 had a lot of Input Registers in your product.
    271          *              2) If your product doesn't have input registers, you could simply set '*err' to
    272          *                 MODBUS_ERR_NONE and return 0.
    273          *********************************************************************************************************
    274          */
    275          
    276          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    277          CPU_INT16U  MB_InRegRd (CPU_INT16U   reg,
    278                                  CPU_INT16U  *perr)
    279          {
    280              CPU_INT16U  val;
    281              CPU_SR      cpu_sr;
    282          
    283          
    284              switch (reg) {
    285                  case 10:
    286                       CPU_CRITICAL_ENTER();
    287                       val = (CPU_INT16U)OSCPUUsage;
    288                       CPU_CRITICAL_EXIT();
    289                       break;
    290          
    291                  case 11:
    292                       CPU_CRITICAL_ENTER();
    293                       val = (CPU_INT16U)OSCtxSwCtr;
    294                       CPU_CRITICAL_EXIT();
    295                       break;
    296          
    297                  case 12:
    298                       CPU_CRITICAL_ENTER();
    299                       val = (CPU_INT16U)(OSTime >> 16);
    300                       CPU_CRITICAL_EXIT();
    301                       break;
    302          
    303                  case 13:
    304                       CPU_CRITICAL_ENTER();
    305                       val = (CPU_INT16U)(OSTime & 0x0000FFFF);
    306                       CPU_CRITICAL_EXIT();
    307                       break;
    308          
    309                  case 14:
    310                       CPU_CRITICAL_ENTER();
    311                       val = (CPU_INT16U)MB_ChSize;
    312                       CPU_CRITICAL_EXIT();
    313                       break;
    314          
    315                  case 15:
    316                       CPU_CRITICAL_ENTER();
    317                       val = (CPU_INT16U)(MB_TotalRAMSize & 0x0000FFFF);
    318                       CPU_CRITICAL_EXIT();
    319                       break;
    320          
    321                  default:
    322                       val = 0;
    323                       break;
    324              }
    325              *perr = MODBUS_ERR_NONE;
    326              return (val);
    327          }
    328          #endif
    329          
    330          /*
    331          *********************************************************************************************************
    332          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' INPUT REGISTER
    333          *
    334          * Description: This function reads the value of a single Input Register.
    335          *              It is called by 'MBS_FC04_InRegRd()' when the argument 'reg' is ABOVE or equal to the
    336          *              value set the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    337          *              You must 'map' the Input Register to the actual application's corresponding floating-point
    338          *              register.
    339          *
    340          * Arguments  : reg       is the Input Register number that needs to be read.
    341          *
    342          *              perr      is a pointer to an error code variable.  You must either return:
    343          *
    344          *                        MODBUS_ERR_NONE     the specified input register is valid and your code is
    345          *                                            returning its current value.
    346          *                        MODBUS_ERR_RANGE    the specified input register is an invalid number in your
    347          *                                            application (i.e. product).  YOUR product defines what the
    348          *                                            valid range of values is for the 'reg' argument.
    349          *
    350          * Note(s)    : 1) You can perform the mapping of input register number to the application's input registers
    351          *                 directly in this function or via a table lookup.  A table lookup would make sense if you
    352          *                 had a lot of Input Registers in your product.
    353          *              2) If your product doesn't have input registers, you could simply set '*err' to
    354          *                 MODBUS_ERR_NONE and return (CPU_FP32)0.
    355          *********************************************************************************************************
    356          */
    357          
    358          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    359          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    360          CPU_FP32  MB_InRegRdFP (CPU_INT16U   reg,
    361                                  CPU_INT16U  *perr)
    362          {
    363              (void)reg;
    364              *perr = MODBUS_ERR_NONE;
    365              return ((CPU_FP32)0);
    366          }
    367          #endif
    368          #endif
    369          
    370          /*$PAGE*/
    371          /*
    372          *********************************************************************************************************
    373          *                             GET THE VALUE OF A SINGLE HOLDING REGISTER
    374          *
    375          * Description: This function reads the value of a single Holding Register.
    376          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is BELOW the value set
    377          *              by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    378          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    379          *
    380          * Arguments  : reg       is the Holding Register number that needs to be read.
    381          *
    382          *              perr      is a pointer to an error code variable.  You must either return:
    383          *
    384          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    385          *                                            returning its current value.
    386          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    387          *                                            application (i.e. product).  YOUR product defines what the
    388          *                                            valid range of values is for the 'reg' argument.
    389          *
    390          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    391          *                 registers directly in this function or via a table lookup.  A table lookup would make
    392          *                 sense if you had a lot of Holding Registers in your product.
    393          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    394          *                 MODBUS_ERR_NONE and return 0.
    395          *********************************************************************************************************
    396          */
    397          
    398          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    399          CPU_INT16U  MB_HoldingRegRd (CPU_INT16U   reg,
    400                                       CPU_INT16U  *perr)
    401          {
   \                     MB_HoldingRegRd: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    402              CPU_INT16U  reg_val;
    403              CPU_SR      cpu_sr;
    404          
    405              /***********************************************
    406              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    407              */
    408          //    if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
    409              if ( sCtrl.Password != MB_DATA_ACC_PASSWORD ) {
   \   00000008   0x....             LDR.N    R0,??DataTable3
   \   0000000A   0x8800             LDRH     R0,[R0, #+0]
   \   0000000C   0xF641 0x015D      MOVW     R1,#+6237
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD003             BEQ.N    ??MB_HoldingRegRd_0
    410                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x8028             STRH     R0,[R5, #+0]
    411                  return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE01C             B.N      ??MB_HoldingRegRd_1
    412              }
    413                  
    414          //    CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    415              CPU_INT16U *preg       = (CPU_INT16U *)&sCtrl;
   \                     ??MB_HoldingRegRd_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R8,??DataTable3
    416              /***********************************************
    417              * 描述： 获取值
    418              */
    419              if ( reg < sizeof(sCtrl) / 2 ) {
   \   00000020   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000022   0xF5B4 0x7F62      CMP      R4,#+904
   \   00000026   0xD810             BHI.N    ??MB_HoldingRegRd_2
    420                  CPU_CRITICAL_ENTER();
   \   00000028   0x.... 0x....      BL       CPU_SR_Save
   \   0000002C   0x0007             MOVS     R7,R0
   \   0000002E   0x.... 0x....      BL       CPU_IntDisMeasStart
    421                  reg_val = preg[reg];
   \   00000032   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000034   0xF838 0x0014      LDRH     R0,[R8, R4, LSL #+1]
   \   00000038   0x0006             MOVS     R6,R0
    422                  CPU_CRITICAL_EXIT();
   \   0000003A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       CPU_SR_Restore
    423                  *perr = MODBUS_ERR_NONE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x8028             STRH     R0,[R5, #+0]
   \   00000048   0xE003             B.N      ??MB_HoldingRegRd_3
    424              } else {
    425                  reg_val = 0;
   \                     ??MB_HoldingRegRd_2: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x0006             MOVS     R6,R0
    426                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0x8028             STRH     R0,[R5, #+0]
    427              }
    428              
    429              return (reg_val);
   \                     ??MB_HoldingRegRd_3: (+1)
   \   00000052   0x0030             MOVS     R0,R6
   \   00000054   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \                     ??MB_HoldingRegRd_1: (+1)
   \   00000056   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    430          }
    431          #endif
    432          
    433          /*$PAGE*/
    434          /*
    435          *********************************************************************************************************
    436          *                     GET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    437          *
    438          * Description: This function reads the value of a single Floating-Point Holding Register.
    439          *              It is called by 'MBS_FC03_HoldingRegRd()' when the argument 'reg' is ABOVE or equal to the
    440          *              value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    441          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    442          *              register.
    443          *
    444          * Arguments  : reg       is the Holding Register number that needs to be read.
    445          *
    446          *              perr      is a pointer to an error code variable.  You must either return:
    447          *
    448          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    449          *                                            returning its current value.
    450          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    451          *                                            application (i.e. product).  YOUR product defines what the
    452          *                                            valid range of values is for the 'reg' argument.
    453          *
    454          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    455          *                 registers directly in this function or via a table lookup.  A table lookup would make
    456          *                 sense if you had a lot of Holding Registers in your product.
    457          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    458          *                 MODBUS_ERR_NONE and return 0.
    459          *********************************************************************************************************
    460          */
    461          
    462          #if (MODBUS_CFG_FP_EN   == DEF_ENABLED)
    463          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    464          CPU_FP32  MB_HoldingRegRdFP (CPU_INT16U   reg,
    465                                       CPU_INT16U  *perr)
    466          {
    467              (void)reg;    
    468              
    469              /***********************************************
    470              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    471              */
    472          //    if ( Ctrl.Para.dat.Password != MB_DATA_ACC_PASSWORD ) {
    473              if ( sCtrl.Password != MB_DATA_ACC_PASSWORD ) {
    474                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    475                  return 0;
    476              }
    477              /***********************************************
    478              * 描述： 浮点寄存器
    479              */
    480          //    CPU_FP32   *preg        = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    481              CPU_FP32   *preg        = (CPU_FP32 *)&sCtrl;   //取首地址
    482              
    483              reg        = reg - MODBUS_CFG_FP_START_IX;
    484              CPU_FP32   reg_val      = 0;
    485              
    486              /***********************************************
    487              * 描述： 获取值
    488              */
    489              if ( reg < sizeof(UnionSenPara) / 4 ) {
    490                  preg    += reg;
    491                  CPU_SR_ALLOC();
    492                  CPU_CRITICAL_ENTER();
    493                  reg_val     = *preg;
    494                  CPU_CRITICAL_EXIT();
    495                  *perr = MODBUS_ERR_NONE;
    496              } else {
    497                  *perr = MODBUS_ERR_RANGE;
    498              }
    499              
    500              return ((CPU_FP32)reg_val);
    501          }
    502          #endif
    503          #endif
    504          
    505          /*$PAGE*/
    506          /*
    507          *********************************************************************************************************
    508          *                            SET THE VALUE OF A SINGLE HOLDING REGISTER
    509          *
    510          * Description: This function is called to change the value of a single Integer Holding Register.
    511          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    512          *              'reg' is BELOW to the value set by the configuration constant MODBUS_CFG_FP_START_IX (see MB_CFG.H).
    513          *              You must 'map' the Holding Register to the actual application's corresponding integer register.
    514          *
    515          * Arguments  : reg       is the Holding Register number that needs to be read.
    516          *
    517          *              reg_val   is the desired value of the holding register.
    518          *                        The value is specified as an unsigned integer even though it could actually be
    519          *                        represented by a signed integer.
    520          *
    521          *              perr      is a pointer to an error code variable.  You must either return:
    522          *
    523          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    524          *                                            returning its current value.
    525          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    526          *                                            application (i.e. product).  YOUR product defines what the
    527          *                                            valid range of values is for the 'reg' argument.
    528          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    529          *
    530          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    531          *                 registers directly in this function or via a table lookup.  A table lookup would make
    532          *                 sense if you had a lot of Holding Registers in your product.
    533          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    534          *                 MODBUS_ERR_NONE and return 0.
    535          *********************************************************************************************************
    536          */
    537          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    538              (MODBUS_CFG_FC16_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    539          void  MB_HoldingRegWr (CPU_INT16U   reg,
    540                                 CPU_INT16U   reg_val,
    541                                 CPU_INT16U  *perr)
    542          {
   \                     MB_HoldingRegWr: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    543              /* Access to your variable here! */
    544              (void)reg;
    545              (void)reg_val;
    546              
    547              /***********************************************
    548              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    549              */
    550          //    if ( ( Ctrl.Para.dat.Password == MB_DATA_ACC_PASSWORD ) ||
    551              if((sCtrl.Password == MB_DATA_ACC_PASSWORD) ||    
    552                   ( ( reg == 0 ) && ( reg_val == MB_DATA_ACC_PASSWORD ) ) ) {
   \   0000000A   0x....             LDR.N    R0,??DataTable3
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0xF641 0x015D      MOVW     R1,#+6237
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD007             BEQ.N    ??MB_HoldingRegWr_0
   \   00000016   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD10A             BNE.N    ??MB_HoldingRegWr_1
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0xF641 0x005D      MOVW     R0,#+6237
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xD105             BNE.N    ??MB_HoldingRegWr_1
    553              } else {
    554                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    555                  return;
    556              }
    557          
    558          //    CPU_INT16U *preg       = (CPU_INT16U *)& Ctrl.Para.buf2[0];
    559              CPU_INT16U *preg       = (CPU_INT16U *)&sCtrl;             //取首地址
   \                     ??MB_HoldingRegWr_0: (+1)
   \   00000026   0x....             LDR.N    R7,??DataTable3
    560              
    561              /***********************************************
    562              * 描述： 在指定地址写入数据
    563              */
    564              if ( reg < sizeof(sCtrl) / 2 ) {
   \   00000028   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000002A   0xF5B4 0x7F62      CMP      R4,#+904
   \   0000002E   0xD816             BHI.N    ??MB_HoldingRegWr_2
   \   00000030   0xE002             B.N      ??MB_HoldingRegWr_3
   \                     ??MB_HoldingRegWr_1: (+1)
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x8030             STRH     R0,[R6, #+0]
   \   00000036   0xE014             B.N      ??MB_HoldingRegWr_4
    565                  preg    += reg;
   \                     ??MB_HoldingRegWr_3: (+1)
   \   00000038   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003A   0xEB17 0x0744      ADDS     R7,R7,R4, LSL #+1
    566                  /***********************************************
    567                  * 描述： 写入测量模块校准参数
    568                  */    
    569                  CPU_SR_ALLOC();
   \   0000003E   0xF05F 0x0800      MOVS     R8,#+0
    570                  CPU_CRITICAL_ENTER();
   \   00000042   0x.... 0x....      BL       CPU_SR_Save
   \   00000046   0x4680             MOV      R8,R0
   \   00000048   0x.... 0x....      BL       CPU_IntDisMeasStart
    571                  *preg       = reg_val;
   \   0000004C   0x803D             STRH     R5,[R7, #+0]
    572                  CPU_CRITICAL_EXIT();
   \   0000004E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x.... 0x....      BL       CPU_SR_Restore
    573                  
    574                  *perr = MODBUS_ERR_NONE;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x8030             STRH     R0,[R6, #+0]
   \   0000005C   0xE001             B.N      ??MB_HoldingRegWr_5
    575              } else {
    576                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
   \                     ??MB_HoldingRegWr_2: (+1)
   \   0000005E   0x2002             MOVS     R0,#+2
   \   00000060   0x8030             STRH     R0,[R6, #+0]
    577              }    
    578          }
   \                     ??MB_HoldingRegWr_5: (+1)
   \                     ??MB_HoldingRegWr_4: (+1)
   \   00000062   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    579          #endif
    580          
    581          /*$PAGE*/
    582          /*
    583          *********************************************************************************************************
    584          *                     SET THE VALUE OF A SINGLE 'FLOATING-POINT' HOLDING REGISTER
    585          *
    586          * Description: This function is called to change the value of a single Floating-Point Holding Register.
    587          *              It is called by 'MBS_FC06_HoldingRegWr()' and 'MBS_FC16_HoldingRegWrMultiple()' when the argument
    588          *              'reg' is ABOVE or equal to the value set by the configuration constant MODBUS_CFG_FP_START_IX
    589          *              (see MB_CFG.H).
    590          *              You must 'map' the Holding Register to the actual application's corresponding floating-point
    591          *              register.
    592          *
    593          * Arguments  : reg       is the Holding Register number that needs to be read.
    594          *
    595          *              reg_val   is the desired value of the holding register.
    596          *                        The value is specified as an unsigned integer even though it could actually be
    597          *                        represented by a signed integer.
    598          *
    599          *              perr      is a pointer to an error code variable.  You must either return:
    600          *
    601          *                        MODBUS_ERR_NONE     the specified holding register is valid and your code is
    602          *                                            returning its current value.
    603          *                        MODBUS_ERR_RANGE    the specified holding register is an invalid number in your
    604          *                                            application (i.e. product).  YOUR product defines what the
    605          *                                            valid range of values is for the 'reg' argument.
    606          *                        MODBUS_ERR_WR       if the device is not able to write or accept the value
    607          *
    608          * Note(s)    : 1) You can perform the mapping of holding register number to the application's holding
    609          *                 registers directly in this function or via a table lookup.  A table lookup would make
    610          *                 sense if you had a lot of Holding Registers in your product.
    611          *              2) If your product doesn't have holding registers, you could simply set '*err' to
    612          *                 MODBUS_ERR_NONE and return 0.
    613          *********************************************************************************************************
    614          */
    615          
    616          #if (MODBUS_CFG_FP_EN    == DEF_ENABLED)
    617          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED) || \
    618              (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    619          void  MB_HoldingRegWrFP (CPU_INT16U   reg,
    620                                   CPU_FP32     reg_val_fp,
    621                                   CPU_INT16U  *perr)
    622          {
    623              (void)reg;
    624              (void)reg_val_fp;
    625                  
    626              /***********************************************
    627              * 描述： 密码确认，通讯前先将MB_DATA_ACC_PASSWORD写入reg0
    628              */
    629              if ( sCtrl.Password  != MB_DATA_ACC_PASSWORD ) {
    630                  *perr = MODBUS_ERR_ILLEGAL_DATA_ADDR;
    631                  return;
    632              }
    633              
    634              /***********************************************
    635              * 描述： 浮点寄存器
    636              */
    637          //    CPU_FP32   *preg      = (CPU_FP32 *)&Ctrl.Sen.Para.buf3[0];
    638              CPU_FP32   *preg       = (CPU_FP32 *)&sCtrl;   //取首地址
    639          
    640              reg        = reg - MODBUS_CFG_FP_START_IX;
    641              /***********************************************
    642              * 描述： 获取值
    643              */
    644              if ( reg < sizeof(UnionSenPara) / 4 ) {
    645                  preg    += reg;
    646                  CPU_SR_ALLOC();
    647                  CPU_CRITICAL_ENTER();
    648                  *preg    = reg_val_fp;
    649                  CPU_CRITICAL_EXIT();
    650                  *perr = MODBUS_ERR_NONE;
    651              } else {
    652                  *perr = MODBUS_ERR_RANGE;
    653              }
    654          }
    655          #endif
    656          #endif
    657          
    658          /*$PAGE*/
    659          /*
    660          *********************************************************************************************************
    661          *                              GET A SINGLE ENTRY FROM A RECORD IN A FILE
    662          *
    663          * Description: This function is called to read a single integer from a file.
    664          *              As mentionned in the Modbus specifications, a file is an organization of records.
    665          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    666          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    667          *
    668          * Arguments  : file_nbr    is the number of the desired file.
    669          *
    670          *              record_nbr  is the desired record within the file
    671          *
    672          *              ix          is the desired entry in the specified record.
    673          *
    674          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    675          *                          this function to provide the 'requested' requested length from the MODBUS command.
    676          *
    677          *              perr        is a pointer to an error code variable.  You must either return:
    678          *
    679          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    680          *                                              returning its current value.
    681          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    682          *                                              your product.
    683          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    684          *                                              specified file.
    685          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    686          *                                              record.
    687          *
    688          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    689          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    690          *                 data in your files.
    691          *********************************************************************************************************
    692          */
    693          
    694          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    695          CPU_INT16U  MB_FileRd (CPU_INT16U   file_nbr,
    696                                 CPU_INT16U   record_nbr,
    697                                 CPU_INT16U   ix,
    698                                 CPU_INT08U   record_len,
    699                                 CPU_INT16U  *perr)
    700          {
   \                     MB_FileRd: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x9D02             LDR      R5,[SP, #+8]
    701              (void)file_nbr;
    702              (void)record_nbr;
    703              (void)ix;
    704              (void)record_len;
    705              *perr  = MODBUS_ERR_NONE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x8028             STRH     R0,[R5, #+0]
    706              return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBC30             POP      {R4,R5}
   \   0000000E   0x4770             BX       LR               ;; return
    707          }
    708          #endif
    709          
    710          /*$PAGE*/
    711          /*
    712          *********************************************************************************************************
    713          *                               SET A SINGLE ENTRY OF A RECORD IN A FILE
    714          *
    715          * Description: This function is called to change a single integer value in a file.
    716          *              As mentionned in the Modbus specifications, a file is an organization of records.
    717          *              Each file can contain up to 10,000 records (addressed from 0 to 9999).
    718          *              You must 'map' the File/Record/Ix to the actual application's corresponding data.
    719          *
    720          * Arguments  : file_nbr    is the number of the desired file.
    721          *
    722          *              record_nbr  is the desired record within the file
    723          *
    724          *              ix          is the desired entry in the specified record.
    725          *
    726          *              record_len  is the desired length of the record.  Note that this parameter is passed to
    727          *                          this function to provide the 'requested' requested length from the MODBUS command.
    728          *
    729          *              val         is the new value to place in the file.
    730          *
    731          *              perr        is a pointer to an error code variable.  You must either return:
    732          *
    733          *                          MODBUS_ERR_NONE     the specified file/record/entry is valid and your code is
    734          *                                              returning its current value.
    735          *                          MODBUS_ERR_FILE     if the specified 'file_nbr' is not a valid file number in
    736          *                                              your product.
    737          *                          MODBUS_ERR_RECORD   if the specified 'record_nbr' is not a valid record in the
    738          *                                              specified file.
    739          *                          MODBUS_ERR_IX       if the specified 'ix' is not a valid index into the specified
    740          *                                              record.
    741          *
    742          * Note(s)    : 1) You can perform the mapping of file/record/ix to the application's data directly in
    743          *                 this function or via a table lookup.  A table lookup would make sense if you had a lot
    744          *                 data in your files.
    745          *********************************************************************************************************
    746          */
    747          
    748          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    749          void  MB_FileWr (CPU_INT16U   file_nbr,
    750                           CPU_INT16U   record_nbr,
    751                           CPU_INT16U   ix,
    752                           CPU_INT08U   record_len,
    753                           CPU_INT16U   val,
    754                           CPU_INT16U  *perr)
    755          {
   \                     MB_FileWr: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x9C03             LDR      R4,[SP, #+12]
    756              (void)file_nbr;
    757              (void)record_nbr;
    758              (void)ix;
    759              (void)record_len;
    760              (void)val;
    761              *perr = MODBUS_ERR_NONE;
   \   00000004   0x2500             MOVS     R5,#+0
   \   00000006   0x8025             STRH     R5,[R4, #+0]
    762          }
   \   00000008   0xBC30             POP      {R4,R5}
   \   0000000A   0x4770             BX       LR               ;; return
    763          #endif
    764          
    765          /***********************************************
    766          * 描述： 2015/12/07增加，用于非MODBBUS通信
    767          *        非MODBUS通信，带帧头帧尾的通信数据处理
    768          */
    769          #if MB_NONMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    770          CPU_BOOLEAN NON_MBS_FCxx_Handler (MODBUS_CH  *pch)
    771          {    
    772              /***********************************************
    773              * 描述： 调用串口数据处理回调函数
    774              */
    775          //    extern INT08U APP_CommRxDataDealCB(MODBUS_CH  *pch);
    776          //    
    777          //    return APP_CommRxDataDealCB(pch);
    778          }
   \                     NON_MBS_FCxx_Handler: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    779          #endif
    780          
    781          
    782          /***********************************************
    783          * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    784          */
    785          #if MB_IAPMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    786          CPU_BOOLEAN IAP_MBS_FCxx_Handler (MODBUS_CH  *pch)
    787          {    
   \                     IAP_MBS_FCxx_Handler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    788              /***********************************************
    789              * 描述： 调用串口数据处理回调函数
    790              */
    791              extern INT08U IAP_CommRxDataDealCB(MODBUS_CH  *pch);
    792              
    793              return IAP_CommRxDataDealCB(pch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       IAP_CommRxDataDealCB
   \   0000000A   0xBD10             POP      {R4,PC}          ;; return
    794          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     sCtrl
    795          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   IAP_MBS_FCxx_Handler
         8   -> IAP_CommRxDataDealCB
      16   MB_CoilRd
      48   MB_CoilWr
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
       8   MB_FileRd
       8   MB_FileWr
      24   MB_HoldingRegRd
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
      24   MB_HoldingRegWr
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
       0   NON_MBS_FCxx_Handler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
      12  IAP_MBS_FCxx_Handler
      90  MB_CoilRd
     170  MB_CoilWr
      16  MB_FileRd
      12  MB_FileWr
      90  MB_HoldingRegRd
     102  MB_HoldingRegWr
       2  NON_MBS_FCxx_Handler
     268  mbData

 
 268 bytes in section .data
 498 bytes in section .text
 
 498 bytes of CODE memory
 268 bytes of DATA memory

Errors: none
Warnings: 1
