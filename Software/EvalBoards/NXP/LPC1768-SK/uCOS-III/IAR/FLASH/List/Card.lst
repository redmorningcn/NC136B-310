###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/Aug/2017  10:56:44
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310 统计模块\Application\Library\CardOperations\Card.c
#    Command line =  
#        "F:\iar\NC136B-310 统计模块\Application\Library\CardOperations\Card.c"
#        -lCN "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -I "F:\iar\NC136B-310 统计模块\Application\Library\csnr_package_deal\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\Card.lst
#    Object file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\Card.o
#
###############################################################################

F:\iar\NC136B-310 统计模块\Application\Library\CardOperations\Card.c
      1          //#include 	"config.h"
      2          //#include 	"string.h"
      3          //#include 	"CpuDrive.h"
      4          //#include 	"HardDrive.h"
      5          
      6          #include    "includes.h"  
      7          #include    "card.h"  
      8          
      9          
     10          #define		SCK_IC	120//P004  
     11          #define		MISO_IC	123//P005  
     12          #define		MOSI_IC	124//P006 
     13          #define     SSEL0	7//P007
     14          
     15          #define		CS_IC	127//P228	
     16          #define		SOFT_SPI_CS_IC	CS_IC//P228	
     17          #define		POW_IC	211//P028
     18          
     19          #define		IC_SWT	200//P029
     20          #define		IC_RST	212//P230
     21          #define		FINISH		1
     22          #define		UNFINISH	0
     23          

   \                                 In section .bss, align 4
     24          uint32		l_Spi0Len 	= 0;
   \                     l_Spi0Len:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     25          uint32		l_Spi0Point = 0;
   \                     l_Spi0Point:
   \   00000000                      DS8 4
     26          //uint8_t		Spi0SendBuf[256*1];
     27          //uint8_t		Spi0RevBuf[256*1];

   \                                 In section .data, align 1
     28          uint8_t		Spi0FinishFlg = FINISH;
   \                     Spi0FinishFlg:
   \   00000000   0x01               DC8 1
     29          
     30          //------------------------------------------------------------------------
     31          //  名  称 ：void WriteSCK_IC( uint8_t temp )
     32          //  功  能 ：设置 SCK_IC
     33          // 入口参数：无
     34          // 出口参数：无
     35          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     36          void WriteSCK_IC(uint8_t temp)
     37          {	
   \                     WriteSCK_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     38          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSCK_IC_0
     39          	{
     40          		GPIO_SetOrClearValue(SCK_IC,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2078             MOVS     R0,#+120
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSCK_IC_1
     41          	}
     42          	else
     43          	{
     44          		GPIO_SetOrClearValue(SCK_IC,0);		
   \                     ??WriteSCK_IC_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2078             MOVS     R0,#+120
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
     45          	}	
     46          	nop();	
   \                     ??WriteSCK_IC_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
     47          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     48          
     49          //------------------------------------------------------------------------
     50          //  名  称 ：uint8_t ReadSCK_IC(void)
     51          //  功  能 ：读取 SCK_IC 的值
     52          // 入口参数：无
     53          // 出口参数：无
     54          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     55          uint8_t ReadSCK_IC(void)
     56          {
   \                     ReadSCK_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     57          	uint8_t temp;
     58          
     59          	temp = 	GPIO_ReadIoVal(SCK_IC);
   \   00000002   0x2078             MOVS     R0,#+120
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
     60          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
     61          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     62          }
     63          
     64          //------------------------------------------------------------------------
     65          //  名  称 ：void WriteMOSI_IC( uint8_t temp )
     66          //  功  能 ：设置 MOSI_IC
     67          // 入口参数：无
     68          // 出口参数：无
     69          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     70          void WriteMOSI_IC(uint8_t temp)
     71          {	
   \                     WriteMOSI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     72          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteMOSI_IC_0
     73          	{
     74          		GPIO_SetOrClearValue(MOSI_IC,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x207C             MOVS     R0,#+124
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteMOSI_IC_1
     75          	}
     76          	else
     77          	{
     78          		GPIO_SetOrClearValue(MOSI_IC,0);		
   \                     ??WriteMOSI_IC_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x207C             MOVS     R0,#+124
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
     79          	}	
     80          }
   \                     ??WriteMOSI_IC_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          //------------------------------------------------------------------------
     83          //  名  称 ：uint8_t ReadMOSI_IC(void)
     84          //  功  能 ：读取 MOSI_IC 的值
     85          // 入口参数：无
     86          // 出口参数：无
     87          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     88          uint8_t ReadMOSI_IC(void)
     89          {
   \                     ReadMOSI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     90          	uint8_t temp;
     91          	
     92          	temp = 	GPIO_ReadIoVal(MOSI_IC);
   \   00000002   0x207C             MOVS     R0,#+124
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
     93          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
     94          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     95          }
     96          
     97          //------------------------------------------------------------------------
     98          //  名  称 ：void WriteMOSI_IC( uint8_t temp )
     99          //  功  能 ：设置 MOSI_IC
    100          // 入口参数：无
    101          // 出口参数：无
    102          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    103          void WriteMISO_IC(uint8_t temp)
    104          {
   \                     WriteMISO_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    105          	
    106          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteMISO_IC_0
    107          	{
    108          		GPIO_SetOrClearValue(MISO_IC,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x207B             MOVS     R0,#+123
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteMISO_IC_1
    109          	}
    110          	else
    111          	{
    112          		GPIO_SetOrClearValue(MISO_IC,0);		
   \                     ??WriteMISO_IC_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x207B             MOVS     R0,#+123
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    113          	}
    114          		
    115          	nop();		
   \                     ??WriteMISO_IC_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    116          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    117          
    118          //void  SSP0_Init(void)
    119          //{
    120          // //   LPC_SC->PCONP |= (1 << 21);                                         /* 打开SSP0电源                 */
    121          //  
    122          ////    LPC_PINCON->PINSEL3 |= (0x03ul << 8);                              /* 设置管脚功能                 */
    123          ////    LPC_PINCON->PINSEL3 |= (0x03ul << 14)|(0x03 << 16);
    124          //   /* 
    125          //    * 设置数据长度为8位，帧格式SPI，SCK高有效，第一个时钟沿采样，位速率为默认值 
    126          //    */
    127          //    LPC_SSP0->CR0 = (0x01 << 8)                                         /* SCR  设置SPI时钟分频         */
    128          //                  | (0x01 << 7)                                         /* CPHA 时钟输出相位            */
    129          //                  | (0x01 << 6)                                         /* CPOL 时钟输出极性            */
    130          //                  | (0x00 << 4)                                         /* FRF  帧格式 00=SPI           */
    131          //                  | (0x07 << 0);                                        /* DSS  数据长度,0111=8位       */
    132          //
    133          //    LPC_SSP0->CR1 = (0x00 << 3)                                         /* SOD  从机输出禁能,0=允许     */
    134          //                  | (0x00 << 2)                                         /* MS   主从选择,0=主机,1=从机  */
    135          //                  | (0x01 << 1)                                         /* SSE  SSP使能                 */
    136          //                  | (0x00 << 0);                                        /* LBM  回写模式                */
    137          //    LPC_SSP0->CPSR = 0x52;                                              /* 设置SSP从PCLK获得的分频值,   */
    138          //                                                                        /* 主模式下有效, 最小值为0x02   */
    139          //}		
    140          

   \                                 In section .text, align 2, keep-with-next
    141          void SSP0_Init(void)
    142          {
   \                     SSP0_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    143          	SSP_CFG_Type SSP_ConfigStruct;
    144          
    145          	SSP_ConfigStructInit(&SSP_ConfigStruct);
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x.... 0x....      BL       SSP_ConfigStructInit
    146          	// Initialize SSP peripheral with parameter given in structure above
    147          	SSP_Init(LPC_SSP0, &SSP_ConfigStruct);
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40088000
   \   00000010   0x.... 0x....      BL       SSP_Init
    148          
    149          	// Enable SSP peripheral
    150          	SSP_Cmd(LPC_SSP0, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17  ;; 0x40088000
   \   0000001A   0x.... 0x....      BL       SSP_Cmd
    151          }		 
   \   0000001E   0xB007             ADD      SP,SP,#+28
   \   00000020   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
    152          void InitCardIO( void )
    153          {
   \                     InitCardIO: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    154          	GPIO_PinselConfig(SCK_IC,3);
   \   00000002   0x2103             MOVS     R1,#+3
   \   00000004   0x2078             MOVS     R0,#+120
   \   00000006   0x.... 0x....      BL       GPIO_PinselConfig
    155          	GPIO_PinselConfig(MOSI_IC,3);
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x207C             MOVS     R0,#+124
   \   0000000E   0x.... 0x....      BL       GPIO_PinselConfig
    156          	GPIO_PinselConfig(MISO_IC,3);
   \   00000012   0x2103             MOVS     R1,#+3
   \   00000014   0x207B             MOVS     R0,#+123
   \   00000016   0x.... 0x....      BL       GPIO_PinselConfig
    157          	GPIO_PinselConfig(SOFT_SPI_CS_IC,0);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x207F             MOVS     R0,#+127
   \   0000001E   0x.... 0x....      BL       GPIO_PinselConfig
    158          	GPIO_PinselConfig(IC_SWT,0);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x20C8             MOVS     R0,#+200
   \   00000026   0x.... 0x....      BL       GPIO_PinselConfig
    159          
    160          	SSP0_Init();
   \   0000002A   0x.... 0x....      BL       SSP0_Init
    161          }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    162          		       
    163          //void	InitCardIO(void)
    164          //{
    165          //	GPIO_PinselConfig(SCK_IC,0);
    166          //	GPIO_PinselConfig(SCK_IC,0);
    167          //	GPIO_PinselConfig(MOSI_IC,0);
    168          //	GPIO_PinselConfig(MOSI_IC,0);	
    169          //	GPIO_PinselConfig(MISO_IC,0);
    170          //	GPIO_PinselConfig(MISO_IC,0);	
    171          //	GPIO_PinselConfig(SOFT_SPI_CS_IC,0);			
    172          //	GPIO_PinselConfig(POW_IC,0);
    173          //	GPIO_PinselConfig(IC_SWT,0);
    174          //	GPIO_PinselConfig(IC_SWT,0);
    175          //
    176          //	SSP0_Init();
    177          //}
    178          
    179          
    180          
    181          
    182          //------------------------------------------------------------------------
    183          //  名  称 ：uint8_t ReadMOSI_IC(void)
    184          //  功  能 ：读取 MOSI_IC 的值
    185          // 入口参数：无
    186          // 出口参数：无
    187          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    188          uint8_t ReadMISO_IC(void)
    189          {
   \                     ReadMISO_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    190          	uint8_t temp;
    191          
    192          	temp = 	GPIO_ReadIoVal(MISO_IC);
   \   00000002   0x207B             MOVS     R0,#+123
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
    193          
    194          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    195          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    196          }
    197          
    198          //------------------------------------------------------------------------
    199          //  名  称 ：void WriteMOSI_IC( uint8_t temp )
    200          //  功  能 ：设置 MOSI_IC
    201          // 入口参数：无
    202          // 出口参数：无
    203          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    204          void WriteSoftSpiCSIC(uint8_t temp)
    205          {	
   \                     WriteSoftSpiCSIC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    206          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSoftSpiCSIC_0
    207          	{
    208          		GPIO_SetOrClearValue(SOFT_SPI_CS_IC,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x207F             MOVS     R0,#+127
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSoftSpiCSIC_1
    209          	}
    210          	else
    211          	{
    212          		GPIO_SetOrClearValue(SOFT_SPI_CS_IC,0);		
   \                     ??WriteSoftSpiCSIC_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x207F             MOVS     R0,#+127
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    213          	}	
    214          
    215          	nop();		
   \                     ??WriteSoftSpiCSIC_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    216          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    217          
    218          
    219          //---------------------------------------------------------------------------------
    220          //函数名称:             SentByte_SPI()
    221          //功    能:             SPI发送一字节数据
    222          //入口参数:             Data8
    223          //出口参数:             无
    224          //说    明:				以模拟SPI总线方式发送数据
    225          //----------------------------------------------------------------------------------
    226          //uint8_t SendOrRecByte_SPI_IC(uint8_t ch)
    227          //{
    228          //	uint8_t i,temp;   
    229          //	
    230          ////	WriteSCK_IC ( 0 );
    231          //	printfcom0("\r\n temp1 %x,%x",ch);
    232          //    for (i=0;i<8;i++)
    233          //    {
    234          //		temp=ch&0x80;
    235          //    	ch=ch<<1;
    236          //      if(temp)
    237          //      {
    238          //      	WriteMOSI_IC( 1 );	
    239          //
    240          //      	WriteSCK_IC ( 0 );
    241          //
    242          //      	WriteSCK_IC ( 1 );	        	
    243          //      }
    244          //      else
    245          //      {
    246          //      	WriteMOSI_IC( 0 );	
    247          //
    248          //        WriteSCK_IC ( 0 );
    249          //          
    250          //      	WriteSCK_IC ( 1 );
    251          //      }
    252          //      
    253          //      ch |= ReadMISO_IC();
    254          //	  //nop();
    255          //    }
    256          //        
    257          //   // WriteSCK_IC ( 0 );
    258          //    printfcom0("\r\n temp2 %x,%x",ch);
    259          //    return	ch;
    260          //}
    261          
    262          

   \                                 In section .text, align 2, keep-with-next
    263          uint8_t SendOrRecByte_SPI_IC(uint8_t data)
    264          {
   \                     SendOrRecByte_SPI_IC: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    265          	uint8_t	tmp;
    266          
    267              while((LPC_SSP0->SR & 0x04) == 0x04)
   \                     ??SendOrRecByte_SPI_IC_0: (+1)
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x4008800c
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x0752             LSLS     R2,R2,#+29
   \   0000000A   0xD504             BPL.N    ??SendOrRecByte_SPI_IC_1
    268          	{
    269          		tmp	= LPC_SSP0->DR; 
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable17_2  ;; 0x40088008
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x0010             MOVS     R0,R2
   \   00000014   0xE7F5             B.N      ??SendOrRecByte_SPI_IC_0
    270          	}
    271          	while ((LPC_SSP0->SR & 0x02) == 0);                                 /* 等待发送FIFO留出空间         */   
   \                     ??SendOrRecByte_SPI_IC_1: (+1)
   \   00000016   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x4008800c
   \   0000001A   0x6812             LDR      R2,[R2, #+0]
   \   0000001C   0x0792             LSLS     R2,R2,#+30
   \   0000001E   0xD5FA             BPL.N    ??SendOrRecByte_SPI_IC_1
    272              LPC_SSP0->DR = data;
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable17_2  ;; 0x40088008
   \   00000026   0x6011             STR      R1,[R2, #+0]
    273              while ((LPC_SSP0->SR & 0x10) == 0x10);                              /* 等待数据帧发送完毕           */ 
   \                     ??SendOrRecByte_SPI_IC_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x4008800c
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x06D2             LSLS     R2,R2,#+27
   \   00000030   0xD4FA             BMI.N    ??SendOrRecByte_SPI_IC_2
    274          	
    275          	while((LPC_SSP0->SR & 0x04) == 0x04)
   \                     ??SendOrRecByte_SPI_IC_3: (+1)
   \   00000032   0x.... 0x....      LDR.W    R2,??DataTable17_1  ;; 0x4008800c
   \   00000036   0x6812             LDR      R2,[R2, #+0]
   \   00000038   0x0752             LSLS     R2,R2,#+29
   \   0000003A   0xD504             BPL.N    ??SendOrRecByte_SPI_IC_4
    276          	{
    277          		tmp	= LPC_SSP0->DR; 
   \   0000003C   0x.... 0x....      LDR.W    R2,??DataTable17_2  ;; 0x40088008
   \   00000040   0x6812             LDR      R2,[R2, #+0]
   \   00000042   0x0010             MOVS     R0,R2
   \   00000044   0xE7F5             B.N      ??SendOrRecByte_SPI_IC_3
    278          	}
    279              return tmp;
   \                     ??SendOrRecByte_SPI_IC_4: (+1)
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x4770             BX       LR               ;; return
    280          }
    281          
    282          
    283          

   \                                 In section .text, align 2, keep-with-next
    284          void	SendByte_SPI_IC(uint8_t	ch)
    285          {
   \                     SendByte_SPI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    286          	SendOrRecByte_SPI_IC(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPI_IC
    287          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    288          

   \                                 In section .text, align 2, keep-with-next
    289          uint8_t	RecByte_SPI_IC(void)
    290          {
   \                     RecByte_SPI_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    291          	uint8_t		ch =0;
   \   00000002   0x2400             MOVS     R4,#+0
    292          	return	SendOrRecByte_SPI_IC(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPI_IC
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    293          }
    294          
    295          
    296          
    297          //------------------------------------------------------------------------
    298          // 名    称：   uint8_t SentByte_SPI(uint8_t  Dat8)
    299          // 功    能：   SPI口0串口发送1个数据
    300          // 入口参数：   Dat8:数据缓
    301          // 出口参数：	(主机)
    302          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    303          uint8_t SentByte_SPI(uint8_t  Dat8)
    304          {
   \                     SentByte_SPI: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    305          	SendByte_SPI_IC(Dat8);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendByte_SPI_IC
    306          	return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD10             POP      {R4,PC}          ;; return
    307          }
    308          
    309          //------------------------------------------------------------------------
    310          // 名    称：   uint8_t RevByte_SPI(void)
    311          // 功    能：   SPI0查询方式接收数据                  	
    312          // 入口参数：  
    313          // 出口参数：	接收到的数据
    314          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    315          uint8_t RevByte_SPI(void)
    316          {
   \                     RevByte_SPI: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    317              uint8_t	Tmp;
    318              
    319          	Tmp = RecByte_SPI_IC();
   \   00000002   0x.... 0x....      BL       RecByte_SPI_IC
   \   00000006   0x0004             MOVS     R4,R0
    320                  
    321              return  Tmp;                  			//清发送完成标识
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    322          }
    323          
    324          //------------------------------------------------------------------------
    325          //  名  称 ：void WritePOW_IC( uint8_t temp )
    326          //  功  能 ：设置 POW_IC
    327          // 入口参数：无
    328          // 出口参数：无
    329          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    330          void WritePOW_IC(uint8_t temp)
    331          {
   \                     WritePOW_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    332          	nop();		
   \   00000004   0x.... 0x....      BL       `nop`
    333          	
    334          	if(temp)		
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD004             BEQ.N    ??WritePOW_IC_0
    335          	{
    336          		GPIO_SetOrClearValue(POW_IC,1);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x20D3             MOVS     R0,#+211
   \   00000012   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000016   0xE003             B.N      ??WritePOW_IC_1
    337          	}
    338          	else
    339          	{
    340          		GPIO_SetOrClearValue(POW_IC,0);		
   \                     ??WritePOW_IC_0: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x20D3             MOVS     R0,#+211
   \   0000001C   0x.... 0x....      BL       GPIO_SetOrClearValue
    341          	}	
    342          
    343          	nop();		
   \                     ??WritePOW_IC_1: (+1)
   \   00000020   0x.... 0x....      BL       `nop`
    344          }
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    345          
    346          //------------------------------------------------------------------------------------------
    347          //  名  称 ：void WriteCS_IC( uint8_t temp )
    348          //  功  能 ：设置 CS_IC
    349          // 入口参数：无
    350          // 出口参数：无
    351          //-----------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    352          void WriteCS_IC(uint8_t temp)
    353          {
   \                     WriteCS_IC: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    354          	GPIO_PinselConfig(CS_IC,0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x207F             MOVS     R0,#+127
   \   00000008   0x.... 0x....      BL       GPIO_PinselConfig
    355          	
    356          	nop();
   \   0000000C   0x.... 0x....      BL       `nop`
    357          	if(temp)		
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C00             CMP      R4,#+0
   \   00000014   0xD004             BEQ.N    ??WriteCS_IC_0
    358          	{
    359          		GPIO_SetOrClearValue(CS_IC,1);
   \   00000016   0x2101             MOVS     R1,#+1
   \   00000018   0x207F             MOVS     R0,#+127
   \   0000001A   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000001E   0xE003             B.N      ??WriteCS_IC_1
    360          	}
    361          	else
    362          	{
    363          		GPIO_SetOrClearValue(CS_IC,0);		
   \                     ??WriteCS_IC_0: (+1)
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x207F             MOVS     R0,#+127
   \   00000024   0x.... 0x....      BL       GPIO_SetOrClearValue
    364          	}
    365          	nop();	
   \                     ??WriteCS_IC_1: (+1)
   \   00000028   0x.... 0x....      BL       `nop`
    366          }
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    367          
    368          //--------------------------------------------------------------------------------------------
    369          //  名  称 ：void WriteIC_RST( uint8_t temp )
    370          //  功  能 ：设置 IC_RST
    371          // 入口参数：无
    372          // 出口参数：无
    373          //----------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    374          void WriteIC_RST(uint8_t temp)
    375          {
   \                     WriteIC_RST: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    376          	GPIO_PinselConfig(IC_RST,0);
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x20D4             MOVS     R0,#+212
   \   00000008   0x.... 0x....      BL       GPIO_PinselConfig
    377          	
    378          	if(temp)		
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD004             BEQ.N    ??WriteIC_RST_0
    379          	{
    380          		GPIO_SetOrClearValue(IC_RST,1);
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x20D4             MOVS     R0,#+212
   \   00000016   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   0000001A   0xE003             B.N      ??WriteIC_RST_1
    381          	}
    382          	else
    383          	{
    384          		GPIO_SetOrClearValue(IC_RST,0);		
   \                     ??WriteIC_RST_0: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x20D4             MOVS     R0,#+212
   \   00000020   0x.... 0x....      BL       GPIO_SetOrClearValue
    385          	}		
    386          }
   \                     ??WriteIC_RST_1: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    387          //--------------------------------------------------------------------------------------------
    388          //  名  称 ：void WriteIC_SWT( uint8_t temp )
    389          //  功  能 ：设置 IC_SWT
    390          // 入口参数：无
    391          // 出口参数：无
    392          //---------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    393          void WriteIC_SWT(uint8_t temp)
    394          {
   \                     WriteIC_SWT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    395          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteIC_SWT_0
    396          	{
    397          		GPIO_SetOrClearValue(IC_SWT,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20C8             MOVS     R0,#+200
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteIC_SWT_1
    398          	}
    399          	else
    400          	{
    401          		GPIO_SetOrClearValue(IC_SWT,0);		
   \                     ??WriteIC_SWT_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20C8             MOVS     R0,#+200
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    402          	}	
    403          }
   \                     ??WriteIC_SWT_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    404          
    405          //-----------------------------------------------------------------------------------------------
    406          //  名  称 ：uint8_t ReadIC_SWT(void)
    407          //  功  能 ：读取 IC_SWT 的值
    408          // 入口参数：无
    409          // 出口参数：无
    410          //------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    411          uint8_t ReadIC_SWT(void)
    412          {
   \                     ReadIC_SWT: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    413          	uint8_t	Tmp;
    414          
    415          	nop();	
   \   00000002   0x.... 0x....      BL       `nop`
    416          	Tmp = 	GPIO_ReadIoVal(IC_SWT);
   \   00000006   0x20C8             MOVS     R0,#+200
   \   00000008   0x.... 0x....      BL       GPIO_ReadIoVal
   \   0000000C   0x0004             MOVS     R4,R0
    417          
    418          	return Tmp;	
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    419          }
    420          
    421          
    422          
    423          //定义AT45DB041D命令    命令针对于PAGESIZE=l_CardPageSize-------------------------------------- 
    424          #define    	READ_STU               0x57            //读状态字命令
    425          #define    	CON_ARR_READ           0xe8            //continuous array read code
    426          #define    	BUFF1_WRITE            0x84            //write buffer1
    427          #define    	BUFF2_WRITE            0x87            //write buffer2
    428          #define    	BUFF1_TO_MEM           0x83            //BUFFER1 to Main Memory Page Program with Built-in Erase
    429          #define    	BUFF2_TO_MEM           0x86            //BUFFER1 to Main Memory Page Program with Built-in Erase
    430          
    431          //#define    BUFF1_READ             0xD4            //read Buff1
    432          //#define    BUFF2_READ             0xD6            //read Buff2
    433          #define    	BUFF1_READ             0x54            //read Buff1
    434          #define   	BUFF2_READ             0x56            //read Buff2
    435          #define    	MEM_TO_BUFF1           0x53            //
    436          #define    	MEM_TO_BUFF2           0x55            //
    437          //IC卡参数

   \                                 In section .bss, align 4
    438          uint32		l_CardPageSize;	
   \                     l_CardPageSize:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    439          uint32		l_CardStartAddr;	
   \                     l_CardStartAddr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    440          uint32		l_CardPageNum;
   \                     l_CardPageNum:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    441          uint8_t		l_CardTypeFlg;
   \                     l_CardTypeFlg:
   \   00000000                      DS8 1
    442          
    443          //-------------------------------------------------------------------------------
    444          //Status Register Format:
    445          //   -----------------------------------------------------------------------
    446          //  |  bit7  |  bit6   |  bit5  |  bit4  |  bit3  |  bit2  |  bit1  |  bit0  |
    447          //  |--------|---------|---------|--------|---------|---------|---------|--------|
    448          //  |RDY/BUSY|  COMP  |   0    |   1    |   1    |   1    |   X    |   X    | */
    449          //
    450          //bit7 - 忙标记，0为忙1为不忙
    451          //当Status Register的位0移出之后，接下来的时钟脉冲序列将使SPI器件继续将最新的状态字节送出。
    452          //bit6 - 标记最近一次Main Memory Page和Buffer的比较结果，0相同，1不同。
    453          //bit5
    454          //bit4
    455          //bit3
    456          //bit2 - 这4位用来标记器件密度，对于AT45DB041B，这4位应该是0111，一共能标记16种不同密度的器件
    457          //bit1
    458          //bit0 - 这2位暂时无效
    459          //函数实现对AT45DB041D芯片状态字读出功能
    460          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    461          uint8_t   StatusRegisterRead_Card(void)
    462          {
   \                     StatusRegisterRead_Card: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    463              uint8_t Statues;
    464          
    465              WriteCS_IC(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       WriteCS_IC
    466              
    467          	WriteCS_IC(0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       WriteCS_IC
    468              WriteCS_IC(0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x.... 0x....      BL       WriteCS_IC
    469              
    470              SentByte_SPI(READ_STU);                          	//发送读状态存储器命令
   \   00000014   0x2057             MOVS     R0,#+87
   \   00000016   0x.... 0x....      BL       SentByte_SPI
    471              Statues = RevByte_SPI();                       		//读取状态寄存器命令
   \   0000001A   0x.... 0x....      BL       RevByte_SPI
   \   0000001E   0x0004             MOVS     R4,R0
    472          
    473              WriteCS_IC(1);
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x.... 0x....      BL       WriteCS_IC
    474          
    475              return Statues;
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBD10             POP      {R4,PC}          ;; return
    476          }
    477          
    478          //------------------------------------------------------------------------
    479          // 名    称：   void   InitCardInfo(void)				
    480          // 功    能：   初始化IC卡参数     	
    481          // 入口参数：  	无
    482          // 出口参数：	无
    483          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    484          void   InitCardInfo(void)								
    485          {
   \                     InitCardInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    486          	uint8_t	CardState;
    487          	CardState = StatusRegisterRead_Card();
   \   00000002   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000006   0x0004             MOVS     R4,R0
    488          	
    489          	if((CardState & 0x3c) == AT45DB041)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000000E   0x281C             CMP      R0,#+28
   \   00000010   0xD112             BNE.N    ??InitCardInfo_0
    490          	{
    491          		l_CardPageSize	= 256;	
   \   00000012   0xF44F 0x7080      MOV      R0,#+256
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    492          		l_CardStartAddr	= 0;	
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000022   0x6008             STR      R0,[R1, #+0]
    493          		l_CardPageNum	= 2048;
   \   00000024   0xF44F 0x6000      MOV      R0,#+2048
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    494          		l_CardTypeFlg	= AT45DB041;
   \   0000002E   0x201C             MOVS     R0,#+28
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000034   0x7008             STRB     R0,[R1, #+0]
   \   00000036   0xE046             B.N      ??InitCardInfo_1
    495          	}
    496          	else if((CardState & 0x3c) == AT45DB161)
   \                     ??InitCardInfo_0: (+1)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000003E   0x282C             CMP      R0,#+44
   \   00000040   0xD112             BNE.N    ??InitCardInfo_2
    497          	{
    498          		l_CardPageSize	= 512;	
   \   00000042   0xF44F 0x7000      MOV      R0,#+512
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    499          		l_CardStartAddr	= 0;	
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000052   0x6008             STR      R0,[R1, #+0]
    500          		l_CardPageNum	= 4096;
   \   00000054   0xF44F 0x5080      MOV      R0,#+4096
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    501          		l_CardTypeFlg	= AT45DB161;		
   \   0000005E   0x202C             MOVS     R0,#+44
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   \   00000066   0xE02E             B.N      ??InitCardInfo_1
    502          	}	
    503          	else if((CardState & 0x3c) == AT45DB321)
   \                     ??InitCardInfo_2: (+1)
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000006E   0x2834             CMP      R0,#+52
   \   00000070   0xD112             BNE.N    ??InitCardInfo_3
    504          	{
    505          		l_CardPageSize	= 512;	
   \   00000072   0xF44F 0x7000      MOV      R0,#+512
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000007A   0x6008             STR      R0,[R1, #+0]
    506          		l_CardStartAddr	= 0;	
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000082   0x6008             STR      R0,[R1, #+0]
    507          		l_CardPageNum	= 8192;
   \   00000084   0xF44F 0x5000      MOV      R0,#+8192
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    508          		l_CardTypeFlg	= AT45DB321;		
   \   0000008E   0x2034             MOVS     R0,#+52
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   00000094   0x7008             STRB     R0,[R1, #+0]
   \   00000096   0xE016             B.N      ??InitCardInfo_1
    509          	}	
    510          	else if((CardState & 0x3c) == AT45DB642)
   \                     ??InitCardInfo_3: (+1)
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000009E   0x283C             CMP      R0,#+60
   \   000000A0   0xD111             BNE.N    ??InitCardInfo_1
    511          	{
    512          		l_CardPageSize	= 1024;	
   \   000000A2   0xF44F 0x6080      MOV      R0,#+1024
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    513          		l_CardStartAddr	= 0;	
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   000000B2   0x6008             STR      R0,[R1, #+0]
    514          		l_CardPageNum	= 8192;
   \   000000B4   0xF44F 0x5000      MOV      R0,#+8192
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    515          		l_CardTypeFlg	= AT45DB642;		
   \   000000BE   0x203C             MOVS     R0,#+60
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable17_6
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
    516          	}		
    517          	
    518          	//printfcom0("\r\n l_CardPageSize %d l_CardStartAddr %d l_CardPageNum %d l_CardTypeFlg %d ",l_CardPageSize,l_CardStartAddr,l_CardPageNum,l_CardTypeFlg);	
    519          }
   \                     ??InitCardInfo_1: (+1)
   \   000000C6   0xBD10             POP      {R4,PC}          ;; return
    520          
    521          //------------------------------------------------------------------------
    522          // 名    称：   uint32   GetCardPageSize(void)			//取IC卡页大小
    523          // 功    能：   初始化IC卡参数     	
    524          // 入口参数：  
    525          // 出口参数：	
    526          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    527          uint32   GetCardPageSize(void)							//取IC卡页大小
    528          {
    529          	return	l_CardPageSize;
   \                     GetCardPageSize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    530          }
    531          
    532          //-------------------------------------------------------------------------------
    533          //描述：
    534          //    When the Flsh bit in the main memory array has been read,the device will
    535          //    continue reading back at the beginning of the first page of memory.As w-
    536          //    ith crossing over page boundaries,no Delays will be incurred when wrapp-
    537          //    ing around from the end of the array to the beginning of the array.
    538          //参数：
    539          //    PA      - 页地址，0~2047
    540          //    BFA     - 指定BUFFER中的起始写入地址
    541          //    pHeader - 指定数据的首地址
    542          //    len     - 指定数据的长度
    543          //函数现象连续读取AT45DB041D存储空间功能
    544          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    545          void    ContinuousArrayRead_Card(uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    546          {
   \                     ContinuousArrayRead_Card: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x001E             MOVS     R6,R3
    547              uint16 i = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    548          /**/
    549              while(i++ < 255)                                  		//确认AT45DB041D准备,确认256次后退出等待
   \                     ??ContinuousArrayRead_Card_0: (+1)
   \   0000000E   0x0038             MOVS     R0,R7
   \   00000010   0x1C47             ADDS     R7,R0,#+1
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xDA03             BGE.N    ??ContinuousArrayRead_Card_1
    550              {
    551                  if(StatusRegisterRead_Card() & 0x80)              	//准备完成,进行后续操作
   \   00000018   0x.... 0x....      BL       StatusRegisterRead_Card
   \   0000001C   0x0600             LSLS     R0,R0,#+24
   \   0000001E   0xD5F6             BPL.N    ??ContinuousArrayRead_Card_0
    552                  {
    553                      break;
    554                  }
    555                  
    556                  //SysHoldTast();
    557              }
    558          
    559              WriteCS_IC(0);
   \                     ??ContinuousArrayRead_Card_1: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      BL       WriteCS_IC
    560              
    561              SentByte_SPI(CON_ARR_READ);                             //送连续读命令
   \   00000026   0x20E8             MOVS     R0,#+232
   \   00000028   0x.... 0x....      BL       SentByte_SPI
    562              
    563              if(l_CardTypeFlg == AT45DB041)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x281C             CMP      R0,#+28
   \   00000034   0xD112             BNE.N    ??ContinuousArrayRead_Card_2
    564              {
    565          			SentByte_SPI((uint8_t)(PA>>7));            		//送页地址
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x09C0             LSRS     R0,R0,#+7
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x.... 0x....      BL       SentByte_SPI
    566          			SentByte_SPI((uint8_t)((PA<<1)|(BFA>>8)));   		//
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000046   0x0A00             LSRS     R0,R0,#+8
   \   00000048   0xEA50 0x0048      ORRS     R0,R0,R8, LSL #+1
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0x.... 0x....      BL       SentByte_SPI
    567          			SentByte_SPI((uint8_t)BFA);                   	//送Buffer地址
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x.... 0x....      BL       SentByte_SPI
   \   0000005A   0xE046             B.N      ??ContinuousArrayRead_Card_3
    568          		}
    569          		else if(l_CardTypeFlg == AT45DB161)
   \                     ??ContinuousArrayRead_Card_2: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000060   0x7800             LDRB     R0,[R0, #+0]
   \   00000062   0x282C             CMP      R0,#+44
   \   00000064   0xD112             BNE.N    ??ContinuousArrayRead_Card_4
    570          		{
    571          			SentByte_SPI((uint8_t)(PA>>6));            		//送页地址
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x0980             LSRS     R0,R0,#+6
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x.... 0x....      BL       SentByte_SPI
    572          			SentByte_SPI((uint8_t)((PA<<2)|(BFA>>8)));     	//
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x0A00             LSRS     R0,R0,#+8
   \   00000078   0xEA50 0x0088      ORRS     R0,R0,R8, LSL #+2
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x.... 0x....      BL       SentByte_SPI
    573          			SentByte_SPI((uint8_t)BFA);   
   \   00000082   0x0020             MOVS     R0,R4
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       SentByte_SPI
   \   0000008A   0xE02E             B.N      ??ContinuousArrayRead_Card_3
    574          		}
    575          		else if(l_CardTypeFlg == AT45DB321)
   \                     ??ContinuousArrayRead_Card_4: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0x2834             CMP      R0,#+52
   \   00000094   0xD112             BNE.N    ??ContinuousArrayRead_Card_5
    576          		{
    577          			SentByte_SPI((uint8_t)(PA>>6));              		//送页地址
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x0980             LSRS     R0,R0,#+6
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x.... 0x....      BL       SentByte_SPI
    578          			SentByte_SPI((uint8_t)((PA<<2)|(BFA>>8)));     	//
   \   000000A2   0x0020             MOVS     R0,R4
   \   000000A4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000A6   0x0A00             LSRS     R0,R0,#+8
   \   000000A8   0xEA50 0x0088      ORRS     R0,R0,R8, LSL #+2
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x.... 0x....      BL       SentByte_SPI
    579          			SentByte_SPI((uint8_t)BFA);   
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B6   0x.... 0x....      BL       SentByte_SPI
   \   000000BA   0xE016             B.N      ??ContinuousArrayRead_Card_3
    580          		}	
    581          		else if(l_CardTypeFlg == AT45DB642)
   \                     ??ContinuousArrayRead_Card_5: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x283C             CMP      R0,#+60
   \   000000C4   0xD111             BNE.N    ??ContinuousArrayRead_Card_3
    582          		{
    583          			SentByte_SPI((uint8_t)(PA>>5));                	//送页地址
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000CA   0x0940             LSRS     R0,R0,#+5
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0x.... 0x....      BL       SentByte_SPI
    584          			SentByte_SPI((uint8_t)((PA<<3)|(BFA>>8)));      	//
   \   000000D2   0x0020             MOVS     R0,R4
   \   000000D4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D6   0x0A00             LSRS     R0,R0,#+8
   \   000000D8   0xEA50 0x00C8      ORRS     R0,R0,R8, LSL #+3
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x.... 0x....      BL       SentByte_SPI
    585          			SentByte_SPI((uint8_t)BFA);   
   \   000000E2   0x0020             MOVS     R0,R4
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x.... 0x....      BL       SentByte_SPI
    586          		}		
    587          
    588              SentByte_SPI(0x00);                                     //时续要求
   \                     ??ContinuousArrayRead_Card_3: (+1)
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x.... 0x....      BL       SentByte_SPI
    589              SentByte_SPI(0x00);
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x.... 0x....      BL       SentByte_SPI
    590              SentByte_SPI(0x00);
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      BL       SentByte_SPI
    591              SentByte_SPI(0x00);
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x.... 0x....      BL       SentByte_SPI
    592          
    593              for(i=0;i<Len;i++)                                    	//读数
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x0007             MOVS     R7,R0
   \                     ??ContinuousArrayRead_Card_6: (+1)
   \   00000106   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000108   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000010A   0x42B7             CMP      R7,R6
   \   0000010C   0xD205             BCS.N    ??ContinuousArrayRead_Card_7
    594              {
    595                  pHeader[i] = RevByte_SPI();
   \   0000010E   0x.... 0x....      BL       RevByte_SPI
   \   00000112   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000114   0x5578             STRB     R0,[R7, R5]
    596              }
   \   00000116   0x1C7F             ADDS     R7,R7,#+1
   \   00000118   0xE7F5             B.N      ??ContinuousArrayRead_Card_6
    597              
    598              WriteCS_IC(1);
   \                     ??ContinuousArrayRead_Card_7: (+1)
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0x.... 0x....      BL       WriteCS_IC
    599          }
   \   00000120   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    600          
    601          //-----------------------------------------------------------------------------
    602          //描述：
    603          //    将指定数据写入从某个地址（0~263）开始的页中：包含2个动作，首先将指定数据
    604          //    写入到BUFFER 1或者BUFFER 2中，其中可以指定BUFFER中的起始写入地址，此写入
    605          //    动作不影响BUFFER中其它地址中的数据，然后再将BUFFER中的整个数据写入到某指
    606          //    定页中(带预擦除)。
    607          //参数：
    608          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    609          //    PA      - 页地址，0~2047
    610          //    BFA     - 指定BUFFER中的起始写入地址
    611          //    pHeader - 指定数据的首地址
    612          //    len     - 指定数据的长度
    613          //--------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    614          void    MainMemoryToBuff(uint8_t Buffer,uint16 PA)
    615          {
   \                     MainMemoryToBuff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    616              uint16 i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    617          
    618              while(i++<3000)                                         //确认AT45DB041D为不忙,确认1000次后退出等待
   \                     ??MainMemoryToBuff_0: (+1)
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x1C46             ADDS     R6,R0,#+1
   \   0000000C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000E   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xDA03             BGE.N    ??MainMemoryToBuff_1
    619              {
    620                  if(StatusRegisterRead_Card()&0x80)
   \   00000016   0x.... 0x....      BL       StatusRegisterRead_Card
   \   0000001A   0x0600             LSLS     R0,R0,#+24
   \   0000001C   0xD5F4             BPL.N    ??MainMemoryToBuff_0
    621                  {
    622                      break;
    623                  }
    624                  
    625                  //SysHoldTast();
    626              }
    627          
    628              WriteCS_IC(0);
   \                     ??MainMemoryToBuff_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       WriteCS_IC
    629              
    630              switch(Buffer)                                          //选Buffer
   \   00000024   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD002             BEQ.N    ??MainMemoryToBuff_2
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD004             BEQ.N    ??MainMemoryToBuff_3
   \   00000030   0xE006             B.N      ??MainMemoryToBuff_4
    631              {
    632                  case 1:SentByte_SPI(MEM_TO_BUFF1);break;
   \                     ??MainMemoryToBuff_2: (+1)
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x.... 0x....      BL       SentByte_SPI
   \   00000038   0xE002             B.N      ??MainMemoryToBuff_4
    633                  case 2:SentByte_SPI(MEM_TO_BUFF2);break;
   \                     ??MainMemoryToBuff_3: (+1)
   \   0000003A   0x2055             MOVS     R0,#+85
   \   0000003C   0x.... 0x....      BL       SentByte_SPI
    634              }
    635              if(l_CardTypeFlg == AT45DB041)
   \                     ??MainMemoryToBuff_4: (+1)
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x281C             CMP      R0,#+28
   \   00000048   0xD10A             BNE.N    ??MainMemoryToBuff_5
    636              {
    637          	    SentByte_SPI((uint8_t)(PA>>7));                       //确定页地址
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004E   0x09C0             LSRS     R0,R0,#+7
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x.... 0x....      BL       SentByte_SPI
    638          	    SentByte_SPI((uint8_t)(PA<<1));
   \   00000056   0x0068             LSLS     R0,R5,#+1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x.... 0x....      BL       SentByte_SPI
   \   0000005E   0xE02E             B.N      ??MainMemoryToBuff_6
    639          	}
    640          	else if(l_CardTypeFlg == AT45DB161)
   \                     ??MainMemoryToBuff_5: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x282C             CMP      R0,#+44
   \   00000068   0xD10A             BNE.N    ??MainMemoryToBuff_7
    641          	{
    642          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000006A   0x0028             MOVS     R0,R5
   \   0000006C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006E   0x0980             LSRS     R0,R0,#+6
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x.... 0x....      BL       SentByte_SPI
    643          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000076   0x00A8             LSLS     R0,R5,#+2
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x.... 0x....      BL       SentByte_SPI
   \   0000007E   0xE01E             B.N      ??MainMemoryToBuff_6
    644          	}
    645          	else if(l_CardTypeFlg == AT45DB321)
   \                     ??MainMemoryToBuff_7: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x2834             CMP      R0,#+52
   \   00000088   0xD10A             BNE.N    ??MainMemoryToBuff_8
    646          	{
    647          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000008A   0x0028             MOVS     R0,R5
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       SentByte_SPI
    648          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000096   0x00A8             LSLS     R0,R5,#+2
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x.... 0x....      BL       SentByte_SPI
   \   0000009E   0xE00E             B.N      ??MainMemoryToBuff_6
    649          	}	
    650          	else if(l_CardTypeFlg == AT45DB642)
   \                     ??MainMemoryToBuff_8: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x283C             CMP      R0,#+60
   \   000000A8   0xD109             BNE.N    ??MainMemoryToBuff_6
    651          	{
    652          		SentByte_SPI((uint8_t)(PA>>5));                       //确定页地址
   \   000000AA   0x0028             MOVS     R0,R5
   \   000000AC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AE   0x0940             LSRS     R0,R0,#+5
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x.... 0x....      BL       SentByte_SPI
    653          	    SentByte_SPI((uint8_t)(PA<<3));
   \   000000B6   0x00E8             LSLS     R0,R5,#+3
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x.... 0x....      BL       SentByte_SPI
    654          	}		
    655          		
    656              SentByte_SPI(0x00);
   \                     ??MainMemoryToBuff_6: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      BL       SentByte_SPI
    657          
    658              WriteCS_IC(1);
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0x.... 0x....      BL       WriteCS_IC
    659          }
   \   000000CA   0xBD70             POP      {R4-R6,PC}       ;; return
    660          
    661          
    662          //------------------------------------------------------------------------------
    663          //描述：
    664          //    将指定数据写入从某个地址（0~263）开始的BUFFER中。
    665          //参数：
    666          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    667          //              在该指令序列中，操作码84H选择BUFFER 1，87H选择BUFFER 2
    668          //    BFA     - BUFFER中的起始地址，0~263
    669          //    pHeader - 待存数据的头指针
    670          //    len     - 待存数据的长度1~l_CardPageSize
    671          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    672          void    BufferRead_Card(uint8_t Buffer,uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    673          {
   \                     BufferRead_Card: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
    674              uint16 i;
    675          
    676          	MainMemoryToBuff(Buffer,PA);							//读取指定的页内容
   \   0000000E   0x0031             MOVS     R1,R6
   \   00000010   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       MainMemoryToBuff
    677          
    678              while(i++<5000)                                       	//确认AT45DB041D为不忙,确认500次后退出等待
   \                     ??BufferRead_Card_0: (+1)
   \   0000001A   0x4648             MOV      R0,R9
   \   0000001C   0xF110 0x0901      ADDS     R9,R0,#+1
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0xF241 0x3188      MOVW     R1,#+5000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xDA03             BGE.N    ??BufferRead_Card_1
    679              {
    680                  if(StatusRegisterRead_Card() & 0x80)
   \   0000002A   0x.... 0x....      BL       StatusRegisterRead_Card
   \   0000002E   0x0600             LSLS     R0,R0,#+24
   \   00000030   0xD5F3             BPL.N    ??BufferRead_Card_0
    681                  {
    682                      break;
    683                  }
    684                  
    685                  //SysHoldTast();
    686              }
    687          
    688              WriteCS_IC(0);
   \                     ??BufferRead_Card_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      BL       WriteCS_IC
    689          
    690              switch(Buffer)                                       	//选择buffer
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x0028             MOVS     R0,R5
   \   0000003C   0x2801             CMP      R0,#+1
   \   0000003E   0xD002             BEQ.N    ??BufferRead_Card_2
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xD004             BEQ.N    ??BufferRead_Card_3
   \   00000044   0xE006             B.N      ??BufferRead_Card_4
    691              {
    692                  case 1:SentByte_SPI(BUFF1_READ);break;             	//送buffer1 写命令
   \                     ??BufferRead_Card_2: (+1)
   \   00000046   0x2054             MOVS     R0,#+84
   \   00000048   0x.... 0x....      BL       SentByte_SPI
   \   0000004C   0xE002             B.N      ??BufferRead_Card_4
    693                  case 2:SentByte_SPI(BUFF2_READ);break;             	//送buffer2 写命令
   \                     ??BufferRead_Card_3: (+1)
   \   0000004E   0x2056             MOVS     R0,#+86
   \   00000050   0x.... 0x....      BL       SentByte_SPI
    694              }
    695              
    696              SentByte_SPI(0x00);
   \                     ??BufferRead_Card_4: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       SentByte_SPI
    697              SentByte_SPI((uint8_t)(BFA>>8));                          //A8地址
   \   0000005A   0x0038             MOVS     R0,R7
   \   0000005C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005E   0x0A00             LSRS     R0,R0,#+8
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x.... 0x....      BL       SentByte_SPI
    698              SentByte_SPI((uint8_t)BFA);                               //A7~A0
   \   00000066   0x0038             MOVS     R0,R7
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x.... 0x....      BL       SentByte_SPI
    699              SentByte_SPI(0x00);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       SentByte_SPI
    700          
    701              for(i=0;i<Len;i++)                                 		//写Buffer
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0x4681             MOV      R9,R0
   \                     ??BufferRead_Card_5: (+1)
   \   00000078   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000007E   0x45A1             CMP      R9,R4
   \   00000080   0xD208             BCS.N    ??BufferRead_Card_6
    702              {
    703                  pHeader[i] = RevByte_SPI();
   \   00000082   0x.... 0x....      BL       RevByte_SPI
   \   00000086   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000008A   0xF809 0x0008      STRB     R0,[R9, R8]
    704              }
   \   0000008E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000092   0xE7F1             B.N      ??BufferRead_Card_5
    705          
    706              WriteCS_IC(1);
   \                     ??BufferRead_Card_6: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       WriteCS_IC
    707          }
   \   0000009A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    708          
    709          //---------------------------------------------------------------------------
    710          //描述：
    711          //    将指定数据写入从某个地址（0~263）开始的BUFFER中。
    712          //参数：
    713          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    714          //              在该指令序列中，操作码84H选择BUFFER 1，87H选择BUFFER 2
    715          //    BFA     - BUFFER中的起始地址，0~263
    716          //    pHeader - 待存数据的头指针
    717          //    len     - 待存数据的长度1~l_CardPageSize
    718          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    719          void    BufferWrite_Card(uint8_t Buffer,uint16 BFA,uint8_t *pHeader,uint16 Len)
    720          {
   \                     BufferWrite_Card: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    721              uint16 i;
    722          /*
    723              while(i++<500)                                      	//确认AT45DB041D为不忙,确认500次后退出等待
    724              {
    725                  if(StatusRegisterRead_Card() & 0x80)
    726                  {
    727                      break;
    728                  }
    729              }
    730          */
    731              WriteCS_IC(0);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       WriteCS_IC
    732          
    733              switch(Buffer)                                        	//选择buffer
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD002             BEQ.N    ??BufferWrite_Card_0
   \   0000001A   0x2802             CMP      R0,#+2
   \   0000001C   0xD004             BEQ.N    ??BufferWrite_Card_1
   \   0000001E   0xE006             B.N      ??BufferWrite_Card_2
    734              {
    735                  case 1:SentByte_SPI(BUFF1_WRITE);break;             //送buffer1 写命令
   \                     ??BufferWrite_Card_0: (+1)
   \   00000020   0x2084             MOVS     R0,#+132
   \   00000022   0x.... 0x....      BL       SentByte_SPI
   \   00000026   0xE002             B.N      ??BufferWrite_Card_2
    736                  case 2:SentByte_SPI(BUFF2_WRITE);break;             //送buffer2 写命令
   \                     ??BufferWrite_Card_1: (+1)
   \   00000028   0x2087             MOVS     R0,#+135
   \   0000002A   0x.... 0x....      BL       SentByte_SPI
    737              }
    738              
    739              SentByte_SPI(0x00);
   \                     ??BufferWrite_Card_2: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       SentByte_SPI
    740              SentByte_SPI((uint8_t)(BFA>>8));                          //A8地址
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000038   0x0A00             LSRS     R0,R0,#+8
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x.... 0x....      BL       SentByte_SPI
    741              SentByte_SPI((uint8_t)BFA);                               //A7~A0
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x.... 0x....      BL       SentByte_SPI
    742          
    743              for(i=0;i<Len;i++)                                   	//写Buffer
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x4680             MOV      R8,R0
   \                     ??BufferWrite_Card_3: (+1)
   \   0000004C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000050   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000052   0x45B8             CMP      R8,R7
   \   00000054   0xD208             BCS.N    ??BufferWrite_Card_4
    744              {
    745                  SentByte_SPI(pHeader[i]);
   \   00000056   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000005A   0xF818 0x0006      LDRB     R0,[R8, R6]
   \   0000005E   0x.... 0x....      BL       SentByte_SPI
    746              }
   \   00000062   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000066   0xE7F1             B.N      ??BufferWrite_Card_3
    747          
    748              WriteCS_IC(1);
   \                     ??BufferWrite_Card_4: (+1)
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x.... 0x....      BL       WriteCS_IC
    749          }
   \   0000006E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    750          
    751          //-----------------------------------------------------------------------------
    752          //描述：
    753          //    将指定数据写入从某个地址（0~263）开始的页中：包含2个动作，首先将指定数据
    754          //    写入到BUFFER 1或者BUFFER 2中，其中可以指定BUFFER中的起始写入地址，此写入
    755          //    动作不影响BUFFER中其它地址中的数据，然后再将BUFFER中的整个数据写入到某指
    756          //    定页中(带预擦除)。
    757          //参数：
    758          //    buffer  - 选择BUFFER，01H选择BUFFER 1，02H选择BUFFER 2
    759          //    PA      - 页地址，0~2047
    760          //    BFA     - 指定BUFFER中的起始写入地址
    761          //    pHeader - 指定数据的首地址
    762          //    len     - 指定数据的长度
    763          //--------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    764          void    BufferToMainMemoryPageProgramWithBuilt_inErase_Card(uint8_t Buffer,uint16 PA,uint16 BFA,uint8_t *pHeader,uint16 Len)
    765          {
   \                     BufferToMainMemoryPageProgramWithBuilt_inErase_Card: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
   \   0000000C   0x9C08             LDR      R4,[SP, #+32]
    766              uint16 i = 0;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    767          
    768              BufferWrite_Card(Buffer,BFA,pHeader,Len);         		//写buffer操作
   \   00000012   0x0023             MOVS     R3,R4
   \   00000014   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000016   0x003A             MOVS     R2,R7
   \   00000018   0x0031             MOVS     R1,R6
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0x0028             MOVS     R0,R5
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       BufferWrite_Card
    769          
    770              while(i++<3000)                                         //确认AT45DB041D为不忙,确认1000次后退出等待
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_0: (+1)
   \   00000024   0x4640             MOV      R0,R8
   \   00000026   0xF110 0x0801      ADDS     R8,R0,#+1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xDA03             BGE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_1
    771              {
    772                  if(StatusRegisterRead_Card()&0x80)
   \   00000034   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000038   0x0600             LSLS     R0,R0,#+24
   \   0000003A   0xD5F3             BPL.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_0
    773                  {
    774                      break;
    775                  }
    776                  
    777                  //SysHoldTast();
    778              }
    779          
    780              WriteCS_IC(0);
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_1: (+1)
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       WriteCS_IC
    781              
    782              switch(Buffer)                                          //选Buffer
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x2801             CMP      R0,#+1
   \   00000048   0xD002             BEQ.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_2
   \   0000004A   0x2802             CMP      R0,#+2
   \   0000004C   0xD004             BEQ.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_3
   \   0000004E   0xE006             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_4
    783              {
    784                  case 1:SentByte_SPI(BUFF1_TO_MEM);break;
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_2: (+1)
   \   00000050   0x2083             MOVS     R0,#+131
   \   00000052   0x.... 0x....      BL       SentByte_SPI
   \   00000056   0xE002             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_4
    785                  case 2:SentByte_SPI(BUFF2_TO_MEM);break;
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_3: (+1)
   \   00000058   0x2086             MOVS     R0,#+134
   \   0000005A   0x.... 0x....      BL       SentByte_SPI
    786              }
    787              if(l_CardTypeFlg == AT45DB041)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_4: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x281C             CMP      R0,#+28
   \   00000066   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_5
    788              {
    789          	    SentByte_SPI((uint8_t)(PA>>7));                       //确定页地址
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x09C0             LSRS     R0,R0,#+7
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x.... 0x....      BL       SentByte_SPI
    790          	    SentByte_SPI((uint8_t)(PA<<1));
   \   00000074   0xEA5F 0x0049      LSLS     R0,R9,#+1
   \   00000078   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007A   0x.... 0x....      BL       SentByte_SPI
   \   0000007E   0xE031             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    791          	}
    792          	else if(l_CardTypeFlg == AT45DB161)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_5: (+1)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0x282C             CMP      R0,#+44
   \   00000088   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_7
    793          	{
    794          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   0000008A   0x4648             MOV      R0,R9
   \   0000008C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000008E   0x0980             LSRS     R0,R0,#+6
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x.... 0x....      BL       SentByte_SPI
    795          	    SentByte_SPI((uint8_t)(PA<<2));
   \   00000096   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0x.... 0x....      BL       SentByte_SPI
   \   000000A0   0xE020             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    796          	}
    797          	else if(l_CardTypeFlg == AT45DB321)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_7: (+1)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x2834             CMP      R0,#+52
   \   000000AA   0xD10B             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_8
    798          	{
    799          		SentByte_SPI((uint8_t)(PA>>6));                       //确定页地址
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B0   0x0980             LSRS     R0,R0,#+6
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       SentByte_SPI
    800          	    SentByte_SPI((uint8_t)(PA<<2));
   \   000000B8   0xEA5F 0x0089      LSLS     R0,R9,#+2
   \   000000BC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BE   0x.... 0x....      BL       SentByte_SPI
   \   000000C2   0xE00F             B.N      ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    801          	}	
    802          	else if(l_CardTypeFlg == AT45DB642)
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_8: (+1)
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable17_6
   \   000000C8   0x7800             LDRB     R0,[R0, #+0]
   \   000000CA   0x283C             CMP      R0,#+60
   \   000000CC   0xD10A             BNE.N    ??BufferToMainMemoryPageProgramWithBuilt_inEras_6
    803          	{
    804          		SentByte_SPI((uint8_t)(PA>>5));                       //确定页地址
   \   000000CE   0x4648             MOV      R0,R9
   \   000000D0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D2   0x0940             LSRS     R0,R0,#+5
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x.... 0x....      BL       SentByte_SPI
    805          	    SentByte_SPI((uint8_t)(PA<<3));
   \   000000DA   0xEA5F 0x00C9      LSLS     R0,R9,#+3
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x.... 0x....      BL       SentByte_SPI
    806          	}		
    807          	
    808              SentByte_SPI(0x00);
   \                     ??BufferToMainMemoryPageProgramWithBuilt_inEras_6: (+1)
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x.... 0x....      BL       SentByte_SPI
    809          
    810              WriteCS_IC(1);
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x.... 0x....      BL       WriteCS_IC
    811          }
   \   000000F0   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    812          

   \                                 In section .bss, align 1
    813          static	uint8_t	l_CardBufNum;
   \                     l_CardBufNum:
   \   00000000                      DS8 1
    814          //extern	SysFastHoldTast(void);
    815          //---------------------------------------------------------------------
    816          //名    称：   ReadCard(uint32 Addr,uint32 *buf,uint32 Len)
    817          //功    能：   将指定区IC卡值读出。
    818          //入口参数：   Addr    读取数据的地址       地址：0~Sizeof(IC)
    819          //             buf     读取后放置的缓冲区
    820          //             Len     读出的数据长度  以8位的数据为长度单位
    821          //出口参数：   无
    822          //----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    823          uint8_t ReadCard(uint32 Addr,uint8_t *TargetBuf,uint32 Len)
    824          {
   \                     ReadCard: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    825              uint16	PageNum;                                                    //页
    826          	uint16	PageOffset;                                                 //页内地址
    827          	uint16  ReadPageTimes;                                              //读页次数       
    828          	uint16  LenTemp;                                                  	//长度         
    829          	uint16  i;
    830          	uint32  BufOffset = 0;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    831              uint32  AddrTemp; 
    832          	uint32	PageNoReadSize;
    833          	uint32	BufNoReadSize;
    834          	
    835          	AddrTemp =  Addr; 
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x4683             MOV      R11,R0
    836              AddrTemp += l_CardStartAddr;                                      	//映射到IC卡内部
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0xEB10 0x0B0B      ADDS     R11,R0,R11
    837                         
    838              if(AddrTemp + Len > l_CardStartAddr + l_CardPageNum*l_CardPageSize)    
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable17_3
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000032   0xEB15 0x010B      ADDS     R1,R5,R11
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD201             BCS.N    ??ReadCard_0
    839              {
    840                 //printfcom0("\r\n READ AddrTemp + Len %d > l_CardStartAddr + l_CardPageNum*l_CardPageSize %d  ", 
    841          //       								AddrTemp + Len,l_CardStartAddr + l_CardPageNum*l_CardPageSize);
    842                 return  FALSE;                                                   //地址超阶
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE064             B.N      ??ReadCard_1
    843              }
    844          
    845              PageNum         = AddrTemp / l_CardPageSize ;                     	//求页
   \                     ??ReadCard_0: (+1)
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000048   0x0006             MOVS     R6,R0
    846              PageOffset      = AddrTemp % l_CardPageSize ;                     	//求页内地址
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000058   0x6809             LDR      R1,[R1, #+0]
   \   0000005A   0xFB01 0xB010      MLS      R0,R1,R0,R11
   \   0000005E   0x0007             MOVS     R7,R0
    847              ReadPageTimes   = (Len + PageOffset  + (l_CardPageSize - 1)) / l_CardPageSize;            
   \   00000060   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000062   0x1978             ADDS     R0,R7,R5
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000078   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    848              /* 																	//读页次数        
    849              for(i = 0; i < ReadPageTimes; i++)
    850              {
    851                  PageNoReadSize = 	l_CardPageSize - (PageOffset + BufOffset)
    852                  					 % l_CardPageSize;							//计算IC卡一页内未写地址
    853                  BufNoReadSize	=	Len - BufOffset;							//缓冲区未读入字节长度
    854                  LenTemp = (PageNoReadSize < BufNoReadSize ? PageNoReadSize:BufNoReadSize);
    855                  																//取将一页写满或将未读入字节长度
    856          	    BufferRead_Card(((l_CardBufNum++%2)+1),PageNum,PageOffset
    857          	    							,(uint8_t *)&TargetBuf[BufOffset],LenTemp);	
    858          	    																//取数 
    859                  BufOffset += LenTemp;
    860                  PageNum++; 
    861              }
    862              */
    863              
    864              for(i = 0; i <= ReadPageTimes; i++)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x4681             MOV      R9,R0
   \                     ??ReadCard_2: (+1)
   \   00000080   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000084   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000088   0x4548             CMP      R0,R9
   \   0000008A   0xD33C             BCC.N    ??ReadCard_3
    865              {
    866              	//SysFastHoldTast();
    867          
    868                  PageNoReadSize = 	l_CardPageSize - (PageOffset + BufOffset)
    869                  					 % l_CardPageSize;						//计算IC卡一页内未写地址
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0xEB1A 0x0107      ADDS     R1,R10,R7
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x1A40             SUBS     R0,R0,R1
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable17_3
   \   0000009E   0x6812             LDR      R2,[R2, #+0]
   \   000000A0   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000A4   0x.... 0x....      LDR.W    R2,??DataTable17_3
   \   000000A8   0x6812             LDR      R2,[R2, #+0]
   \   000000AA   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   000000AE   0x9001             STR      R0,[SP, #+4]
    870                  BufNoReadSize	=	Len - BufOffset;						//缓冲区未读入字节长度
   \   000000B0   0xEBB5 0x000A      SUBS     R0,R5,R10
   \   000000B4   0x9000             STR      R0,[SP, #+0]
    871                  LenTemp = (PageNoReadSize < BufNoReadSize ? PageNoReadSize:BufNoReadSize);
   \   000000B6   0x9801             LDR      R0,[SP, #+4]
   \   000000B8   0x9900             LDR      R1,[SP, #+0]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD202             BCS.N    ??ReadCard_4
   \   000000BE   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \   000000C2   0xE001             B.N      ??ReadCard_5
   \                     ??ReadCard_4: (+1)
   \   000000C4   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    872                  																//取将一页写满或将未读入字节长度  
    873                  ContinuousArrayRead_Card(PageNum,PageOffset,(uint8_t *)&TargetBuf[BufOffset],LenTemp);	//取数 
   \                     ??ReadCard_5: (+1)
   \   000000C8   0x4643             MOV      R3,R8
   \   000000CA   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   000000CC   0xEB1A 0x0204      ADDS     R2,R10,R4
   \   000000D0   0x0039             MOVS     R1,R7
   \   000000D2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D4   0x0030             MOVS     R0,R6
   \   000000D6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D8   0x.... 0x....      BL       ContinuousArrayRead_Card
    874                          
    875                  BufOffset += LenTemp;
   \   000000DC   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000E0   0xEB18 0x0A0A      ADDS     R10,R8,R10
    876                  PageOffset += LenTemp;
   \   000000E4   0xEB18 0x0707      ADDS     R7,R8,R7
    877                  PageOffset %= l_CardPageSize;
   \   000000E8   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable17_3
   \   000000EE   0x6800             LDR      R0,[R0, #+0]
   \   000000F0   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   000000F8   0x6809             LDR      R1,[R1, #+0]
   \   000000FA   0xFB01 0x7710      MLS      R7,R1,R0,R7
    878                  
    879                  PageNum++; 
   \   000000FE   0x1C76             ADDS     R6,R6,#+1
    880              }
   \   00000100   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000104   0xE7BC             B.N      ??ReadCard_2
    881              
    882              //NOP(); 
    883              return  TRUE;	                                                    //正确                   
   \                     ??ReadCard_3: (+1)
   \   00000106   0x2001             MOVS     R0,#+1
   \                     ??ReadCard_1: (+1)
   \   00000108   0xB005             ADD      SP,SP,#+20
   \   0000010A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    884          }
    885          
    886          //---------------------------------------------------------------------
    887          //名    称：   uint8_t WriteCardPartPage(uint16 PageNum,SegmentNum,uint8_t *Buf,uint32 Len)
    888          
    889          //功    能：   写页中的一部分,要求SegmentNum+Len <= l_CardPageSize
    890          //入口参数：   PageNum  页号        地址：0~Sizeof(IC)
    891          //             Buf:     数据缓冲    
    892          //出口参数：   写成功
    893          //----------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    894          uint8_t WriteCardPage(uint16 PageNum,uint16 SegmentNum,uint8_t *Buf,uint32 Len)
    895          {
   \                     WriteCardPage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x6D81      SUB      SP,SP,#+1032
   \   00000008   0x0004             MOVS     R4,R0
   \   0000000A   0x000D             MOVS     R5,R1
   \   0000000C   0x0016             MOVS     R6,R2
   \   0000000E   0x001F             MOVS     R7,R3
    896              uint8_t   IC_BufTemp[256*4];  
    897          
    898              if(PageNum > l_CardPageNum || (SegmentNum + Len) > l_CardPageSize )
   \   00000010   0x....             LDR.N    R0,??DataTable17_5
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000016   0x42A0             CMP      R0,R4
   \   00000018   0xD305             BCC.N    ??WriteCardPage_0
   \   0000001A   0x....             LDR.N    R0,??DataTable17_3
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0x1979             ADDS     R1,R7,R5
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD201             BCS.N    ??WriteCardPage_1
    899              {
    900                  return  FALSE;
   \                     ??WriteCardPage_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE049             B.N      ??WriteCardPage_2
    901              }     
    902              if(Len == l_CardPageSize)                                         //写完整页
   \                     ??WriteCardPage_1: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable17_3
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x4287             CMP      R7,R0
   \   00000030   0xD119             BNE.N    ??WriteCardPage_3
    903              {
    904                  BufferToMainMemoryPageProgramWithBuilt_inErase_Card(((l_CardBufNum++%2)+1),PageNum,0,Buf,l_CardPageSize);
   \   00000032   0x....             LDR.N    R0,??DataTable17_7
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x1C41             ADDS     R1,R0,#+1
   \   00000038   0x....             LDR.N    R2,??DataTable17_7
   \   0000003A   0x7011             STRB     R1,[R2, #+0]
   \   0000003C   0x....             LDR.N    R1,??DataTable17_3
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x9100             STR      R1,[SP, #+0]
   \   00000044   0x0033             MOVS     R3,R6
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xF05F 0x0C02      MOVS     R12,#+2
   \   00000052   0xFB90 0xFEFC      SDIV     LR,R0,R12
   \   00000056   0xFB0E 0x0E1C      MLS      LR,LR,R12,R0
   \   0000005A   0xF11E 0x0001      ADDS     R0,LR,#+1
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x.... 0x....      BL       BufferToMainMemoryPageProgramWithBuilt_inErase_Card
   \   00000064   0xE02A             B.N      ??WriteCardPage_4
    905              }
    906              else 
    907              {
    908                  ContinuousArrayRead_Card(PageNum, 0 , IC_BufTemp, l_CardPageSize); 				//IC卡读第PageNum页
   \                     ??WriteCardPage_3: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable17_3
   \   00000068   0x6803             LDR      R3,[R0, #+0]
   \   0000006A   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   0000006C   0xAA01             ADD      R2,SP,#+4
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000074   0x.... 0x....      BL       ContinuousArrayRead_Card
    909                  memcpy((uint8_t *)&IC_BufTemp[SegmentNum], Buf ,Len);                            //将数据填充
   \   00000078   0xA801             ADD      R0,SP,#+4
   \   0000007A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000007C   0xEB15 0x0800      ADDS     R8,R5,R0
   \   00000080   0x003A             MOVS     R2,R7
   \   00000082   0x0031             MOVS     R1,R6
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       __aeabi_memcpy
    910          
    911                  BufferToMainMemoryPageProgramWithBuilt_inErase_Card(((l_CardBufNum++%2)+1),PageNum,0,IC_BufTemp,l_CardPageSize);
   \   0000008A   0x....             LDR.N    R0,??DataTable17_7
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x1C41             ADDS     R1,R0,#+1
   \   00000090   0x....             LDR.N    R2,??DataTable17_7
   \   00000092   0x7011             STRB     R1,[R2, #+0]
   \   00000094   0x....             LDR.N    R1,??DataTable17_3
   \   00000096   0x6809             LDR      R1,[R1, #+0]
   \   00000098   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000009A   0x9100             STR      R1,[SP, #+0]
   \   0000009C   0xAB01             ADD      R3,SP,#+4
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x0021             MOVS     R1,R4
   \   000000A2   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A6   0xF05F 0x0C02      MOVS     R12,#+2
   \   000000AA   0xFB90 0xFEFC      SDIV     LR,R0,R12
   \   000000AE   0xFB0E 0x0E1C      MLS      LR,LR,R12,R0
   \   000000B2   0xF11E 0x0001      ADDS     R0,LR,#+1
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BufferToMainMemoryPageProgramWithBuilt_inErase_Card
    912              }
    913              
    914              //NOP();
    915              return  TRUE;    
   \                     ??WriteCardPage_4: (+1)
   \   000000BC   0x2001             MOVS     R0,#+1
   \                     ??WriteCardPage_2: (+1)
   \   000000BE   0xF50D 0x6D81      ADD      SP,SP,#+1032
   \   000000C2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    916          }
    917          
    918          //---------------------------------------------------------------------
    919          // 名    称：   WriteCard()
    920          // 功    能：   指定缓冲区数据编程。
    921          // 入口参数：   Addr    编程地址(内部地址)
    922          //						地址从00 ~ CARD_SIZE  
    923          //
    924          //              buf     编程数据缓冲区 注意：此为16位字
    925          
    926          //              Len     编程数据长度  以8位的写入数据为长度单位，相当于 Len 个字节数目
    927          
    928          // 出口参数：   返回TRUE表示操作成功，返回FALSE表示操作失败
    929          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    930          uint8_t WriteCard(uint32 Addr,uint8_t *SourceBuf,uint16 Len)
    931          {
   \                     WriteCard: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
    932              uint16	PageNum;                                                    //页
    933          	uint16	PageOffset;                                                 //页内地址
    934          	uint32  AddrTemp; 
    935          	uint16  WritePageTimes;                                             //写页次数       
    936          	uint16  LenTemp;                                                  	//长度         
    937          	uint16  i;
    938          	uint16  BufOffset = 0;
   \   0000000A   0xF05F 0x0A00      MOVS     R10,#+0
    939          	uint32	PageNoWriteSize;
    940          	uint32	BufNoWriteSize;
    941          	
    942          	AddrTemp =  Addr; 
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x4683             MOV      R11,R0
    943              AddrTemp += l_CardStartAddr;                                      	//映射到IC卡内部
   \   00000012   0x....             LDR.N    R0,??DataTable17_4
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0xEB10 0x0B0B      ADDS     R11,R0,R11
    944                        
    945              if(AddrTemp + Len > l_CardStartAddr + l_CardPageNum*l_CardPageSize)    
   \   0000001A   0x....             LDR.N    R0,??DataTable17_4
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable17_5
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x....             LDR.N    R2,??DataTable17_3
   \   00000024   0x6812             LDR      R2,[R2, #+0]
   \   00000026   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0xEB15 0x010B      ADDS     R1,R5,R11
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD201             BCS.N    ??WriteCard_0
    946              {
    947                 return  FALSE;                                                   //地址超阶
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE061             B.N      ??WriteCard_1
    948              }
    949          
    950              PageNum         = AddrTemp / l_CardPageSize ;                     	//求页
   \                     ??WriteCard_0: (+1)
   \   00000038   0x....             LDR.N    R0,??DataTable17_3
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   00000040   0x0006             MOVS     R6,R0
    951              PageOffset      = AddrTemp % l_CardPageSize ;                     	//求页内地址
   \   00000042   0x....             LDR.N    R0,??DataTable17_3
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xFBBB 0xF0F0      UDIV     R0,R11,R0
   \   0000004A   0x....             LDR.N    R1,??DataTable17_3
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0xFB01 0xB010      MLS      R0,R1,R0,R11
   \   00000052   0x0007             MOVS     R7,R0
    952              WritePageTimes  = (Len + PageOffset + (l_CardPageSize - 1)) / l_CardPageSize;            	//读页次数
   \   00000054   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000056   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000058   0x1978             ADDS     R0,R7,R5
   \   0000005A   0x....             LDR.N    R1,??DataTable17_3
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x1808             ADDS     R0,R1,R0
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable17_3
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000006A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    953              
    954              for(i = 0; i < WritePageTimes; i++)
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x4681             MOV      R9,R0
   \                     ??WriteCard_2: (+1)
   \   00000072   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   00000076   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007A   0x4581             CMP      R9,R0
   \   0000007C   0xD23D             BCS.N    ??WriteCard_3
    955              {
    956              	//SysFastHoldTast();
    957          
    958                  PageNoWriteSize = 	l_CardPageSize - (PageOffset + BufOffset)
    959                  					 % l_CardPageSize;							//计算IC卡一页内未写地址
   \   0000007E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000080   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   00000084   0xEB1A 0x0107      ADDS     R1,R10,R7
   \   00000088   0x....             LDR.N    R0,??DataTable17_3
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1A40             SUBS     R0,R0,R1
   \   0000008E   0x....             LDR.N    R2,??DataTable17_3
   \   00000090   0x6812             LDR      R2,[R2, #+0]
   \   00000092   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   00000096   0x....             LDR.N    R2,??DataTable17_3
   \   00000098   0x6812             LDR      R2,[R2, #+0]
   \   0000009A   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000009E   0x9001             STR      R0,[SP, #+4]
    960                  BufNoWriteSize	=	Len - BufOffset;							//缓冲区未写字节长度
   \   000000A0   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   000000A2   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000A6   0xEBB5 0x000A      SUBS     R0,R5,R10
   \   000000AA   0x9000             STR      R0,[SP, #+0]
    961                  LenTemp = (PageNoWriteSize < BufNoWriteSize ? PageNoWriteSize:BufNoWriteSize);
   \   000000AC   0x9801             LDR      R0,[SP, #+4]
   \   000000AE   0x9900             LDR      R1,[SP, #+0]
   \   000000B0   0x4288             CMP      R0,R1
   \   000000B2   0xD202             BCS.N    ??WriteCard_4
   \   000000B4   0xF8DD 0x8004      LDR      R8,[SP, #+4]
   \   000000B8   0xE001             B.N      ??WriteCard_5
   \                     ??WriteCard_4: (+1)
   \   000000BA   0xF8DD 0x8000      LDR      R8,[SP, #+0]
    962                  																//取将一页写满或将缓冲共写完字节长度
    963                  WriteCardPage(PageNum,PageOffset,(uint8_t *)&SourceBuf[BufOffset],LenTemp);     //取数 
   \                     ??WriteCard_5: (+1)
   \   000000BE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000C2   0x4643             MOV      R3,R8
   \   000000C4   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   000000C8   0xEB1A 0x0204      ADDS     R2,R10,R4
   \   000000CC   0x0039             MOVS     R1,R7
   \   000000CE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D0   0x0030             MOVS     R0,R6
   \   000000D2   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000D4   0x.... 0x....      BL       WriteCardPage
    964          
    965                  BufOffset += LenTemp;
   \   000000D8   0xEB18 0x0A0A      ADDS     R10,R8,R10
    966                  PageOffset += LenTemp;
   \   000000DC   0xEB18 0x0707      ADDS     R7,R8,R7
    967                  PageOffset %= l_CardPageSize;
   \   000000E0   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000E2   0x....             LDR.N    R0,??DataTable17_3
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xFBB7 0xF0F0      UDIV     R0,R7,R0
   \   000000EA   0x....             LDR.N    R1,??DataTable17_3
   \   000000EC   0x6809             LDR      R1,[R1, #+0]
   \   000000EE   0xFB01 0x7710      MLS      R7,R1,R0,R7
    968                  
    969                  PageNum++; 
   \   000000F2   0x1C76             ADDS     R6,R6,#+1
    970              }
   \   000000F4   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000F8   0xE7BB             B.N      ??WriteCard_2
    971          
    972              return  TRUE;	                                                    //正确  
   \                     ??WriteCard_3: (+1)
   \   000000FA   0x2001             MOVS     R0,#+1
   \                     ??WriteCard_1: (+1)
   \   000000FC   0xB005             ADD      SP,SP,#+20
   \   000000FE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    973          }
    974          
    975          //---------------------------------------------------------------------
    976          // 名    称：   uint32 GetToEndLen(uint32 Addr)
    977          // 功    能：   指定到指定地址到卡的结束的长度
    978          // 入口参数：   Addr    指定地址
    979          // 出口参数：   返回长度
    980          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    981          uint32 GetToEndLen(uint32 Addr)
    982          {
    983          	return	(l_CardStartAddr + l_CardPageNum*l_CardPageSize - Addr);
   \                     GetToEndLen: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable17_4
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x....             LDR.N    R2,??DataTable17_5
   \   00000006   0x6812             LDR      R2,[R2, #+0]
   \   00000008   0x....             LDR.N    R3,??DataTable17_3
   \   0000000A   0x681B             LDR      R3,[R3, #+0]
   \   0000000C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000010   0x1A08             SUBS     R0,R1,R0
   \   00000012   0x4770             BX       LR               ;; return
    984          }
    985          

   \                                 In section .bss, align 1
    986          static	uint8_t   mPlugInFlg = NO_PLUG_IN_CARD;                     		//卡片插入标识
   \                     mPlugInFlg:
   \   00000000                      DS8 1
    987          

   \                                 In section .bss, align 4
    988          static uint32   mPlugTime  = 0;											//没有插卡次数
   \                     mPlugTime:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    989          static uint32   mNoPlugTime= 0;
   \                     mNoPlugTime:
   \   00000000                      DS8 4
    990          

   \                                 In section .data, align 1
    991          uint8_t		l_CardErrorFlg = NO_ERROR;
   \                     l_CardErrorFlg:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    992          uint8_t		l_LongTimePlugCardErrFlg = NO_ERROR;
   \                     l_LongTimePlugCardErrFlg:
   \   00000000   0x01               DC8 1
    993          
    994          //---------------------------------------------------------------------
    995          // 名    称：   void   PlugCard( void )
    996          // 功    能：   判断是否有卡片插入
    997          // 入口参数：   无
    998          // 出口参数：   无
    999          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1000          void   PlugCard( void )
   1001          {
   \                     PlugCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1002              if(ReadIC_SWT() == 1)                               //判断是否插入卡片
   \   00000002   0x.... 0x....      BL       ReadIC_SWT
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10F             BNE.N    ??PlugCard_0
   1003              {
   1004                  mPlugTime++;                                   	//判卡次数
   \   0000000A   0x....             LDR.N    R0,??DataTable17_8
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x....             LDR.N    R1,??DataTable17_8
   \   00000012   0x6008             STR      R0,[R1, #+0]
   1005          
   1006                  if( mPlugTime > 20)                          	//去抖动,是否插入卡片
   \   00000014   0x....             LDR.N    R0,??DataTable17_8
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2815             CMP      R0,#+21
   \   0000001A   0xD318             BCC.N    ??PlugCard_1
   1007                  {
   1008                      mPlugInFlg = PLUG_IN_CARD;              	//有卡
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable17_9
   \   00000020   0x7008             STRB     R0,[R1, #+0]
   1009                      
   1010                      mNoPlugTime = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable17_10
   \   00000026   0x6008             STR      R0,[R1, #+0]
   \   00000028   0xE011             B.N      ??PlugCard_1
   1011                  }
   1012              }
   1013              else
   1014              {            
   1015                  mNoPlugTime++;                                   //判卡次数
   \                     ??PlugCard_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable17_10
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x....             LDR.N    R1,??DataTable17_10
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1016          
   1017                  if( mNoPlugTime > 20)                            //去抖动,是否插入卡片
   \   00000034   0x....             LDR.N    R0,??DataTable17_10
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x2815             CMP      R0,#+21
   \   0000003A   0xD308             BCC.N    ??PlugCard_1
   1018                  {
   1019                      mPlugInFlg = NO_PLUG_IN_CARD;             	//无卡
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable17_9
   \   00000040   0x7008             STRB     R0,[R1, #+0]
   1020          
   1021                    	l_LongTimePlugCardErrFlg = NO_ERROR;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable17_11
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   1022          
   1023                      mPlugTime = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x....             LDR.N    R1,??DataTable17_8
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1024                      
   1025                	//	ReStartPluse();							//开柴速测量
   1026                  }
   1027              }
   1028              
   1029              ////printfcom0("\r\n mPlugInFlg %d",mPlugInFlg);
   1030          }
   \                     ??PlugCard_1: (+1)
   \   0000004E   0xBD01             POP      {R0,PC}          ;; return
   1031          
   1032          
   1033          //---------------------------------------------------------------------
   1034          // 名    称：   void   HoldCard( void )
   1035          // 功    能：   IC卡插入维护
   1036          // 入口参数：   无
   1037          // 出口参数：   无
   1038          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1039          void   HoldCard( void )
   1040          {
   \                     HoldCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1041          	PlugCard();
   \   00000002   0x.... 0x....      BL       PlugCard
   1042          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1043          
   1044          //---------------------------------------------------------------------
   1045          // 名    称：   uint8_t   GetPlugFlg()
   1046          // 功    能：   返回插卡标志
   1047          // 入口参数：   无
   1048          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
   1049          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1050          uint32   GetPlugTime(void)
   1051          {
   1052              return  mPlugTime;
   \                     GetPlugTime: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable17_8
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1053          }
   1054          
   1055          //extern	void ClosePluseInput(void);
   1056          //---------------------------------------------------------------------
   1057          // 名    称：   uint8_t   GetPlugFlg()
   1058          // 功    能：   返回插卡标志
   1059          // 入口参数：   无
   1060          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
   1061          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1062          uint8_t   GetPlugFlg(void)
   1063          {
   \                     GetPlugFlg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1064          	if(mPlugInFlg == NO_PLUG_IN_CARD)
   \   00000002   0x....             LDR.N    R0,??DataTable17_9
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE.N    ??GetPlugFlg_0
   1065          	{
   1066          		WritePOW_IC( 1 );								//关电源
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       WritePOW_IC
   \   00000010   0xE002             B.N      ??GetPlugFlg_1
   1067          	}
   1068          	else
   1069          	{
   1070          		WritePOW_IC( 0 );								//开电源
   \                     ??GetPlugFlg_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       WritePOW_IC
   1071          	}
   1072          		
   1073              return  mPlugInFlg;
   \                     ??GetPlugFlg_1: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable17_9
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   1074          }
   1075          
   1076          //---------------------------------------------------------------------
   1077          // 名    称：   uint8_t   GetPlugFlg()
   1078          // 功    能：   返回插卡标志
   1079          // 入口参数：   无
   1080          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
   1081          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1082          void   ResetPlugFlgEvt(void)
   1083          {
   1084              //mPlugInFlg = NO_PLUG_IN_CARD;						//卡拔表示自动判断
   1085          }
   \                     ResetPlugFlgEvt: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1086          
   1087          //---------------------------------------------------------------------
   1088          // 名    称：   void   LongTimePlugCard( void )
   1089          // 功    能：   长时间插入IC卡错误
   1090          // 入口参数：   无
   1091          // 出口参数：   无
   1092          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1093          uint8_t   LongTimePlugCard( void )
   1094          {
   \                     LongTimePlugCard: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1095          	l_LongTimePlugCardErrFlg = NO_ERROR;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable17_11
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1096          	
   1097          	if(GetPlugTime() > 10*60*100)
   \   00000008   0x.... 0x....      BL       GetPlugTime
   \   0000000C   0xF64E 0x2161      MOVW     R1,#+60001
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD302             BCC.N    ??LongTimePlugCard_0
   1098          	{
   1099          		l_LongTimePlugCardErrFlg = ERROR;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable17_11
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   1100          	}
   1101          	
   1102          	return	l_LongTimePlugCardErrFlg;
   \                     ??LongTimePlugCard_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable17_11
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0xBD02             POP      {R1,PC}          ;; return
   1103          }
   1104          
   1105          //---------------------------------------------------------------------
   1106          // 名    称：   void   GetLongTimePlugCardErrFlg( void )
   1107          // 功    能：   长时间插入IC卡错误
   1108          // 入口参数：   无
   1109          // 出口参数：   无
   1110          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1111          uint8_t   GetLongTimePlugCardErrFlg( void )
   1112          {
   1113          	return	l_LongTimePlugCardErrFlg;
   \                     GetLongTimePlugCardErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable17_11
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1114          }
   1115          
   1116          
   1117          //void	ReStartPluse(void);										//关柴速测量
   1118          //---------------------------------------------------------------------
   1119          // 名    称：   uint8_t   PlugICCard(void)
   1120          // 功    能：   判断是否插入IC卡
   1121          // 入口参数：   无
   1122          // 出口参数：   TRUE:有卡插入,FALSE:无卡插入 
   1123          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1124          uint8_t PlugICCard(void)
   1125          {
   \                     PlugICCard: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1126          	uint8_t	CardSta;
   1127          	uint8_t	Flg;
   1128          	uint8_t	Times;
   1129          
   1130              Times 	= 3; 
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x0006             MOVS     R6,R0
   1131              Flg 	= FALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x0005             MOVS     R5,R0
   1132                        
   1133              while(Times-- && Flg == FALSE) 							//判断3次
   \                     ??PlugICCard_0: (+1)
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x1E46             SUBS     R6,R0,#+1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD03B             BEQ.N    ??PlugICCard_1
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD138             BNE.N    ??PlugICCard_1
   1134              {        
   1135          	    NOP();
   \   0000001A   0x.... 0x....      BL       `NOP`
   1136          		if(GetPlugFlg() == PLUG_IN_CARD)					//有卡插入
   \   0000001E   0x.... 0x....      BL       GetPlugFlg
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD12D             BNE.N    ??PlugICCard_2
   1137          	    {
   1138          	    	WritePOW_IC( 0 );								//开电源
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       WritePOW_IC
   1139          
   1140          			DelayX10ms(20);
   \   0000002C   0x2014             MOVS     R0,#+20
   \   0000002E   0x.... 0x....      BL       DelayX10ms
   1141          							
   1142          			CardSta = StatusRegisterRead_Card();			//读IC卡状态
   \   00000032   0x.... 0x....      BL       StatusRegisterRead_Card
   \   00000036   0x0004             MOVS     R4,R0
   1143          			
   1144          			if(	(	((CardSta & AT45DB041) == AT45DB041) 
   1145          				|| 	((CardSta & AT45DB161) == AT45DB161)
   1146          		 		|| 	((CardSta & AT45DB321) == AT45DB321)
   1147          		 		|| 	((CardSta & AT45DB642) == AT45DB642))
   1148          				&& 	( CardSta != 0xff) )
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0xF014 0x001C      ANDS     R0,R4,#0x1C
   \   0000003E   0x281C             CMP      R0,#+28
   \   00000040   0xD00E             BEQ.N    ??PlugICCard_3
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0xF014 0x002C      ANDS     R0,R4,#0x2C
   \   00000048   0x282C             CMP      R0,#+44
   \   0000004A   0xD009             BEQ.N    ??PlugICCard_3
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0xF014 0x0034      ANDS     R0,R4,#0x34
   \   00000052   0x2834             CMP      R0,#+52
   \   00000054   0xD004             BEQ.N    ??PlugICCard_3
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0xF014 0x003C      ANDS     R0,R4,#0x3C
   \   0000005C   0x283C             CMP      R0,#+60
   \   0000005E   0xD10A             BNE.N    ??PlugICCard_4
   \                     ??PlugICCard_3: (+1)
   \   00000060   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000062   0x2CFF             CMP      R4,#+255
   \   00000064   0xD007             BEQ.N    ??PlugICCard_4
   1149          			{
   1150          				l_CardErrorFlg = NO_ERROR;					//清卡类型错误
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable17_12
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   1151          				
   1152          				InitCardInfo();								//初始化卡信息
   \   0000006C   0x.... 0x....      BL       InitCardInfo
   1153          
   1154          				Flg = TRUE; 								//返回1	
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0x0005             MOVS     R5,R0
   1155          				break;		
   \   00000074   0xE00A             B.N      ??PlugICCard_1
   1156          			}	
   1157          			else
   1158          			{		 
   1159          				l_CardErrorFlg = ERROR;						//置卡错误
   \                     ??PlugICCard_4: (+1)
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x....             LDR.N    R1,??DataTable17_12
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
   1160          				
   1161          				Flg = FALSE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0005             MOVS     R5,R0
   \   00000080   0xE7C3             B.N      ??PlugICCard_0
   1162          			}	
   1163          
   1164          		}
   1165          		else
   1166          		{
   1167          			l_CardErrorFlg = NO_ERROR;							//卡类
   \                     ??PlugICCard_2: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x....             LDR.N    R1,??DataTable17_12
   \   00000086   0x7008             STRB     R0,[R1, #+0]
   1168          			
   1169          			Flg = FALSE;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x0005             MOVS     R5,R0
   1170          
   1171          			break;	
   1172          		}
   1173          	}
   1174          	
   1175          	if(Flg == FALSE)
   \                     ??PlugICCard_1: (+1)
   \   0000008C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008E   0x2D00             CMP      R5,#+0
   \   00000090   0xD102             BNE.N    ??PlugICCard_5
   1176          	{
   1177          		WritePOW_IC( 1 );										//非卡，关电源
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x.... 0x....      BL       WritePOW_IC
   1178          	}
   1179          	
   1180          	return 	Flg;
   \                     ??PlugICCard_5: (+1)
   \   00000098   0x0028             MOVS     R0,R5
   \   0000009A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
   1181          }
   1182          
   1183          //---------------------------------------------------------------------
   1184          // 名    称：   uint8_t   GetCardErrorFlg()
   1185          // 功    能：   返回插卡错误标志
   1186          // 入口参数：   无
   1187          // 出口参数：   TRUE:插入卡类型正确,FALSE:插入卡类型错误 
   1188          //---------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1189          uint8_t   GetCardErrorFlg(void)
   1190          {
   1191              return  l_CardErrorFlg;
   \                     GetCardErrorFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable17_12
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   1192          }
   1193          
   1194          #define		RIGHT_DATA					0xff
   1195          #define		CARD_TYPE_ERR				62
   1196          #define		CARD_PLUG_LONG_TIME_ERR		61
   1197          #define		USB_TYPE_ERR				66
   1198          
   1199          extern	uint8_t	l_UsbErrFlg;
   1200          #define		ERR_USB_UNKNOWN 			0xFA
   1201          
   1202          //extern	uint8_t	TestCH376Host( void );
   1203          //-------------------------------------------------------------------------------------------------
   1204          //函数名称:            	uint8_t  JudgeCardError(void) 
   1205          //函数功能:             对IC卡的卡类型进行判断
   1206          //入口参数:            
   1207          //出口参数:             
   1208          //--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
   1209          uint8_t  JudgeCardError(void) 
   1210          {
   \                     JudgeCardError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1211          	uint8_t		ErrorType;
   1212          	
   1213          	#ifdef	HARD_VER_111122	
   1214          	static		uint32	Times = 0;
   1215          	#endif
   1216          	
   1217          	ErrorType = RIGHT_DATA;
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x0004             MOVS     R4,R0
   1218          	
   1219          	if(GetCardErrorFlg() == ERROR)
   \   00000006   0x.... 0x....      BL       GetCardErrorFlg
   1220          	{
   1221          //		ErrorType = CARD_TYPE_ERR;
   1222          	}
   1223          	
   1224          	if(GetLongTimePlugCardErrFlg() == ERROR)
   \   0000000A   0x.... 0x....      BL       GetLongTimePlugCardErrFlg
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??JudgeCardError_0
   1225          	{
   1226          		ErrorType = CARD_PLUG_LONG_TIME_ERR;
   \   00000012   0x203D             MOVS     R0,#+61
   \   00000014   0x0004             MOVS     R4,R0
   1227          	}
   1228          	
   1229          	#ifdef	HARD_VER_111122	
   1230          	if(TestCH376Host() == ERR_USB_UNKNOWN)
   1231          	{
   1232          		if(Times++ < 10)
   1233          		{
   1234          			mInitCH376Host();
   1235          		}
   1236          
   1237          		ErrorType = USB_TYPE_ERR;
   1238          	}
   1239          	else
   1240          	{
   1241          		Times = 0;
   1242          	}
   1243          	#endif
   1244          	
   1245          	return	ErrorType;
   \                     ??JudgeCardError_0: (+1)
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
   1246          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40088000         DC32     0x40088000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x4008800C         DC32     0x4008800c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40088008         DC32     0x40088008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     l_CardPageSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     l_CardStartAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     l_CardPageNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     l_CardTypeFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     l_CardBufNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     mPlugTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     mPlugInFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     mNoPlugTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     l_LongTimePlugCardErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     l_CardErrorFlg
   1247          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   BufferRead_Card
        32   -> MainMemoryToBuff
        32   -> RevByte_SPI
        32   -> SentByte_SPI
        32   -> StatusRegisterRead_Card
        32   -> WriteCS_IC
      32   BufferToMainMemoryPageProgramWithBuilt_inErase_Card
        32   -> BufferWrite_Card
        32   -> SentByte_SPI
        32   -> StatusRegisterRead_Card
        32   -> WriteCS_IC
      24   BufferWrite_Card
        24   -> SentByte_SPI
        24   -> WriteCS_IC
      24   ContinuousArrayRead_Card
        24   -> RevByte_SPI
        24   -> SentByte_SPI
        24   -> StatusRegisterRead_Card
        24   -> WriteCS_IC
       0   GetCardErrorFlg
       0   GetCardPageSize
       0   GetLongTimePlugCardErrFlg
       8   GetPlugFlg
         8   -> WritePOW_IC
       0   GetPlugTime
       0   GetToEndLen
       8   HoldCard
         8   -> PlugCard
       8   InitCardIO
         8   -> GPIO_PinselConfig
         8   -> SSP0_Init
       8   InitCardInfo
         8   -> StatusRegisterRead_Card
       8   JudgeCardError
         8   -> GetCardErrorFlg
         8   -> GetLongTimePlugCardErrFlg
       8   LongTimePlugCard
         8   -> GetPlugTime
      16   MainMemoryToBuff
        16   -> SentByte_SPI
        16   -> StatusRegisterRead_Card
        16   -> WriteCS_IC
       8   PlugCard
         8   -> ReadIC_SWT
      16   PlugICCard
        16   -> DelayX10ms
        16   -> GetPlugFlg
        16   -> InitCardInfo
        16   -> NOP
        16   -> StatusRegisterRead_Card
        16   -> WritePOW_IC
      56   ReadCard
        56   -> ContinuousArrayRead_Card
       8   ReadIC_SWT
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadMISO_IC
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadMOSI_IC
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadSCK_IC
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   RecByte_SPI_IC
         8   -> SendOrRecByte_SPI_IC
       0   ResetPlugFlgEvt
       8   RevByte_SPI
         8   -> RecByte_SPI_IC
      32   SSP0_Init
        32   -> SSP_Cmd
        32   -> SSP_ConfigStructInit
        32   -> SSP_Init
       8   SendByte_SPI_IC
         8   -> SendOrRecByte_SPI_IC
       0   SendOrRecByte_SPI_IC
       8   SentByte_SPI
         8   -> SendByte_SPI_IC
       8   StatusRegisterRead_Card
         8   -> RevByte_SPI
         8   -> SentByte_SPI
         8   -> WriteCS_IC
       8   WriteCS_IC
         8   -> GPIO_PinselConfig
         8   -> GPIO_SetOrClearValue
         8   -> nop
      56   WriteCard
        56   -> WriteCardPage
    1056   WriteCardPage
      1056   -> BufferToMainMemoryPageProgramWithBuilt_inErase_Card
      1056   -> ContinuousArrayRead_Card
      1056   -> __aeabi_memcpy
       8   WriteIC_RST
         8   -> GPIO_PinselConfig
         8   -> GPIO_SetOrClearValue
       8   WriteIC_SWT
         8   -> GPIO_SetOrClearValue
       8   WriteMISO_IC
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteMOSI_IC
         8   -> GPIO_SetOrClearValue
       8   WritePOW_IC
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteSCK_IC
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteSoftSpiCSIC
         8   -> GPIO_SetOrClearValue
         8   -> nop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
     158  BufferRead_Card
     244  BufferToMainMemoryPageProgramWithBuilt_inErase_Card
     114  BufferWrite_Card
     292  ContinuousArrayRead_Card
       6  GetCardErrorFlg
       8  GetCardPageSize
       6  GetLongTimePlugCardErrFlg
      30  GetPlugFlg
       6  GetPlugTime
      20  GetToEndLen
       8  HoldCard
      48  InitCardIO
     200  InitCardInfo
      28  JudgeCardError
      32  LongTimePlugCard
     204  MainMemoryToBuff
      80  PlugCard
     158  PlugICCard
     270  ReadCard
      20  ReadIC_SWT
      20  ReadMISO_IC
      20  ReadMOSI_IC
      20  ReadSCK_IC
      14  RecByte_SPI_IC
       2  ResetPlugFlgEvt
      14  RevByte_SPI
      34  SSP0_Init
      14  SendByte_SPI_IC
      74  SendOrRecByte_SPI_IC
      16  SentByte_SPI
       1  Spi0FinishFlg
      44  StatusRegisterRead_Card
      46  WriteCS_IC
     258  WriteCard
     198  WriteCardPage
      38  WriteIC_RST
      30  WriteIC_SWT
      34  WriteMISO_IC
      30  WriteMOSI_IC
      38  WritePOW_IC
      34  WriteSCK_IC
      34  WriteSoftSpiCSIC
       1  l_CardBufNum
       1  l_CardErrorFlg
       4  l_CardPageNum
       4  l_CardPageSize
       4  l_CardStartAddr
       1  l_CardTypeFlg
       1  l_LongTimePlugCardErrFlg
       4  l_Spi0Len
       4  l_Spi0Point
       4  mNoPlugTime
       1  mPlugInFlg
       4  mPlugTime

 
    31 bytes in section .bss
     3 bytes in section .data
 2 996 bytes in section .text
 
 2 996 bytes of CODE memory
    34 bytes of DATA memory

Errors: none
Warnings: 1
