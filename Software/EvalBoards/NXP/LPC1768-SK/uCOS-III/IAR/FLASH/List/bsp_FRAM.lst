###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Oct/2017  19:33:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-310统计模块\Software\BSP\Driver\bsp_FRAM.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\BSP\Driver\bsp_FRAM.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\bsp_FRAM.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\bsp_FRAM.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\BSP\Driver\bsp_FRAM.c
      1          /*******************************************************************************
      2           *   Filename:      bsp_FRAM.c
      3           *   Revised:       $Date: 2017-05-15$
      4           *   Revision:      $
      5           *   Writer:	    redmorningcn.
      6           *
      7           *   Description:
      8           *   Notes:
      9           *     				E-mail:redmorningcn@qq.com
     10           *
     11           *   All copyrights reserved to redmorningcn.
     12           *
     13           *******************************************************************************/
     14          
     15          /*******************************************************************************
     16          * INCLUDES
     17          */
     18          #include <includes.h>
     19          #include "bsp_FRAM.h"
     20          #include "App_ctrl.h"
     21          
     22          
     23          
     24          /***********************************************
     25          * 描述: OS接口
     26          */
     27          #if UCOS_EN     == DEF_ENABLED
     28              #if OS_VERSION > 30000U
     29              static  OS_SEM			Bsp_Fram_Sem;    	//信号量
     30              #else
     31              static  OS_EVENT		*Bsp_Fram_Sem;    //信号量
     32              #endif
     33          #endif
     34              
     35          
     36          #if (UCOS_EN     == DEF_ENABLED)
     37          /*******************************************************************************
     38          * 名    称： 		FRAM_WaitEvent
     39          * 功    能： 		等待信号量
     40          * 入口参数： 	无
     41          * 出口参数：  	0（操作有误），1（操作成功）
     42          * 作　 　者： 	redmorningcn
     43          * 创建日期： 	2017-05-15
     44          * 修    改：
     45          * 修改日期：
     46          * 备    注： 仅在使用UCOS操作系统时使用
     47          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     48          static uint8_t FRAM_WaitEvent(void)
     49          {
     50              /***********************************************
     51              * 描述： OS接口
     52              */
     53          
     54          //#if OS_VERSION > 30000U
     55          //    return BSP_OS_SemWait(&Bsp_Fram_Sem,0);           	// 等待信号量
     56          //#else
     57          //    uint8_t       err;
     58          //    OSSemPend(Bsp_Fram_Sem,0,&err);                   		// 等待信号量
     59          //    if ( err = OS_ERR_NONE )
     60          //      return TRUE;
     61          //    else
     62          //      return FALSE;
     63          //#endif
     64          }
   \                     FRAM_WaitEvent: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     65          
     66          /*******************************************************************************
     67          * 名    称：	 	FRAM_SendEvent
     68          * 功    能： 		释放信号量
     69          * 入口参数： 	无
     70          * 出口参数： 	无
     71          * 作　 　者： 	redmorningcn
     72          * 创建日期： 	2017-05-15
     73          * 修    改：
     74          * 修改日期：
     75          * 备    注： 仅在使用UCOS操作系统时使用
     76          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     77          static void FRAM_SendEvent(void)
     78          {
     79          //    /***********************************************
     80          //    * 描述： OS接口
     81          //    */
     82          //#if OS_VERSION > 30000U
     83          //    BSP_OS_SemPost(&Bsp_Fram_Sem);                        	// 发送信号量
     84          //#else
     85          //    uint8_t       err;
     86          //    OSSemPost(Bsp_Fram_Sem);                             		 // 发送信号量
     87          //#endif
     88          }
   \                     FRAM_SendEvent: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     89          
     90          #endif /* end of (UCOS_EN     == DEF_ENABLED)*/
     91          
     92          
     93          //-------------------------------------------------------------------------------------------------------
     94          //函数名称: 		WriteFM24CL16()
     95          //功    能:			对FM24CL16指定地址进行写数据
     96          //入口参数:         ADDR:       操作地址    地址：0 ~ sizeof(FM24CL16)
     97          //                  		*DataBuf:   数据缓冲
     98          //                  Len: 	数据长度
     99          //作　 　者： 	redmorningcn
    100          //创建日期： 	2017-05-15
    101          //出口参数:    	无
    102          //说明：            
    103          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    104          uint8 WriteFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
    105          {
   \                     WriteFM24CL64: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    106              uint32  i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    107              uint8   SlaveAddr;                                      //从机地址
    108              uint16  AddrTemp = 0;                                   //地址缓存
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    109              
    110              AddrTemp = Addr;
   \   00000010   0x46A1             MOV      R9,R4
    111              AddrTemp += FRAM_START_ADDR;                            //计算地址
    112          
    113              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   00000012   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000016   0xEB16 0x0009      ADDS     R0,R6,R9
   \   0000001A   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000001E   0xD901             BLS.N    ??WriteFM24CL64_0
    114              {
    115                  return  FALSE;                                      			//地址未超阶
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE026             B.N      ??WriteFM24CL64_1
    116              }
    117                  
    118              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
   \                     ??WriteFM24CL64_0: (+1)
   \   00000024   0x20A0             MOVS     R0,#+160
   \   00000026   0x4680             MOV      R8,R0
    119              
    120              StartI2C();                                             //启动IIC总线
   \   00000028   0x.... 0x....      BL       StartI2C
    121              
    122              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64地址
   \   0000002C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       WriteByteWithI2C
    123              CheckSlaveAckI2C();
   \   00000036   0x.... 0x....      BL       CheckSlaveAckI2C
    124           
    125              WriteByteWithI2C(Addr >> 8);                            //写FM24CL64高位地址
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x0A00             LSRS     R0,R0,#+8
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      BL       WriteByteWithI2C
    126              CheckSlaveAckI2C();
   \   00000046   0x.... 0x....      BL       CheckSlaveAckI2C
    127              
    128              WriteByteWithI2C( Addr );                               //写FM24CL64低位地址
   \   0000004A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000004C   0x0020             MOVS     R0,R4
   \   0000004E   0x.... 0x....      BL       WriteByteWithI2C
    129              CheckSlaveAckI2C();     
   \   00000052   0x.... 0x....      BL       CheckSlaveAckI2C
    130            
    131              for(i = 0; i < DataBufLen; i++)                         //发送数据
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x0007             MOVS     R7,R0
   \                     ??WriteFM24CL64_2: (+1)
   \   0000005A   0x42B7             CMP      R7,R6
   \   0000005C   0xD206             BCS.N    ??WriteFM24CL64_3
    132              {
    133                  WriteByteWithI2C(DataBuf[i]);                       //写数据
   \   0000005E   0x5D78             LDRB     R0,[R7, R5]
   \   00000060   0x.... 0x....      BL       WriteByteWithI2C
    134                  CheckSlaveAckI2C();                                 //读从机应答信号
   \   00000064   0x.... 0x....      BL       CheckSlaveAckI2C
    135              }
   \   00000068   0x1C7F             ADDS     R7,R7,#+1
   \   0000006A   0xE7F6             B.N      ??WriteFM24CL64_2
    136              
    137              StopI2C();                                              //停止IIC操作   
   \                     ??WriteFM24CL64_3: (+1)
   \   0000006C   0x.... 0x....      BL       StopI2C
    138              
    139              return  TRUE;                                           //正确
   \   00000070   0x2001             MOVS     R0,#+1
   \                     ??WriteFM24CL64_1: (+1)
   \   00000072   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    140          }
    141          
    142          //-------------------------------------------------------------------------------------------------------
    143          //函数名称:         ReadFM24CL16()
    144          //功    能:         读取FM24CL16指定地址进行数据
    145          //入口参数:         ADDR:       操作地址   地址：0 ~ sizeof(FM24CL16)
    146          //                  *DataBuf:   数据缓冲 
    147          //                  Len:        数据长度
    148          //出口参数:         无
    149          //作　 　者： 	redmorningcn
    150          //创建日期： 	2017-05-15
    151          //说明：            
    152          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    153          uint8 ReadFM24CL64(uint16  Addr, uint8 *DataBuf, uint32 DataBufLen)            
    154          {
   \                     ReadFM24CL64: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    155              uint32  i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    156              uint8   SlaveAddr;                                      //从机地址
    157              uint16  AddrTemp;                                       //地址缓存
    158              
    159              AddrTemp = Addr;
   \   0000000C   0x46A1             MOV      R9,R4
    160              
    161              AddrTemp += FRAM_START_ADDR;                            //计算地址
    162              
    163              if( (uint16)AddrTemp + DataBufLen > FRAM_END_ADDR ) 
   \   0000000E   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000012   0xEB16 0x0009      ADDS     R0,R6,R9
   \   00000016   0xF5B0 0x5F00      CMP      R0,#+8192
   \   0000001A   0xD901             BLS.N    ??ReadFM24CL64_0
    164              {
    165                  return  FALSE;                                      //地址未超阶
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE037             B.N      ??ReadFM24CL64_1
    166              }
    167              
    168              SlaveAddr = FRAM_DIVICE_ADDR & (~(0x01));               //求FM24CL64设备写地址
   \                     ??ReadFM24CL64_0: (+1)
   \   00000020   0x20A0             MOVS     R0,#+160
   \   00000022   0x4680             MOV      R8,R0
    169              
    170              StartI2C();                                             //启动IIC总线
   \   00000024   0x.... 0x....      BL       StartI2C
    171              
    172              WriteByteWithI2C(SlaveAddr);                            //写FM24CL64设备写地址
   \   00000028   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x.... 0x....      BL       WriteByteWithI2C
    173              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000032   0x.... 0x....      BL       CheckSlaveAckI2C
    174              
    175              WriteByteWithI2C(Addr >> 8 );                           //写数据高位地址
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x0A00             LSRS     R0,R0,#+8
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x.... 0x....      BL       WriteByteWithI2C
    176              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000042   0x.... 0x....      BL       CheckSlaveAckI2C
    177              
    178              WriteByteWithI2C( Addr );                               //写数据低位地址
   \   00000046   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       WriteByteWithI2C
    179              CheckSlaveAckI2C();                                     //读从机应答信号
   \   0000004E   0x.... 0x....      BL       CheckSlaveAckI2C
    180                  
    181              SlaveAddr = (FRAM_DIVICE_ADDR)|(0x01);                  //求FM24CL64设备读地址
   \   00000052   0x20A1             MOVS     R0,#+161
   \   00000054   0x4680             MOV      R8,R0
    182              
    183              StartI2C();                                             //启动IIC总线
   \   00000056   0x.... 0x....      BL       StartI2C
    184              
    185              WriteByteWithI2C(SlaveAddr);                            //写FM24CL16地址
   \   0000005A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       WriteByteWithI2C
    186              CheckSlaveAckI2C();                                     //读从机应答信号
   \   00000064   0x.... 0x....      BL       CheckSlaveAckI2C
    187             
    188              for(i = 0; i < (DataBufLen -1); i++)                    //发送数据
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x0007             MOVS     R7,R0
   \                     ??ReadFM24CL64_2: (+1)
   \   0000006C   0x1E70             SUBS     R0,R6,#+1
   \   0000006E   0x4287             CMP      R7,R0
   \   00000070   0xD206             BCS.N    ??ReadFM24CL64_3
    189              {
    190                  DataBuf[i] = ReadByteWithI2C();                     //写数据
   \   00000072   0x.... 0x....      BL       ReadByteWithI2C
   \   00000076   0x5578             STRB     R0,[R7, R5]
    191                  MasterAckI2C();                                     //主机应答从机
   \   00000078   0x.... 0x....      BL       MasterAckI2C
    192              }
   \   0000007C   0x1C7F             ADDS     R7,R7,#+1
   \   0000007E   0xE7F5             B.N      ??ReadFM24CL64_2
    193              DataBuf[i] = ReadByteWithI2C();                         //写数据
   \                     ??ReadFM24CL64_3: (+1)
   \   00000080   0x.... 0x....      BL       ReadByteWithI2C
   \   00000084   0x5578             STRB     R0,[R7, R5]
    194              
    195              MasterNoAckI2C();                                       //主机应答从机
   \   00000086   0x.... 0x....      BL       MasterNoAckI2C
    196              
    197              StopI2C();
   \   0000008A   0x.... 0x....      BL       StopI2C
    198              
    199              return  TRUE;                                           //正确
   \   0000008E   0x2001             MOVS     R0,#+1
   \                     ??ReadFM24CL64_1: (+1)
   \   00000090   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    200          }
    201          
    202          
    203          //  RecNumMgr
    204          //
    205          //-------------------------------------------------------------------------------------------------------
    206          //函数名称	:       FRAM_StoreRecNumMgr()
    207          //功    		能	:       存储数据记录管理地址
    208          //入口参数	:       待存储的数据记录指针
    209          //出口参数  :       成功TURE，失败FALSE
    210          //作　 　者： 	redmorningcn
    211          //创建日期： 	2017-05-15
    212          //说		 明：            
    213          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    214          uint8 FRAM_StoreRecNumMgr(StrRecNumMgr  *SRecNumMgr)
    215          {
   \                     FRAM_StoreRecNumMgr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    216          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    217          	
    218          //	FRAM_WaitEvent();
    219              
    220              CPU_SR  cpu_sr;
    221          CPU_CRITICAL_ENTER() ;
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    222          	if(!WriteFM24CL64(FRAM_RECNUM_MGR_ADDR, (uint8 *)SRecNumMgr, sizeof(StrRecNumMgr)))		//存数据管理
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x.... 0x....      BL       WriteFM24CL64
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??FRAM_StoreRecNumMgr_0
    223          		flg = FALSE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0005             MOVS     R5,R0
    224          CPU_CRITICAL_EXIT();
   \                     ??FRAM_StoreRecNumMgr_0: (+1)
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       CPU_SR_Restore
    225          //	FRAM_SendEvent();
    226          	return	flg;
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    227          }
    228          
    229          
    230          //-------------------------------------------------------------------------------------------------------
    231          //函数名称	:      FRAM_ReadRecNumMgr()
    232          //功    		能	:      读数据记录管理指令
    233          //入口参数	:      待读取的数据记录的储存位置
    234          //出口参数  :      成功TURE，失败FALSE
    235          //作　 　者 ： 	redmorningcn
    236          //创建日期  ： 	2017-05-15
    237          //说		 明：  
    238          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    239          uint8 FRAM_ReadRecNumMgr(StrRecNumMgr  *SRecNumMgr)
    240          {
   \                     FRAM_ReadRecNumMgr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    241          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    242          	
    243          //	FRAM_WaitEvent();
    244              
    245              CPU_SR  cpu_sr;
    246          CPU_CRITICAL_ENTER() ;
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    247          	if(!ReadFM24CL64(FRAM_RECNUM_MGR_ADDR, (uint8 *)SRecNumMgr, sizeof(StrRecNumMgr)))		//读数据管理
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2004             MOVS     R0,#+4
   \   00000016   0x.... 0x....      BL       ReadFM24CL64
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE.N    ??FRAM_ReadRecNumMgr_0
    248          		flg = FALSE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0005             MOVS     R5,R0
    249          CPU_CRITICAL_EXIT();	
   \                     ??FRAM_ReadRecNumMgr_0: (+1)
   \   00000022   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000026   0x0030             MOVS     R0,R6
   \   00000028   0x.... 0x....      BL       CPU_SR_Restore
    250          //	FRAM_SendEvent();
    251          	return	flg;
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0xBD70             POP      {R4-R6,PC}       ;; return
    252          }
    253          
    254          //  ProductInfo
    255          //
    256          //-------------------------------------------------------------------------------------------------------
    257          //函数名称:       FRAM_StoreProductInfo()
    258          //功    能:       存产品信息
    259          //入口参数:      
    260          //出口参数:       
    261          //作　 　者： 	    redmorningcn
    262          //创建日期： 	    2017-05-15
    263          //说		 明：            
    264          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    265          uint8 FRAM_StoreProductInfo(StrProductInfo  *sProductInfo)
    266          {
   \                     FRAM_StoreProductInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    267          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    268          	
    269          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    270          	if(!WriteFM24CL64(FRAM_PRODUCT_INFO_ADDR, (uint8 *)sProductInfo, sizeof(StrProductInfo)))		
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x2014             MOVS     R0,#+20
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_StoreProductInfo_0
    271          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    272          	
    273          	FRAM_SendEvent();
   \                     ??FRAM_StoreProductInfo_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    274          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    275          }
    276          
    277          //-------------------------------------------------------------------------------------------------------
    278          //函数名称	:      FRAM_ReadProductInfo()
    279          //功    		能	:      读产品信息
    280          //入口参数	:      产品的
    281          //出口参数  :       
    282          //作　 　者 ： 	redmorningcn
    283          //创建日期  ： 	2017-05-15
    284          //说		 明：  
    285          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    286          uint8 FRAM_ReadProductInfo(StrProductInfo  *sProductInfo)
    287          {
   \                     FRAM_ReadProductInfo: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    289          	
    290          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    291          	if(!ReadFM24CL64(FRAM_PRODUCT_INFO_ADDR, (uint8 *)sProductInfo, sizeof(StrProductInfo)))		
   \   0000000A   0x220C             MOVS     R2,#+12
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x2014             MOVS     R0,#+20
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_ReadProductInfo_0
    292          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    293          	
    294          	FRAM_SendEvent();
   \                     ??FRAM_ReadProductInfo_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    295          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    296          }
    297          
    298          
    299          
    300          //  currecord
    301          //
    302          //-------------------------------------------------------------------------------------------------------
    303          //函数名称	:      FRAM_StoreCurRecord()
    304          //功    		能	:      存当前记录的 
    305          //入口参数	:      
    306          //出口参数  :       
    307          //作　 　者 ： 	redmorningcn
    308          //创建日期  ： 	2017-05-15
    309          //说		 明：            
    310          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    311          uint8 FRAM_StoreCurRecord(stcFlshRec  *sFlshRec)
    312          {
   \                     FRAM_StoreCurRecord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    313          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    314          	
    315          	//FRAM_WaitEvent();
    316          	if(!WriteFM24CL64(FRAM_REC_ADDR, (uint8 *)sFlshRec, sizeof(stcFlshRec)))		
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      BL       WriteFM24CL64
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??FRAM_StoreCurRecord_0
    317          		flg = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    318          	
    319          	//FRAM_SendEvent();
    320          	return	flg;
   \                     ??FRAM_StoreCurRecord_0: (+1)
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    321          }
    322          
    323          //-------------------------------------------------------------------------------------------------------
    324          //函数名称	:      FRAM_ReadProductInfo()
    325          //功    		能	:      读当前记录的 
    326          //入口参数	:      产品的
    327          //出口参数  :       
    328          //作　 　者 ： 	redmorningcn
    329          //创建日期  ： 	2017-05-15
    330          //说		 明：  
    331          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    332          uint8 FRAM_ReadCurRecord(stcFlshRec  *sFlshRec)
    333          {
   \                     FRAM_ReadCurRecord: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    334          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    335          	
    336          	//FRAM_WaitEvent();
    337          	if(!ReadFM24CL64(FRAM_REC_ADDR, (uint8 *)sFlshRec, sizeof(stcFlshRec)))		
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0021             MOVS     R1,R4
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      BL       ReadFM24CL64
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE.N    ??FRAM_ReadCurRecord_0
    338          		flg = FALSE;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0005             MOVS     R5,R0
    339          	
    340          	//FRAM_SendEvent();
    341          	return	flg;
   \                     ??FRAM_ReadCurRecord_0: (+1)
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    342          }
    343          
    344          //  oilpara
    345          //
    346          //-------------------------------------------------------------------------------------------------------
    347          //函数名称	:      FRAM_StoreOilPara()
    348          //功    		能	:      
    349          //入口参数	:      
    350          //出口参数  :       
    351          //作　 　者 ： 	redmorningcn
    352          //创建日期  ： 	2017-05-15
    353          //说		 明：            
    354          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    355          uint8 FRAM_StoreOilPara(StrOilPara  *SOilPara)
    356          {
   \                     FRAM_StoreOilPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    357          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    358          	
    359          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    360          	if(!WriteFM24CL64(FRAM_OIL_PARA_ADDR, (uint8 *)SOilPara, sizeof(StrOilPara)))		
   \   0000000A   0x2224             MOVS     R2,#+36
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x20A0             MOVS     R0,#+160
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_StoreOilPara_0
    361          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    362          	
    363          	FRAM_SendEvent();
   \                     ??FRAM_StoreOilPara_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    364          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    365          }
    366          
    367          //-------------------------------------------------------------------------------------------------------
    368          //函数名称	:      FRAM_ReadOilPara()
    369          //功    		能	:      
    370          //入口参数	:     
    371          //出口参数  :       
    372          //作　 　者 ： 	redmorningcn
    373          //创建日期  ： 	2017-05-15
    374          //说		 明：  
    375          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    376          uint8 FRAM_ReadOilPara(StrOilPara  *SOilPara)
    377          {
   \                     FRAM_ReadOilPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    378          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    379          	
    380          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    381          	if(!ReadFM24CL64(FRAM_OIL_PARA_ADDR, (uint8 *)SOilPara, sizeof(StrOilPara)))		
   \   0000000A   0x2224             MOVS     R2,#+36
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x20A0             MOVS     R0,#+160
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_ReadOilPara_0
    382          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    383          	
    384          	FRAM_SendEvent();
   \                     ??FRAM_ReadOilPara_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    385          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    386          }
    387          
    388          
    389          //  runpara
    390          //
    391          //-------------------------------------------------------------------------------------------------------
    392          //函数名称	:      FRAM_StoreRunPara()
    393          //功    		能	:      
    394          //入口参数	:      
    395          //出口参数  :       
    396          //作　 　者 ： 	redmorningcn
    397          //创建日期  ： 	2017-05-15
    398          //说		 明：            
    399          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    400          uint8 FRAM_StoreRunPara(stcRunPara  *sRunPara)
    401          {
   \                     FRAM_StoreRunPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    402          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    403          	
    404          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    405          	
    406          	if(!WriteFM24CL64(FRAM_RUN_PARA_ADDR, (uint8 *)sRunPara, sizeof(stcRunPara)))		
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x20C4             MOVS     R0,#+196
   \   00000010   0x.... 0x....      BL       WriteFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_StoreRunPara_0
    407          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    408          	
    409          	FRAM_SendEvent();
   \                     ??FRAM_StoreRunPara_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    410          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    411          }
    412          
    413          //-------------------------------------------------------------------------------------------------------
    414          //函数名称	:      FRAM_ReadRunPara()
    415          //功    		能	:      
    416          //入口参数	:     
    417          //出口参数  :       
    418          //作　 　者 ： 	redmorningcn
    419          //创建日期  ： 	2017-05-15
    420          //说		 明：  
    421          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    422          uint8 FRAM_ReadRunPara(stcRunPara  *sRunPara)
    423          {
   \                     FRAM_ReadRunPara: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    424          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    425          	
    426          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    427          	
    428          	if(!ReadFM24CL64(FRAM_RUN_PARA_ADDR, (uint8 *)sRunPara, sizeof(stcRunPara)))		
   \   0000000A   0x2208             MOVS     R2,#+8
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x20C4             MOVS     R0,#+196
   \   00000010   0x.... 0x....      BL       ReadFM24CL64
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE.N    ??FRAM_ReadRunPara_0
    429          		flg = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0005             MOVS     R5,R0
    430          	
    431          	FRAM_SendEvent();
   \                     ??FRAM_ReadRunPara_0: (+1)
   \   0000001C   0x.... 0x....      BL       FRAM_SendEvent
    432          	return	flg;
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    433          }
    434          
    435          //  calcmodel
    436          //
    437          //-------------------------------------------------------------------------------------------------------
    438          //函数名称	:      FRAM_StoreCalcModel()
    439          //功    		能	:      
    440          //入口参数	:      
    441          //出口参数  :       
    442          //作　 　者 ： 	redmorningcn
    443          //创建日期  ： 	2017-05-15
    444          //说		 明：            
    445          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    446          uint8 FRAM_StoreCalcModel(stcCalcModel  *sCalcModel)
    447          {
   \                     FRAM_StoreCalcModel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    448          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    449          	
    450          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    451          	
    452          	if(!WriteFM24CL64(FRAM_CALC_MODEL_ADDR, (uint8 *)sCalcModel, sizeof(stcCalcModel)))		
   \   0000000A   0xF44F 0x72CC      MOV      R2,#+408
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x20CC             MOVS     R0,#+204
   \   00000012   0x.... 0x....      BL       WriteFM24CL64
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??FRAM_StoreCalcModel_0
    453          		flg = FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0005             MOVS     R5,R0
    454          	
    455          	FRAM_SendEvent();
   \                     ??FRAM_StoreCalcModel_0: (+1)
   \   0000001E   0x.... 0x....      BL       FRAM_SendEvent
    456          	return	flg;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    457          }
    458          
    459          //-------------------------------------------------------------------------------------------------------
    460          //函数名称	:      FRAM_ReadRunPara()
    461          //功    		能	:      
    462          //入口参数	:     
    463          //出口参数  :       
    464          //作　 　者 ： 	redmorningcn
    465          //创建日期  ： 	2017-05-15
    466          //说		 明：  
    467          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    468          uint8 FRAM_ReadCalcModel(stcCalcModel  *sCalcModel)
    469          {
   \                     FRAM_ReadCalcModel: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    470          	uint8	flg = TRUE;
   \   00000004   0x2501             MOVS     R5,#+1
    471          	
    472          	FRAM_WaitEvent();
   \   00000006   0x.... 0x....      BL       FRAM_WaitEvent
    473          	
    474          	if(!ReadFM24CL64(FRAM_CALC_MODEL_ADDR, (uint8 *)sCalcModel, sizeof(stcCalcModel)))		
   \   0000000A   0xF44F 0x72CC      MOV      R2,#+408
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x20CC             MOVS     R0,#+204
   \   00000012   0x.... 0x....      BL       ReadFM24CL64
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD101             BNE.N    ??FRAM_ReadCalcModel_0
    475          		flg = FALSE;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0005             MOVS     R5,R0
    476          	
    477          	FRAM_SendEvent();
   \                     ??FRAM_ReadCalcModel_0: (+1)
   \   0000001E   0x.... 0x....      BL       FRAM_SendEvent
    478          	return	flg;
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    479          }
    480          
    481          //-------------------------------------------------------------------------------------------------------
    482          //函数名称	:      GetOilBoxModelsModel()
    483          //功         能	:  查找邮箱模型区域，寻找有效的油箱模型。 
    484          //入口参数	:     
    485          //出口参数  :       
    486          //作　 　者 ： 	redmorningcn
    487          //创建日期  ： 	2017-05-15
    488          //说		 明：  
    489          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    490          uint8	GetOilBoxModelsModel(stcModel * sModel)
    491          {
   \                     GetOilBoxModelsModel: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    492          	  uint32	i;
    493          	  uint32	ModelNumAdd;
    494          	  uint32	ModelAdd;
    495          	  uint8		ModelNum;
    496          	  uint16	CrcCheck;
    497          	  uint8		OilBoxTypCod;
    498          
    499          	  OilBoxTypCod	= GetOilBoxCod(); 
   \   00000006   0x.... 0x....      BL       GetOilBoxCod
   \   0000000A   0x4681             MOV      R9,R0
    500          
    501          	  for(i = 0; i < 18;i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0005             MOVS     R5,R0
   \                     ??GetOilBoxModelsModel_0: (+1)
   \   00000010   0x2D12             CMP      R5,#+18
   \   00000012   0xD22C             BCS.N    ??GetOilBoxModelsModel_1
    502          	  {
    503          	      ModelNumAdd =  OIL_BOX_MODEL_ADDR + sizeof(stcModel)*i + sizeof(stcModPot)*50 + 2 + 2;
   \   00000014   0x20D0             MOVS     R0,#+208
   \   00000016   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000001A   0xF600 0x009C      ADDW     R0,R0,#+2204
   \   0000001E   0x0006             MOVS     R6,R0
    504          
    505          		  ReadFM24CL64(ModelNumAdd,(uint8 *)&ModelNum, sizeof(ModelNum));
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       ReadFM24CL64
    506          
    507          //		  printfcom0("\r\n 11 OilBoxTypCod == ModelNum %d ,i = %d",ModelNum,i);
    508          
    509          		  if(OilBoxTypCod == ModelNum)
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000034   0x4581             CMP      R9,R0
   \   00000036   0xD118             BNE.N    ??GetOilBoxModelsModel_2
    510          		  {
    511          //		  	  printfcom0("\r\n 2OilBoxTypCod == ModelNum %d,i = %d",ModelNum,i);
    512          			  
    513          			  ModelAdd = OIL_BOX_MODEL_ADDR + sizeof(stcModel)*i;		  		
   \   00000038   0x20D0             MOVS     R0,#+208
   \   0000003A   0xFB00 0xF005      MUL      R0,R0,R5
   \   0000003E   0xF510 0x60FA      ADDS     R0,R0,#+2000
   \   00000042   0x0007             MOVS     R7,R0
    514          		      ReadFM24CL64(ModelAdd,(uint8 *)sModel,sizeof(stcModel));
   \   00000044   0x22D0             MOVS     R2,#+208
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x.... 0x....      BL       ReadFM24CL64
    515          //			  printfcom0("\r\n ModelAdd == ModelNum %d,i = %d",ModelAdd);
    516          //			  for(i = 0;i < sModel->PotNum;i++)
    517          //			  {
    518          //			  	printfcom0("\r\n  gaodu %d,youliang %d",sModel->sModPot[i].HigVal,sModel->sModPot[i].DipVal);
    519          //			  }
    520          
    521          			  CrcCheck = GetCrc16Check((uint8 *)sModel,sizeof(stcModel) - 2);
   \   00000050   0x21CE             MOVS     R1,#+206
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       GetCrc16Check
   \   00000058   0x4680             MOV      R8,R0
    522          
    523          			  if(CrcCheck == sModel->CrcCheck)
   \   0000005A   0xF8B4 0x00CE      LDRH     R0,[R4, #+206]
   \   0000005E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000062   0x4580             CMP      R8,R0
   \   00000064   0xD101             BNE.N    ??GetOilBoxModelsModel_2
    524          			  {
    525          			  	 //printfcom0("\r\n 3PotNum %d",sModel->PotNum);	
    526          			  	 return  1;
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE002             B.N      ??GetOilBoxModelsModel_3
    527          			  }
    528          		  }
    529          	  }
   \                     ??GetOilBoxModelsModel_2: (+1)
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \   0000006C   0xE7D0             B.N      ??GetOilBoxModelsModel_0
    530          
    531          	  return  0;
   \                     ??GetOilBoxModelsModel_1: (+1)
   \   0000006E   0x2000             MOVS     R0,#+0
   \                     ??GetOilBoxModelsModel_3: (+1)
   \   00000070   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    532          }
    533          
    534          //-------------------------------------------------------------------------------------------------------
    535          //函数名称	:      GetOilBoxModelsModelSemple()
    536          //功    		能	:     查找邮箱模型区域，寻找有效的油箱模型。  
    537          //入口参数	:     
    538          //出口参数  :       
    539          //作　 　者 ： 	redmorningcn
    540          //创建日期  ： 	2017-05-15
    541          //说		 明：  
    542          //--------------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    543          uint8	GetOilBoxModelsModelSemple(stcModelSemple * sModelSemple)
    544          {
   \                     GetOilBoxModelsModelSemple: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    545          	  uint32	i;
    546          	  uint32	ModelNumAdd;
    547          	  uint32	ModelAdd;
    548          	  uint8		ModelNum;
    549          	  uint16	CrcCheck;
    550          	  uint8		OilBoxTypCod;
    551          
    552          	  OilBoxTypCod	= GetOilBoxCod(); 
   \   00000006   0x.... 0x....      BL       GetOilBoxCod
   \   0000000A   0x4681             MOV      R9,R0
    553          
    554          	  for(i = 0; i < 46;i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x0005             MOVS     R5,R0
   \                     ??GetOilBoxModelsModelSemple_0: (+1)
   \   00000010   0x2D2E             CMP      R5,#+46
   \   00000012   0xD22B             BCS.N    ??GetOilBoxModelsModelSemple_1
    555          	  {
    556          		  ModelNumAdd =  OIL_BOX_MODEL_ADDR + sizeof(stcModel)*18 
    557          		  				+ sizeof(stcModelSemple)*i + sizeof(stcModPot)*10 + 2 + 2;
   \   00000014   0x2030             MOVS     R0,#+48
   \   00000016   0xF241 0x619C      MOVW     R1,#+5788
   \   0000001A   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000001E   0x0006             MOVS     R6,R0
    558          
    559          		  ReadFM24CL64(ModelNumAdd,(uint8 *)&ModelNum, sizeof(ModelNum));
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0x.... 0x....      BL       ReadFM24CL64
    560          
    561          		  //printfcom0("\r\n 22 OilBoxTypCod == ModelNum %d, %d",ModelNum,OilBoxTypCod);
    562          
    563          		  if(OilBoxTypCod == ModelNum)
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000034   0x4581             CMP      R9,R0
   \   00000036   0xD117             BNE.N    ??GetOilBoxModelsModelSemple_2
    564          		  {
    565          			  ModelAdd = OIL_BOX_MODEL_ADDR + sizeof(stcModel)*18  
    566          			  			+ sizeof(stcModelSemple)*i ;
   \   00000038   0x2030             MOVS     R0,#+48
   \   0000003A   0xF241 0x6170      MOVW     R1,#+5744
   \   0000003E   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000042   0x0007             MOVS     R7,R0
    567          		
    568          		      ReadFM24CL64(ModelAdd,(uint8 *)sModelSemple,sizeof(stcModelSemple));
   \   00000044   0x2230             MOVS     R2,#+48
   \   00000046   0x0021             MOVS     R1,R4
   \   00000048   0x0038             MOVS     R0,R7
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x.... 0x....      BL       ReadFM24CL64
    569          
    570          			  CrcCheck = GetCrc16Check((uint8 *)sModelSemple,sizeof(stcModelSemple) - 2);
   \   00000050   0x212E             MOVS     R1,#+46
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       GetCrc16Check
   \   00000058   0x4680             MOV      R8,R0
    571          
    572          //			  printfcom0("\r\n 22 CrcCheck == CrcCheck %d, %d",CrcCheck,sModelSemple->CrcCheck);
    573          			  if(CrcCheck == sModelSemple->CrcCheck)
   \   0000005A   0x8DE0             LDRH     R0,[R4, #+46]
   \   0000005C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000060   0x4580             CMP      R8,R0
   \   00000062   0xD101             BNE.N    ??GetOilBoxModelsModelSemple_2
    574          			  {
    575          			  	 return  1;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0xE002             B.N      ??GetOilBoxModelsModelSemple_3
    576          			  }
    577          		  }
    578          	  }
   \                     ??GetOilBoxModelsModelSemple_2: (+1)
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
   \   0000006A   0xE7D1             B.N      ??GetOilBoxModelsModelSemple_0
    579          
    580          	  return  0;
   \                     ??GetOilBoxModelsModelSemple_1: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \                     ??GetOilBoxModelsModelSemple_3: (+1)
   \   0000006E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    581          }
    582          
    583          //#endif
    584              

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FRAM_ReadCalcModel
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
      16   FRAM_ReadCurRecord
        16   -> ReadFM24CL64
      16   FRAM_ReadOilPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
      16   FRAM_ReadProductInfo
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
      16   FRAM_ReadRecNumMgr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> ReadFM24CL64
      16   FRAM_ReadRunPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> ReadFM24CL64
       0   FRAM_SendEvent
      16   FRAM_StoreCalcModel
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
      16   FRAM_StoreCurRecord
        16   -> WriteFM24CL64
      16   FRAM_StoreOilPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
      16   FRAM_StoreProductInfo
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
      16   FRAM_StoreRecNumMgr
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> WriteFM24CL64
      16   FRAM_StoreRunPara
        16   -> FRAM_SendEvent
        16   -> FRAM_WaitEvent
        16   -> WriteFM24CL64
       0   FRAM_WaitEvent
      32   GetOilBoxModelsModel
        32   -> GetCrc16Check
        32   -> GetOilBoxCod
        32   -> ReadFM24CL64
      32   GetOilBoxModelsModelSemple
        32   -> GetCrc16Check
        32   -> GetOilBoxCod
        32   -> ReadFM24CL64
      32   ReadFM24CL64
        32   -> CheckSlaveAckI2C
        32   -> MasterAckI2C
        32   -> MasterNoAckI2C
        32   -> ReadByteWithI2C
        32   -> StartI2C
        32   -> StopI2C
        32   -> WriteByteWithI2C
      32   WriteFM24CL64
        32   -> CheckSlaveAckI2C
        32   -> StartI2C
        32   -> StopI2C
        32   -> WriteByteWithI2C


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  FRAM_ReadCalcModel
      30  FRAM_ReadCurRecord
      38  FRAM_ReadOilPara
      38  FRAM_ReadProductInfo
      50  FRAM_ReadRecNumMgr
      38  FRAM_ReadRunPara
       2  FRAM_SendEvent
      40  FRAM_StoreCalcModel
      30  FRAM_StoreCurRecord
      38  FRAM_StoreOilPara
      38  FRAM_StoreProductInfo
      50  FRAM_StoreRecNumMgr
      38  FRAM_StoreRunPara
       2  FRAM_WaitEvent
     116  GetOilBoxModelsModel
     114  GetOilBoxModelsModelSemple
     148  ReadFM24CL64
     118  WriteFM24CL64

 
 968 bytes in section .text
 
 968 bytes of CODE memory

Errors: none
Warnings: 14
