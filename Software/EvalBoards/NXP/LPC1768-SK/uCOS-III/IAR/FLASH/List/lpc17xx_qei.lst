###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       15/Aug/2017  16:25:16
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_qei.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_qei.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_qei.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_qei.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_qei.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_qei.c				2010-05-21
      3          *//**
      4          * @file		lpc17xx_qei.c
      5          * @brief	Contains all functions support for QEI firmware library on LPC17xx
      6          * @version	2.0
      7          * @date		21. May. 2010
      8          * @author	NXP MCU SW Application Team
      9          *
     10          * Copyright(C) 2010, NXP Semiconductor
     11          * All rights reserved.
     12          *
     13          ***********************************************************************
     14          * Software that is described herein is for illustrative purposes only
     15          * which provides customers with programming information regarding the
     16          * products. This software is supplied "AS IS" without any warranties.
     17          * NXP Semiconductors assumes no responsibility or liability for the
     18          * use of the software, conveys no license or title under any patent,
     19          * copyright, or mask work right to the product. NXP Semiconductors
     20          * reserves the right to make changes in the software without
     21          * notification. NXP Semiconductors also make no representation or
     22          * warranty that such application will be suitable for the specified
     23          * use without further testing or modification.
     24          * Permission to use, copy, modify, and distribute this software and its
     25          * documentation is hereby granted, under NXP Semiconductors'
     26          * relevant copyright in the software, without fee, provided that it
     27          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     28          * copyright, permission, and disclaimer notice must appear in all copies of
     29          * this code.
     30          **********************************************************************/
     31          
     32          /* Peripheral group ----------------------------------------------------------- */
     33          /** @addtogroup QEI
     34           * @{
     35           */
     36          
     37          /* Includes ------------------------------------------------------------------- */
     38          #include "lpc17xx_qei.h"
     39          #include "lpc17xx_clkpwr.h"
     40          
     41          
     42          /* If this source file built with example, the LPC17xx FW library configuration
     43           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     44           * otherwise the default FW library configuration file must be included instead
     45           */
     46          #ifdef __BUILD_WITH_EXAMPLE__
     47          #include "lpc17xx_libcfg.h"
     48          #else
     49          #include "lpc17xx_libcfg_default.h"
     50          #endif /* __BUILD_WITH_EXAMPLE__ */
     51          
     52          
     53          #ifdef _QEI
     54          
     55          /* Private Types -------------------------------------------------------------- */
     56          /** @defgroup QEI_Private_Types QEI Private Types
     57           * @{
     58           */
     59          
     60          /**
     61           * @brief QEI configuration union type definition
     62           */
     63          typedef union {
     64          	QEI_CFG_Type bmQEIConfig;
     65          	uint32_t ulQEIConfig;
     66          } QEI_CFGOPT_Type;
     67          
     68          /**
     69           * @}
     70           */
     71          
     72          
     73          /* Public Functions ----------------------------------------------------------- */
     74          /** @addtogroup QEI_Public_Functions
     75           * @{
     76           */
     77          
     78          /*********************************************************************//**
     79           * @brief		Resets value for each type of QEI value, such as velocity,
     80           * 				counter, position, etc..
     81           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
     82           * @param[in]	ulResetType		QEI Reset Type, should be one of the following:
     83           * 								- QEI_RESET_POS: Reset Position Counter
     84           * 								- QEI_RESET_POSOnIDX: Reset Position Counter on Index signal
     85           * 								- QEI_RESET_VEL: Reset Velocity
     86           * 								- QEI_RESET_IDX: Reset Index Counter
     87           * @return		None
     88           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     89          void QEI_Reset(LPC_QEI_TypeDef *QEIx, uint32_t ulResetType)
     90          {
   \                     QEI_Reset: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     91          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_Reset_0
   \   0000000E   0x215B             MOVS     R1,#+91
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
     92          	CHECK_PARAM(PARAM_QEI_RESET(ulResetType));
   \                     ??QEI_Reset_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD00A             BEQ.N    ??QEI_Reset_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD008             BEQ.N    ??QEI_Reset_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD006             BEQ.N    ??QEI_Reset_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD004             BEQ.N    ??QEI_Reset_1
   \   00000028   0x215C             MOVS     R1,#+92
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000002E   0x.... 0x....      BL       check_failed
     93          
     94          	QEIx->QEICON = ulResetType;
   \                     ??QEI_Reset_1: (+1)
   \   00000032   0x6025             STR      R5,[R4, #+0]
     95          }
   \   00000034   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     96          
     97          /*********************************************************************//**
     98           * @brief		Initializes the QEI peripheral according to the specified
     99          *               parameters in the QEI_ConfigStruct.
    100           * @param[in]	QEIx				QEI peripheral, should be LPC_QEI
    101           * @param[in]	QEI_ConfigStruct	Pointer to a QEI_CFG_Type structure
    102          *                    that contains the configuration information for the
    103          *                    specified QEI peripheral
    104           * @return		None
    105           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void QEI_Init(LPC_QEI_TypeDef *QEIx, QEI_CFG_Type *QEI_ConfigStruct)
    107          {
   \                     QEI_Init: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    108          
    109          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_Init_0
   \   0000000E   0x216D             MOVS     R1,#+109
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    110          	CHECK_PARAM(PARAM_QEI_DIRINV(QEI_ConfigStruct->DirectionInvert));
   \                     ??QEI_Init_0: (+1)
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0x7829             LDRB     R1,[R5, #+0]
   \   00000020   0xF011 0x0101      ANDS     R1,R1,#0x1
   \   00000024   0xF091 0x0101      EORS     R1,R1,#0x1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4208             TST      R0,R1
   \   0000002C   0xD004             BEQ.N    ??QEI_Init_1
   \   0000002E   0x216E             MOVS     R1,#+110
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000034   0x.... 0x....      BL       check_failed
    111          	CHECK_PARAM(PARAM_QEI_SIGNALMODE(QEI_ConfigStruct->SignalMode));
   \                     ??QEI_Init_1: (+1)
   \   00000038   0x6828             LDR      R0,[R5, #+0]
   \   0000003A   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   0000003E   0x07C0             LSLS     R0,R0,#+31
   \   00000040   0xD509             BPL.N    ??QEI_Init_2
   \   00000042   0x6828             LDR      R0,[R5, #+0]
   \   00000044   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000048   0x07C0             LSLS     R0,R0,#+31
   \   0000004A   0xD404             BMI.N    ??QEI_Init_2
   \   0000004C   0x216F             MOVS     R1,#+111
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000052   0x.... 0x....      BL       check_failed
    112          	CHECK_PARAM(PARAM_QEI_CAPMODE(QEI_ConfigStruct->CaptureMode));
   \                     ??QEI_Init_2: (+1)
   \   00000056   0x6828             LDR      R0,[R5, #+0]
   \   00000058   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD509             BPL.N    ??QEI_Init_3
   \   00000060   0x6828             LDR      R0,[R5, #+0]
   \   00000062   0xF3C0 0x0080      UBFX     R0,R0,#+2,#+1
   \   00000066   0x07C0             LSLS     R0,R0,#+31
   \   00000068   0xD404             BMI.N    ??QEI_Init_3
   \   0000006A   0x2170             MOVS     R1,#+112
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000070   0x.... 0x....      BL       check_failed
    113          	CHECK_PARAM(PARAM_QEI_INVINX(QEI_ConfigStruct->InvertIndex));
   \                     ??QEI_Init_3: (+1)
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   0000007A   0x07C0             LSLS     R0,R0,#+31
   \   0000007C   0xD509             BPL.N    ??QEI_Init_4
   \   0000007E   0x6828             LDR      R0,[R5, #+0]
   \   00000080   0xF3C0 0x00C0      UBFX     R0,R0,#+3,#+1
   \   00000084   0x07C0             LSLS     R0,R0,#+31
   \   00000086   0xD404             BMI.N    ??QEI_Init_4
   \   00000088   0x2171             MOVS     R1,#+113
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   0000008E   0x.... 0x....      BL       check_failed
    114          
    115          	/* Set up clock and power for QEI module */
    116          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, ENABLE);
   \                     ??QEI_Init_4: (+1)
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0xF45F 0x2080      MOVS     R0,#+262144
   \   00000098   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    117          
    118          	/* As default, peripheral clock for QEI module
    119          	 * is set to FCCLK / 2 */
    120          	CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_QEI, CLKPWR_PCLKSEL_CCLK_DIV_1);
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x2020             MOVS     R0,#+32
   \   000000A0   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
    121          
    122          	// Reset all remaining value in QEI peripheral
    123          	QEIx->QEICON = QEI_CON_RESP | QEI_CON_RESV | QEI_CON_RESI;
   \   000000A4   0x200D             MOVS     R0,#+13
   \   000000A6   0x6020             STR      R0,[R4, #+0]
    124          	QEIx->QEIMAXPOS = 0x00;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x6120             STR      R0,[R4, #+16]
    125          	QEIx->CMPOS0 = 0x00;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x6160             STR      R0,[R4, #+20]
    126          	QEIx->CMPOS1 = 0x00;
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x61A0             STR      R0,[R4, #+24]
    127          	QEIx->CMPOS2 = 0x00;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x61E0             STR      R0,[R4, #+28]
    128          	QEIx->INXCMP = 0x00;
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x6260             STR      R0,[R4, #+36]
    129          	QEIx->QEILOAD = 0x00;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x62A0             STR      R0,[R4, #+40]
    130          	QEIx->VELCOMP = 0x00;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x63A0             STR      R0,[R4, #+56]
    131          	QEIx->FILTER = 0x00;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x63E0             STR      R0,[R4, #+60]
    132          	// Disable all Interrupt
    133          	QEIx->QEIIEC = QEI_IECLR_BITMASK;
   \   000000C8   0xF641 0x70FF      MOVW     R0,#+8191
   \   000000CC   0xF8C4 0x0FD8      STR      R0,[R4, #+4056]
    134          	// Clear all Interrupt pending
    135          	QEIx->QEICLR = QEI_INTCLR_BITMASK;
   \   000000D0   0xF641 0x70FF      MOVW     R0,#+8191
   \   000000D4   0xF8C4 0x0FE8      STR      R0,[R4, #+4072]
    136          	// Set QEI configuration value corresponding to its setting up value
    137          	QEIx->QEICONF = ((QEI_CFGOPT_Type *)QEI_ConfigStruct)->ulQEIConfig;
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x60A0             STR      R0,[R4, #+8]
    138          }
   \   000000DC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    139          
    140          
    141          /*********************************************************************//**
    142           * @brief		De-initializes the QEI peripheral registers to their
    143          *                  default reset values.
    144           * @param[in]	QEIx	QEI peripheral, should be LPC_QEI
    145           * @return 		None
    146           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    147          void QEI_DeInit(LPC_QEI_TypeDef *QEIx)
    148          {
   \                     QEI_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    149          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_DeInit_0
   \   0000000C   0x2195             MOVS     R1,#+149
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    150          
    151          	/* Turn off clock and power for QEI module */
    152          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCQEI, DISABLE);
   \                     ??QEI_DeInit_0: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0xF45F 0x2080      MOVS     R0,#+262144
   \   0000001C   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    153          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    154          
    155          
    156          /*****************************************************************************//**
    157          * @brief		Fills each QIE_InitStruct member with its default value:
    158          * 				- DirectionInvert = QEI_DIRINV_NONE
    159          * 				- SignalMode = QEI_SIGNALMODE_QUAD
    160          * 				- CaptureMode = QEI_CAPMODE_4X
    161          * 				- InvertIndex = QEI_INVINX_NONE
    162          * @param[in]	QIE_InitStruct Pointer to a QEI_CFG_Type structure
    163          *                    which will be initialized.
    164          * @return		None
    165          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    166          void QEI_ConfigStructInit(QEI_CFG_Type *QIE_InitStruct)
    167          {
    168          	QIE_InitStruct->CaptureMode = QEI_CAPMODE_4X;
   \                     QEI_ConfigStructInit: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   00000006   0x6001             STR      R1,[R0, #+0]
    169          	QIE_InitStruct->DirectionInvert = QEI_DIRINV_NONE;
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0849             LSRS     R1,R1,#+1
   \   0000000C   0x0049             LSLS     R1,R1,#+1
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    170          	QIE_InitStruct->InvertIndex = QEI_INVINX_NONE;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF031 0x0108      BICS     R1,R1,#0x8
   \   00000016   0x6001             STR      R1,[R0, #+0]
    171          	QIE_InitStruct->SignalMode = QEI_SIGNALMODE_QUAD;
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0xF031 0x0102      BICS     R1,R1,#0x2
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    172          }
   \   00000020   0x4770             BX       LR               ;; return
    173          
    174          
    175          /*********************************************************************//**
    176           * @brief		Check whether if specified flag status is set or not
    177           * @param[in]	QEIx		QEI peripheral, should be LPC_QEI
    178           * @param[in]	ulFlagType	Status Flag Type, should be one of the following:
    179           * 							- QEI_STATUS_DIR: Direction Status
    180           * @return		New Status of this status flag (SET or RESET)
    181           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    182          FlagStatus QEI_GetStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulFlagType)
    183          {
   \                     QEI_GetStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    184          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_GetStatus_0
   \   0000000E   0x21B8             MOVS     R1,#+184
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    185          	CHECK_PARAM(PARAM_QEI_STATUS(ulFlagType));
   \                     ??QEI_GetStatus_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD004             BEQ.N    ??QEI_GetStatus_1
   \   0000001C   0x21B9             MOVS     R1,#+185
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000022   0x.... 0x....      BL       check_failed
    186          	return ((QEIx->QEISTAT & ulFlagType) ? SET : RESET);
   \                     ??QEI_GetStatus_1: (+1)
   \   00000026   0x6860             LDR      R0,[R4, #+4]
   \   00000028   0x4228             TST      R0,R5
   \   0000002A   0xD001             BEQ.N    ??QEI_GetStatus_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??QEI_GetStatus_3
   \                     ??QEI_GetStatus_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??QEI_GetStatus_3: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    187          }
    188          
    189          /*********************************************************************//**
    190           * @brief		Get current position value in QEI peripheral
    191           * @param[in]	QEIx	QEI peripheral, should be LPC_QEI
    192           * @return		Current position value of QEI peripheral
    193           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          uint32_t QEI_GetPosition(LPC_QEI_TypeDef *QEIx)
    195          {
   \                     QEI_GetPosition: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    196          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_GetPosition_0
   \   0000000C   0x21C4             MOVS     R1,#+196
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    197          	return (QEIx->QEIPOS);
   \                     ??QEI_GetPosition_0: (+1)
   \   00000016   0x68E0             LDR      R0,[R4, #+12]
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    198          }
    199          
    200          /*********************************************************************//**
    201           * @brief		Set max position value for QEI peripheral
    202           * @param[in]	QEIx		QEI peripheral, should be LPC_QEI
    203           * @param[in]	ulMaxPos	Max position value to set
    204           * @return		None
    205           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    206          void QEI_SetMaxPosition(LPC_QEI_TypeDef *QEIx, uint32_t ulMaxPos)
    207          {
   \                     QEI_SetMaxPosition: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    208          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_SetMaxPosition_0
   \   0000000E   0x21D0             MOVS     R1,#+208
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    209          	QEIx->QEIMAXPOS = ulMaxPos;
   \                     ??QEI_SetMaxPosition_0: (+1)
   \   00000018   0x6125             STR      R5,[R4, #+16]
    210          }
   \   0000001A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    211          
    212          /*********************************************************************//**
    213           * @brief		Set position compare value for QEI peripheral
    214           * @param[in]	QEIx		QEI peripheral, should be LPC_QEI
    215           * @param[in]	bPosCompCh	Compare Position channel, should be:
    216           * 							- QEI_COMPPOS_CH_0: QEI compare position channel 0
    217           * 							- QEI_COMPPOS_CH_1: QEI compare position channel 1
    218           * 							- QEI_COMPPOS_CH_2: QEI compare position channel 2
    219           * @param[in]	ulPosComp	Compare Position value to set
    220           * @return		None
    221           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    222          void QEI_SetPositionComp(LPC_QEI_TypeDef *QEIx, uint8_t bPosCompCh, uint32_t ulPosComp)
    223          {
   \                     QEI_SetPositionComp: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    224          	uint32_t *tmp;
    225          
    226          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable18  ;; 0x400bc000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD003             BEQ.N    ??QEI_SetPositionComp_0
   \   00000010   0x21E2             MOVS     R1,#+226
   \   00000012   0x....             LDR.N    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    227          	CHECK_PARAM(PARAM_QEI_COMPPOS_CH(bPosCompCh));
   \                     ??QEI_SetPositionComp_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD009             BEQ.N    ??QEI_SetPositionComp_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD006             BEQ.N    ??QEI_SetPositionComp_1
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D02             CMP      R5,#+2
   \   00000028   0xD003             BEQ.N    ??QEI_SetPositionComp_1
   \   0000002A   0x21E3             MOVS     R1,#+227
   \   0000002C   0x....             LDR.N    R0,??DataTable18_1
   \   0000002E   0x.... 0x....      BL       check_failed
    228          	tmp = (uint32_t *) (&(QEIx->CMPOS0) + bPosCompCh * 4);
   \                     ??QEI_SetPositionComp_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0xEB14 0x1005      ADDS     R0,R4,R5, LSL #+4
   \   00000038   0x3014             ADDS     R0,R0,#+20
   \   0000003A   0x0007             MOVS     R7,R0
    229          	*tmp = ulPosComp;
   \   0000003C   0x603E             STR      R6,[R7, #+0]
    230          
    231          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    232          
    233          /*********************************************************************//**
    234           * @brief		Get current index counter of QEI peripheral
    235           * @param[in]	QEIx		QEI peripheral, should be LPC_QEI
    236           * @return		Current value of QEI index counter
    237           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    238          uint32_t QEI_GetIndex(LPC_QEI_TypeDef *QEIx)
    239          {
   \                     QEI_GetIndex: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    240          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD003             BEQ.N    ??QEI_GetIndex_0
   \   0000000A   0x21F0             MOVS     R1,#+240
   \   0000000C   0x....             LDR.N    R0,??DataTable18_1
   \   0000000E   0x.... 0x....      BL       check_failed
    241          	return (QEIx->INXCNT);
   \                     ??QEI_GetIndex_0: (+1)
   \   00000012   0x6A20             LDR      R0,[R4, #+32]
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    242          }
    243          
    244          /*********************************************************************//**
    245           * @brief		Set value for index compare in QEI peripheral
    246           * @param[in]	QEIx		QEI peripheral, should be LPC_QEI
    247           * @param[in]	ulIndexComp		Compare Index Value to set
    248           * @return		None
    249           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    250          void QEI_SetIndexComp(LPC_QEI_TypeDef *QEIx, uint32_t ulIndexComp)
    251          {
   \                     QEI_SetIndexComp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    252          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD003             BEQ.N    ??QEI_SetIndexComp_0
   \   0000000C   0x21FC             MOVS     R1,#+252
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    253          	QEIx->INXCMP = ulIndexComp;
   \                     ??QEI_SetIndexComp_0: (+1)
   \   00000014   0x6265             STR      R5,[R4, #+36]
    254          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    255          
    256          /*********************************************************************//**
    257           * @brief		Set timer reload value for QEI peripheral. When the velocity timer is
    258           * 				over-flow, the value that set for Timer Reload register will be loaded
    259           * 				into the velocity timer for next period. The calculated velocity in RPM
    260           * 				therefore will be affect by this value.
    261           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    262           * @param[in]	QEIReloadStruct	QEI reload structure
    263           * @return		None
    264           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    265          void QEI_SetTimerReload(LPC_QEI_TypeDef *QEIx, QEI_RELOADCFG_Type *QEIReloadStruct)
    266          {
   \                     QEI_SetTimerReload: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000F             MOVS     R7,R1
    267          	uint64_t pclk;
    268          
    269          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4286             CMP      R6,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetTimerReload_0
   \   0000000C   0xF240 0x110D      MOVW     R1,#+269
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    270          	CHECK_PARAM(PARAM_QEI_TIMERRELOAD(QEIReloadStruct->ReloadOption));
   \                     ??QEI_SetTimerReload_0: (+1)
   \   00000016   0x7838             LDRB     R0,[R7, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD007             BEQ.N    ??QEI_SetTimerReload_1
   \   0000001C   0x7838             LDRB     R0,[R7, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD004             BEQ.N    ??QEI_SetTimerReload_1
   \   00000022   0xF44F 0x7187      MOV      R1,#+270
   \   00000026   0x....             LDR.N    R0,??DataTable18_1
   \   00000028   0x.... 0x....      BL       check_failed
    271          
    272          	if (QEIReloadStruct->ReloadOption == QEI_TIMERRELOAD_TICKVAL) {
   \                     ??QEI_SetTimerReload_1: (+1)
   \   0000002C   0x7838             LDRB     R0,[R7, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD103             BNE.N    ??QEI_SetTimerReload_2
    273          		QEIx->QEILOAD = QEIReloadStruct->ReloadValue - 1;
   \   00000032   0x6878             LDR      R0,[R7, #+4]
   \   00000034   0x1E40             SUBS     R0,R0,#+1
   \   00000036   0x62B0             STR      R0,[R6, #+40]
   \   00000038   0xE012             B.N      ??QEI_SetTimerReload_3
    274          	} else {
    275          		pclk = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
   \                     ??QEI_SetTimerReload_2: (+1)
   \   0000003A   0x2020             MOVS     R0,#+32
   \   0000003C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x0004             MOVS     R4,R0
   \   00000044   0x000D             MOVS     R5,R1
    276          		pclk = (pclk /(1000000/QEIReloadStruct->ReloadValue)) - 1;
   \   00000046   0x....             LDR.N    R0,??DataTable18_2  ;; 0xf4240
   \   00000048   0x6879             LDR      R1,[R7, #+4]
   \   0000004A   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0x0029             MOVS     R1,R5
   \   00000054   0x.... 0x....      BL       __aeabi_uldivmod
   \   00000058   0x1E44             SUBS     R4,R0,#+1
   \   0000005A   0xF171 0x0500      SBCS     R5,R1,#+0
    277          		QEIx->QEILOAD = (uint32_t)pclk;
   \   0000005E   0x62B4             STR      R4,[R6, #+40]
    278          	}
    279          }
   \                     ??QEI_SetTimerReload_3: (+1)
   \   00000060   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    280          
    281          /*********************************************************************//**
    282           * @brief		Get current timer counter in QEI peripheral
    283           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    284           * @return		Current timer counter in QEI peripheral
    285           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    286          uint32_t QEI_GetTimer(LPC_QEI_TypeDef *QEIx)
    287          {
   \                     QEI_GetTimer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetTimer_0
   \   0000000A   0xF44F 0x7190      MOV      R1,#+288
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    289          	return (QEIx->QEITIME);
   \                     ??QEI_GetTimer_0: (+1)
   \   00000014   0x6AE0             LDR      R0,[R4, #+44]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    290          }
    291          
    292          /*********************************************************************//**
    293           * @brief		Get current velocity pulse counter in current time period
    294           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    295           * @return		Current velocity pulse counter value
    296           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    297          uint32_t QEI_GetVelocity(LPC_QEI_TypeDef *QEIx)
    298          {
   \                     QEI_GetVelocity: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    299          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetVelocity_0
   \   0000000A   0xF240 0x112B      MOVW     R1,#+299
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    300          	return (QEIx->QEIVEL);
   \                     ??QEI_GetVelocity_0: (+1)
   \   00000014   0x6B20             LDR      R0,[R4, #+48]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    301          }
    302          
    303          /*********************************************************************//**
    304           * @brief		Get the most recently measured velocity of the QEI. When
    305           * 				the Velocity timer in QEI is over-flow, the current velocity
    306           * 				value will be loaded into Velocity Capture register.
    307           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    308           * @return		The most recently measured velocity value
    309           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    310          uint32_t QEI_GetVelocityCap(LPC_QEI_TypeDef *QEIx)
    311          {
   \                     QEI_GetVelocityCap: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    312          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000004   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000006   0x4284             CMP      R4,R0
   \   00000008   0xD004             BEQ.N    ??QEI_GetVelocityCap_0
   \   0000000A   0xF44F 0x719C      MOV      R1,#+312
   \   0000000E   0x....             LDR.N    R0,??DataTable18_1
   \   00000010   0x.... 0x....      BL       check_failed
    313          	return (QEIx->QEICAP);
   \                     ??QEI_GetVelocityCap_0: (+1)
   \   00000014   0x6B60             LDR      R0,[R4, #+52]
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
    314          }
    315          
    316          /*********************************************************************//**
    317           * @brief		Set Velocity Compare value for QEI peripheral
    318           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    319           * @param[in]	ulVelComp		Compare Velocity value to set
    320           * @return		None
    321           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    322          void QEI_SetVelocityComp(LPC_QEI_TypeDef *QEIx, uint32_t ulVelComp)
    323          {
   \                     QEI_SetVelocityComp: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    324          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetVelocityComp_0
   \   0000000C   0xF44F 0x71A2      MOV      R1,#+324
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    325          	QEIx->VELCOMP = ulVelComp;
   \                     ??QEI_SetVelocityComp_0: (+1)
   \   00000016   0x63A5             STR      R5,[R4, #+56]
    326          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    327          
    328          /*********************************************************************//**
    329           * @brief		Set value of sampling count for the digital filter in
    330           * 				QEI peripheral
    331           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    332           * @param[in]	ulSamplingPulse	Value of sampling count to set
    333           * @return		None
    334           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    335          void QEI_SetDigiFilter(LPC_QEI_TypeDef *QEIx, uint32_t ulSamplingPulse)
    336          {
   \                     QEI_SetDigiFilter: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    337          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_SetDigiFilter_0
   \   0000000C   0xF240 0x1151      MOVW     R1,#+337
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    338          	QEIx->FILTER = ulSamplingPulse;
   \                     ??QEI_SetDigiFilter_0: (+1)
   \   00000016   0x63E5             STR      R5,[R4, #+60]
    339          }
   \   00000018   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    340          
    341          /*********************************************************************//**
    342           * @brief		Check whether if specified interrupt flag status in QEI
    343           * 				peripheral is set or not
    344           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    345           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    346          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    347          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    348          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    349          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    350          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    351          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    352          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    353          														current position interrupt
    354          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    355          														current position interrupt
    356          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    357          														current position interrupt
    358          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    359          														index count interrupt
    360          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    361          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    362          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    363           * @return		New State of specified interrupt flag status (SET or RESET)
    364           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    365          FlagStatus QEI_GetIntStatus(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    366          {
   \                     QEI_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    367          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_GetIntStatus_0
   \   0000000C   0xF240 0x116F      MOVW     R1,#+367
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    368          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_GetIntStatus_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_GetIntStatus_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_GetIntStatus_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_GetIntStatus_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_GetIntStatus_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_GetIntStatus_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_GetIntStatus_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_GetIntStatus_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_GetIntStatus_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_GetIntStatus_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_GetIntStatus_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_GetIntStatus_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_GetIntStatus_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_GetIntStatus_1
   \   00000054   0xF44F 0x71B8      MOV      R1,#+368
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    369          
    370          	return((QEIx->QEIINTSTAT & ulIntType) ? SET : RESET);
   \                     ??QEI_GetIntStatus_1: (+1)
   \   0000005E   0xF8D4 0x0FE0      LDR      R0,[R4, #+4064]
   \   00000062   0x4228             TST      R0,R5
   \   00000064   0xD001             BEQ.N    ??QEI_GetIntStatus_2
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0xE000             B.N      ??QEI_GetIntStatus_3
   \                     ??QEI_GetIntStatus_2: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??QEI_GetIntStatus_3: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    371          }
    372          
    373          /*********************************************************************//**
    374           * @brief		Enable/Disable specified interrupt in QEI peripheral
    375           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    376           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    377           * 								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    378           *								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    379           *								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    380           * 								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    381           *  							- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    382           * 								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    383           *								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    384           *														current position interrupt
    385           *								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    386           *														current position interrupt
    387           *								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    388           *														current position interrupt
    389           *								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    390           *														index count interrupt
    391           *								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    392           *								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    393           *								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    394           * @param[in]	NewState		New function state, should be:
    395           *								- DISABLE
    396           *								- ENABLE
    397           * @return		None
    398           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    399          void QEI_IntCmd(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType, FunctionalState NewState)
    400          {
   \                     QEI_IntCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    401          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000008   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??QEI_IntCmd_0
   \   0000000E   0xF240 0x1191      MOVW     R1,#+401
   \   00000012   0x....             LDR.N    R0,??DataTable18_1
   \   00000014   0x.... 0x....      BL       check_failed
    402          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntCmd_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD021             BEQ.N    ??QEI_IntCmd_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD01F             BEQ.N    ??QEI_IntCmd_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD01D             BEQ.N    ??QEI_IntCmd_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD01B             BEQ.N    ??QEI_IntCmd_1
   \   00000028   0x2D10             CMP      R5,#+16
   \   0000002A   0xD019             BEQ.N    ??QEI_IntCmd_1
   \   0000002C   0x2D20             CMP      R5,#+32
   \   0000002E   0xD017             BEQ.N    ??QEI_IntCmd_1
   \   00000030   0x2D40             CMP      R5,#+64
   \   00000032   0xD015             BEQ.N    ??QEI_IntCmd_1
   \   00000034   0x2D80             CMP      R5,#+128
   \   00000036   0xD013             BEQ.N    ??QEI_IntCmd_1
   \   00000038   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003C   0xD010             BEQ.N    ??QEI_IntCmd_1
   \   0000003E   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000042   0xD00D             BEQ.N    ??QEI_IntCmd_1
   \   00000044   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000048   0xD00A             BEQ.N    ??QEI_IntCmd_1
   \   0000004A   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004E   0xD007             BEQ.N    ??QEI_IntCmd_1
   \   00000050   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000054   0xD004             BEQ.N    ??QEI_IntCmd_1
   \   00000056   0xF44F 0x71C9      MOV      R1,#+402
   \   0000005A   0x....             LDR.N    R0,??DataTable18_1
   \   0000005C   0x.... 0x....      BL       check_failed
    403          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??QEI_IntCmd_1: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD007             BEQ.N    ??QEI_IntCmd_2
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E01             CMP      R6,#+1
   \   0000006A   0xD004             BEQ.N    ??QEI_IntCmd_2
   \   0000006C   0xF240 0x1193      MOVW     R1,#+403
   \   00000070   0x....             LDR.N    R0,??DataTable18_1
   \   00000072   0x.... 0x....      BL       check_failed
    404          
    405          	if (NewState == ENABLE) {
   \                     ??QEI_IntCmd_2: (+1)
   \   00000076   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000078   0x2E01             CMP      R6,#+1
   \   0000007A   0xD102             BNE.N    ??QEI_IntCmd_3
    406          		QEIx->QEIIES = ulIntType;
   \   0000007C   0xF8C4 0x5FDC      STR      R5,[R4, #+4060]
   \   00000080   0xE001             B.N      ??QEI_IntCmd_4
    407          	} else {
    408          		QEIx->QEIIEC = ulIntType;
   \                     ??QEI_IntCmd_3: (+1)
   \   00000082   0xF8C4 0x5FD8      STR      R5,[R4, #+4056]
    409          	}
    410          }
   \                     ??QEI_IntCmd_4: (+1)
   \   00000086   0xBD70             POP      {R4-R6,PC}       ;; return
    411          
    412          
    413          /*********************************************************************//**
    414           * @brief		Sets (forces) specified interrupt in QEI peripheral
    415           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    416           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    417          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    418          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    419          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    420          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    421          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    422          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    423          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    424          														current position interrupt
    425          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    426          														current position interrupt
    427          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    428          														current position interrupt
    429          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    430          														index count interrupt
    431          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    432          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    433          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    434           * @return		None
    435           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    436          void QEI_IntSet(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    437          {
   \                     QEI_IntSet: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    438          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_IntSet_0
   \   0000000C   0xF44F 0x71DB      MOV      R1,#+438
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    439          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntSet_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_IntSet_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_IntSet_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_IntSet_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_IntSet_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_IntSet_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_IntSet_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_IntSet_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_IntSet_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_IntSet_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_IntSet_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_IntSet_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_IntSet_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_IntSet_1
   \   00000054   0xF240 0x11B7      MOVW     R1,#+439
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    440          
    441          	QEIx->QEISET = ulIntType;
   \                     ??QEI_IntSet_1: (+1)
   \   0000005E   0xF8C4 0x5FEC      STR      R5,[R4, #+4076]
    442          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    443          
    444          /*********************************************************************//**
    445           * @brief		Clear (force) specified interrupt (pending) in QEI peripheral
    446           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    447           * @param[in]	ulIntType		Interrupt Flag Status type, should be:
    448          								- QEI_INTFLAG_INX_Int: index pulse was detected interrupt
    449          								- QEI_INTFLAG_TIM_Int: Velocity timer over flow interrupt
    450          								- QEI_INTFLAG_VELC_Int: Capture velocity is less than compare interrupt
    451          								- QEI_INTFLAG_DIR_Int: Change of direction interrupt
    452          								- QEI_INTFLAG_ERR_Int: An encoder phase error interrupt
    453          								- QEI_INTFLAG_ENCLK_Int: An encoder clock pulse was detected interrupt
    454          								- QEI_INTFLAG_POS0_Int: position 0 compare value is equal to the
    455          														current position interrupt
    456          								- QEI_INTFLAG_POS1_Int: position 1 compare value is equal to the
    457          														current position interrupt
    458          								- QEI_INTFLAG_POS2_Int: position 2 compare value is equal to the
    459          														current position interrupt
    460          								- QEI_INTFLAG_REV_Int: Index compare value is equal to the current
    461          														index count interrupt
    462          								- QEI_INTFLAG_POS0REV_Int: Combined position 0 and revolution count interrupt
    463          								- QEI_INTFLAG_POS1REV_Int: Combined position 1 and revolution count interrupt
    464          								- QEI_INTFLAG_POS2REV_Int: Combined position 2 and revolution count interrupt
    465           * @return		None
    466           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    467          void QEI_IntClear(LPC_QEI_TypeDef *QEIx, uint32_t ulIntType)
    468          {
   \                     QEI_IntClear: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    469          	CHECK_PARAM(PARAM_QEIx(QEIx));
   \   00000006   0x....             LDR.N    R0,??DataTable18  ;; 0x400bc000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??QEI_IntClear_0
   \   0000000C   0xF240 0x11D5      MOVW     R1,#+469
   \   00000010   0x....             LDR.N    R0,??DataTable18_1
   \   00000012   0x.... 0x....      BL       check_failed
    470          	CHECK_PARAM(PARAM_QEI_INTFLAG(ulIntType));
   \                     ??QEI_IntClear_0: (+1)
   \   00000016   0x2D01             CMP      R5,#+1
   \   00000018   0xD021             BEQ.N    ??QEI_IntClear_1
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD01F             BEQ.N    ??QEI_IntClear_1
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xD01D             BEQ.N    ??QEI_IntClear_1
   \   00000022   0x2D08             CMP      R5,#+8
   \   00000024   0xD01B             BEQ.N    ??QEI_IntClear_1
   \   00000026   0x2D10             CMP      R5,#+16
   \   00000028   0xD019             BEQ.N    ??QEI_IntClear_1
   \   0000002A   0x2D20             CMP      R5,#+32
   \   0000002C   0xD017             BEQ.N    ??QEI_IntClear_1
   \   0000002E   0x2D40             CMP      R5,#+64
   \   00000030   0xD015             BEQ.N    ??QEI_IntClear_1
   \   00000032   0x2D80             CMP      R5,#+128
   \   00000034   0xD013             BEQ.N    ??QEI_IntClear_1
   \   00000036   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000003A   0xD010             BEQ.N    ??QEI_IntClear_1
   \   0000003C   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000040   0xD00D             BEQ.N    ??QEI_IntClear_1
   \   00000042   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000046   0xD00A             BEQ.N    ??QEI_IntClear_1
   \   00000048   0xF5B5 0x6F00      CMP      R5,#+2048
   \   0000004C   0xD007             BEQ.N    ??QEI_IntClear_1
   \   0000004E   0xF5B5 0x5F80      CMP      R5,#+4096
   \   00000052   0xD004             BEQ.N    ??QEI_IntClear_1
   \   00000054   0xF44F 0x71EB      MOV      R1,#+470
   \   00000058   0x....             LDR.N    R0,??DataTable18_1
   \   0000005A   0x.... 0x....      BL       check_failed
    471          
    472          	QEIx->QEICLR = ulIntType;
   \                     ??QEI_IntClear_1: (+1)
   \   0000005E   0xF8C4 0x5FE8      STR      R5,[R4, #+4072]
    473          }
   \   00000062   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    474          
    475          
    476          /*********************************************************************//**
    477           * @brief		Calculates the actual velocity in RPM passed via velocity
    478           * 				capture value and Pulse Per Round (of the encoder) value
    479           * 				parameter input.
    480           * @param[in]	QEIx			QEI peripheral, should be LPC_QEI
    481           * @param[in]	ulVelCapValue	Velocity capture input value that can
    482           * 								be got from QEI_GetVelocityCap() function
    483           * @param[in]	ulPPR			Pulse per round of encoder
    484           * @return		The actual value of velocity in RPM (Round per minute)
    485           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    486          uint32_t QEI_CalculateRPM(LPC_QEI_TypeDef *QEIx, uint32_t ulVelCapValue, uint32_t ulPPR)
    487          {
   \                     QEI_CalculateRPM: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x4690             MOV      R8,R2
    488          	uint64_t rpm, clock, Load, edges;
    489          
    490          	// Get current Clock rate for timer input
    491          	clock = (uint64_t)CLKPWR_GetPCLK(CLKPWR_PCLKSEL_QEI);
   \   0000000A   0x2020             MOVS     R0,#+32
   \   0000000C   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
    492          	// Get Timer load value (velocity capture period)
    493          	Load  = (uint64_t)(QEIx->QEILOAD + 1);
   \   00000016   0x9806             LDR      R0,[SP, #+24]
   \   00000018   0x6A80             LDR      R0,[R0, #+40]
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
    494          	// Get Edge
    495          	edges = (uint64_t)((QEIx->QEICONF & QEI_CONF_CAPMODE) ? 4 : 2);
   \   00000022   0x9806             LDR      R0,[SP, #+24]
   \   00000024   0x6880             LDR      R0,[R0, #+8]
   \   00000026   0x0740             LSLS     R0,R0,#+29
   \   00000028   0xD502             BPL.N    ??QEI_CalculateRPM_0
   \   0000002A   0x2404             MOVS     R4,#+4
   \   0000002C   0x2500             MOVS     R5,#+0
   \   0000002E   0xE001             B.N      ??QEI_CalculateRPM_1
   \                     ??QEI_CalculateRPM_0: (+1)
   \   00000030   0x2402             MOVS     R4,#+2
   \   00000032   0x2500             MOVS     R5,#+0
    496          	// Calculate RPM
    497          	rpm = ((clock * ulVelCapValue * 60) / (Load * ulPPR * edges));
   \                     ??QEI_CalculateRPM_1: (+1)
   \   00000034   0xE9DD 0x0102      LDRD     R0,R1,[SP, #+8]
   \   00000038   0x2700             MOVS     R7,#+0
   \   0000003A   0xFBA6 0x2300      UMULL    R2,R3,R6,R0
   \   0000003E   0xFB06 0x3301      MLA      R3,R6,R1,R3
   \   00000042   0xFB07 0x3300      MLA      R3,R7,R0,R3
   \   00000046   0xF05F 0x0A3C      MOVS     R10,#+60
   \   0000004A   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000004E   0xFBAA 0x0102      UMULL    R0,R1,R10,R2
   \   00000052   0xFB0A 0x1103      MLA      R1,R10,R3,R1
   \   00000056   0xFB0B 0x1102      MLA      R1,R11,R2,R1
   \   0000005A   0x4682             MOV      R10,R0
   \   0000005C   0x468B             MOV      R11,R1
   \   0000005E   0xE9DD 0x0100      LDRD     R0,R1,[SP, #+0]
   \   00000062   0xF05F 0x0900      MOVS     R9,#+0
   \   00000066   0xFBA8 0x2300      UMULL    R2,R3,R8,R0
   \   0000006A   0xFB08 0x3301      MLA      R3,R8,R1,R3
   \   0000006E   0xFB09 0x3300      MLA      R3,R9,R0,R3
   \   00000072   0xFBA4 0x0102      UMULL    R0,R1,R4,R2
   \   00000076   0xFB04 0x1103      MLA      R1,R4,R3,R1
   \   0000007A   0xFB05 0x1102      MLA      R1,R5,R2,R1
   \   0000007E   0x0002             MOVS     R2,R0
   \   00000080   0x000B             MOVS     R3,R1
   \   00000082   0x4650             MOV      R0,R10
   \   00000084   0x4659             MOV      R1,R11
   \   00000086   0x.... 0x....      BL       __aeabi_uldivmod
   \   0000008A   0xE9CD 0x0104      STRD     R0,R1,[SP, #+16]
    498          
    499          	return (uint32_t)(rpm);
   \   0000008E   0xE9DD 0x0104      LDRD     R0,R1,[SP, #+16]
   \   00000092   0xB007             ADD      SP,SP,#+28
   \   00000094   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    500          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x400BC000         DC32     0x400bc000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0xCD          DC8 30H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H, 0BFH
   \              0xB3 0xBC    
   \              0xC6 0xC4    
   \              0xA3 0xBF    
   \   00000018   0xE9 0x5C          DC8 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H, 61H
   \              0x53 0x6F    
   \              0x66 0x74    
   \              0x77 0x61    
   \   00000020   0x72 0x65          DC8 72H, 65H, 5CH, 43H, 53H, 42H, 5CH, 73H
   \              0x5C 0x43    
   \              0x53 0x42    
   \              0x5C 0x73    
   \   00000028   0x6F 0x75          DC8 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH, 70H
   \              0x72 0x63    
   \              0x65 0x5C    
   \              0x6C 0x70    
   \   00000030   0x63 0x31          DC8 63H, 31H, 37H, 78H, 78H, 5FH, 71H, 65H
   \              0x37 0x78    
   \              0x78 0x5F    
   \              0x71 0x65    
   \   00000038   0x69 0x2E          DC8 69H, 2EH, 63H, 0
   \              0x63 0x00    
    501          
    502          
    503          /**
    504           * @}
    505           */
    506          
    507          #endif /* _QEI */
    508          
    509          /**
    510           * @}
    511           */
    512          
    513          /* --------------------------------- End Of File ------------------------------ */
    514          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   QEI_CalculateRPM
        64   -> CLKPWR_GetPCLK
        64 __aeabi_uldivmod
       0   QEI_ConfigStructInit
       8   QEI_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
       8   QEI_GetIndex
         8   -> check_failed
      16   QEI_GetIntStatus
        16   -> check_failed
       8   QEI_GetPosition
         8   -> check_failed
      16   QEI_GetStatus
        16   -> check_failed
       8   QEI_GetTimer
         8   -> check_failed
       8   QEI_GetVelocity
         8   -> check_failed
       8   QEI_GetVelocityCap
         8   -> check_failed
      16   QEI_Init
        16   -> CLKPWR_ConfigPPWR
        16   -> CLKPWR_SetPCLKDiv
        16   -> check_failed
      16   QEI_IntClear
        16   -> check_failed
      16   QEI_IntCmd
        16   -> check_failed
      16   QEI_IntSet
        16   -> check_failed
      16   QEI_Reset
        16   -> check_failed
      16   QEI_SetDigiFilter
        16   -> check_failed
      16   QEI_SetIndexComp
        16   -> check_failed
      16   QEI_SetMaxPosition
        16   -> check_failed
      24   QEI_SetPositionComp
        24   -> check_failed
      24   QEI_SetTimerReload
        24   -> CLKPWR_GetPCLK
        24   -> check_failed
        24 __aeabi_uldivmod
      16   QEI_SetVelocityComp
        16   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
      60  ?_0
     152  QEI_CalculateRPM
      34  QEI_ConfigStructInit
      34  QEI_DeInit
      22  QEI_GetIndex
     112  QEI_GetIntStatus
      26  QEI_GetPosition
      54  QEI_GetStatus
      24  QEI_GetTimer
      24  QEI_GetVelocity
      24  QEI_GetVelocityCap
     222  QEI_Init
     100  QEI_IntClear
     136  QEI_IntCmd
     100  QEI_IntSet
      54  QEI_Reset
      26  QEI_SetDigiFilter
      24  QEI_SetIndexComp
      28  QEI_SetMaxPosition
      64  QEI_SetPositionComp
      98  QEI_SetTimerReload
      26  QEI_SetVelocityComp

 
    60 bytes in section .rodata
 1 396 bytes in section .text
 
 1 396 bytes of CODE  memory
    60 bytes of CONST memory

Errors: none
Warnings: none
