###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       22/Sep/2017  00:13:13
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\APP\Tasks\app_task_comm.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\APP\Tasks\app_task_comm.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\app_task_comm.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\app_task_comm.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\APP\Tasks\app_task_comm.c
      1          /*******************************************************************************
      2          *   Filename:       app_task_comm.c
      3          *   Revised:        All copyrights reserved to wumingshen.
      4          *   Revision:       v1.0
      5          *   Writer:	     wumingshen.
      6          *
      7          *   Description:    双击选中 comm 按 Ctrl + H, 钩选 Match the case, Replace with
      8          *                   输入您要的名字，点击 Replace All
      9          *                   双击选中 Comm 按 Ctrl + H, 钩选 Match the case, Replace with
     10          *                   输入您要的名字，点击 Replace All
     11          *                   双击选中 COMM 按 Ctrl + H, 钩选 Match the case, Replace with
     12          *                   输入您要的名字，点击 Replace All
     13          *                   在 app_cfg.h 中指定本任务的 优先级  （ APP_TASK_COMM_PRIO     ）
     14          *                                            和 任务堆栈（ APP_TASK_COMM_STK_SIZE ）大小
     15          *
     16          *   Notes:
     17          *     				E-mail: shenchangwei945@163.com
     18          *
     19          *******************************************************************************/
     20          
     21          /*******************************************************************************
     22          * INCLUDES
     23          */
     24          #define  SNL_APP_SOURCE
     25          #include <includes.h>
     26          #include <app_comm_protocol.h>
     27          #include <app_ctrl.h>
     28          #include <os_cfg_app.h>
     29          #include "csnc_package_deal.h"
     30          
     31          //#include <bsp_flash.h>
     32          //#include <iap.h>
     33          
     34          #ifdef VSC_INCLUDE_SOURCE_FILE_NAMES
     35          const  CPU_CHAR  *app_task_comm__c = "$Id: $";
     36          #endif
     37          
     38          #define APP_TASK_COMM_EN     DEF_ENABLED
     39          #if APP_TASK_COMM_EN == DEF_ENABLED
     40          /*******************************************************************************
     41          * CONSTANTS
     42          */
     43          
     44          /*******************************************************************************
     45          * MACROS
     46          */
     47          #define CYCLE_TIME_TICKS            (OS_TICKS_PER_SEC * 1)
     48          
     49          /*******************************************************************************
     50          * TYPEDEFS
     51          */
     52          
     53          
     54          
     55          /***********************************************
     56          * 描述： 任务控制块（TCB）
     57          */

   \                                 In section .bss, align 4
     58          static  OS_TCB   AppTaskCommTCB;
   \                     AppTaskCommTCB:
   \   00000000                      DS8 200
     59          
     60          /***********************************************
     61          * 描述： 任务堆栈（STACKS）
     62          */

   \                                 In section .bss, align 4
     63          static  CPU_STK  AppTaskCommStk[ APP_TASK_COMM_STK_SIZE ];
   \                     AppTaskCommStk:
   \   00000000                      DS8 1024
     64          
     65          //StrCtrlDCB       Ctrl;
     66          

   \                                 In section .bss, align 4
     67          OS_Q             MTR_RxQ;
   \                     MTR_RxQ:
   \   00000000                      DS8 48
     68          /*******************************************************************************
     69          * LOCAL VARIABLES
     70          */
     71          
     72          /*******************************************************************************
     73          * GLOBAL VARIABLES
     74          */
     75          
     76          /***********************************************
     77          * 描述： 软定时器声明
     78          */

   \                                 In section .bss, align 4
     79          OS_TMR          OSTmr1;                         //定时器1
   \                     OSTmr1:
   \   00000000                      DS8 52
     80          
     81          /***********************************************
     82          * 描述： 软定时器回调函数
     83          */
     84          void            OSTmr1_callback             (OS_TMR *ptmr,void *p_arg);
     85          CPU_BOOLEAN     APP_CSNC_CommHandler        (MODBUS_CH  *pch);
     86          CPU_BOOLEAN     APP_MaterCommHandler        (MODBUS_CH  *pch);
     87          
     88          /*******************************************************************************
     89          * LOCAL FUNCTIONS
     90          */
     91          static void    AppTaskComm                 (void *p_arg);
     92          static void    APP_CommInit                (void);
     93          void    App_McuStatusInit           (void);
     94          void    ReportDevStatusHandle       (void);
     95          void    InformCommConfigMode        (u8 mode);
     96          static void    App_ModbusInit              (void);
     97          
     98          INT08U          APP_CommRxDataDealCB        (MODBUS_CH  *pch);
     99          INT08U          IAP_CommRxDataDealCB        (MODBUS_CH  *pch);
    100          /*******************************************************************************
    101          * GLOBAL FUNCTIONS
    102          */
    103          
    104          /*******************************************************************************
    105          * EXTERN VARIABLES
    106          */
    107          
    108          /*******************************************************************************
    109          * EXTERN FUNCTIONS
    110          */
    111          extern  void    app_comm_mtr(void);
    112          extern  void    app_comm_dtu(void);
    113          extern  void    app_comm_otr(void);
    114          
    115          unsigned char GetRecSlaveAddr(void);
    116          
    117          /*******************************************************************************/
    118          
    119          /*******************************************************************************
    120          * 名    称： App_TaskCommCreate
    121          * 功    能： **任务创建
    122          * 入口参数： 无
    123          * 出口参数： 无
    124          * 作　 　者： wumingshen.
    125          * 创建日期： 2015-02-05
    126          * 修    改：
    127          * 修改日期：
    128          * 备    注： 任务创建函数需要在app.h文件中声明
    129          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    130          void  App_TaskCommCreate(void)
    131          {
   \                     App_TaskCommCreate: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    132              OS_ERR  err;
    133              
    134              /***********************************************
    135              * 描述： 任务创建
    136              */
    137              OSTaskCreate((OS_TCB     *)&AppTaskCommTCB,                     // 任务控制块  （当前文件中定义）
    138                           (CPU_CHAR   *)"App Task Comm",                     // 任务名称
    139                           (OS_TASK_PTR ) AppTaskComm,                        // 任务函数指针（当前文件中定义）
    140                           (void       *) 0,                                  // 任务函数参数
    141                           (OS_PRIO     ) APP_TASK_COMM_PRIO,                 // 任务优先级，不同任务优先级可以相同，0 < 优先级 < OS_CFG_PRIO_MAX - 2（app_cfg.h中定义）
    142                           (CPU_STK    *)&AppTaskCommStk[0],                  // 任务栈顶
    143                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE / 10,        // 任务栈溢出报警值
    144                           (CPU_STK_SIZE) APP_TASK_COMM_STK_SIZE,             // 任务栈大小（CPU数据宽度 * 8 * size = 4 * 8 * size(字节)）（app_cfg.h中定义）
    145                           (OS_MSG_QTY  ) 0u,                                 // 可以发送给任务的最大消息队列数量
    146                           (OS_TICK     ) 0u,                                 // 相同优先级任务的轮循时间（ms），0为默认
    147                           (void       *) 0,                                  // 是一个指向它被用作一个TCB扩展用户提供的存储器位置
    148                           (OS_OPT      )(OS_OPT_TASK_STK_CHK |               // 允许堆栈检查该任务
    149                                          OS_OPT_TASK_STK_CLR),               // 创建任务时堆栈清零
    150                           (OS_ERR     *)&err);                               // 指向错误代码的指针，用于创建结果处理
   \   00000004   0xA809             ADD      R0,SP,#+36
   \   00000006   0x9008             STR      R0,[SP, #+32]
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x9007             STR      R0,[SP, #+28]
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9006             STR      R0,[SP, #+24]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9005             STR      R0,[SP, #+20]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9004             STR      R0,[SP, #+16]
   \   00000018   0xF44F 0x7080      MOV      R0,#+256
   \   0000001C   0x9003             STR      R0,[SP, #+12]
   \   0000001E   0x2019             MOVS     R0,#+25
   \   00000020   0x9002             STR      R0,[SP, #+8]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable6
   \   00000026   0x9001             STR      R0,[SP, #+4]
   \   00000028   0x2031             MOVS     R0,#+49
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x.... 0x....      ADR.W    R2,AppTaskComm
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable6_1
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable6_2
   \   0000003A   0x.... 0x....      BL       OSTaskCreate
    151              
    152          }
   \   0000003E   0xB00B             ADD      SP,SP,#+44
   \   00000040   0xBD00             POP      {PC}             ;; return
    153          
    154          /*******************************************************************************
    155          * 名    称： AppTaskComm
    156          * 功    能： 控制任务
    157          * 入口参数： p_arg - 由任务创建函数传入
    158          * 出口参数： 无
    159          * 作　 　者： wumingshen.
    160          * 创建日期： 2015-02-05
    161          * 修    改：
    162          * 修改日期：
    163          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    164          static  void  AppTaskComm (void *p_arg)
    165          {
   \                     AppTaskComm: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0004             MOVS     R4,R0
    166              OS_ERR      err;
    167              
    168              OS_TICK     dly     = CYCLE_TIME_TICKS;
   \   00000008   0xF44F 0x757A      MOV      R5,#+1000
    169              OS_TICK     ticks;
    170              /***********************************************
    171              * 描述： 任务初始化
    172              */
    173              APP_CommInit();         
   \   0000000C   0x.... 0x....      BL       APP_CommInit
    174              
    175              /***********************************************
    176              * 描述： Task body, always written as an infinite loop.
    177              */
    178              while (DEF_TRUE) { 
    179                  /***********************************************
    180                  * 描述： 本任务看门狗标志置位
    181                  */
    182                  OS_FlagPost(( OS_FLAG_GRP *)&WdtFlagGRP,
    183                              ( OS_FLAGS     ) WDT_FLAG_COMM,
    184                              ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    185                              ( CPU_TS       ) 0,
    186                              ( OS_ERR      *) &err);
   \                     ??AppTaskComm_0: (+1)
   \   00000010   0xA802             ADD      R0,SP,#+8
   \   00000012   0x9000             STR      R0,[SP, #+0]
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable6_3
   \   0000001E   0x.... 0x....      BL       OS_FlagPost
    187                  
    188                  /***********************************************
    189                  * 描述： 等待COMM的标识组
    190                  */
    191                  OS_FLAGS    flags = 
    192                      OSFlagPend( ( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    193                                 ( OS_FLAGS     ) sCtrl.Os.CommEvtFlag,
    194                                 ( OS_TICK      ) dly,
    195                                 ( OS_OPT       ) OS_OPT_PEND_FLAG_SET_ANY,
    196                                 ( CPU_TS      *) NULL,
    197                                 ( OS_ERR      *)&err);
   \   00000022   0xA802             ADD      R0,SP,#+8
   \   00000024   0x9001             STR      R0,[SP, #+4]
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9000             STR      R0,[SP, #+0]
   \   0000002A   0x2308             MOVS     R3,#+8
   \   0000002C   0x002A             MOVS     R2,R5
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   00000032   0xF8D0 0x1824      LDR      R1,[R0, #+2084]
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   0000003A   0x.... 0x....      BL       OSFlagPend
   \   0000003E   0x0007             MOVS     R7,R0
    198                  
    199                  OS_ERR      terr;
    200                  ticks   = OSTimeGet(&terr);                        // 获取当前OSTick
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x.... 0x....      BL       OSTimeGet
   \   00000046   0x0006             MOVS     R6,R0
    201                  
    202                  /***********************************************
    203                  * 描述： 没有错误,有事件发生
    204                  */
    205                  if ( err == OS_ERR_NONE ) {
   \   00000048   0xF8BD 0x0008      LDRH     R0,[SP, #+8]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD1DF             BNE.N    ??AppTaskComm_0
    206                      OS_FLAGS    flagClr = 0;
   \   00000050   0xF05F 0x0800      MOVS     R8,#+0
    207                      /***********************************************
    208                      * 和测量某块通讯有关事件发生，调用MTR通讯处理函数
    209                      */           
    210                      if(     flags & COMM_EVT_FLAG_MTR_RX 
    211                         ||   flags & COMM_EVT_FLAG_MTR_TIMEOUT ) {
   \   00000054   0xF017 0x0F09      TST      R7,#0x9
   \   00000058   0xD009             BEQ.N    ??AppTaskComm_1
    212                             
    213                             //调用mtr通讯处理函数
    214                             app_comm_mtr();                             
   \   0000005A   0x.... 0x....      BL       app_comm_mtr
    215                             
    216                             if(flags & COMM_EVT_FLAG_MTR_RX) {      
   \   0000005E   0x07F8             LSLS     R0,R7,#+31
   \   00000060   0xD502             BPL.N    ??AppTaskComm_2
    217                                 flagClr |= COMM_EVT_FLAG_MTR_RX;         //接收到数据，清接收数据标示
   \   00000062   0xF058 0x0801      ORRS     R8,R8,#0x1
   \   00000066   0xE028             B.N      ??AppTaskComm_3
    218                             }else{
    219                                 flagClr |= COMM_EVT_FLAG_MTR_TIMEOUT;   //超时，清接收数据标示
   \                     ??AppTaskComm_2: (+1)
   \   00000068   0xF058 0x0808      ORRS     R8,R8,#0x8
   \   0000006C   0xE025             B.N      ??AppTaskComm_3
    220                             }
    221                         }
    222                      
    223                      /***********************************************
    224                      * 和无线发送模块事件发生，调用DTU通讯处理函数
    225                      */           
    226                      else  if(   flags & COMM_EVT_FLAG_DTU_RX 
    227                               ||  flags & COMM_EVT_FLAG_DTU_TIMEOUT ) {
   \                     ??AppTaskComm_1: (+1)
   \   0000006E   0xF017 0x0F12      TST      R7,#0x12
   \   00000072   0xD009             BEQ.N    ??AppTaskComm_4
    228                                   
    229                                   //调用DTU通讯处理函数
    230                                   app_comm_dtu();                            
   \   00000074   0x.... 0x....      BL       app_comm_dtu
    231                                   
    232                                   if(flags &      COMM_EVT_FLAG_DTU_RX) {      
   \   00000078   0x07B8             LSLS     R0,R7,#+30
   \   0000007A   0xD502             BPL.N    ??AppTaskComm_5
    233                                       flagClr |=  COMM_EVT_FLAG_DTU_RX;        //接收到数据，清接收数据标示
   \   0000007C   0xF058 0x0802      ORRS     R8,R8,#0x2
   \   00000080   0xE01B             B.N      ??AppTaskComm_3
    234          
    235                                   }else{
    236                                       flagClr |=  COMM_EVT_FLAG_DTU_TIMEOUT;   //接收到数据，清接收数据标示
   \                     ??AppTaskComm_5: (+1)
   \   00000082   0xF058 0x0810      ORRS     R8,R8,#0x10
   \   00000086   0xE018             B.N      ??AppTaskComm_3
    237                                   }
    238                               }
    239                      
    240                      /***********************************************
    241                      * 和IC模块事件发生，调用OTR通讯处理函数
    242                      */           
    243                      else if(    flags & COMM_EVT_FLAG_OTR_RX 
    244                              ||  flags & COMM_EVT_FLAG_OTR_TIMEOUT ) {
   \                     ??AppTaskComm_4: (+1)
   \   00000088   0xF017 0x0F24      TST      R7,#0x24
   \   0000008C   0xD009             BEQ.N    ??AppTaskComm_6
    245                                  
    246                                  //调用DTU通讯处理函数
    247                                  app_comm_otr();                             
   \   0000008E   0x.... 0x....      BL       app_comm_otr
    248                                  
    249                                  if(flags &      COMM_EVT_FLAG_OTR_RX) {      
   \   00000092   0x0778             LSLS     R0,R7,#+29
   \   00000094   0xD502             BPL.N    ??AppTaskComm_7
    250                                      flagClr |=  COMM_EVT_FLAG_OTR_RX;        //接收到数据，清接收数据标示
   \   00000096   0xF058 0x0804      ORRS     R8,R8,#0x4
   \   0000009A   0xE00E             B.N      ??AppTaskComm_3
    251                                  }else{
    252                                      flagClr |=  COMM_EVT_FLAG_OTR_TIMEOUT;   //接收到数据，清接收数据标示
   \                     ??AppTaskComm_7: (+1)
   \   0000009C   0xF058 0x0820      ORRS     R8,R8,#0x20
   \   000000A0   0xE00B             B.N      ??AppTaskComm_3
    253                                  }
    254                              }
    255                      else if(    flags & COMM_EVT_FLAG_TAX_RX 
    256                              ||  flags & COMM_EVT_FLAG_TAX_TIMEOUT ) {
   \                     ??AppTaskComm_6: (+1)
   \   000000A2   0xF017 0x0FC0      TST      R7,#0xC0
   \   000000A6   0xD008             BEQ.N    ??AppTaskComm_3
    257                      
    258                                  //调用DTU通讯处理函数
    259                                  app_comm_tax();                             
   \   000000A8   0x.... 0x....      BL       app_comm_tax
    260                                  
    261                                  if(flags &      COMM_EVT_FLAG_TAX_RX) {      
   \   000000AC   0x0678             LSLS     R0,R7,#+25
   \   000000AE   0xD502             BPL.N    ??AppTaskComm_8
    262                                      flagClr |=  COMM_EVT_FLAG_TAX_RX;        //接收到数据，清接收数据标示
   \   000000B0   0xF058 0x0840      ORRS     R8,R8,#0x40
   \   000000B4   0xE001             B.N      ??AppTaskComm_3
    263                                  }else{
    264                                      flagClr |=  COMM_EVT_FLAG_TAX_TIMEOUT;   //接收到数据，清接收数据标示
   \                     ??AppTaskComm_8: (+1)
   \   000000B6   0xF058 0x0880      ORRS     R8,R8,#0x80
    265                                  }
    266                              }
    267                      /***********************************************
    268                      * 描述： 清除标志
    269                      */
    270                      if ( !flagClr ) {
   \                     ??AppTaskComm_3: (+1)
   \   000000BA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000BE   0xD100             BNE.N    ??AppTaskComm_9
    271                          flagClr = flags;
   \   000000C0   0x46B8             MOV      R8,R7
    272                      }
    273                      
    274                      /***********************************************
    275                      * 描述： 清除标志位
    276                      */
    277                      OSFlagPost( ( OS_FLAG_GRP  *)&sCtrl.Os.CommEvtFlagGrp,
    278                                 ( OS_FLAGS      )flagClr,
    279                                 ( OS_OPT        )OS_OPT_POST_FLAG_CLR,
    280                                 ( OS_ERR       *)&err);
   \                     ??AppTaskComm_9: (+1)
   \   000000C2   0xAB02             ADD      R3,SP,#+8
   \   000000C4   0x2201             MOVS     R2,#+1
   \   000000C6   0x4641             MOV      R1,R8
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   000000CC   0x.... 0x....      BL       OSFlagPost
   \   000000D0   0xE79E             B.N      ??AppTaskComm_0
    281                  }
    282              }
    283          }
    284          
    285          /*******************************************************************************
    286          * 名    称： APP_ModbusInit
    287          * 功    能： MODBUS初始化
    288          * 入口参数： 无
    289          * 出口参数： 无
    290          * 作　 　者： 无名沈
    291          * 创建日期： 2015-03-28
    292          * 修    改：
    293          * 修改日期：
    294          * 备    注： 该初始化会创建Modbus任务。
    295          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    296          void App_ModbusInit(void)
    297          {
   \                     App_ModbusInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    298              MODBUS_CH   *pch;
    299              /***********************************************
    300              * 描述： uCModBus初始化，RTU时钟频率为1000HZ
    301              *        使用了定时器2（TIM2）
    302              */
    303              MB_Init(1000);
   \   00000004   0xF44F 0x707A      MOV      R0,#+1000
   \   00000008   0x.... 0x....      BL       MB_Init
    304              
    305              // UART1
    306              /***********************************************
    307              * 描述：  UART1串口和测量装置连接。master
    308              *        用作主机。
    309              */
    310          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    311              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    312                                     MODBUS_SLAVE,          // ... This is a MASTER
    313                                     500,                    // ... 0 when a slave
    314                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    315                                     1,                      // ... Specify UART #1
    316                                     9600,                   // ... Baud Rate
    317                                     UART_DATABIT_8,         // ... Number of data bits 7 or 8
    318                                     UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    319                                     UART_STOPBIT_1,         // ... Number of stop bits 1 or 2
    320                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x9005             STR      R0,[SP, #+20]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9004             STR      R0,[SP, #+16]
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x9003             STR      R0,[SP, #+12]
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x9002             STR      R0,[SP, #+8]
   \   0000001C   0xF44F 0x5016      MOV      R0,#+9600
   \   00000020   0x9001             STR      R0,[SP, #+4]
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x9000             STR      R0,[SP, #+0]
   \   00000026   0x2300             MOVS     R3,#+0
   \   00000028   0xF44F 0x72FA      MOV      R2,#+500
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x.... 0x....      BL       MB_CfgCh
   \   00000034   0x0004             MOVS     R4,R0
    321              pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
   \   00000036   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   0000003A   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000003E   0xF884 0x0452      STRB     R0,[R4, #+1106]
    322              pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
   \   00000042   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000046   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004A   0xF884 0x0452      STRB     R0,[R4, #+1106]
    323              pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
   \   0000004E   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000052   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000056   0xF884 0x0452      STRB     R0,[R4, #+1106]
    324              
    325              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   0000005A   0xF241 0x0028      MOVW     R0,#+4136
   \   0000005E   0xF8A4 0x034A      STRH     R0,[R4, #+842]
    326              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   00000062   0xF241 0x002C      MOVW     R0,#+4140
   \   00000066   0xF8A4 0x034C      STRH     R0,[R4, #+844]
    327              
    328              sCtrl.Mtr.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   0000006E   0xF8C0 0x43A8      STR      R4,[R0, #+936]
    329              
    330          #endif
    331              // UART2
    332              /***********************************************
    333              * 描述:   UART2串口和无线发送模块连接。master
    334              *         用作主机 通过无线模块  连接 公司无线接收服务器
    335              */
    336              
    337          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    338              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    339                                     MODBUS_SLAVE,           // ... This is a MASTER
    340                                     500,                    // ... 0 when a slave
    341                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    342                                     3,                      // ... Specify UART #3
    343                                     57600,                  // ... Baud Rate
    344                                     UART_DATABIT_8,         // ... Number of data bits 7 or 8
    345                                     UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    346                                     UART_STOPBIT_1,         // ... Number of stop bits 1 or 2
    347                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x9005             STR      R0,[SP, #+20]
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x9004             STR      R0,[SP, #+16]
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x9003             STR      R0,[SP, #+12]
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x9002             STR      R0,[SP, #+8]
   \   00000082   0xF44F 0x4061      MOV      R0,#+57600
   \   00000086   0x9001             STR      R0,[SP, #+4]
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0x9000             STR      R0,[SP, #+0]
   \   0000008C   0x2300             MOVS     R3,#+0
   \   0000008E   0xF44F 0x72FA      MOV      R2,#+500
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       MB_CfgCh
   \   0000009A   0x0004             MOVS     R4,R0
    348              pch->AesEn          =   DEF_DISABLED;           // ... AES加密禁止
   \   0000009C   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   000000A0   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   000000A4   0xF884 0x0452      STRB     R0,[R4, #+1106]
    349              pch->NonModbusEn    =   DEF_ENABLED;            // ... 支持非MODBUS通信
   \   000000A8   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   000000AC   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000B0   0xF884 0x0452      STRB     R0,[R4, #+1106]
    350              pch->IapModbusEn    =   DEF_ENABLED;            // ... 支持IAP MODBUS通信
   \   000000B4   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   000000B8   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000BC   0xF884 0x0452      STRB     R0,[R4, #+1106]
    351              
    352              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   000000C0   0xF241 0x0028      MOVW     R0,#+4136
   \   000000C4   0xF8A4 0x034A      STRH     R0,[R4, #+842]
    353              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   000000C8   0xF241 0x002C      MOVW     R0,#+4140
   \   000000CC   0xF8A4 0x034C      STRH     R0,[R4, #+844]
    354              
    355              
    356              sCtrl.Dtu.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   000000D4   0xF8C0 0x4509      STR      R4,[R0, #+1289]
    357          #endif
    358              
    359              // UART3
    360              /***********************************************
    361              * 描述：  UART3串口和IC卡模块连接。master
    362              *        
    363              */
    364          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    365              
    366              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    367                                     MODBUS_SLAVE,           // ... This is a SLAVE
    368                                     500,                    // ... 0 when a slave
    369                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    370                                     2,                      // ... Specify UART #2
    371                                     57600,                   // ... Baud Rate
    372                                     UART_DATABIT_8,         // ... Number of data bits 7 or 8
    373                                     UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    374                                     UART_STOPBIT_1,         // ... Number of stop bits 1 or 2
    375                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0x9005             STR      R0,[SP, #+20]
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x9004             STR      R0,[SP, #+16]
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9003             STR      R0,[SP, #+12]
   \   000000E4   0x2003             MOVS     R0,#+3
   \   000000E6   0x9002             STR      R0,[SP, #+8]
   \   000000E8   0xF44F 0x4061      MOV      R0,#+57600
   \   000000EC   0x9001             STR      R0,[SP, #+4]
   \   000000EE   0x2002             MOVS     R0,#+2
   \   000000F0   0x9000             STR      R0,[SP, #+0]
   \   000000F2   0x2300             MOVS     R3,#+0
   \   000000F4   0xF44F 0x72FA      MOV      R2,#+500
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x.... 0x....      BL       MB_CfgCh
   \   00000100   0x0004             MOVS     R4,R0
    376              pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
   \   00000102   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000106   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   0000010A   0xF884 0x0452      STRB     R0,[R4, #+1106]
    377              pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
   \   0000010E   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000112   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000116   0xF884 0x0452      STRB     R0,[R4, #+1106]
    378              pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
   \   0000011A   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   0000011E   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000122   0xF884 0x0452      STRB     R0,[R4, #+1106]
    379              
    380              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   00000126   0xF241 0x0028      MOVW     R0,#+4136
   \   0000012A   0xF8A4 0x034A      STRH     R0,[R4, #+842]
    381              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   0000012E   0xF241 0x002C      MOVW     R0,#+4140
   \   00000132   0xF8A4 0x034C      STRH     R0,[R4, #+844]
    382              
    383              sCtrl.Otr.pch       = pch;                      // ... modbus控制块和全局结构体建立连接
   \   00000136   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   0000013A   0xF8C0 0x466A      STR      R4,[R0, #+1642]
    384          #endif
    385              
    386              // UART3
    387              /***********************************************
    388              * 描述：  UART0串口和TAX连接。slave
    389              *        
    390              */
    391          #if MODBUS_CFG_MASTER_EN == DEF_TRUE
    392              
    393              pch         = MB_CfgCh( ModbusNode,             // ... Modbus Node # for this slave channel
    394                                     MODBUS_SLAVE,           // ... This is a SLAVE
    395                                     500,                    // ... 0 when a slave
    396                                     MODBUS_MODE_RTU,        // ... Modbus Mode (_ASCII or _RTU)
    397                                     0,                      // ... Specify UART #0
    398                                     28800,                   // ... Baud Rate
    399                                     UART_DATABIT_8,         // ... Number of data bits 7 or 8
    400                                     //UART_PARITY_NONE,       // ... Parity: _NONE, _ODD or _EVEN
    401                                     UART_PARITY_SP_0,
    402                                     UART_STOPBIT_1,         // ... Number of stop bits 1 or 2
    403                                     MODBUS_WR_EN);          // ... Enable (_EN) or disable (_DIS) writes
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x9005             STR      R0,[SP, #+20]
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x9004             STR      R0,[SP, #+16]
   \   00000146   0x2004             MOVS     R0,#+4
   \   00000148   0x9003             STR      R0,[SP, #+12]
   \   0000014A   0x2003             MOVS     R0,#+3
   \   0000014C   0x9002             STR      R0,[SP, #+8]
   \   0000014E   0xF44F 0x40E1      MOV      R0,#+28800
   \   00000152   0x9001             STR      R0,[SP, #+4]
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x9000             STR      R0,[SP, #+0]
   \   00000158   0x2300             MOVS     R3,#+0
   \   0000015A   0xF44F 0x72FA      MOV      R2,#+500
   \   0000015E   0x2100             MOVS     R1,#+0
   \   00000160   0x2001             MOVS     R0,#+1
   \   00000162   0x.... 0x....      BL       MB_CfgCh
   \   00000166   0x0004             MOVS     R4,R0
    404              pch->AesEn          = DEF_DISABLED;             // ... AES加密禁止
   \   00000168   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   0000016C   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000170   0xF884 0x0452      STRB     R0,[R4, #+1106]
    405              pch->NonModbusEn    = DEF_ENABLED;              // ... 支持非MODBUS通信
   \   00000174   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000178   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000017C   0xF884 0x0452      STRB     R0,[R4, #+1106]
    406              pch->IapModbusEn    = DEF_ENABLED;              // ... 支持IAP MODBUS通信
   \   00000180   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000184   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000188   0xF884 0x0452      STRB     R0,[R4, #+1106]
    407              
    408              pch->RxFrameHead    = 0x1028;                   // ... 添加匹配帧头
   \   0000018C   0xF241 0x0028      MOVW     R0,#+4136
   \   00000190   0xF8A4 0x034A      STRH     R0,[R4, #+842]
    409              pch->RxFrameTail    = 0x102C;                   // ... 添加匹配帧尾
   \   00000194   0xF241 0x002C      MOVW     R0,#+4140
   \   00000198   0xF8A4 0x034C      STRH     R0,[R4, #+844]
    410              
    411              pch->RTU_TimeoutCnts = 50;
   \   0000019C   0x2032             MOVS     R0,#+50
   \   0000019E   0x8320             STRH     R0,[R4, #+24]
    412              pch->RTU_TimeoutCtr  = 50;
   \   000001A0   0x2032             MOVS     R0,#+50
   \   000001A2   0x8360             STRH     R0,[R4, #+26]
    413              
    414              sCtrl.DevTax.pch    = pch;                      // ... modbus控制块和全局结构体建立连接
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   000001A8   0xF8C0 0x47CB      STR      R4,[R0, #+1995]
    415          #endif
    416              
    417          }
   \   000001AC   0xB006             ADD      SP,SP,#+24
   \   000001AE   0xBD10             POP      {R4,PC}          ;; return
    418          
    419          
    420          /*******************************************************************************
    421          * 名    称： APP_CommInit
    422          * 功    能： 任务初始化
    423          * 入口参数： 无
    424          * 出口参数： 无
    425          * 作　 　者： wumingshen.
    426          * 创建日期： 2015-03-28
    427          * 修    改：
    428          * 修改日期：
    429          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    430          void APP_CommInit(void)
    431          {
   \                     APP_CommInit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    432              OS_ERR err;
    433              
    434              /***********************************************
    435              * 描述： 创建事件标志组,协调comm收发
    436              */
    437              OSFlagCreate(( OS_FLAG_GRP  *)&sCtrl.Os.CommEvtFlagGrp,
    438                           ( CPU_CHAR     *)"App_CommFlag",
    439                           ( OS_FLAGS      )0,
    440                           ( OS_ERR       *)&err);
   \   00000002   0x466B             MOV      R3,SP
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable6_6
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   0000000E   0x.... 0x....      BL       OSFlagCreate
    441              
    442              sCtrl.Os.CommEvtFlag= COMM_EVT_FLAG_MTR_RX        // MTR 接收事件
    443                  + COMM_EVT_FLAG_DTU_RX          // DTU 接收事件
    444                      + COMM_EVT_FLAG_OTR_RX        // OTR 接收事件
    445                          + COMM_EVT_FLAG_MTR_TIMEOUT   // MTR 操作超时，定时发送使用
    446                              + COMM_EVT_FLAG_DTU_TIMEOUT   // DTU 操作超时，定时发送使用
    447                                  + COMM_EVT_FLAG_OTR_TIMEOUT  // OTR 操作超时，定时发送使用   
    448                                      + COMM_EVT_FLAG_TAX_RX   // TAX 操作超时，定时发送使用
    449                                          + COMM_EVT_FLAG_TAX_TIMEOUT;  // TAX 操作超时，定时发送使用  
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000018   0xF8C1 0x0824      STR      R0,[R1, #+2084]
    450              
    451              /***********************************************
    452              * 描述： 初始化MODBUS通信
    453              */        
    454              App_ModbusInit();
   \   0000001C   0x.... 0x....      BL       App_ModbusInit
    455              
    456              
    457              /***********************************************
    458              * 描述： 在看门狗标志组注册本任务的看门狗标志
    459              */
    460              WdtFlags |= WDT_FLAG_COMM;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable6_7
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable6_7
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    461          }
   \   00000030   0xBD01             POP      {R0,PC}          ;; return
    462          
    463          /*******************************************************************************
    464          * 名    称： APP_CommRxDataDealCB
    465          * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    466          * 入口参数： 无
    467          * 出口参数： 无
    468          * 作    者： 无名沈
    469          * 创建日期： 2016-01-04
    470          * 修    改：
    471          * 修改日期：
    472          * 备    注： 
    473          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    474          INT08U APP_CommRxDataDealCB(MODBUS_CH  *pch)
    475          {
   \                     APP_CommRxDataDealCB: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0C7             SUB      SP,SP,#+284
   \   00000006   0x0004             MOVS     R4,R0
    476              /***********************************************
    477              * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    478              */
    479          #if MB_IAPMODBUS_EN == DEF_ENABLED
    480              //    /***********************************************
    481              //    * 描述： 如果程序处在升级模式
    482              //    */
    483              //    if ( ( Iap.Status != IAP_STS_DEF ) && 
    484              //         ( Iap.Status != IAP_STS_SUCCEED ) &&
    485              //         ( Iap.Status != IAP_STS_FAILED ) ) {
    486              //        return IAP_CommRxDataDealCB(pch);
    487              //    }
    488          #endif
    489              /***********************************************
    490              * 描述： 获取帧头
    491              */
    492              CPU_SR_ALLOC();
   \   00000008   0x2500             MOVS     R5,#+0
    493              
    494              //redmorningcn 数据复制功能由MBS_RTU_Task 已经执行。此处无需重复拷贝。
    495              
    496              //    CPU_CRITICAL_ENTER();
    497              //    //u8  Len     = pch->RxBufByteCtr;
    498              //u8  Len     = pch->RxBufByteCnt;
    499              //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    500              //    CPU_CRITICAL_EXIT();
    501              
    502              OS_ERR      err;
    503              
    504              //DataBuf = pch->RxFrameData;
    505              
    506              //INT08U  *DataBuf = 0 ;
    507              /***********************************************
    508              * 描述： 接收数据处理,
    509              * 根据协议，返回数据是            源地址
    510              *           目标地址由           GetRecSlaveAddr （）获得。
    511              *           数据区长度在          Len
    512              *           数据区                 DataBuf
    513              *           接收序号            GetRecvFrameNbr（）
    514              */  
    515              
    516               //在此增加新的V2.0   
    517              stcCsncProtocolPara sCsncPara;      //csnsY
    518              sCsncPara.destaddr = 0;             //地址赋值
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0005      STRB     R0,[SP, #+5]
    519              
    520              uint8       buf[256];
    521              uint8       flg; 
    522              sCsncPara.databuf = buf;
   \   00000010   0xA806             ADD      R0,SP,#+24
   \   00000012   0x9002             STR      R0,[SP, #+8]
    523              sCsncPara.rxtxbuf = (uint8 *)pch->RxFrameData;
   \   00000014   0xF514 0x7011      ADDS     R0,R4,#+580
   \   00000018   0x9003             STR      R0,[SP, #+12]
    524              sCsncPara.rxtxlen = pch->RxBufByteCnt;
   \   0000001A   0x8E60             LDRH     R0,[R4, #+50]
   \   0000001C   0xF88D 0x0011      STRB     R0,[SP, #+17]
    525              flg = DataUnpack_CSNC(&sCsncPara);   
   \   00000020   0xA801             ADD      R0,SP,#+4
   \   00000022   0x.... 0x....      BL       DataUnpack_CSNC
   \   00000026   0x0006             MOVS     R6,R0
    526          //   
    527          //    //fhV1.0
    528          //    uint8   DataPos;
    529          //    u8  SourceAddr = 
    530          //        CSNC_GetData(	(uint8 *)pch->RxFrameData,      //RecBuf,
    531          //                     (uint16 )Len,                      //RecLen, 
    532          //                     (uint8 *)&DataPos,                 //DataBuf,
    533          //                     (uint16 *)&Len);                   //InfoLen)
    534              /***********************************************
    535              * 描述： 如果接收地址和装置地址不符，则不处理，接收数据错误。
    536              */
    537              
    538          //    if ( MASTE_ADDR_HOST != GetRecSlaveAddr() ) 
    539          //        return FALSE;
    540              //fhDl考]
    541              if ( MASTE_ADDR_HOST != sCsncPara.destaddr || flg == 0 ) //解析错误、地址错误，退出。
   \   00000028   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000002C   0x2880             CMP      R0,#+128
   \   0000002E   0xD102             BNE.N    ??APP_CommRxDataDealCB_0
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD101             BNE.N    ??APP_CommRxDataDealCB_1
    542                  return FALSE;
   \                     ??APP_CommRxDataDealCB_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xE19F             B.N      ??APP_CommRxDataDealCB_2
    543              
    544              /***********************************************
    545              * 描述： 根据 地址  pch来源  判断数据是 否 合理 ，
    546              *       并赋值。
    547              */
    548              //switch  (pch->Ch )
    549              switch  (pch->PortNbr )     //根据端口号定义
   \                     ??APP_CommRxDataDealCB_1: (+1)
   \   0000003A   0x7A60             LDRB     R0,[R4, #+9]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD006             BEQ.N    ??APP_CommRxDataDealCB_3
   \   00000040   0x2802             CMP      R0,#+2
   \   00000042   0xF000 0x810D      BEQ.W    ??APP_CommRxDataDealCB_4
   \   00000046   0xD303             BCC.N    ??APP_CommRxDataDealCB_5
   \   00000048   0x2803             CMP      R0,#+3
   \   0000004A   0xD073             BEQ.N    ??APP_CommRxDataDealCB_6
   \   0000004C   0xE194             B.N      ??APP_CommRxDataDealCB_7
    550              {
    551                  /***********************************************
    552                  * 描述： UART0接收到数据
    553                  */
    554              case 0:
    555                  break;
   \                     ??APP_CommRxDataDealCB_3: (+1)
   \   0000004E   0xE193             B.N      ??APP_CommRxDataDealCB_7
    556                  
    557                  /***********************************************
    558                  * 描述： UART1接收到数据。数据发送地址：A1、A2
    559                  *                         数据接收地址：80
    560                  */        
    561              case 1:
    562          //        if(     SLAVE_ADDR_DIP1 == SourceAddr 
    563          //           ||   SLAVE_ADDR_DIP2 == SourceAddr    
    564                  if(     SLAVE_ADDR_DIP1 == sCsncPara.sourceaddr 
    565                     ||   SLAVE_ADDR_DIP2 == sCsncPara.sourceaddr                   
    566                         
    567                         )   
   \                     ??APP_CommRxDataDealCB_5: (+1)
   \   00000050   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000054   0x28A1             CMP      R0,#+161
   \   00000056   0xD003             BEQ.N    ??APP_CommRxDataDealCB_8
   \   00000058   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000005C   0x28A2             CMP      R0,#+162
   \   0000005E   0xD154             BNE.N    ??APP_CommRxDataDealCB_9
    568                  {
    569          //            sCtrl.Mtr.RxCtrl.SourceAddr = SourceAddr;           //源地址
    570          //            sCtrl.Mtr.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
    571          //            sCtrl.Mtr.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
    572          //            sCtrl.Mtr.RxCtrl.Code       = 0;                    //指令码 ，测量装置未定义 
    573          //            sCtrl.Mtr.RxCtrl.Len        = Len;                  //数据区长度
    574                      
    575                      sCtrl.Mtr.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
   \                     ??APP_CommRxDataDealCB_8: (+1)
   \   00000060   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000068   0xF881 0x038D      STRB     R0,[R1, #+909]
    576                      sCtrl.Mtr.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
   \   0000006C   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000074   0xF881 0x038C      STRB     R0,[R1, #+908]
    577                      sCtrl.Mtr.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
   \   00000078   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000080   0xF881 0x038E      STRB     R0,[R1, #+910]
    578                      sCtrl.Mtr.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
   \   00000084   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000088   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000090   0xF881 0x0390      STRB     R0,[R1, #+912]
    579                      sCtrl.Mtr.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度    
   \   00000094   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   0000009C   0xF881 0x038F      STRB     R0,[R1, #+911]
    580                      
    581                      //取数据记录，将数据记录保存到接收区
    582                      //OS_CRITICAL_ENTER();
    583          //            memcpy( (INT08U *)&sCtrl.Mtr.Rd.Buf[0], (INT08U *)&pch->RxFrameData[DataPos], Len );
    584                      //memcpy( (INT08U *)&sCtrl.Mtr.Rd.Buf[0], buf, Len );
    585                      memcpy( (INT08U *)&sCtrl.Mtr.Rd.Buf[0], buf, sCsncPara.datalen );
   \   000000A0   0xF89D 0x7010      LDRB     R7,[SP, #+16]
   \   000000A4   0xF10D 0x0818      ADD      R8,SP,#+24
   \   000000A8   0x.... 0x....      LDR.W    R9,??DataTable6_8
   \   000000AC   0x003A             MOVS     R2,R7
   \   000000AE   0x4641             MOV      R1,R8
   \   000000B0   0x4648             MOV      R0,R9
   \   000000B2   0x.... 0x....      BL       __aeabi_memcpy
    586                      //OS_CRITICAL_EXIT();
    587                      
    588                      /***********************************************
    589                      * 描述： UART1连接状态描述
    590                      */       
    591                      for(uint8 i = 0;i< COMM_DEV_MTR_CONN_NUM;i++)
   \   000000B6   0x2000             MOVS     R0,#+0
   \                     ??APP_CommRxDataDealCB_10: (+1)
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x2802             CMP      R0,#+2
   \   000000BC   0xDA1C             BGE.N    ??APP_CommRxDataDealCB_11
    592                      {
    593          //                if( sCtrl.Mtr.ConnCtrl[i].SlaveAddr == SourceAddr)
    594                          if( sCtrl.Mtr.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr )
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   000000C8   0xF891 0x139C      LDRB     R1,[R1, #+924]
   \   000000CC   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   000000D0   0x4291             CMP      R1,R2
   \   000000D2   0xD10F             BNE.N    ??APP_CommRxDataDealCB_12
    595                          {
    596                              sCtrl.Mtr.ConnCtrl[i].RecvEndFlg   = 1;      //接收到数据，置1。数据处理后置0
   \   000000D4   0x2101             MOVS     R1,#+1
   \   000000D6   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000E0   0xF882 0x1399      STRB     R1,[R2, #+921]
    597                              sCtrl.Mtr.ConnCtrl[i].TimeOut      = 0;      //超时计数器清零。
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \   000000EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EC   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000F0   0xF882 0x139A      STRB     R1,[R2, #+922]
    598                          }
    599                      }
   \                     ??APP_CommRxDataDealCB_12: (+1)
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0xE7DF             B.N      ??APP_CommRxDataDealCB_10
    600                      
    601                      OS_FlagPost(( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    602                                  ( OS_FLAGS     ) COMM_EVT_FLAG_MTR_RX,
    603                                  ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    604                                  ( CPU_TS       ) 0,
    605                                  ( OS_ERR      *) &err);       
   \                     ??APP_CommRxDataDealCB_11: (+1)
   \   000000F8   0xA805             ADD      R0,SP,#+20
   \   000000FA   0x9000             STR      R0,[SP, #+0]
   \   000000FC   0x2300             MOVS     R3,#+0
   \   000000FE   0x2200             MOVS     R2,#+0
   \   00000100   0x2101             MOVS     R1,#+1
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable6_5
   \   00000106   0x.... 0x....      BL       OS_FlagPost
    606                  }
    607                  
    608                  sCtrl.Mtr.ConnectFlag       = 1;
   \                     ??APP_CommRxDataDealCB_9: (+1)
   \   0000010A   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   0000010E   0xF890 0x03AC      LDRB     R0,[R0, #+940]
   \   00000112   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   0000011A   0xF881 0x03AC      STRB     R0,[R1, #+940]
    609                  sCtrl.Mtr.ConnectTimeOut    = 0;   
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   00000122   0xF890 0x03AC      LDRB     R0,[R0, #+940]
   \   00000126   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   0000012E   0xF881 0x03AC      STRB     R0,[R1, #+940]
    610                  
    611                  break;
   \   00000132   0xE121             B.N      ??APP_CommRxDataDealCB_7
    612                  
    613                  /***********************************************
    614                  * 描述： UART3接收到数据。数据发送地址：CA、C2
    615                  *                         数据接收地址:80
    616                  */   
    617              case 3:
    618          //        if(         SLAVE_ADDR_DTU == SourceAddr 
    619          //           ||      SLAVE_ADDR_SET  == SourceAddr    
    620                  
    621                  if(         SLAVE_ADDR_DTU == sCsncPara.sourceaddr 
    622                     ||      SLAVE_ADDR_SET  == sCsncPara.sourceaddr    
    623                         )   
   \                     ??APP_CommRxDataDealCB_6: (+1)
   \   00000134   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000138   0x28CA             CMP      R0,#+202
   \   0000013A   0xD003             BEQ.N    ??APP_CommRxDataDealCB_13
   \   0000013C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000140   0x28C2             CMP      R0,#+194
   \   00000142   0xD17C             BNE.N    ??APP_CommRxDataDealCB_14
    624                  {
    625          //            sCtrl.Dtu.RxCtrl.SourceAddr = SourceAddr;           //源地址
    626          //            sCtrl.Dtu.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
    627          //            sCtrl.Dtu.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
    628          
    629                      sCtrl.Dtu.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
   \                     ??APP_CommRxDataDealCB_13: (+1)
   \   00000144   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   0000014C   0xF881 0x04EE      STRB     R0,[R1, #+1262]
    630                      sCtrl.Dtu.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
   \   00000150   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000158   0xF881 0x04ED      STRB     R0,[R1, #+1261]
    631                      sCtrl.Dtu.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
   \   0000015C   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000164   0xF881 0x04EF      STRB     R0,[R1, #+1263]
    632                      sCtrl.Dtu.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
   \   00000168   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   0000016C   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000174   0xF881 0x04F1      STRB     R0,[R1, #+1265]
    633                      sCtrl.Dtu.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度               
   \   00000178   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000017C   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   00000180   0xF881 0x04F0      STRB     R0,[R1, #+1264]
    634          
    635          			/***********************************************
    636                      * 描述：无线通讯及IC卡通讯，定义数据区的前 4 个字节为命令字，   
    637                      *                           ，4字节后才是真正的数据。                        
    638                      */                   
    639                      //if(Len >=4)     
    640                      if(sCsncPara.datalen >=4 && sCtrl.Dtu.RxCtrl.FrameCode == 0) 
   \   00000184   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   00000188   0x2804             CMP      R0,#+4
   \   0000018A   0xDB24             BLT.N    ??APP_CommRxDataDealCB_15
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable6_4
   \   00000190   0xF890 0x04F1      LDRB     R0,[R0, #+1265]
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD11E             BNE.N    ??APP_CommRxDataDealCB_15
    641                      {
    642                          //sCtrl.Dtu.RxCtrl.Len        = Len - 4;                  //数据区长度
    643                          sCtrl.Dtu.RxCtrl.Len        = sCsncPara.datalen - 4;                  //数据区长度
   \   00000198   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   0000019C   0x1F00             SUBS     R0,R0,#+4
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   000001A2   0xF881 0x04F0      STRB     R0,[R1, #+1264]
    644                          //取数据记录，将数据记录保存到接收区
    645                          //OS_CRITICAL_ENTER();
    646                          //memcpy( (INT08U *)&sCtrl.Dtu.RxCtrl.Code, (INT08U *)&pch->RxFrameData[DataPos], 4);        //功能码
    647                          //memcpy( (INT08U *)&sCtrl.Dtu.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos+4], Len-4 );   //数据区
    648                          memcpy( (INT08U *)&sCtrl.Dtu.RxCtrl.DataCode, buf, 4);        //功能码
   \   000001A6   0x2704             MOVS     R7,#+4
   \   000001A8   0xF10D 0x0818      ADD      R8,SP,#+24
   \   000001AC   0x.... 0x....      LDR.W    R9,??DataTable6_9
   \   000001B0   0x003A             MOVS     R2,R7
   \   000001B2   0x4641             MOV      R1,R8
   \   000001B4   0x4648             MOV      R0,R9
   \   000001B6   0x.... 0x....      BL       __aeabi_memcpy
    649                          memcpy( (INT08U *)&sCtrl.Dtu.Rd.Buf[0],   (INT08U *)&buf[4], sCsncPara.datalen-4 );   //数据区
   \   000001BA   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000001BE   0xF1B0 0x0904      SUBS     R9,R0,#+4
   \   000001C2   0xF10D 0x0A1C      ADD      R10,SP,#+28
   \   000001C6   0x.... 0x....      LDR.W    R11,??DataTable6_10
   \   000001CA   0x464A             MOV      R2,R9
   \   000001CC   0x4651             MOV      R1,R10
   \   000001CE   0x4658             MOV      R0,R11
   \   000001D0   0x.... 0x....      BL       __aeabi_memcpy
    650          
    651                          //OS_CRITICAL_EXIT();                    
    652                      }
   \   000001D4   0xE00A             B.N      ??APP_CommRxDataDealCB_16
    653                      else        //V2.0协议操作  //将数据拷贝数据区，在根据协议解析   
    654                      {
    655                          memcpy( (INT08U *)&sCtrl.Dtu.Rd.Buf[0],   (INT08U *)&buf[0], sCsncPara.datalen );
   \                     ??APP_CommRxDataDealCB_15: (+1)
   \   000001D6   0xF89D 0x7010      LDRB     R7,[SP, #+16]
   \   000001DA   0xF10D 0x0818      ADD      R8,SP,#+24
   \   000001DE   0x.... 0x....      LDR.W    R9,??DataTable6_10
   \   000001E2   0x003A             MOVS     R2,R7
   \   000001E4   0x4641             MOV      R1,R8
   \   000001E6   0x4648             MOV      R0,R9
   \   000001E8   0x.... 0x....      BL       __aeabi_memcpy
    656                      }
    657                      /***********************************************
    658                      * 描述： UART3连接状态描述
    659                      */       
    660                      for(uint8 i = 0;i< COMM_DEV_DTU_CONN_NUM;i++)
   \                     ??APP_CommRxDataDealCB_16: (+1)
   \   000001EC   0x2000             MOVS     R0,#+0
   \                     ??APP_CommRxDataDealCB_17: (+1)
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x2802             CMP      R0,#+2
   \   000001F2   0xDA1C             BGE.N    ??APP_CommRxDataDealCB_18
    661                      {
    662                          //if( sCtrl.Dtu.ConnCtrl[i].SlaveAddr == SourceAddr)
    663                          if( sCtrl.Dtu.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr)
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable6_4
   \   000001F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FA   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   000001FE   0xF891 0x14FD      LDRB     R1,[R1, #+1277]
   \   00000202   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   00000206   0x4291             CMP      R1,R2
   \   00000208   0xD10F             BNE.N    ??APP_CommRxDataDealCB_19
    664                          {
    665                              sCtrl.Dtu.ConnCtrl[i].RecvEndFlg  = 1;              //接收到数据，置1。数据处理后置0
   \   0000020A   0x2101             MOVS     R1,#+1
   \   0000020C   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000216   0xF882 0x14FA      STRB     R1,[R2, #+1274]
    666                              sCtrl.Dtu.ConnCtrl[i].TimeOut     = 0;              //超时计数器清零。
   \   0000021A   0x2100             MOVS     R1,#+0
   \   0000021C   0x.... 0x....      LDR.W    R2,??DataTable6_4
   \   00000220   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000222   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000226   0xF882 0x14FB      STRB     R1,[R2, #+1275]
    667                          }
    668                      }
   \                     ??APP_CommRxDataDealCB_19: (+1)
   \   0000022A   0x1C40             ADDS     R0,R0,#+1
   \   0000022C   0xE7DF             B.N      ??APP_CommRxDataDealCB_17
    669                      
    670                      OS_FlagPost(( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    671                                  ( OS_FLAGS     ) COMM_EVT_FLAG_DTU_RX,
    672                                  ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    673                                  ( CPU_TS       ) 0,
    674                                  ( OS_ERR      *) &err);       
   \                     ??APP_CommRxDataDealCB_18: (+1)
   \   0000022E   0xA805             ADD      R0,SP,#+20
   \   00000230   0x9000             STR      R0,[SP, #+0]
   \   00000232   0x2300             MOVS     R3,#+0
   \   00000234   0x2200             MOVS     R2,#+0
   \   00000236   0x2102             MOVS     R1,#+2
   \   00000238   0x....             LDR.N    R0,??DataTable6_5
   \   0000023A   0x.... 0x....      BL       OS_FlagPost
    675                  }
    676                  
    677                  sCtrl.Dtu.ConnectFlag       = 1;
   \                     ??APP_CommRxDataDealCB_14: (+1)
   \   0000023E   0x....             LDR.N    R0,??DataTable6_4
   \   00000240   0xF890 0x050D      LDRB     R0,[R0, #+1293]
   \   00000244   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000248   0x....             LDR.N    R1,??DataTable6_4
   \   0000024A   0xF881 0x050D      STRB     R0,[R1, #+1293]
    678                  sCtrl.Dtu.ConnectTimeOut    = 0;   
   \   0000024E   0x....             LDR.N    R0,??DataTable6_4
   \   00000250   0xF890 0x050D      LDRB     R0,[R0, #+1293]
   \   00000254   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000258   0x....             LDR.N    R1,??DataTable6_4
   \   0000025A   0xF881 0x050D      STRB     R0,[R1, #+1293]
    679                  
    680                  break;
   \   0000025E   0xE08B             B.N      ??APP_CommRxDataDealCB_7
    681                  /***********************************************
    682                  * 描述： UART2接收到数据
    683                  */   
    684              case 2:
    685          //        if(         SLAVE_ADDR_OTR == SourceAddr 
    686          //           ||      SLAVE_ADDR_SET  == SourceAddr    
    687          //               
    688                  if(         SLAVE_ADDR_OTR == sCsncPara.sourceaddr 
    689                     ||      SLAVE_ADDR_SET  == sCsncPara.sourceaddr    
    690                         )   
   \                     ??APP_CommRxDataDealCB_4: (+1)
   \   00000260   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000264   0x28C1             CMP      R0,#+193
   \   00000266   0xD003             BEQ.N    ??APP_CommRxDataDealCB_20
   \   00000268   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   0000026C   0x28C2             CMP      R0,#+194
   \   0000026E   0xD173             BNE.N    ??APP_CommRxDataDealCB_21
    691                  {
    692          //            sCtrl.Otr.RxCtrl.SourceAddr = SourceAddr;           //源地址
    693          //            sCtrl.Otr.RxCtrl.DestAddr   = GetRecSlaveAddr();    //目标地址
    694          //            sCtrl.Otr.RxCtrl.FramNum    = GetRecvFrameNbr();    //接收到的帧号
    695          
    696                      sCtrl.Otr.RxCtrl.SourceAddr = sCsncPara.sourceaddr;   	//源地址
   \                     ??APP_CommRxDataDealCB_20: (+1)
   \   00000270   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000274   0x....             LDR.N    R1,??DataTable6_4
   \   00000276   0xF881 0x064F      STRB     R0,[R1, #+1615]
    697                      sCtrl.Otr.RxCtrl.DestAddr   = sCsncPara.destaddr;    	//目标地址
   \   0000027A   0xF89D 0x0005      LDRB     R0,[SP, #+5]
   \   0000027E   0x....             LDR.N    R1,??DataTable6_4
   \   00000280   0xF881 0x064E      STRB     R0,[R1, #+1614]
    698                      sCtrl.Otr.RxCtrl.FramNum    = sCsncPara.framnum;    	//接收到的帧号
   \   00000284   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   00000288   0x....             LDR.N    R1,??DataTable6_4
   \   0000028A   0xF881 0x0650      STRB     R0,[R1, #+1616]
    699                      sCtrl.Otr.RxCtrl.FrameCode  = (uint8)sCsncPara.framcode & (0x0f);//指令码 ，测量装置未定义 
   \   0000028E   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000292   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   00000296   0x....             LDR.N    R1,??DataTable6_4
   \   00000298   0xF881 0x0652      STRB     R0,[R1, #+1618]
    700                      sCtrl.Otr.RxCtrl.Len        = sCsncPara.datalen;       	//数据区长度               
   \   0000029C   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000002A0   0x....             LDR.N    R1,??DataTable6_4
   \   000002A2   0xF881 0x0651      STRB     R0,[R1, #+1617]
    701          
    702                      /***********************************************
    703                      * 描述：无线通讯及IC卡通讯，定义数据区的前 4 个字节为命令字，   
    704                      *                           ，4字节后才是真正的数据。                        
    705                      */                   
    706                      //if(Len >=4)  //V1.0协议操作
    707                      if(sCsncPara.datalen >=4 && sCtrl.Otr.RxCtrl.FrameCode == 0) 
   \   000002A6   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000002AA   0x2804             CMP      R0,#+4
   \   000002AC   0xDB23             BLT.N    ??APP_CommRxDataDealCB_22
   \   000002AE   0x....             LDR.N    R0,??DataTable6_4
   \   000002B0   0xF890 0x0652      LDRB     R0,[R0, #+1618]
   \   000002B4   0x2800             CMP      R0,#+0
   \   000002B6   0xD11E             BNE.N    ??APP_CommRxDataDealCB_22
    708                      {
    709                          //sCtrl.Otr.RxCtrl.Len        = Len - 4;                  //数据区长度
    710                          sCtrl.Otr.RxCtrl.Len        = sCtrl.Otr.RxCtrl.Len  - 4;                  //数据区长度 - 4;                  //数据区长度
   \   000002B8   0x....             LDR.N    R0,??DataTable6_4
   \   000002BA   0xF890 0x0651      LDRB     R0,[R0, #+1617]
   \   000002BE   0x1F00             SUBS     R0,R0,#+4
   \   000002C0   0x....             LDR.N    R1,??DataTable6_4
   \   000002C2   0xF881 0x0651      STRB     R0,[R1, #+1617]
    711                          //取数据记录，将数据记录保存到接收区
    712                          //OS_CRITICAL_ENTER();
    713                          //memcpy( (INT08U *)&sCtrl.Otr.RxCtrl.Code, (INT08U *)&pch->RxFrameData[DataPos], 4);        //功能码
    714                          //memcpy( (INT08U *)&sCtrl.Otr.Rd.Buf[0],   (INT08U *)&pch->RxFrameData[DataPos+4], Len-4 );   //数据区
    715          
    716                          memcpy( (INT08U *)&sCtrl.Otr.RxCtrl.DataCode, buf, 4);        //功能码
   \   000002C6   0x2704             MOVS     R7,#+4
   \   000002C8   0xF10D 0x0818      ADD      R8,SP,#+24
   \   000002CC   0x.... 0x....      LDR.W    R9,??DataTable6_11
   \   000002D0   0x003A             MOVS     R2,R7
   \   000002D2   0x4641             MOV      R1,R8
   \   000002D4   0x4648             MOV      R0,R9
   \   000002D6   0x.... 0x....      BL       __aeabi_memcpy
    717                          memcpy( (INT08U *)&sCtrl.Otr.Rd.Buf[0],   (INT08U *)&buf[4], sCsncPara.datalen-4 );   //数据区                //OS_CRITICAL_EXIT();                    
   \   000002DA   0xF89D 0x0010      LDRB     R0,[SP, #+16]
   \   000002DE   0xF1B0 0x0904      SUBS     R9,R0,#+4
   \   000002E2   0xF10D 0x0A1C      ADD      R10,SP,#+28
   \   000002E6   0x.... 0x....      LDR.W    R11,??DataTable6_12
   \   000002EA   0x464A             MOV      R2,R9
   \   000002EC   0x4651             MOV      R1,R10
   \   000002EE   0x4658             MOV      R0,R11
   \   000002F0   0x.... 0x....      BL       __aeabi_memcpy
    718                      }
   \   000002F4   0xE00A             B.N      ??APP_CommRxDataDealCB_23
    719                      else        //V2.0协议操作    //将数据拷贝数据区，在根据协议解析 
    720                      {
    721                          memcpy( (INT08U *)&sCtrl.Otr.Rd.Buf[0],   (INT08U *)&buf[0], sCsncPara.datalen );
   \                     ??APP_CommRxDataDealCB_22: (+1)
   \   000002F6   0xF89D 0x7010      LDRB     R7,[SP, #+16]
   \   000002FA   0xF10D 0x0818      ADD      R8,SP,#+24
   \   000002FE   0x.... 0x....      LDR.W    R9,??DataTable6_12
   \   00000302   0x003A             MOVS     R2,R7
   \   00000304   0x4641             MOV      R1,R8
   \   00000306   0x4648             MOV      R0,R9
   \   00000308   0x.... 0x....      BL       __aeabi_memcpy
    722                      }
    723                      /***********************************************
    724                      * 描述： UART2连接状态描述
    725                      */       
    726                      for(uint8 i = 0;i< COMM_DEV_OTR_CONN_NUM;i++)
   \                     ??APP_CommRxDataDealCB_23: (+1)
   \   0000030C   0x2000             MOVS     R0,#+0
   \                     ??APP_CommRxDataDealCB_24: (+1)
   \   0000030E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000310   0x2802             CMP      R0,#+2
   \   00000312   0xDA19             BGE.N    ??APP_CommRxDataDealCB_25
    727                      {
    728                          //if( sCtrl.Otr.ConnCtrl[i].SlaveAddr == SourceAddr)
    729                          if( sCtrl.Otr.ConnCtrl[i].SlaveAddr == sCsncPara.sourceaddr)
   \   00000314   0x....             LDR.N    R1,??DataTable6_4
   \   00000316   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000318   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \   0000031C   0xF891 0x165E      LDRB     R1,[R1, #+1630]
   \   00000320   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \   00000324   0x4291             CMP      R1,R2
   \   00000326   0xD10D             BNE.N    ??APP_CommRxDataDealCB_26
    730                          {
    731                              sCtrl.Otr.ConnCtrl[i].RecvEndFlg  = 1;      //接收到数据，置1。数据处理后置0
   \   00000328   0x2101             MOVS     R1,#+1
   \   0000032A   0x....             LDR.N    R2,??DataTable6_4
   \   0000032C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000032E   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000332   0xF882 0x165B      STRB     R1,[R2, #+1627]
    732                              sCtrl.Otr.ConnCtrl[i].TimeOut     = 0;      //超时计数器清零。
   \   00000336   0x2100             MOVS     R1,#+0
   \   00000338   0x....             LDR.N    R2,??DataTable6_4
   \   0000033A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000033C   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000340   0xF882 0x165C      STRB     R1,[R2, #+1628]
    733                          }
    734                      } 
   \                     ??APP_CommRxDataDealCB_26: (+1)
   \   00000344   0x1C40             ADDS     R0,R0,#+1
   \   00000346   0xE7E2             B.N      ??APP_CommRxDataDealCB_24
    735                      
    736                      OS_FlagPost(( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    737                                  ( OS_FLAGS     ) COMM_EVT_FLAG_OTR_RX,
    738                                  ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    739                                  ( CPU_TS       ) 0,
    740                                  ( OS_ERR      *) &err);       
   \                     ??APP_CommRxDataDealCB_25: (+1)
   \   00000348   0xA805             ADD      R0,SP,#+20
   \   0000034A   0x9000             STR      R0,[SP, #+0]
   \   0000034C   0x2300             MOVS     R3,#+0
   \   0000034E   0x2200             MOVS     R2,#+0
   \   00000350   0x2104             MOVS     R1,#+4
   \   00000352   0x....             LDR.N    R0,??DataTable6_5
   \   00000354   0x.... 0x....      BL       OS_FlagPost
    741                  }
    742                  
    743                  sCtrl.Otr.ConnectFlag       = 1;
   \                     ??APP_CommRxDataDealCB_21: (+1)
   \   00000358   0x....             LDR.N    R0,??DataTable6_4
   \   0000035A   0xF890 0x066E      LDRB     R0,[R0, #+1646]
   \   0000035E   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   00000362   0x....             LDR.N    R1,??DataTable6_4
   \   00000364   0xF881 0x066E      STRB     R0,[R1, #+1646]
    744                  sCtrl.Otr.ConnectTimeOut    = 0;   
   \   00000368   0x....             LDR.N    R0,??DataTable6_4
   \   0000036A   0xF890 0x066E      LDRB     R0,[R0, #+1646]
   \   0000036E   0xF010 0x0080      ANDS     R0,R0,#0x80
   \   00000372   0x....             LDR.N    R1,??DataTable6_4
   \   00000374   0xF881 0x066E      STRB     R0,[R1, #+1646]
    745                  
    746                  break;
    747              }
    748              
    749              return TRUE;
   \                     ??APP_CommRxDataDealCB_7: (+1)
   \   00000378   0x2001             MOVS     R0,#+1
   \                     ??APP_CommRxDataDealCB_2: (+1)
   \   0000037A   0xB047             ADD      SP,SP,#+284
   \   0000037C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    750          }
    751          
    752          /***********************************************
    753          * 描述： 2016/01/08增加，用于非MODBBUS IAP升级通信
    754          */
    755          #if MB_IAPMODBUS_EN == DEF_ENABLED
    756          /*******************************************************************************
    757          * 名    称： APP_CommRxDataDealCB
    758          * 功    能： 串口数据处理回调函数，由MB_DATA.C调用
    759          * 入口参数： 无
    760          * 出口参数： 无
    761          * 作    者： 无名沈
    762          * 创建日期： 2016-01-04
    763          * 修    改：
    764          * 修改日期：
    765          * 备    注： 
    766          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    767          INT08U IAP_CommRxDataDealCB(MODBUS_CH  *pch)
    768          {
    769              //    CPU_SR_ALLOC();
    770              //    CPU_CRITICAL_ENTER();
    771              //    u8  Len     = pch->RxBufByteCtr;
    772              //    memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    773              //    CPU_CRITICAL_EXIT();
    774              //    
    775              //    /***********************************************
    776              //    * 描述： 获取帧头
    777              //    */    
    778              //    INT08U  *DataBuf    = pch->RxFrameData;
    779              //    
    780              //    /***********************************************
    781              //    * 描述： 接收数据处理
    782              //    */
    783              //    u8  DstAddr = 
    784              //    CSNC_GetData(	(unsigned char *)pch->RxFrameData,          //RecBuf,
    785              //                    (unsigned char	 )Len,                       //RecLen, 
    786              //                    (unsigned char *)DataBuf,                   //DataBuf,
    787              //                    (unsigned short *)&Len);                    //InfoLen)
    788              //    /***********************************************
    789              //    * 描述： 检测接收结束
    790              //    */
    791              //    if ( ( Len == 16) && 
    792              //         ( 0 >= memcmp((const char *)"IAP_pragram end!",(const char *)&pch->RxFrameData[8], 16) ) ) {
    793              //        /***********************************************
    794              //        * 描述： 发送数据处理
    795              //        */
    796              //        CSNC_SendData(	(MODBUS_CH      *)sCtrl.Com.pch,
    797              //                        (unsigned char  ) sCtrl.Com.SlaveAddr,          // SourceAddr,
    798              //                        (unsigned char  ) sCtrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    799              //                        (unsigned char *)&pch->RxFrameData[8],          // DataBuf,
    800              //                        (unsigned short ) Len); 
    801              //        /***********************************************
    802              //        * 描述： 置位IAP结束标志位
    803              //        */
    804              //        OS_ERR err;
    805              //        OS_FlagPost(( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    806              //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    807              //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    808              //                    ( CPU_TS       ) 0,
    809              //                    ( OS_ERR      *) &err);
    810              //        
    811              //        return TRUE;
    812              //    }
    813              //    
    814              //    if ( ( Len == 18) && 
    815              //         ( 0 >= memcmp((const char *)"IAP_pragram start!",(const char *)&pch->RxFrameData[8], 18) ) ) {
    816              //        
    817              //#if defined     (IMAGE_A) || defined   (IMAGE_B)
    818              //#else
    819              //        /***********************************************
    820              //        * 描述： 发送数据处理
    821              //        */
    822              //        CSNC_SendData(	(MODBUS_CH      *)sCtrl.Com.pch,
    823              //                        (unsigned char  ) sCtrl.Com.SlaveAddr,          // SourceAddr,
    824              //                        (unsigned char  ) sCtrl.Com.Rd.Head.SrcAddr,    // DistAddr,
    825              //                        (unsigned char *)&pch->RxFrameData[8],         // DataBuf,
    826              //                        (unsigned int	 ) Len);                        // DataLen 
    827              //#endif
    828              //        IAP_Restart();
    829              //        Iap.FrameIdx    = 0;
    830              //        return TRUE;
    831              //    }
    832              //    
    833              //    if ( Iap.Status < IAP_STS_START )
    834              //        return TRUE;
    835              //    /***********************************************
    836              //    * 描述： 写数据
    837              //    */
    838              //    /***********************************************
    839              //    * 描述： 将数据打包给发送结构
    840              //    */
    841              //    sCtrl.Com.Wr.Head.DataLen       = 0;
    842              //    /***********************************************
    843              //    * 描述： 编辑应答内容
    844              //    */
    845              //    char str[20];
    846              //    usprintf(str,"\n%d",Iap.FrameIdx);
    847              //    str[19]  = 0;
    848              //    /***********************************************
    849              //    * 描述： 写数据到Flash
    850              //    */
    851              //    IAP_Program((StrIapState *)&Iap, (INT16U *)&pch->RxFrameData[8], Len, (INT16U )GetRecvFrameNbr() );
    852              //    /***********************************************
    853              //    * 描述： 发送数据处理
    854              //    */
    855              //    CSNC_SendData(	(MODBUS_CH     *) sCtrl.Com.pch,
    856              //                    (unsigned char  ) sCtrl.Com.SlaveAddr,                    // SourceAddr,
    857              //                    (unsigned char  ) sCtrl.Com.Rd.Head.SrcAddr,              // DistAddr,
    858              //                    (unsigned char *) str,                                    // DataBuf,
    859              //                    (unsigned short ) strlen(str));                           // DataLen 
    860              //    if ( Len < 128 ) {
    861              //        /***********************************************
    862              //        * 描述： 置位IAP结束标志位
    863              //        */
    864              //        OS_ERR err;
    865              //        OS_FlagPost(( OS_FLAG_GRP *)&sCtrl.Os.CommEvtFlagGrp,
    866              //                    ( OS_FLAGS     ) COMM_EVT_FLAG_IAP_END,
    867              //                    ( OS_OPT       ) OS_OPT_POST_FLAG_SET,
    868              //                    ( CPU_TS       ) 0,
    869              //                    ( OS_ERR      *) &err);
    870              //    } else {
    871              //        IAP_Programing();                               // 复位超时计数器
    872              //    }
    873              //        
    874              //    /***********************************************
    875              //    * 描述： 串口接受COMM模组的消息并处理
    876              //    */
    877              //    sCtrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
    878              //    sCtrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
    879              //    
    880              //    return TRUE;
    881          }
   \                     IAP_CommRxDataDealCB: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    882          #endif
    883          
    884          /*******************************************************************************
    885          * 名    称： NMBS_FCxx_Handler
    886          * 功    能： 非MODBUS串口数据处理回调函数，由mbs_core.d调用。处理接收中断应答。
    887          * 入口参数： 无
    888          * 出口参数： 无
    889          * 作    者： 无名沈
    890          * 创建日期： 2017-02-03
    891          * 修    改：
    892          * 修改日期：
    893          * 备    注： 
    894          *******************************************************************************/
    895          extern OS_Q                MTR_RxQ;
    896          extern OS_Q                COM_RxQ;
    897          extern OS_Q                DTU_RxQ;

   \                                 In section .text, align 2, keep-with-next
    898          CPU_BOOLEAN  NMBS_FCxx_Handler (MODBUS_CH  *pch)
    899          {
   \                     NMBS_FCxx_Handler: (+1)
   \   00000000   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    900              OS_ERR      err;
    901              //   CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
    902              //    CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCtr-1],
    903              //                                       pch->RxBuf[pch->RxBufByteCtr-2]);
    904              CPU_INT16U  head    = BUILD_INT16U( pch->RxFrameData[1], pch->RxFrameData[0]);
   \   00000006   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000000A   0xF894 0x1244      LDRB     R1,[R4, #+580]
   \   0000000E   0xEB10 0x2501      ADDS     R5,R0,R1, LSL #+8
    905              CPU_INT16U  tail    = BUILD_INT16U( pch->RxFrameData[pch->RxBufByteCnt-1],
    906                                                 pch->RxFrameData[pch->RxBufByteCnt-2]);           //20170526 RxBufByteCtr 中断函数中动态更新。
   \   00000012   0x8E60             LDRH     R0,[R4, #+50]
   \   00000014   0x1900             ADDS     R0,R0,R4
   \   00000016   0xF890 0x0243      LDRB     R0,[R0, #+579]
   \   0000001A   0x8E61             LDRH     R1,[R4, #+50]
   \   0000001C   0x1909             ADDS     R1,R1,R4
   \   0000001E   0xF891 0x1242      LDRB     R1,[R1, #+578]
   \   00000022   0xEB10 0x2601      ADDS     R6,R0,R1, LSL #+8
    907              
    908              /***********************************************
    909              * 描述： 长沙南车DTU协议处理
    910              */
    911              
    912              if ( ( pch->RxFrameHead == head ) &&              
    913                  ( pch->RxFrameTail == tail ) ) {
   \   00000026   0xF8B4 0x034A      LDRH     R0,[R4, #+842]
   \   0000002A   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000002C   0x42A8             CMP      R0,R5
   \   0000002E   0xD108             BNE.N    ??NMBS_FCxx_Handler_0
   \   00000030   0xF8B4 0x034C      LDRH     R0,[R4, #+844]
   \   00000034   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000036   0x42B0             CMP      R0,R6
   \   00000038   0xD103             BNE.N    ??NMBS_FCxx_Handler_0
    914                      APP_CommRxDataDealCB(pch);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       APP_CommRxDataDealCB
   \   00000040   0xE064             B.N      ??NMBS_FCxx_Handler_1
    915                      /***********************************************
    916                      * 描述： 电表调试协议协议,电表协议协议处理处理
    917                      */
    918                  } else  if ( ( 0xAA55 == head ) || ( 0xAAAA == head ) ) {
   \                     ??NMBS_FCxx_Handler_0: (+1)
   \   00000042   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000044   0xF64A 0x2055      MOVW     R0,#+43605
   \   00000048   0x4285             CMP      R5,R0
   \   0000004A   0xD004             BEQ.N    ??NMBS_FCxx_Handler_2
   \   0000004C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000004E   0xF64A 0x20AA      MOVW     R0,#+43690
   \   00000052   0x4285             CMP      R5,R0
   \   00000054   0xD150             BNE.N    ??NMBS_FCxx_Handler_3
    919                      OS_ERR  err;
    920                      
    921                      CPU_SR_ALLOC();
   \                     ??NMBS_FCxx_Handler_2: (+1)
   \   00000056   0x2700             MOVS     R7,#+0
    922                      OS_CRITICAL_ENTER();
   \   00000058   0x.... 0x....      BL       CPU_SR_Save
   \   0000005C   0x0007             MOVS     R7,R0
   \   0000005E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000062   0x....             LDR.N    R0,??DataTable6_13
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable6_13
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   \   0000006C   0x....             LDR.N    R0,??DataTable6_13
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2801             CMP      R0,#+1
   \   00000072   0xD101             BNE.N    ??NMBS_FCxx_Handler_4
   \   00000074   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??NMBS_FCxx_Handler_4: (+1)
   \   00000078   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0x.... 0x....      BL       CPU_SR_Restore
    923                      memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, pch->RxBufByteCnt );
   \   00000082   0xF8B4 0x8032      LDRH     R8,[R4, #+50]
   \   00000086   0xF114 0x0938      ADDS     R9,R4,#+56
   \   0000008A   0xF514 0x7A11      ADDS     R10,R4,#+580
   \   0000008E   0x4642             MOV      R2,R8
   \   00000090   0x4649             MOV      R1,R9
   \   00000092   0x4650             MOV      R0,R10
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy
    924                      OS_CRITICAL_EXIT();
   \   00000098   0x.... 0x....      BL       CPU_SR_Save
   \   0000009C   0x0007             MOVS     R7,R0
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   000000A2   0x....             LDR.N    R0,??DataTable6_13
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x1E40             SUBS     R0,R0,#+1
   \   000000A8   0x....             LDR.N    R1,??DataTable6_13
   \   000000AA   0x7008             STRB     R0,[R1, #+0]
   \   000000AC   0x....             LDR.N    R0,??DataTable6_13
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD113             BNE.N    ??NMBS_FCxx_Handler_5
   \   000000B4   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   000000B8   0x....             LDR.N    R0,??DataTable6_14
   \   000000BA   0x8800             LDRH     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD007             BEQ.N    ??NMBS_FCxx_Handler_6
   \   000000C0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000C4   0x0038             MOVS     R0,R7
   \   000000C6   0x.... 0x....      BL       CPU_SR_Restore
   \   000000CA   0x.... 0x....      BL       OS_Sched0
   \   000000CE   0xE00A             B.N      ??NMBS_FCxx_Handler_7
   \                     ??NMBS_FCxx_Handler_6: (+1)
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x0038             MOVS     R0,R7
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
   \   000000DA   0xE004             B.N      ??NMBS_FCxx_Handler_7
   \                     ??NMBS_FCxx_Handler_5: (+1)
   \   000000DC   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000E0   0x0038             MOVS     R0,R7
   \   000000E2   0x.... 0x....      BL       CPU_SR_Restore
    925                      
    926                      (void)OSQPost((OS_Q         *)&MTR_RxQ,
    927                                    (void         *) pch,
    928                                    //(OS_MSG_SIZE   ) pch->RxBufByteCtr,
    929                                    (OS_MSG_SIZE   ) pch->RxBufByteCnt,
    930                                    (OS_OPT        ) OS_OPT_POST_FIFO,
    931                                    (OS_ERR       *)&err);
   \                     ??NMBS_FCxx_Handler_7: (+1)
   \   000000E6   0xA801             ADD      R0,SP,#+4
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0x2300             MOVS     R3,#+0
   \   000000EC   0x8E62             LDRH     R2,[R4, #+50]
   \   000000EE   0x0021             MOVS     R1,R4
   \   000000F0   0x....             LDR.N    R0,??DataTable6_15
   \   000000F2   0x.... 0x....      BL       OSQPost
   \   000000F6   0xE009             B.N      ??NMBS_FCxx_Handler_1
    932                       //BSP_OS_TimeDly(5);
    933                       /***********************************************
    934                       * 描述： tax通讯协议
    935                       */  
    936                  } else {
    937                      if(pch->PortNbr == 0)                       //串口0，做 
   \                     ??NMBS_FCxx_Handler_3: (+1)
   \   000000F8   0x7A60             LDRB     R0,[R4, #+9]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD106             BNE.N    ??NMBS_FCxx_Handler_1
    938                          if(TAX_FCxx_Handler(pch) == FALSE)     //tax通讯处理
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       TAX_FCxx_Handler
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD101             BNE.N    ??NMBS_FCxx_Handler_1
    939                              return DEF_FALSE;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE000             B.N      ??NMBS_FCxx_Handler_8
    940                  }
    941              return DEF_TRUE;
   \                     ??NMBS_FCxx_Handler_1: (+1)
   \   0000010C   0x2001             MOVS     R0,#+1
   \                     ??NMBS_FCxx_Handler_8: (+1)
   \   0000010E   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    942          }
    943          
    944          
    945          /*******************************************************************************
    946          * 名    称： APP_MaterCommHandler
    947          * 功    能： 电表串口数据处理函数
    948          * 入口参数： 无
    949          * 出口参数： 无
    950          * 作　　者： wumingshen.
    951          * 创建日期： 2015-03-28
    952          * 修    改：
    953          * 修改日期：
    954          *******************************************************************************/
    955          /***********************************************
    956          * 描述： 2015/12/07增加，用于非MODBBUS通信
    957          *        非MODBUS通信，带帧头帧尾的通信数据处理
    958          */
    959          #if MB_NONMODBUS_EN == DEF_ENABLED

   \                                 In section .text, align 2, keep-with-next
    960          CPU_BOOLEAN APP_MaterCommHandler (MODBUS_CH  *pch)
    961          {    
   \                     APP_MaterCommHandler: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0004             MOVS     R4,R0
    962              uint8_t     fram_clr[4]     = {0};
   \   00000008   0xA801             ADD      R0,SP,#+4
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    963          	uint8_t     IDBuf[4]        = {0};
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6001             STR      R1,[R0, #+0]
    964          	uint8_t     clear_buf[24]   = {0};
   \   00000014   0xA802             ADD      R0,SP,#+8
   \   00000016   0x2118             MOVS     R1,#+24
   \   00000018   0x.... 0x....      BL       __aeabi_memclr4
    965          	uint32_t    ID              = 0;
   \   0000001C   0x2500             MOVS     R5,#+0
    966          	uint32_t    utemp;
    967              
    968          	//TIME        system; 
    969              
    970              /***********************************************
    971              * 描述： 拷贝数据到数据区
    972              */
    973              //CPU_SR_ALLOC();
    974              //CPU_CRITICAL_ENTER();
    975              //uint32_t  Len     = pch->RxBufByteCnt;
    976              //memcpy( (INT08U *)&pch->RxFrameData, (INT08U *)pch->RxBuf, Len );
    977              //CPU_CRITICAL_EXIT();
    978              uint32_t    Len       = pch->RxBufByteCnt;
   \   0000001E   0x8E66             LDRH     R6,[R4, #+50]
    979              INT08U      *DataBuf  = pch->RxFrameData;
   \   00000020   0xF514 0x7711      ADDS     R7,R4,#+580
    980              
    981              
    982              CPU_INT16U  head    = BUILD_INT16U(pch->RxBuf[1], pch->RxBuf[0]);
   \   00000024   0xF894 0x0039      LDRB     R0,[R4, #+57]
   \   00000028   0xF894 0x1038      LDRB     R1,[R4, #+56]
   \   0000002C   0xEB10 0x2801      ADDS     R8,R0,R1, LSL #+8
    983              CPU_INT16U  tail    = BUILD_INT16U(pch->RxBuf[pch->RxBufByteCnt-1],
    984                                                 pch->RxBuf[pch->RxBufByteCnt-2]);
   \   00000030   0x8E60             LDRH     R0,[R4, #+50]
   \   00000032   0x1900             ADDS     R0,R0,R4
   \   00000034   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   00000038   0x8E61             LDRH     R1,[R4, #+50]
   \   0000003A   0x1909             ADDS     R1,R1,R4
   \   0000003C   0xF891 0x1036      LDRB     R1,[R1, #+54]
   \   00000040   0xEB10 0x2901      ADDS     R9,R0,R1, LSL #+8
    985              /***********************************************
    986              * 描述： 长沙南车DTU协议处理
    987              */
    988              if ( ( pch->RxFrameHead == head ) &&
    989                  ( pch->RxFrameTail == tail ) ) {
   \   00000044   0xF8B4 0x034A      LDRH     R0,[R4, #+842]
   \   00000048   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000004C   0x4540             CMP      R0,R8
   \   0000004E   0xD10D             BNE.N    ??APP_MaterCommHandler_0
   \   00000050   0xF8B4 0x034C      LDRH     R0,[R4, #+844]
   \   00000054   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000058   0x4548             CMP      R0,R9
   \   0000005A   0xD107             BNE.N    ??APP_MaterCommHandler_0
    990                      DataBuf = &pch->RxFrameData[8];
   \   0000005C   0xF514 0x7013      ADDS     R0,R4,#+588
   \   00000060   0x0007             MOVS     R7,R0
    991                      //        Len     = sCtrl.Com.Rd.Head.DataLen;        
    992                      head    = BUILD_INT16U(DataBuf[1], DataBuf[0]);
   \   00000062   0x7878             LDRB     R0,[R7, #+1]
   \   00000064   0x7839             LDRB     R1,[R7, #+0]
   \   00000066   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   0000006A   0x4680             MOV      R8,R0
    993                  }
    994              
    995              /***********************************************
    996              * 描述： 
    997              序号    内容       字节数 内容说明
    998              1       帧头       2      0xAA 0xAA
    999              2       帧长度     1      0x08 帧长度固定为8字节
   1000              3       命令类型   2      0x00 0x01
   1001              4       预留       2      0x00 0x00
   1002              5       累加和     1      前7个字节的累加和
   1003              */ 
   1004              if ( 0xAAAA == head ) {
   \                     ??APP_MaterCommHandler_0: (+1)
   \   0000006C   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000070   0xF64A 0x20AA      MOVW     R0,#+43690
   \   00000074   0x4580             CMP      R8,R0
   \   00000076   0xD10E             BNE.N    ??APP_MaterCommHandler_1
   1005                  Len            -= 1;
   \   00000078   0x1E76             SUBS     R6,R6,#+1
   1006                  int8_t chkSum   = GetCheckSum(DataBuf,Len);
   \   0000007A   0x0031             MOVS     R1,R6
   \   0000007C   0x0038             MOVS     R0,R7
   \   0000007E   0x.... 0x....      BL       GetCheckSum
   \   00000082   0x0001             MOVS     R1,R0
   1007                  
   1008                  if ( chkSum ==  DataBuf[Len] ) {
   \   00000084   0x0008             MOVS     R0,R1
   \   00000086   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000088   0x5DF2             LDRB     R2,[R6, R7]
   \   0000008A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000008C   0xB212             SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
   \   0000008E   0x4290             CMP      R0,R2
   \   00000090   0xD124             BNE.N    ??APP_MaterCommHandler_2
   1009                      //            pch->TxFrameData[0]     = 0xAA;
   1010                      //            pch->TxFrameData[1]     = 0xAA;
   1011                      //            pch->TxFrameData[2]     = 0x30;
   1012                      //            pch->TxFrameData[3]     = 0x00;
   1013                      //            pch->TxFrameData[4]     = 0x71;
   1014                      //            
   1015                      //            CPU_SR  cpu_sr;
   1016                      //            OS_CRITICAL_ENTER();
   1017                      //            memcpy(&pch->TxFrameData[5],(uint8_t *)&Mater.Energy, sizeof(StrEnergy));
   1018                      //            OS_CRITICAL_EXIT();
   1019                      //            
   1020                      //            pch->TxFrameData[45]    = 0x00;
   1021                      //            pch->TxFrameData[46]    = 0x00;
   1022                      //            
   1023                      //            pch->TxFrameData[47]    = GetCheckSum(pch->TxFrameData,47);
   1024                      //            
   1025                      //            NMB_Tx((MODBUS_CH   *)pch,
   1026                      //                   (CPU_INT08U  *)pch->TxFrameData,
   1027                      //                   (CPU_INT16U   )48);
   1028                      return TRUE;
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE023             B.N      ??APP_MaterCommHandler_3
   1029                  }
   1030                  /***********************************************
   1031                  * 描述： 调试参数
   1032                  */
   1033              } else if ( ( 0xAA55 == head ) && ( Len > 10 )) {
   \                     ??APP_MaterCommHandler_1: (+1)
   \   00000096   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000009A   0xF64A 0x2055      MOVW     R0,#+43605
   \   0000009E   0x4580             CMP      R8,R0
   \   000000A0   0xD11C             BNE.N    ??APP_MaterCommHandler_2
   \   000000A2   0x2E0B             CMP      R6,#+11
   \   000000A4   0xD31A             BCC.N    ??APP_MaterCommHandler_2
   1034                  /***********************************************
   1035                  * 描述： 检测是否有帧尾，没有帧尾则进行CRC校验
   1036                  */
   1037                  if ( tail != 0x55AA  ) {
   1038                      //uint16_t crc16_Cal = crc16((uint8_t *)&DataBuf[0],9);
   1039                      //uint16_t crc16_Rec = BUILD_INT16U(DataBuf[9],DataBuf[10]);
   1040                      //if(crc16_Cal != crc16_Rec) {                
   1041                      //    return TRUE;
   1042                      //}
   1043                  }
   1044                  switch(DataBuf[2])
   \   000000A6   0x78B8             LDRB     R0,[R7, #+2]
   \   000000A8   0x28A1             CMP      R0,#+161
   \   000000AA   0xD004             BEQ.N    ??APP_MaterCommHandler_4
   \   000000AC   0xD316             BCC.N    ??APP_MaterCommHandler_5
   \   000000AE   0x28A3             CMP      R0,#+163
   \   000000B0   0xD013             BEQ.N    ??APP_MaterCommHandler_6
   \   000000B2   0xD311             BCC.N    ??APP_MaterCommHandler_7
   \   000000B4   0xE012             B.N      ??APP_MaterCommHandler_5
   1045                  {
   1046                      /***********************************************
   1047                      * 描述： 设置序列号
   1048                      */
   1049                  case 0xA1:
   1050                      ID = BUILD_INT32U(DataBuf[3], DataBuf[4], DataBuf[5], DataBuf[6]);
   \                     ??APP_MaterCommHandler_4: (+1)
   \   000000B6   0x78F8             LDRB     R0,[R7, #+3]
   \   000000B8   0x7939             LDRB     R1,[R7, #+4]
   \   000000BA   0xEB10 0x2001      ADDS     R0,R0,R1, LSL #+8
   \   000000BE   0x7979             LDRB     R1,[R7, #+5]
   \   000000C0   0xEB10 0x4001      ADDS     R0,R0,R1, LSL #+16
   \   000000C4   0x79B9             LDRB     R1,[R7, #+6]
   \   000000C6   0xEB10 0x6001      ADDS     R0,R0,R1, LSL #+24
   \   000000CA   0x0005             MOVS     R5,R0
   1051                      //WriteFM24CL64(64 , (uint8_t *)&ID , 4);
   1052                      //ReadFM24CL64(64 , (uint8_t *)&ID , 4);
   1053                      uartprintf(pch,"\r\n 本装置ID设置为：%d\r\n" , ID);
   \   000000CC   0x002A             MOVS     R2,R5
   \   000000CE   0x....             LDR.N    R1,??DataTable6_16
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       uartprintf
   1054                      break;            
   \   000000D6   0xE001             B.N      ??APP_MaterCommHandler_2
   1055                      /***********************************************
   1056                      * 描述： 设置机车型号/机车号
   1057                      */
   1058                  case 0xA2:	
   1059                      //Mater.LocoTyp   = BUILD_INT16U(DataBuf[3],DataBuf[4]);
   1060                      //Mater.LocoNbr   = BUILD_INT16U(DataBuf[5],DataBuf[6]);
   1061                      //WriteFM24CL64(68 , (uint8_t *)&Mater.LocoTyp, 2);
   1062                      //WriteFM24CL64(70 , (uint8_t *)&Mater.LocoNbr, 2);
   1063                      //ReadFM24CL64(68 ,  (uint8_t *)&Mater.LocoTyp, 2);
   1064                      //ReadFM24CL64(70 ,  (uint8_t *)&Mater.LocoNbr, 2);
   1065                      //uartprintf(pch,"\r\n 当前车型：%d；当前车号：%d\r\n", Mater.LocoTyp,Mater.LocoNbr);
   1066                      break; 
   \                     ??APP_MaterCommHandler_7: (+1)
   \   000000D8   0xE000             B.N      ??APP_MaterCommHandler_2
   1067                      /***********************************************
   1068                      * 描述： 设置时间
   1069                      */
   1070                  case 0xA3:
   1071                      //            system.Year     =DataBuf[3];
   1072                      //            system.Month    =DataBuf[4];
   1073                      //            system.Day      =DataBuf[5];
   1074                      //            system.Hour     =DataBuf[6];
   1075                      //            system.Min      =DataBuf[7];
   1076                      //            system.Sec      =DataBuf[8];
   1077                      //            WriteTime(system);
   1078                      //            GetTime((TIME *)&recordsfr.Time[0]);
   1079                      //            uartprintf(pch,"\r\n 当前时间为：20%02d-%02d-%02d  %02d:%02d:%02d", 
   1080                      //                       recordsfr.Time[0], recordsfr.Time[1], recordsfr.Time[2],
   1081                      //                       recordsfr.Time[3], recordsfr.Time[4], recordsfr.Time[5]);
   1082                      break;
   \                     ??APP_MaterCommHandler_6: (+1)
   \   000000DA   0xE7FF             B.N      ??APP_MaterCommHandler_2
   1083                      
   1084                  default:
   1085                      break;
   1086                  }
   1087              }
   1088              /***********************************************
   1089              * 描述： 调用串口数据处理回调函数
   1090              */ 
   1091              return TRUE;
   \                     ??APP_MaterCommHandler_5: (+1)
   \                     ??APP_MaterCommHandler_2: (+1)
   \   000000DC   0x2001             MOVS     R0,#+1
   \                     ??APP_MaterCommHandler_3: (+1)
   \   000000DE   0xB009             ADD      SP,SP,#+36
   \   000000E0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1092          }
   1093          
   1094          /*******************************************************************************
   1095          * 名    称： APP_CSNC_CommHandler
   1096          * 功    能： 串口数据处理函数
   1097          * 入口参数： 无
   1098          * 出口参数： 无
   1099          * 作　　者： wumingshen.
   1100          * 创建日期： 2015-03-28
   1101          * 修    改：
   1102          * 修改日期：
   1103          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1104          CPU_BOOLEAN APP_CSNC_CommHandler (MODBUS_CH  *pch)
   1105          {   
   \                     APP_CSNC_CommHandler: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   1106              //    if ( pch->PortNbr == sCtrl.Dtu.pch->PortNbr ) {
   1107              //        if ( GetRecvFrameNbr() == sCtrl.Com.Rd.Head.PacketSn ) {
   1108              //            /***********************************************
   1109              //            * 描述： 清除定时上传标志
   1110              //            */
   1111              //            //SetSendFrameNbr();
   1112              //            //extern void UpdateRecordPoint(uint8_t storeflag);
   1113              //            //UpdateRecordPoint(1);
   1114              //            //pch->StatNoRespCtr  = 0;
   1115              //            
   1116              //            //osal_set_event( OS_TASK_ID_TMR, OS_EVT_TMR_MIN);
   1117              //        }
   1118              //    } else {
   1119              //        /***********************************************
   1120              //        * 描述： 将数据打包给发送结构
   1121              //        */ 
   1122              //        APP_MaterCommHandler(pch);
   1123              //    }
   1124              //    
   1125              //    /***********************************************
   1126              //    * 描述： 串口接受COMM模组的消息并处理
   1127              //    */
   1128              //    sCtrl.Com.ConnectTimeOut    = 0;                // 超时计数器清零
   1129              //    sCtrl.Com.ConnectFlag       = TRUE;             // 转连接成功标志
   1130              //    
   1131              return TRUE;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4770             BX       LR               ;; return
   1132          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     AppTaskCommStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     AppTaskCommTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     WdtFlagGRP

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     sCtrl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     sCtrl+0x7FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     WdtFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     sCtrl+0x24C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     sCtrl+0x4F5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     sCtrl+0x3AD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     sCtrl+0x656

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     sCtrl+0x50E

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     OSIntQNbrEntries

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     MTR_RxQ

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x70          DC8 "App Task Comm"
   \              0x70 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x20 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x70          DC8 "App_CommFlag"
   \              0x70 0x5F    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x46 0x6C    
   \              0x61 0x67    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x0D 0x0A          DC8 "\015\012 \261\276\327\260\326\303ID\311\350\326\303\316\252\243\272%d\015\012"
   \              0x20 0xB1    
   \              0xBE 0xD7    
   \              0xB0 0xD6    
   \              0xC3 0x49    
   \              0x44 0xC9    
   \              0xE8 0xD6    
   \              0xC3 0xCE    
   \              0xAA 0xA3    
   \              0xBA 0x25    
   \              0x64 0x0D    
   \              0x0A 0x00    
   1133          #endif
   1134          /*******************************************************************************
   1135          * 				end of file
   1136          *******************************************************************************/
   1137          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   APP_CSNC_CommHandler
       8   APP_CommInit
         8   -> App_ModbusInit
         8   -> OSFlagCreate
     320   APP_CommRxDataDealCB
       320   -> DataUnpack_CSNC
       320   -> OS_FlagPost
       320   -> __aeabi_memcpy
      64   APP_MaterCommHandler
        64   -> GetCheckSum
        64   -> __aeabi_memclr4
        64   -> uartprintf
      40   AppTaskComm
        40   -> APP_CommInit
        40   -> OSFlagPend
        40   -> OSFlagPost
        40   -> OSTimeGet
        40   -> OS_FlagPost
        40   -> app_comm_dtu
        40   -> app_comm_mtr
        40   -> app_comm_otr
        40   -> app_comm_tax
      32   App_ModbusInit
        32   -> MB_CfgCh
        32   -> MB_Init
      48   App_TaskCommCreate
        48   -> OSTaskCreate
       0   IAP_CommRxDataDealCB
      40   NMBS_FCxx_Handler
        40   -> APP_CommRxDataDealCB
        40   -> CPU_IntDisMeasStart
        40   -> CPU_IntDisMeasStop
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> OSQPost
        40   -> OS_Sched0
        40   -> OS_SchedLockTimeMeasStart
        40   -> OS_SchedLockTimeMeasStop
        40   -> TAX_FCxx_Handler
        40   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      16  ?_0
      16  ?_1
       4  ?_2
       4  ?_3
      24  ?_4
      24  ?_5
       6  APP_CSNC_CommHandler
      50  APP_CommInit
     896  APP_CommRxDataDealCB
     228  APP_MaterCommHandler
     210  AppTaskComm
    1024  AppTaskCommStk
     200  AppTaskCommTCB
     432  App_ModbusInit
      66  App_TaskCommCreate
       2  IAP_CommRxDataDealCB
      48  MTR_RxQ
     274  NMBS_FCxx_Handler
      52  OSTmr1

 
 1 324 bytes in section .bss
    88 bytes in section .rodata
 2 232 bytes in section .text
 
 2 232 bytes of CODE  memory
    88 bytes of CONST memory
 1 324 bytes of DATA  memory

Errors: none
Warnings: 11
