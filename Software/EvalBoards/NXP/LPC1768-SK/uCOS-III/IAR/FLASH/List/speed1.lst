###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       30/Sep/2017  11:25:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Application\Library\SpeedTest\speed1.C
#    Command line =  
#        F:\iar\NC136B-310统计模块\Application\Library\SpeedTest\speed1.C -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\speed1.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\speed1.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Application\Library\SpeedTest\speed1.C
      1          #include <includes.h>
      2          #include <FRAM.h>
      3          #include <osal.h>
      4          #include <bsp_os.h>
      5          
      6          //每圈脉冲常量
      7          #define		PPR		200
      8          //pi = 3.14 * 100
      9          #define		PI		314
     10          //轮对直径 1.1m * 10
     11          //#define		DIM		11
     12          #define		DIM		10.5
     13          //里程常数 PPR *10*100*1000  
     14          #define		PI_DIM_MUL		(10*100)
     15          
     16          #if (UCOS_EN == DEF_ENABLED ) && ( OS_VERSION > 30000U )
     17          extern  OS_SEM           time0_over_Sem;               // 信号量
     18          #endif
     19          
     20          

   \                                 In section .bss, align 4
     21          uint32	mPluseSumCnt0 = 0;
   \                     mPluseSumCnt0:
   \   00000000                      DS8 4
     22          //-------------------------------------------------------------------------------
     23          //函数名称:         GetFrqCnt()
     24          //函数功能:         取频率值
     25          //入口参数:         无		 
     26          //出口参数:         
     27          //-------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     28          uint32  GetFrq1SumCnt(void)
     29          {
     30          	return	mPluseSumCnt0;
   \                     GetFrq1SumCnt: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     31          }
     32          

   \                                 In section .bss, align 4
     33          uint32	m_Time0Sum = 0;
   \                     m_Time0Sum:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     34          uint32	m_AddPluse0 = 0;
   \                     m_AddPluse0:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     35          uint32	m_Pluse0ChgFlg = 0;
   \                     m_Pluse0ChgFlg:
   \   00000000                      DS8 4
     36          

   \                                 In section .bss, align 4
     37          static	stcSpeedPluse	m_sSpeed1Pluse;
   \                     m_sSpeed1Pluse:
   \   00000000                      DS8 8
     38          
     39          
     40          #define	MATH_PLUSE_TIME	 (1*1000*1000)
     41          #define	MATH_PLUSE_NUM 	 500
     42          
     43          #define		CAP00	126
     44          

   \                                 In section .text, align 2, keep-with-next
     45          void TIMER0_IRQHandler(void)
     46          {
   \                     TIMER0_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     47              uint8  tmp = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     48          
     49          	if (TIM_GetIntCaptureStatus(LPC_TIM0,TIM_MR0_INT))
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   0000000A   0x.... 0x....      BL       TIM_GetIntCaptureStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD043             BEQ.N    ??TIMER0_IRQHandler_0
     50          	{
     51          		TIM_ClearIntCapturePending(LPC_TIM0,TIM_MR0_INT);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000018   0x.... 0x....      BL       TIM_ClearIntCapturePending
     52          
     53                  nop();
   \   0000001C   0x.... 0x....      BL       `nop`
     54          //    uint8  tmp = 0;
     55             
     56                  tmp = GPIO_ReadIoVal(CAP00);
   \   00000020   0x207E             MOVS     R0,#+126
   \   00000022   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000026   0x0004             MOVS     R4,R0
     57                  
     58                  if(tmp == 1)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C01             CMP      R4,#+1
   \   0000002C   0xD035             BEQ.N    ??TIMER0_IRQHandler_1
     59                      return;
     60          
     61          		m_Time0Sum += TIM_GetCaptureValue(LPC_TIM0,TIM_COUNTER_INCAP0);
   \                     ??TIMER0_IRQHandler_2: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000034   0x.... 0x....      BL       TIM_GetCaptureValue
   \   00000038   0x....             LDR.N    R1,??DataTable7_1
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0x1840             ADDS     R0,R0,R1
   \   0000003E   0x....             LDR.N    R1,??DataTable7_1
   \   00000040   0x6008             STR      R0,[R1, #+0]
     62          		TIM_ResetCounter(LPC_TIM0);
   \   00000042   0xF05F 0x2040      MOVS     R0,#+1073758208
   \   00000046   0x.... 0x....      BL       TIM_ResetCounter
     63          
     64          		m_AddPluse0++;
   \   0000004A   0x....             LDR.N    R0,??DataTable7_2
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable7_2
   \   00000052   0x6008             STR      R0,[R1, #+0]
     65          		mPluseSumCnt0++;
   \   00000054   0x....             LDR.N    R0,??DataTable7
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable7
   \   0000005C   0x6008             STR      R0,[R1, #+0]
     66          
     67          		if(m_AddPluse0 == MATH_PLUSE_NUM || m_Time0Sum > MATH_PLUSE_TIME) 		//500个脉冲或1秒时间到
   \   0000005E   0x....             LDR.N    R0,??DataTable7_2
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000066   0xD004             BEQ.N    ??TIMER0_IRQHandler_3
   \   00000068   0x....             LDR.N    R0,??DataTable7_1
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x....             LDR.N    R1,??DataTable7_3  ;; 0xf4241
   \   0000006E   0x4288             CMP      R0,R1
   \   00000070   0xD313             BCC.N    ??TIMER0_IRQHandler_0
     68          		{
     69          			m_sSpeed1Pluse.TimeCnt 	= 	m_Time0Sum;
   \                     ??TIMER0_IRQHandler_3: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable7_1
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x....             LDR.N    R1,??DataTable7_4
   \   00000078   0x6048             STR      R0,[R1, #+4]
     70          			m_sSpeed1Pluse.PluseCnt	=   m_AddPluse0;
   \   0000007A   0x....             LDR.N    R0,??DataTable7_2
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x....             LDR.N    R1,??DataTable7_4
   \   00000080   0x6008             STR      R0,[R1, #+0]
     71          				
     72          			m_AddPluse0 = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x....             LDR.N    R1,??DataTable7_2
   \   00000086   0x6008             STR      R0,[R1, #+0]
     73          			m_Time0Sum = 0;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x....             LDR.N    R1,??DataTable7_1
   \   0000008C   0x6008             STR      R0,[R1, #+0]
     74          			m_Pluse0ChgFlg = 1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x....             LDR.N    R1,??DataTable7_5
   \   00000092   0x6008             STR      R0,[R1, #+0]
     75                      
     76                      #if (OS_VERSION > 30000U)
     77                      BSP_OS_SemPost(&time0_over_Sem);                        	// 发送信号量
   \   00000094   0x....             LDR.N    R0,??DataTable7_6
   \   00000096   0x.... 0x....      BL       BSP_OS_SemPost
     78                      #endif
     79          		}
     80          	}
     81          }
   \                     ??TIMER0_IRQHandler_0: (+1)
   \                     ??TIMER0_IRQHandler_1: (+1)
   \   0000009A   0xBD10             POP      {R4,PC}          ;; return
     82          
     83          

   \                                 In section .bss, align 2
     84          uint16  l_speed1;
   \                     l_speed1:
   \   00000000                      DS8 2

   \                                 In section .bss, align 4
     85          int32  	l_addspeed1;
   \                     l_addspeed1:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
     86          uint16	GetMySpeed1(void)
     87          {
     88          	return	l_speed1;
   \                     GetMySpeed1: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_7
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     89          }
     90          

   \                                 In section .text, align 2, keep-with-next
     91          int32	GetMyAddSpeed1(void)
     92          {
     93          	return	l_addspeed1;
   \                     GetMyAddSpeed1: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_8
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
     94          }
     95          

   \                                 In section .text, align 2, keep-with-next
     96          void GetSpeedPluse1(stcSpeedPluse * sSpeedPluse)
     97          {
     98          	static	uint32	Time;
     99          	
    100          	sSpeedPluse->PluseCnt = m_sSpeed1Pluse.PluseCnt;
   \                     GetSpeedPluse1: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_4
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6001             STR      R1,[R0, #+0]
    101          	sSpeedPluse->TimeCnt  = m_sSpeed1Pluse.TimeCnt;
   \   00000006   0x....             LDR.N    R1,??DataTable7_4
   \   00000008   0x6849             LDR      R1,[R1, #+4]
   \   0000000A   0x6041             STR      R1,[R0, #+4]
    102          
    103          	if(m_Pluse0ChgFlg == 1)							//脉冲累加处理,
   \   0000000C   0x....             LDR.N    R1,??DataTable7_5
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x2901             CMP      R1,#+1
   \   00000012   0xD102             BNE.N    ??GetSpeedPluse1_0
    104          	{
    105          		m_Pluse0ChgFlg = 0;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x....             LDR.N    R2,??DataTable7_5
   \   00000018   0x6011             STR      R1,[R2, #+0]
    106          	}
    107          
    108          }
   \                     ??GetSpeedPluse1_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    109          
    110          //计算公式：V = （PI * DIM * n * 3600）/ (( DPR *1000*10*100 )*(t/12000000);
    111          //------------------------------------------------------------------------------
    112          //功    能：    计算总里程，分段里程，自定义里程
    113          //入口参数：    
    114          //出口参数：    
    115          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    116          void  CalcSpeed1( void )
    117          {
   \                     CalcSpeed1: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    118          	uint32	PluseCnt;
    119          	uint32	TimeCnt;
    120          	uint32	DistInSec;
    121          	uint16	speed;
    122          	static	int32	lstaddspeed = 0;
    123          	
    124          	PluseCnt = m_sSpeed1Pluse.PluseCnt;
   \   00000004   0x....             LDR.N    R0,??DataTable7_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4680             MOV      R8,R0
    125          	TimeCnt	 = m_sSpeed1Pluse.TimeCnt;
   \   0000000A   0x....             LDR.N    R0,??DataTable7_4
   \   0000000C   0x6840             LDR      R0,[R0, #+4]
   \   0000000E   0x0004             MOVS     R4,R0
    126          
    127          
    128          #if (OS_VERSION > 30000U)
    129              CPU_BOOLEAN err;   
    130              static  uint8 times = 0;
    131          
    132              err = BSP_OS_SemWait(&time0_over_Sem,10);                        	// 发送信号量
   \   00000010   0x210A             MOVS     R1,#+10
   \   00000012   0x....             LDR.N    R0,??DataTable7_6
   \   00000014   0x.... 0x....      BL       BSP_OS_SemWait
   \   00000018   0x0007             MOVS     R7,R0
    133              if(!err)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD10A             BNE.N    ??CalcSpeed1_0
    134              {
    135                      // 发送信号量,速度慢，需要3秒测试一次，测量才准确
    136                  if(times++ > 5)
   \   00000020   0x....             LDR.N    R0,??DataTable7_9
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x1C41             ADDS     R1,R0,#+1
   \   00000026   0x....             LDR.N    R2,??DataTable7_9
   \   00000028   0x7011             STRB     R1,[R2, #+0]
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2806             CMP      R0,#+6
   \   0000002E   0xDB02             BLT.N    ??CalcSpeed1_0
    137                      l_speed1 = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x....             LDR.N    R1,??DataTable7_7
   \   00000034   0x8008             STRH     R0,[R1, #+0]
    138              }
    139                  
    140              if(err){
   \                     ??CalcSpeed1_0: (+1)
   \   00000036   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xD02E             BEQ.N    ??CalcSpeed1_1
    141                  times = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable7_9
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    142          #endif
    143                  
    144                  if( TimeCnt > 2     && 
    145                      m_Pluse0ChgFlg      )                   //产生新脉冲
   \   00000042   0x2C03             CMP      R4,#+3
   \   00000044   0xD325             BCC.N    ??CalcSpeed1_2
   \   00000046   0x....             LDR.N    R0,??DataTable7_5
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD021             BEQ.N    ??CalcSpeed1_2
    146                  {
    147                      m_Pluse0ChgFlg = 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x....             LDR.N    R1,??DataTable7_5
   \   00000052   0x6008             STR      R0,[R1, #+0]
    148                      
    149                      DistInSec = PluseCnt*PI*DIM;			//单位时间内运行距离  （未除系数）	 
   \   00000054   0xF44F 0x709D      MOV      R0,#+314
   \   00000058   0xFB00 0xF008      MUL      R0,R0,R8
   \   0000005C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000060   0x2200             MOVS     R2,#+0
   \   00000062   0x....             LDR.N    R3,??DataTable7_10  ;; 0x40250000
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000006C   0x0005             MOVS     R5,R0
    150                                                              // V = s/t <==> ((n/N)*100pi*10d)/t  (m/us)    （PI和DIM分别放大100和10倍 PI_DIM_MUL = 100*100 ）
    151                                                              //<==> ((n*pi*d)/N/t)*(1000*1000*3600）/(1000*PI_DIM_MUL))  (km/h)	 
    152                                                              //<==>  ((n*pi*d)*(36/2))/t
    153          
    154                      DistInSec =  (DistInSec*(36/2));
   \   0000006E   0x2012             MOVS     R0,#+18
   \   00000070   0x4345             MULS     R5,R0,R5
    155                      
    156                      if((DistInSec % TimeCnt) > TimeCnt/2 )   //4舍5入
   \   00000072   0xFBB5 0xF0F4      UDIV     R0,R5,R4
   \   00000076   0xFB04 0x5010      MLS      R0,R4,R0,R5
   \   0000007A   0x0861             LSRS     R1,R4,#+1
   \   0000007C   0x4281             CMP      R1,R0
   \   0000007E   0xD204             BCS.N    ??CalcSpeed1_3
    157                      {
    158                          speed = DistInSec / TimeCnt	+1;		
   \   00000080   0xFBB5 0xF0F4      UDIV     R0,R5,R4
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \   00000086   0x0006             MOVS     R6,R0
   \   00000088   0xE005             B.N      ??CalcSpeed1_4
    159                      }
    160                      else
    161                      {
    162                          speed = DistInSec / TimeCnt;
   \                     ??CalcSpeed1_3: (+1)
   \   0000008A   0xFBB5 0xF0F4      UDIV     R0,R5,R4
   \   0000008E   0x0006             MOVS     R6,R0
   \   00000090   0xE001             B.N      ??CalcSpeed1_4
    163                      }
    164          
    165              //		if(PluseCnt > 5)
    166              //		{
    167              //			if(lstaddspeed)
    168              //			{
    169              //				l_addspeed1 = TimeCnt/PluseCnt - lstaddspeed;		
    170              //			}
    171              //			lstaddspeed = 	TimeCnt/PluseCnt;
    172              //		}
    173                  }	
    174                  else
    175                  {
    176                      speed = 0;
   \                     ??CalcSpeed1_2: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x0006             MOVS     R6,R0
    177                  }	
    178          
    179                  l_speed1 = speed;
   \                     ??CalcSpeed1_4: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable7_7
   \   00000098   0x8006             STRH     R6,[R0, #+0]
    180              }
    181          //	printfcom0("\r\n \r\n Speed1 %d \r\n ",speed);
    182          }
   \                     ??CalcSpeed1_1: (+1)
   \   0000009A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 1
   \                     ??times:
   \   00000000                      DS8 1
    183          

   \                                 In section .bss, align 4
    184          uint32	l_kilemeter;
   \                     l_kilemeter:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
    185          uint32	 GetMyKileMeter(void)
    186          {
    187          	return	l_kilemeter;
   \                     GetMyKileMeter: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_11
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    188          }
    189          //------------------------------------------------------------------------------
    190          //功    能：    计算总里程，分段里程，自定义里程
    191          //入口参数：    
    192          //出口参数：    
    193          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    194          void  CalcDist( void )
    195          {
   \                     CalcDist: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
    196          	uint32	A_DistTmp;
    197          	uint32	PluseCnt;
    198          	uint32	DistInSec;
    199          	uint32	moddprtmp;
    200          	uint32	disttmp;
    201          	static	uint32	LsFrqSumCnt = 0;
    202          	uint32	plussumcnt;
    203          	uint32	divtmp;
    204          	stcDist g_sDist;
    205          	
    206          	if(GetMySpeed1())
   \   00000006   0x.... 0x....      BL       GetMySpeed1
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD003             BEQ.N    ??CalcDist_0
    207          	{	
    208          		plussumcnt = GetFrq1SumCnt();
   \   0000000E   0x.... 0x....      BL       GetFrq1SumCnt
   \   00000012   0x0006             MOVS     R6,R0
   \   00000014   0xE002             B.N      ??CalcDist_1
    209          	}
    210          	else
    211          	{
    212          		plussumcnt = GetFrq2SumCnt();
   \                     ??CalcDist_0: (+1)
   \   00000016   0x.... 0x....      BL       GetFrq2SumCnt
   \   0000001A   0x0006             MOVS     R6,R0
    213          	}
    214          	PluseCnt   = plussumcnt - LsFrqSumCnt;					//计算新增脉冲数
   \                     ??CalcDist_1: (+1)
   \   0000001C   0x....             LDR.N    R0,??DataTable7_12
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x1A30             SUBS     R0,R6,R0
   \   00000022   0x4681             MOV      R9,R0
    215          //	printfcom0("\r\n Dist Pplussumcnt is %d， %d",plussumcnt,LsFrqSumCnt);
    216          
    217          	LsFrqSumCnt = plussumcnt;
   \   00000024   0x....             LDR.N    R0,??DataTable7_12
   \   00000026   0x6006             STR      R6,[R0, #+0]
    218          
    219          	ReadDist((stcDist *)&g_sDist);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       ReadDist
    220          	if(PluseCnt > 0)											//有脉冲才进行计算
   \   0000002E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000032   0xD034             BEQ.N    ??CalcDist_2
    221          	{
    222          //		printfcom0("\r\n11 Dist %d, ModDPR %d",g_sDist.A_sDist.Dist,g_sDist.A_sDist.ModDPR);
    223          
    224          		DistInSec = PluseCnt*PI*DIM;							//单位时间内运行距离 D = ((n/N)*pi*d0/PI_DIM_MUL 	（PI和DIM分别放大100和10倍 PI_DIM_MUL = 100*100 ）
   \   00000034   0xF44F 0x709D      MOV      R0,#+314
   \   00000038   0xFB00 0xF009      MUL      R0,R0,R9
   \   0000003C   0x.... 0x....      BL       __aeabi_ui2d
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x....             LDR.N    R3,??DataTable7_10  ;; 0x40250000
   \   00000044   0x.... 0x....      BL       __aeabi_dmul
   \   00000048   0x.... 0x....      BL       __aeabi_d2uiz
   \   0000004C   0x4682             MOV      R10,R0
    225          																// <==> (n*pi*d)/(N *PI_DIM_MUL)	(m)
    226          		 														// <==>	(n*pi*d)/(N *PI_DIM_MUL)/1000(Km)
    227          		divtmp = 200*10*100;									//N*PI_DIM_MUL*1000
   \   0000004E   0x....             LDR.N    R0,??DataTable7_13  ;; 0x30d40
   \   00000050   0x0007             MOVS     R7,R0
    228          //		printfcom0("\r\n DistInSec %d,",DistInSec);
    229          		moddprtmp = g_sDist.A_sDist.ModDPR;
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x4680             MOV      R8,R0
    230          //		printfcom0("\r\n ModDPR %d",g_sDist.A_sDist.ModDPR);
    231          		disttmp = g_sDist.A_sDist.Dist;
   \   00000056   0x9801             LDR      R0,[SP, #+4]
   \   00000058   0x0005             MOVS     R5,R0
    232          		A_DistTmp = moddprtmp + DistInSec;
   \   0000005A   0xEB1A 0x0008      ADDS     R0,R10,R8
   \   0000005E   0x0004             MOVS     R4,R0
    233          //		printfcom0("\r\n A_DistTmp %d,moddprtmp %d,DistInSec %d",A_DistTmp,moddprtmp,DistInSec);
    234          		//A_DistTmp = g_sDist.A_sDist.ModDPR + DistInSec; 		//运行公里 = 上次余数+此次运行数（未除系数DPR）
    235          		
    236          		//总里程计算
    237          		//if(A_DistTmp > DPR)									//满脉冲计数处理
    238          	
    239          		if(A_DistTmp > divtmp*1000)								//满脉冲计数处理
   \   00000060   0xF44F 0x707A      MOV      R0,#+1000
   \   00000064   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000068   0x42A0             CMP      R0,R4
   \   0000006A   0xD206             BCS.N    ??CalcDist_3
    240          		{
    241          			//g_sDist.A_sDist.Dist	+= (A_DistTmp / DPR);		//里程累加
    242          			disttmp	+= (((A_DistTmp / (divtmp)))/1000);	//里程累加
   \   0000006C   0xFBB4 0xF0F7      UDIV     R0,R4,R7
   \   00000070   0xF44F 0x717A      MOV      R1,#+1000
   \   00000074   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000078   0x1945             ADDS     R5,R0,R5
    243          //			printfcom0("\r\n\r\n\r\n A_DistTmp > divtmp %d,%d,%d,%d,disttmp %d",A_DistTmp > divtmp,A_DistTmp,divtmp*1000,((A_DistTmp / (divtmp)))/1000,disttmp);
    244          		}
    245          
    246          		moddprtmp  	=  A_DistTmp % (divtmp*1000);		//取余量
   \                     ??CalcDist_3: (+1)
   \   0000007A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000007E   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000082   0xFBB4 0xF1F0      UDIV     R1,R4,R0
   \   00000086   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   0000008A   0x4680             MOV      R8,R0
    247          
    248          	    g_sDist.A_sDist.ModDPR =moddprtmp ;
   \   0000008C   0xF8CD 0x8000      STR      R8,[SP, #+0]
    249          		g_sDist.A_sDist.Dist =disttmp;
   \   00000090   0x9501             STR      R5,[SP, #+4]
    250          		
    251          		l_kilemeter = g_sDist.A_sDist.Dist;
   \   00000092   0x9801             LDR      R0,[SP, #+4]
   \   00000094   0x....             LDR.N    R1,??DataTable7_11
   \   00000096   0x6008             STR      R0,[R1, #+0]
    252          //	   	printfcom0("\r\n22 Dist %d, ModDPR %d",g_sDist.A_sDist.Dist,g_sDist.A_sDist.ModDPR,A_DistTmp);		
    253          		StoresDist((stcDist *)&g_sDist);											//存里程数据
   \   00000098   0x4668             MOV      R0,SP
   \   0000009A   0x.... 0x....      BL       StoresDist
    254          	}
    255          }
   \                     ??CalcDist_2: (+1)
   \   0000009E   0xB008             ADD      SP,SP,#+32
   \   000000A0   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .bss, align 4
   \                     ??LsFrqSumCnt:
   \   00000000                      DS8 4
    256          
    257          
    258          //------------------------------------------------------------------------------
    259          //功    能：    清零总里程，分段里程，自定义里程
    260          //入口参数：    
    261          //出口参数：    
    262          //------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    263          void  SpeedAndDistTast( void )
    264          {
   \                     SpeedAndDistTast: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    265          
    266          		CalcSpeed1();                       //计算速度
   \   00000002   0x.... 0x....      BL       CalcSpeed1
    267          		CalcSpeed2();                       //计算速度
   \   00000006   0x.... 0x....      BL       CalcSpeed2
    268          		CalcSpeedcs();                      //计算速度
   \   0000000A   0x.... 0x....      BL       CalcSpeedcs
    269                  
    270          		//CalcDist();                         //计算里程
    271                  CheckLocoStaTask();                 //机车工况
   \   0000000E   0x.... 0x....      BL       CheckLocoStaTask
    272          
    273          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     mPluseSumCnt0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     m_Time0Sum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     m_AddPluse0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x000F4241         DC32     0xf4241

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     m_sSpeed1Pluse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     m_Pluse0ChgFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     time0_over_Sem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     l_speed1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     l_addspeed1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     ??times

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x40250000         DC32     0x40250000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x........         DC32     l_kilemeter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x........         DC32     ??LsFrqSumCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x00030D40         DC32     0x30d40

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      64   CalcDist
        64   -> GetFrq1SumCnt
        64   -> GetFrq2SumCnt
        64   -> GetMySpeed1
        64   -> ReadDist
        64   -> StoresDist
        64   -> __aeabi_d2uiz
        64   -> __aeabi_dmul
        64   -> __aeabi_ui2d
      24   CalcSpeed1
        24   -> BSP_OS_SemWait
        24   -> __aeabi_d2uiz
        24   -> __aeabi_dmul
        24   -> __aeabi_ui2d
       0   GetFrq1SumCnt
       0   GetMyAddSpeed1
       0   GetMyKileMeter
       0   GetMySpeed1
       0   GetSpeedPluse1
       8   SpeedAndDistTast
         8   -> CalcSpeed1
         8   -> CalcSpeed2
         8   -> CalcSpeedcs
         8   -> CheckLocoStaTask
       8   TIMER0_IRQHandler
         8   -> BSP_OS_SemPost
         8   -> GPIO_ReadIoVal
         8   -> TIM_ClearIntCapturePending
         8   -> TIM_GetCaptureValue
         8   -> TIM_GetIntCaptureStatus
         8   -> TIM_ResetCounter
         8   -> nop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
     164  CalcDist
     158  CalcSpeed1
       6  GetFrq1SumCnt
       6  GetMyAddSpeed1
       6  GetMyKileMeter
       6  GetMySpeed1
      28  GetSpeedPluse1
       4  LsFrqSumCnt
      20  SpeedAndDistTast
     156  TIMER0_IRQHandler
       4  l_addspeed1
       4  l_kilemeter
       2  l_speed1
       4  mPluseSumCnt0
       4  m_AddPluse0
       4  m_Pluse0ChgFlg
       4  m_Time0Sum
       8  m_sSpeed1Pluse
       1  times

 
  39 bytes in section .bss
 606 bytes in section .text
 
 606 bytes of CODE memory
  39 bytes of DATA memory

Errors: none
Warnings: 10
