###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       07/Sep/2017  21:03:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-310统计模块\Software\OSAL\OS\osal_timer.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\OSAL\OS\osal_timer.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\osal_timer.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\osal_timer.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\OSAL\OS\osal_timer.c
      1          /*******************************************************************************
      2           *   Filename:       osal.h
      3           *   Revised:        $Date: 2013-04-17 $
      4           *   Revision:       $
      5           *   Writer:         Wuming Shen.
      6           *
      7           *   Description:
      8           *
      9           *   Notes:
     10           *
     11           *
     12           *   All copyrights reserved to Wuming Shen.
     13           *
     14           *******************************************************************************/
     15          /*******************************************************************************
     16           * INCLUDES
     17           */
     18          #include <osal.h>
     19          #include <osal_timer.h>
     20          #include <osal_event.h>
     21          #include <osal_memory.h>
     22          
     23          #include <bsp_timer.h>
     24          
     25          #if (UCOS_EN == DEF_ENABLED ) && ( OS_VERSION > 30000U )
     26          #include <os.h>
     27          #endif
     28          
     29          #if OSAL_TIMER_EN > 0
     30          
     31          /*******************************************************************************
     32           * CONSTANTS
     33           */
     34          
     35          /*******************************************************************************
     36           * TYPEDEFS
     37           */
     38          
     39          /*******************************************************************************
     40           * MACROS
     41           */
     42          
     43          /*******************************************************************************
     44           * LOCAL VARIABLES
     45           */

   \                                 In section .bss, align 4
     46          osalTimerRec_t *timerHead;
   \                     timerHead:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     47          byte            timerActive;                            // Flag if hw timer active
   \                     timerActive:
   \   00000000                      DS8 1
     48          #if OSAL_MEM_EN == 0

   \                                 In section .bss, align 4
     49              osalTimerRec_t osalTimer[OSAL_MAX_TIMERS];
   \                     osalTimer:
   \   00000000                      DS8 400
     50          #endif
     51          /*******************************************************************************
     52           * GLOBAL VARIABLES
     53           */
     54               
     55          /*******************************************************************************
     56           * LOCAL FUNCTIONS
     57           */
     58          void            osal_timer_activate         ( byte turn_on );
     59          osalTimerRec_t *osalFindTimer               ( osalTid task_id, osalEvt event_flag );
     60          void            osal_timer_hw_setup         ( byte turn_on );
     61          
     62          /*******************************************************************************
     63           * GLOBAL FUNCTIONS
     64           */

   \                                 In section .bss, align 4
     65          INT32U          osal_system_clock;
   \                     osal_system_clock:
   \   00000000                      DS8 4
     66          
     67          /*******************************************************************************
     68           * EXTERN VARIABLES
     69           */
     70          
     71          /******************************************************************************/
     72          
     73          /*******************************************************************************
     74           * @fn      osalTimerInit
     75           *
     76           * @brief   Initialization for the OSAL Timer System.
     77           *
     78           * @param   none
     79           *
     80           * @return
     81           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     82          void osalTimerInit( void )
     83          {
   \                     osalTimerInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     84          #if OSAL_MEM_EN == 0
     85              INT8U   idx;
     86              for ( idx = 0; idx < OSAL_MAX_TIMERS; idx++ ) {
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x0004             MOVS     R4,R0
   \                     ??osalTimerInit_0: (+1)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C14             CMP      R4,#+20
   \   0000000A   0xDA29             BGE.N    ??osalTimerInit_1
     87                  osalTimer[idx].next         = (void *)NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2214             MOVS     R2,#+20
   \   00000016   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000001A   0x6008             STR      R0,[R1, #+0]
     88                  osalTimer[idx].task_id      = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000002A   0x60C8             STR      R0,[R1, #+12]
     89                  osalTimer[idx].event_flag   = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2214             MOVS     R2,#+20
   \   00000036   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000003A   0x6048             STR      R0,[R1, #+4]
     90                  osalTimer[idx].timeout      = 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x2214             MOVS     R2,#+20
   \   00000046   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000004A   0x6088             STR      R0,[R1, #+8]
     91                  osalTimer[idx].reload      = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable7
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000005A   0x6108             STR      R0,[R1, #+16]
     92              }
   \   0000005C   0x1C64             ADDS     R4,R4,#+1
   \   0000005E   0xE7D2             B.N      ??osalTimerInit_0
     93          #endif
     94              timerHead   = (void *)NULL;
   \                     ??osalTimerInit_1: (+1)
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable7_1
   \   00000066   0x6008             STR      R0,[R1, #+0]
     95              // Initialize the system timer
     96              osal_timer_activate( FALSE );
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       osal_timer_activate
     97              timerActive = FALSE;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable7_2
   \   00000074   0x7008             STRB     R0,[R1, #+0]
     98          
     99              osal_system_clock  = 0;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable7_3
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    100          }
   \   0000007E   0xBD10             POP      {R4,PC}          ;; return
    101          
    102          /*******************************************************************************
    103           * @fn      osalAddTimer
    104           *
    105           * @brief   Add a timer to the timer list.
    106           *          Ints must be disabled.
    107           *
    108           * @param   task_id
    109           * @param   event_flag
    110           * @param   timeout
    111           *
    112           * @return  osalTimerRec_t * - pointer to newly created timer
    113           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    114          osalTimerRec_t *osalAddTimer( osalTid task_id, osalFlg event_flag, osalTime timeout )
    115          {
   \                     osalAddTimer: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    116              osalTimerRec_t  *newTimer;
    117              osalTimerRec_t  *srchTimer;
    118              // Look for an existing timer first
    119              newTimer = osalFindTimer( task_id, event_flag );
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       osalFindTimer
   \   00000012   0x4680             MOV      R8,R0
    120              if ( newTimer ) {
   \   00000014   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000018   0xD003             BEQ.N    ??osalAddTimer_0
    121                  // Timer is found - update it.
    122                  newTimer->timeout = timeout;
   \   0000001A   0xF8C8 0x6008      STR      R6,[R8, #+8]
    123          
    124                  return ( newTimer );
   \   0000001E   0x4640             MOV      R0,R8
   \   00000020   0xE036             B.N      ??osalAddTimer_1
    125              } else {
    126                  // New Timer
    127          #if OSAL_MEM_EN > 0
    128                  newTimer = osal_mem_alloc( sizeof( osalTimerRec_t ) );
    129          #else
    130                  INT8U           idx;
    131                  for ( idx = 0; idx < OSAL_MAX_TIMERS; idx++ ) {
   \                     ??osalAddTimer_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x0001             MOVS     R1,R0
   \                     ??osalAddTimer_2: (+1)
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x2914             CMP      R1,#+20
   \   0000002A   0xDA10             BGE.N    ??osalAddTimer_3
    132                      if ( !osalTimer[idx].event_flag ) {
   \   0000002C   0x....             LDR.N    R0,??DataTable7
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0x2214             MOVS     R2,#+20
   \   00000032   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000036   0x6840             LDR      R0,[R0, #+4]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD106             BNE.N    ??osalAddTimer_4
    133                          newTimer    = &osalTimer[idx];
   \   0000003C   0x....             LDR.N    R0,??DataTable7
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0x2214             MOVS     R2,#+20
   \   00000042   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000046   0x4680             MOV      R8,R0
    134                          break;
   \   00000048   0xE001             B.N      ??osalAddTimer_3
    135                      }
    136                  }
   \                     ??osalAddTimer_4: (+1)
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0xE7EB             B.N      ??osalAddTimer_2
    137          #endif
    138                  if ( newTimer ) {
   \                     ??osalAddTimer_3: (+1)
   \   0000004E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000052   0xD01C             BEQ.N    ??osalAddTimer_5
    139                      // Fill in new timer
    140                      newTimer->task_id       = task_id;
   \   00000054   0xF8C8 0x400C      STR      R4,[R8, #+12]
    141                      newTimer->event_flag    = event_flag;
   \   00000058   0xF8C8 0x5004      STR      R5,[R8, #+4]
    142                      newTimer->timeout       = timeout;
   \   0000005C   0xF8C8 0x6008      STR      R6,[R8, #+8]
    143                      newTimer->next          = (void *)NULL;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xF8C8 0x0000      STR      R0,[R8, #+0]
    144          
    145                      // Does the timer list already exist
    146                      if ( timerHead == NULL ) {
   \   00000066   0x....             LDR.N    R0,??DataTable7_1
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD103             BNE.N    ??osalAddTimer_6
    147                          // Start task list
    148                          timerHead = newTimer;
   \   0000006E   0x....             LDR.N    R0,??DataTable7_1
   \   00000070   0xF8C0 0x8000      STR      R8,[R0, #+0]
   \   00000074   0xE009             B.N      ??osalAddTimer_7
    149                      } else {
    150                          // Add it to the end of the timer list
    151                          srchTimer = timerHead;
   \                     ??osalAddTimer_6: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable7_1
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x0007             MOVS     R7,R0
    152          
    153                          // Stop at the last record
    154                          while ( srchTimer->next )
   \                     ??osalAddTimer_8: (+1)
   \   0000007C   0x6838             LDR      R0,[R7, #+0]
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD001             BEQ.N    ??osalAddTimer_9
    155                              srchTimer = srchTimer->next;
   \   00000082   0x683F             LDR      R7,[R7, #+0]
   \   00000084   0xE7FA             B.N      ??osalAddTimer_8
    156          
    157                          // Add to the list
    158                          srchTimer->next = newTimer;
   \                     ??osalAddTimer_9: (+1)
   \   00000086   0xF8C7 0x8000      STR      R8,[R7, #+0]
    159                      }
    160          
    161                      return ( newTimer );
   \                     ??osalAddTimer_7: (+1)
   \   0000008A   0x4640             MOV      R0,R8
   \   0000008C   0xE000             B.N      ??osalAddTimer_1
    162                  } else
    163                      return ( (osalTimerRec_t *)NULL );
   \                     ??osalAddTimer_5: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \                     ??osalAddTimer_1: (+1)
   \   00000090   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    164              }
    165          }
    166          
    167          /*******************************************************************************
    168           * @fn      osalFindTimer
    169           *
    170           * @brief   Find a timer in a timer list.
    171           *          Ints must be disabled.
    172           *
    173           * @param   task_id
    174           * @param   event_flag
    175           *
    176           * @return  osalTimerRec_t *
    177           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    178          osalTimerRec_t *osalFindTimer( osalTid task_id, osalFlg event_flag )
    179          {
   \                     osalFindTimer: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    180              osalTimerRec_t  *srchTimer;
    181          
    182              // Head of the timer list
    183              srchTimer = timerHead;
   \   00000002   0x....             LDR.N    R3,??DataTable7_1
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x0018             MOVS     R0,R3
    184          
    185              // Stop when found or at the end
    186              while ( srchTimer ) {
   \                     ??osalFindTimer_0: (+1)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??osalFindTimer_1
    187                  if ( srchTimer->event_flag == event_flag &&
    188                      srchTimer->task_id == task_id )
   \   0000000C   0x6843             LDR      R3,[R0, #+4]
   \   0000000E   0x428B             CMP      R3,R1
   \   00000010   0xD102             BNE.N    ??osalFindTimer_2
   \   00000012   0x68C3             LDR      R3,[R0, #+12]
   \   00000014   0x4293             CMP      R3,R2
   \   00000016   0xD001             BEQ.N    ??osalFindTimer_1
    189                      break;
    190                  // Not this one, check another
    191                  srchTimer = srchTimer->next;
   \                     ??osalFindTimer_2: (+1)
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0xE7F5             B.N      ??osalFindTimer_0
    192              }
    193              return ( srchTimer );
   \                     ??osalFindTimer_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    194          }
    195          
    196          /*******************************************************************************
    197           * @fn      osalDeleteTimer
    198           *
    199           * @brief   Delete a timer from a timer list.
    200           *          Ints must be disabled.
    201           *
    202           * @param   table
    203           * @param   rmTimer
    204           *
    205           * @return  none
    206           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    207          void osalDeleteTimer( osalTimerRec_t *rmTimer )
    208          {
    209              osalTimerRec_t  *srchTimer;
    210          
    211              // Does the timer list really exist
    212              if ( (timerHead != NULL) && rmTimer ) {
   \                     osalDeleteTimer: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7_1
   \   00000002   0x6812             LDR      R2,[R2, #+0]
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD025             BEQ.N    ??osalDeleteTimer_0
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD023             BEQ.N    ??osalDeleteTimer_0
    213                  // Add it to the end of the timer list
    214                  srchTimer = timerHead;
   \   0000000C   0x....             LDR.N    R2,??DataTable7_1
   \   0000000E   0x6812             LDR      R2,[R2, #+0]
   \   00000010   0x0011             MOVS     R1,R2
    215          
    216                  // First element?
    217                  if ( srchTimer == rmTimer )  {
   \   00000012   0x4281             CMP      R1,R0
   \   00000014   0xD109             BNE.N    ??osalDeleteTimer_1
    218                      timerHead = rmTimer->next;
   \   00000016   0x6802             LDR      R2,[R0, #+0]
   \   00000018   0x....             LDR.N    R3,??DataTable7_1
   \   0000001A   0x601A             STR      R2,[R3, #+0]
    219          
    220          #if OSAL_MEM_EN > 0
    221                          osal_mem_free( rmTimer );
    222          #else
    223                          rmTimer->event_flag   = 0;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x6042             STR      R2,[R0, #+4]
    224                          rmTimer->next         = (void *)NULL;
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x6002             STR      R2,[R0, #+0]
    225                          rmTimer->task_id      = 0;
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0x60C2             STR      R2,[R0, #+12]
   \   00000028   0xE014             B.N      ??osalDeleteTimer_0
    226          #endif
    227                  } else {
    228                      // Stop when found or at the end
    229                      while ( srchTimer->next && srchTimer->next != rmTimer ) {
   \                     ??osalDeleteTimer_1: (+1)
   \   0000002A   0x680A             LDR      R2,[R1, #+0]
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD004             BEQ.N    ??osalDeleteTimer_2
   \   00000030   0x680A             LDR      R2,[R1, #+0]
   \   00000032   0x4282             CMP      R2,R0
   \   00000034   0xD001             BEQ.N    ??osalDeleteTimer_2
    230                          srchTimer = srchTimer->next;
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0xE7F7             B.N      ??osalDeleteTimer_1
    231                      }
    232                      // Found?
    233                      if ( srchTimer->next == rmTimer ) {
   \                     ??osalDeleteTimer_2: (+1)
   \   0000003A   0x680A             LDR      R2,[R1, #+0]
   \   0000003C   0x4282             CMP      R2,R0
   \   0000003E   0xD109             BNE.N    ??osalDeleteTimer_0
    234                          // Fix pointers
    235                          srchTimer->next = rmTimer->next;
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0x600A             STR      R2,[R1, #+0]
    236                          // Deallocate the timer struct memory
    237          #if OSAL_MEM_EN > 0
    238                          osal_mem_free( rmTimer );
    239          #else
    240                          rmTimer->event_flag   = 0;
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x6042             STR      R2,[R0, #+4]
    241                          rmTimer->next         = (void *)NULL;
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x6002             STR      R2,[R0, #+0]
    242                          rmTimer->task_id      = 0;
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x60C2             STR      R2,[R0, #+12]
    243                          rmTimer->reload       = 0;
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x6102             STR      R2,[R0, #+16]
    244          #endif
    245                      }
    246                  }
    247              }
    248          }
   \                     ??osalDeleteTimer_0: (+1)
   \   00000054   0x4770             BX       LR               ;; return
    249          
    250          /*******************************************************************************
    251           * @fn      osal_timer_activate
    252           *
    253           * @brief
    254           *
    255           *   Turns the hardware timer on or off
    256           *
    257           * @param  byte turn_on - false - turn off, true - turn on
    258           *
    259           * @return  none
    260           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void osal_timer_activate( byte turn_on )
    262          {
   \                     osal_timer_activate: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    263              osal_timer_hw_setup( turn_on );
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       osal_timer_hw_setup
    264              timerActive = turn_on;
   \   0000000C   0x....             LDR.N    R0,??DataTable7_2
   \   0000000E   0x7004             STRB     R4,[R0, #+0]
    265          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    266          
    267          /*******************************************************************************
    268           * @fn      osal_timer_hw_setup
    269           *
    270           * @brief
    271           *
    272           *   Setup the timer hardware.
    273           *
    274           * @param  byte turn_on
    275           *
    276           * @return  void
    277           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    278          void osal_timer_hw_setup( byte turn_on )
    279          {
    280              if (turn_on) {
    281                  //OSAL_TIMER_TICKSTART( ) ;
    282              } else {
    283                  //OSAL_TIMER_TICKSTOP( );
    284              }
    285          }
   \                     osal_timer_hw_setup: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    286          
    287          /*******************************************************************************
    288           * @fn      osal_start_timerEx
    289           *
    290           * @brief
    291           *
    292           *   This function is called to start a timer to expire in n mSecs.
    293           *   When the timer expires, the calling task will get the specified event.
    294           *
    295           * @param   byte taskID - task id to set timer for
    296           * @param   INT16U event_id - event to be notified with
    297           * @param   UNINT16 timeout_value - in milliseconds.
    298           *
    299           * @return  ZSUCCESS, or NO_TIMER_AVAIL.
    300           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    301          byte osal_start_timerEx( osalTid taskID, osalEvt event_id, osalTime timeout_value )
    302          {
   \                     osal_start_timerEx: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    303              halIntState_t     cpu_sr;
    304              osalTimerRec_t   *newTimer;
    305              OS_CRITICAL_ENTER();  // Hold off interrupts.
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000014   0x....             LDR.N    R0,??DataTable7_4
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable7_4
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   \   0000001E   0x....             LDR.N    R0,??DataTable7_4
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??osal_start_timerEx_0
   \   00000026   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??osal_start_timerEx_0: (+1)
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
    306          
    307              // Add timer
    308              newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x0029             MOVS     R1,R5
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       osalAddTimer
   \   00000040   0x4680             MOV      R8,R0
    309              if ( newTimer ) {
   \   00000042   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000046   0xD006             BEQ.N    ??osal_start_timerEx_1
    310                  // Does the timer need to be started?
    311                  if ( timerActive == FALSE ) {
   \   00000048   0x....             LDR.N    R0,??DataTable7_2
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD102             BNE.N    ??osal_start_timerEx_1
    312                      osal_timer_activate( TRUE );
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       osal_timer_activate
    313                  }
    314              }
    315          
    316              OS_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_start_timerEx_1: (+1)
   \   00000056   0x.... 0x....      BL       CPU_SR_Save
   \   0000005A   0x0007             MOVS     R7,R0
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000060   0x....             LDR.N    R0,??DataTable7_4
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x1E40             SUBS     R0,R0,#+1
   \   00000066   0x....             LDR.N    R1,??DataTable7_4
   \   00000068   0x7008             STRB     R0,[R1, #+0]
   \   0000006A   0x....             LDR.N    R0,??DataTable7_4
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD115             BNE.N    ??osal_start_timerEx_2
   \   00000072   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   00000076   0x....             LDR.N    R0,??DataTable7_5
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD008             BEQ.N    ??osal_start_timerEx_3
   \   0000007E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000082   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0x.... 0x....      BL       CPU_SR_Restore
   \   0000008A   0x.... 0x....      BL       OS_Sched0
   \   0000008E   0xE00C             B.N      ??osal_start_timerEx_4
   \                     ??osal_start_timerEx_3: (+1)
   \   00000090   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000094   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000096   0x0038             MOVS     R0,R7
   \   00000098   0x.... 0x....      BL       CPU_SR_Restore
   \   0000009C   0xE005             B.N      ??osal_start_timerEx_4
   \                     ??osal_start_timerEx_2: (+1)
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000A2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A4   0x0038             MOVS     R0,R7
   \   000000A6   0x.... 0x....      BL       CPU_SR_Restore
    317          
    318              return ( (newTimer != NULL) ? ZSUCCESS : NO_TIMER_AVAIL );
   \                     ??osal_start_timerEx_4: (+1)
   \   000000AA   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000AE   0xD001             BEQ.N    ??osal_start_timerEx_5
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xE000             B.N      ??osal_start_timerEx_6
   \                     ??osal_start_timerEx_5: (+1)
   \   000000B4   0x200C             MOVS     R0,#+12
   \                     ??osal_start_timerEx_6: (+1)
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    319          }
    320          /*******************************************************************************
    321           * @fn      osal_start_timerRl
    322           *
    323           * @brief
    324           *
    325           *   This function is called to start a timer to expire in n mSecs.
    326           *   When the timer expires, the calling task will get the specified event.
    327           *
    328           * @param   byte taskID - task id to set timer for
    329           * @param   INT16U event_id - event to be notified with
    330           * @param   UNINT16 timeout_value - in milliseconds.
    331           *
    332           * @return  ZSUCCESS, or NO_TIMER_AVAIL.
    333           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    334          byte osal_start_timerRl( osalTid taskID, osalEvt event_id, osalTime timeout_value )
    335          {
   \                     osal_start_timerRl: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    336              halIntState_t     cpu_sr;
    337              osalTimerRec_t   *newTimer;
    338              // Hold off interrupts.
    339              OS_CRITICAL_ENTER();
   \   0000000A   0x.... 0x....      BL       CPU_SR_Save
   \   0000000E   0x0007             MOVS     R7,R0
   \   00000010   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000014   0x....             LDR.N    R0,??DataTable7_4
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x....             LDR.N    R1,??DataTable7_4
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   \   0000001E   0x....             LDR.N    R0,??DataTable7_4
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD101             BNE.N    ??osal_start_timerRl_0
   \   00000026   0x.... 0x....      BL       OS_SchedLockTimeMeasStart
   \                     ??osal_start_timerRl_0: (+1)
   \   0000002A   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000002E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000030   0x0038             MOVS     R0,R7
   \   00000032   0x.... 0x....      BL       CPU_SR_Restore
    340          
    341              // Add timer
    342              newTimer = osalAddTimer( taskID, event_id, timeout_value );
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x0029             MOVS     R1,R5
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       osalAddTimer
   \   00000040   0x4680             MOV      R8,R0
    343              if ( newTimer ) {
   \   00000042   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000046   0xD00A             BEQ.N    ??osal_start_timerRl_1
    344                  newTimer->reload    = newTimer->timeout;
   \   00000048   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000004C   0xF8C8 0x0010      STR      R0,[R8, #+16]
    345                  // Does the timer need to be started?
    346                  if ( timerActive == FALSE ) {
   \   00000050   0x....             LDR.N    R0,??DataTable7_2
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD102             BNE.N    ??osal_start_timerRl_1
    347                      osal_timer_activate( TRUE );
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x.... 0x....      BL       osal_timer_activate
    348                  }
    349              }
    350          
    351              OS_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_start_timerRl_1: (+1)
   \   0000005E   0x.... 0x....      BL       CPU_SR_Save
   \   00000062   0x0007             MOVS     R7,R0
   \   00000064   0x.... 0x....      BL       CPU_IntDisMeasStart
   \   00000068   0x....             LDR.N    R0,??DataTable7_4
   \   0000006A   0x7800             LDRB     R0,[R0, #+0]
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x....             LDR.N    R1,??DataTable7_4
   \   00000070   0x7008             STRB     R0,[R1, #+0]
   \   00000072   0x....             LDR.N    R0,??DataTable7_4
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD115             BNE.N    ??osal_start_timerRl_2
   \   0000007A   0x.... 0x....      BL       OS_SchedLockTimeMeasStop
   \   0000007E   0x....             LDR.N    R0,??DataTable7_5
   \   00000080   0x8800             LDRH     R0,[R0, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD008             BEQ.N    ??osal_start_timerRl_3
   \   00000086   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000008A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008C   0x0038             MOVS     R0,R7
   \   0000008E   0x.... 0x....      BL       CPU_SR_Restore
   \   00000092   0x.... 0x....      BL       OS_Sched0
   \   00000096   0xE00C             B.N      ??osal_start_timerRl_4
   \                     ??osal_start_timerRl_3: (+1)
   \   00000098   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x0038             MOVS     R0,R7
   \   000000A0   0x.... 0x....      BL       CPU_SR_Restore
   \   000000A4   0xE005             B.N      ??osal_start_timerRl_4
   \                     ??osal_start_timerRl_2: (+1)
   \   000000A6   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000AA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AC   0x0038             MOVS     R0,R7
   \   000000AE   0x.... 0x....      BL       CPU_SR_Restore
    352          
    353              return ( (newTimer != NULL) ? ZSUCCESS : NO_TIMER_AVAIL );
   \                     ??osal_start_timerRl_4: (+1)
   \   000000B2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000B6   0xD001             BEQ.N    ??osal_start_timerRl_5
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0xE000             B.N      ??osal_start_timerRl_6
   \                     ??osal_start_timerRl_5: (+1)
   \   000000BC   0x200C             MOVS     R0,#+12
   \                     ??osal_start_timerRl_6: (+1)
   \   000000BE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    354          }
    355          /*******************************************************************************
    356           * @fn      osal_stop_timerEx
    357           *
    358           * @brief
    359           *
    360           *   This function is called to stop a timer that has already been started.
    361           *   If ZSUCCESS, the function will cancel the timer and prevent the event
    362           *   associated with the timer from being set for the calling task.
    363           *
    364           * @param   byte task_id - task id of timer to stop
    365           * @param   INT16U event_id - identifier of the timer that is to be stopped
    366           *
    367           * @return  ZSUCCESS or INVALID_EVENT_ID
    368           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    369          byte osal_stop_timerEx( osalTid task_id, osalEvt event_id )
    370          {
   \                     osal_stop_timerEx: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    371              halIntState_t     cpu_sr;
    372              osalTimerRec_t   *foundTimer;
    373          
    374              CPU_CRITICAL_ENTER();  // Hold off interrupts.
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0006             MOVS     R6,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    375          
    376              // Find the timer to stop
    377              foundTimer = osalFindTimer( task_id, event_id );
   \   00000010   0x0029             MOVS     R1,R5
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       osalFindTimer
   \   00000018   0x0007             MOVS     R7,R0
    378              if ( foundTimer ) {
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD002             BEQ.N    ??osal_stop_timerEx_0
    379                  osalDeleteTimer( foundTimer );
   \   0000001E   0x0038             MOVS     R0,R7
   \   00000020   0x.... 0x....      BL       osalDeleteTimer
    380              }
    381          
    382              CPU_CRITICAL_EXIT();   // Re-enable interrupts.
   \                     ??osal_stop_timerEx_0: (+1)
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x0030             MOVS     R0,R6
   \   0000002C   0x.... 0x....      BL       CPU_SR_Restore
    383          
    384              return ( (foundTimer != NULL) ? ZSUCCESS : INVALID_EVENT_ID );
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD001             BEQ.N    ??osal_stop_timerEx_1
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE000             B.N      ??osal_stop_timerEx_2
   \                     ??osal_stop_timerEx_1: (+1)
   \   00000038   0x2007             MOVS     R0,#+7
   \                     ??osal_stop_timerEx_2: (+1)
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    385          }
    386          
    387          /*******************************************************************************
    388           * @fn      osalTimerUpdate
    389           *
    390           * @brief   Update the timer structures for a timer tick.
    391           *
    392           * @param   none
    393           *
    394           * @return  none
    395           *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void osalTimerUpdate( void )
    397          {
   \                     osalTimerUpdate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    398              osalTimerRec_t  *srchTimer;
    399              osalTimerRec_t  *prevTimer;
    400              osalTimerRec_t  *saveTimer;
    401          
    402              // Update the system time
    403              osal_system_clock += OSAL_TICK_TIME_MS;
   \   00000002   0x....             LDR.N    R0,??DataTable7_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable7_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    404          
    405              // Look for open timer slot
    406              if ( timerHead != NULL ) {
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD035             BEQ.N    ??osalTimerUpdate_0
    407                  // Add it to the end of the timer list
    408                  srchTimer = timerHead;
   \   00000014   0x....             LDR.N    R0,??DataTable7_1
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x0004             MOVS     R4,R0
    409                  prevTimer = (void *)NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x0005             MOVS     R5,R0
    410          
    411                  // Look for open timer slot
    412                  while ( srchTimer ) {
   \                     ??osalTimerUpdate_1: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD02E             BEQ.N    ??osalTimerUpdate_0
    413                      // Decrease the correct amount of time
    414                      if (srchTimer->timeout <= OSAL_TICK_TIME_MS)
   \   00000022   0x68A0             LDR      R0,[R4, #+8]
   \   00000024   0x2802             CMP      R0,#+2
   \   00000026   0xD202             BCS.N    ??osalTimerUpdate_2
    415                          srchTimer->timeout = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x60A0             STR      R0,[R4, #+8]
   \   0000002C   0xE002             B.N      ??osalTimerUpdate_3
    416                      else
    417                          srchTimer->timeout = srchTimer->timeout - OSAL_TICK_TIME_MS;
   \                     ??osalTimerUpdate_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x60A0             STR      R0,[R4, #+8]
    418          
    419                      // When timeout, execute the task
    420                      if ( srchTimer->timeout == 0 ) {
   \                     ??osalTimerUpdate_3: (+1)
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD11F             BNE.N    ??osalTimerUpdate_4
    421                          osal_set_event( srchTimer->task_id, srchTimer->event_flag );
   \   0000003A   0x6861             LDR      R1,[R4, #+4]
   \   0000003C   0x68E0             LDR      R0,[R4, #+12]
   \   0000003E   0x.... 0x....      BL       osal_set_event
    422                          if ( srchTimer->reload ) {
   \   00000042   0x6920             LDR      R0,[R4, #+16]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD004             BEQ.N    ??osalTimerUpdate_5
    423                            // Restart srchTimer
    424                            srchTimer->timeout    = srchTimer->reload;
   \   00000048   0x6920             LDR      R0,[R4, #+16]
   \   0000004A   0x60A0             STR      R0,[R4, #+8]
    425                            prevTimer = srchTimer;
   \   0000004C   0x0025             MOVS     R5,R4
    426                            // Get next
    427                            srchTimer = srchTimer->next;
   \   0000004E   0x6824             LDR      R4,[R4, #+0]
    428                            continue;
   \   00000050   0xE7E5             B.N      ??osalTimerUpdate_1
    429                          }
    430                          // Take out of list
    431                          if ( prevTimer == NULL )
   \                     ??osalTimerUpdate_5: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD103             BNE.N    ??osalTimerUpdate_6
    432                              timerHead = srchTimer->next;
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x....             LDR.N    R1,??DataTable7_1
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   \   0000005C   0xE001             B.N      ??osalTimerUpdate_7
    433                          else
    434                              prevTimer->next = srchTimer->next;
   \                     ??osalTimerUpdate_6: (+1)
   \   0000005E   0x6820             LDR      R0,[R4, #+0]
   \   00000060   0x6028             STR      R0,[R5, #+0]
    435                          // Next
    436                          saveTimer = srchTimer->next;
   \                     ??osalTimerUpdate_7: (+1)
   \   00000062   0x6820             LDR      R0,[R4, #+0]
   \   00000064   0x0006             MOVS     R6,R0
    437                          // Free memory
    438          #if OSAL_MEM_EN > 0
    439                          osal_mem_free( srchTimer );
    440          #else
    441                          srchTimer->event_flag   = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6060             STR      R0,[R4, #+4]
    442                          srchTimer->next         = (void *)NULL;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x6020             STR      R0,[R4, #+0]
    443                          srchTimer->task_id      = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x60E0             STR      R0,[R4, #+12]
    444                          srchTimer->reload       = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6120             STR      R0,[R4, #+16]
    445          #endif
    446                          srchTimer = saveTimer;
   \   00000076   0x0034             MOVS     R4,R6
   \   00000078   0xE7D1             B.N      ??osalTimerUpdate_1
    447                      } else {
    448                          // Get next
    449                          prevTimer = srchTimer;
   \                     ??osalTimerUpdate_4: (+1)
   \   0000007A   0x0025             MOVS     R5,R4
    450                          srchTimer = srchTimer->next;
   \   0000007C   0x6824             LDR      R4,[R4, #+0]
   \   0000007E   0xE7CE             B.N      ??osalTimerUpdate_1
    451                      }
    452                  }
    453              }
    454          }
   \                     ??osalTimerUpdate_0: (+1)
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     osalTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     timerHead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     timerActive

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     osal_system_clock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     OSSchedLockNestingCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     OSIntQNbrEntries
    455          
    456          /*******************************************************************************
    457           * 				     end of file                               *
    458           *******************************************************************************/
    459          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   osalAddTimer
        24   -> osalFindTimer
       0   osalDeleteTimer
       0   osalFindTimer
       8   osalTimerInit
         8   -> osal_timer_activate
      16   osalTimerUpdate
        16   -> osal_set_event
      24   osal_start_timerEx
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_Sched0
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
        24   -> osalAddTimer
        24   -> osal_timer_activate
      24   osal_start_timerRl
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> OS_Sched0
        24   -> OS_SchedLockTimeMeasStart
        24   -> OS_SchedLockTimeMeasStop
        24   -> osalAddTimer
        24   -> osal_timer_activate
      24   osal_stop_timerEx
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> osalDeleteTimer
        24   -> osalFindTimer
       8   osal_timer_activate
         8   -> osal_timer_hw_setup
       0   osal_timer_hw_setup


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
     148  osalAddTimer
      86  osalDeleteTimer
      30  osalFindTimer
     400  osalTimer
     128  osalTimerInit
     130  osalTimerUpdate
     188  osal_start_timerEx
     196  osal_start_timerRl
      62  osal_stop_timerEx
       4  osal_system_clock
      18  osal_timer_activate
       2  osal_timer_hw_setup
       1  timerActive
       4  timerHead

 
   409 bytes in section .bss
 1 012 bytes in section .text
 
 1 012 bytes of CODE memory
   409 bytes of DATA memory

Errors: none
Warnings: none
