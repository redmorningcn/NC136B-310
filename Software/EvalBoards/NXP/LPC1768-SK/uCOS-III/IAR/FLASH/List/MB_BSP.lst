###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       19/Sep/2017  19:02:40
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C
#        -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MB_BSP.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MB_BSP.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                            uC/Modbus
     19          *
     20          *                                      MODBUS BOARD SUPPORT PACKAGE
     21          *                                         Philips LPC2000 (ARM7)
     22          *
     23          * Filename    : mb_bsp.c
     24          * Version     : V2.12
     25          * Programmers : JJL
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          #include <global.h>
     35          #include <includes.h>

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD509             BPL.N    ??NVIC_SetPriority_0
   \   00000008   0x00CA             LSLS     R2,R1,#+3
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable13_1  ;; 0xe000ed18
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0xF010 0x040F      ANDS     R4,R0,#0xF
   \   00000014   0x18E3             ADDS     R3,R4,R3
   \   00000016   0xF803 0x2C04      STRB     R2,[R3, #-4]
   \   0000001A   0xE004             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000001C   0x00CA             LSLS     R2,R1,#+3
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable13_2  ;; 0xe000e400
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x54C2             STRB     R2,[R0, R3]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
     36          #include <lpc17xx_uart.h>
     37          #include <lpc17xx_gpio.h>
     38          #include <GPIO_APP.h>
     39          
     40          /*
     41          *********************************************************************************************************
     42          *                                            LOCAL DEFINES 
     43          *********************************************************************************************************
     44          */
     45          
     46          #define  BIT0               0x01
     47          #define  BIT1               0x02
     48          #define  BIT2               0x04
     49          #define  BIT3               0x08
     50          #define  BIT4               0x10
     51          #define  BIT5               0x20
     52          #define  BIT6               0x40
     53          #define  BIT7               0x80
     54          
     55          
     56          #define UARAT_CFG_MAX_PORT  5       // 定义最大串口数量
     57          
     58          /***********************************************
     59          * 描述： 
     60          */
     61          #define  BSP_COM0_REN       DEF_ENABLED
     62          #define  BSP_COM1_REN       DEF_ENABLED
     63          #define  BSP_COM2_REN       DEF_ENABLED
     64          #define  BSP_COM3_REN       DEF_ENABLED
     65          
     66          
     67          //0号串口引脚配置
     68          #define     TXD0	        2
     69          #define     RXD0	        3
     70          //#define     EN_485_0		27
     71          #define     EN_485_0		428
     72          
     73          //1号串口引脚配置
     74          #define		TXD1            15
     75          #define		RXD1            16
     76          #define		EN_485_1        122
     77          
     78          //2号串口引脚配置
     79          #define		TXD2            10
     80          #define		RXD2            11
     81          #define		EN_485_2        128
     82          
     83          //3号串口引脚配置
     84          #define		TXD3			0
     85          #define		RXD3			1
     86          #define		EN_485_3		129
     87          
     88          
     89          
     90          
     91          /*
     92          *********************************************************************************************************
     93          *                                             LOCAL VARIABLES
     94          *********************************************************************************************************
     95          */
     96          
     97          static  CPU_INT32U  MB_Tmr_ReloadCnts;

   \                                 In section .bss, align 4
     98          static  MODBUS_CH  *MB_ChPortMap[UARAT_CFG_MAX_PORT] = {NULL,NULL,NULL,NULL,NULL};
   \                     MB_ChPortMap:
   \   00000000                      DS8 20
     99          
    100          
    101          void    USARTx_RxTxISRHandler   (MODBUS_CH *pch);
    102          
    103          /*$PAGE*/
    104          /*
    105          *********************************************************************************************************
    106          *                                             MB_CommExit()
    107          *
    108          * Description : This function is called to terminate Modbus communications.  All Modbus channels are close.
    109          *
    110          * Argument(s) : none
    111          *
    112          * Return(s)   : none.
    113          *
    114          * Caller(s)   : MB_Exit()
    115          *
    116          * Note(s)     : none.
    117          *********************************************************************************************************
    118          */

   \                                 In section .text, align 2, keep-with-next
    119          void  MB_CommExit (void)
    120          {
   \                     MB_CommExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    121              CPU_INT08U   ch;
    122              MODBUS_CH   *pch;
    123          
    124          
    125              pch = &MB_ChTbl[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000006   0x0005             MOVS     R5,R0
    126              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0004             MOVS     R4,R0
   \                     ??MB_CommExit_0: (+1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xDA09             BGE.N    ??MB_CommExit_1
    127                  MB_CommTxIntDis(pch);
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       MB_CommTxIntDis
    128                  MB_CommRxIntDis(pch);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       MB_CommRxIntDis
    129                  pch++;
   \   0000001E   0xF515 0x658D      ADDS     R5,R5,#+1128
    130              }
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0xE7F2             B.N      ??MB_CommExit_0
    131          }
   \                     ??MB_CommExit_1: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    132          
    133          /*
    134          *********************************************************************************************************
    135          *                                            WriteEN_485()
    136          *
    137          * Description : 485  收发控制.
    138          *
    139          * Argument(s) : pornum：串口号
    140                          ctl：  0，接收；1发送
    141          *
    142          * Return(s)   : none.
    143          *
    144          * Caller(s)   : MB_Exit()
    145          *
    146          * Note(s)     : none.
    147          *********************************************************************************************************
    148          */
    149          

   \                                 In section .text, align 2, keep-with-next
    150          void    WriteEN_485(CPU_INT08U port_nbr,CPU_INT08U ctl)
    151          {
   \                     WriteEN_485: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    152              CPU_INT08U  en485_pins[5] = {EN_485_0,EN_485_1,EN_485_2,EN_485_3};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000000E   0xC90C             LDM      R1!,{R2,R3}
   \   00000010   0xC00C             STM      R0!,{R2,R3}
   \   00000012   0x3908             SUBS     R1,R1,#+8
   \   00000014   0x3808             SUBS     R0,R0,#+8
    153          
    154              if(ctl)		
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD006             BEQ.N    ??WriteEN_485_0
    155          	{
    156          		GPIO_SetOrClearValue(en485_pins[port_nbr],1);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x5C20             LDRB     R0,[R4, R0]
   \   00000024   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000028   0xE005             B.N      ??WriteEN_485_1
    157          	}
    158          	else
    159          	{
    160          		GPIO_SetOrClearValue(en485_pins[port_nbr],0);		
   \                     ??WriteEN_485_0: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x5C20             LDRB     R0,[R4, R0]
   \   00000032   0x.... 0x....      BL       GPIO_SetOrClearValue
    161          	}	
    162          }
   \                     ??WriteEN_485_1: (+1)
   \   00000036   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    163          
    164          /*$PAGE*/
    165          /*
    166          *********************************************************************************************************
    167          *                                           MB_CommPortCfg()
    168          *
    169          * Description : This function initializes the serial port to the desired baud rate and the UART will be
    170          *               configured for N, 8, 1 (No parity, 8 bits, 1 stop).
    171          *
    172          * Argument(s) : pch        is a pointer to the Modbus channel
    173          *               port_nbr   is the desired serial port number.  This argument allows you to assign a
    174          *                          specific serial port to a sepcific Modbus channel.
    175          *               baud       is the desired baud rate for the serial port.
    176          *               parity     is the desired parity and can be either:
    177          *
    178          *                          MODBUS_PARITY_NONE
    179          *                          MODBUS_PARITY_ODD
    180          *                          MODBUS_PARITY_EVEN
    181          *
    182          *               bits       specifies the number of bit and can be either 7 or 8.
    183          *               stops      specifies the number of stop bits and can either be 1 or 2
    184          *
    185          * Return(s)   : none.
    186          *
    187          * Caller(s)   : MB_CfgCh()
    188          *
    189          * Note(s)     : none.
    190          *********************************************************************************************************
    191          */
    192                  

   \                                 In section .text, align 2, keep-with-next
    193          void  MB_CommPortCfg (MODBUS_CH  *pch,
    194                                CPU_INT08U  port_nbr,
    195                                CPU_INT32U  baud,
    196                                CPU_INT08U  bits,
    197                                CPU_INT08U  parity,
    198                                CPU_INT08U  stops)
    199          {
   \                     MB_CommPortCfg: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C12             LDR      R4,[SP, #+72]
   \   00000010   0x9D13             LDR      R5,[SP, #+76]
    200              UART_CFG_Type		    UART_ConfigStruct_Test;
    201              UART_FIFO_CFG_Type 	    FIFOCfg_Test;
    202              UART_INT_Type 		    UARTIntCfg_Test;
    203              LPC_UART_TypeDef*       USARTx;
    204              IRQn_Type               UARTx_IRQn;
    205              LPC_UART_TypeDef*       USARTs[4]   = {
    206                  (LPC_UART_TypeDef *)LPC_UART0,
    207                  (LPC_UART_TypeDef *)LPC_UART1,
    208                  (LPC_UART_TypeDef *)LPC_UART2,
    209                  (LPC_UART_TypeDef *)LPC_UART3
    210              };
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \   00000018   0x2210             MOVS     R2,#+16
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy4
    211              
    212              /***********************************************
    213              * 描述： 
    214              */
    215              switch ( port_nbr ) {
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD005             BEQ.N    ??MB_CommPortCfg_0
   \   00000024   0x2F02             CMP      R7,#+2
   \   00000026   0xD031             BEQ.N    ??MB_CommPortCfg_1
   \   00000028   0xD319             BCC.N    ??MB_CommPortCfg_2
   \   0000002A   0x2F03             CMP      R7,#+3
   \   0000002C   0xD045             BEQ.N    ??MB_CommPortCfg_3
   \   0000002E   0xE05A             B.N      ??MB_CommPortCfg_4
    216              case 0:  
    217                  USARTx      = (LPC_UART_TypeDef *)LPC_UART0;
   \                     ??MB_CommPortCfg_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4000c000
   \   00000034   0x4682             MOV      R10,R0
    218                  UARTx_IRQn  = UART0_IRQn;
   \   00000036   0x2005             MOVS     R0,#+5
   \   00000038   0x4683             MOV      R11,R0
    219                  
    220                  //配置端口为UART和收发控制端口为GPIO
    221                  GPIO_PinselConfig(RXD0,1);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      BL       GPIO_PinselConfig
    222                  GPIO_PinselConfig(TXD0,1);	
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x.... 0x....      BL       GPIO_PinselConfig
    223                  GPIO_PinselConfig(EN_485_0,0);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x20AC             MOVS     R0,#+172
   \   0000004E   0x.... 0x....      BL       GPIO_PinselConfig
    224                  
    225                  /***********************************************
    226                  * 描述： 接收发送使能信号
    227                  */
    228          #if (BSP_COM0_REN == DEF_ENABLED)
    229                  WriteEN_485(port_nbr,0);  // 低电平接收使能 
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       WriteEN_485
    230          #endif
    231                  break;
   \   0000005C   0xE043             B.N      ??MB_CommPortCfg_4
    232                  
    233              case 1:
    234                  USARTx      = (LPC_UART_TypeDef *)LPC_UART1;
   \                     ??MB_CommPortCfg_2: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13_7  ;; 0x40010000
   \   00000062   0x4682             MOV      R10,R0
    235                  UARTx_IRQn  = UART1_IRQn;
   \   00000064   0x2006             MOVS     R0,#+6
   \   00000066   0x4683             MOV      R11,R0
    236                  
    237                  //配置端口为UART和收发控制端口为GPIO
    238                  GPIO_PinselConfig(RXD1,1);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2010             MOVS     R0,#+16
   \   0000006C   0x.... 0x....      BL       GPIO_PinselConfig
    239                  GPIO_PinselConfig(TXD1,1);	
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x200F             MOVS     R0,#+15
   \   00000074   0x.... 0x....      BL       GPIO_PinselConfig
    240                  GPIO_PinselConfig(EN_485_1,0);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x207A             MOVS     R0,#+122
   \   0000007C   0x.... 0x....      BL       GPIO_PinselConfig
    241                  
    242                  /***********************************************
    243                  * 描述： 接收发送使能信号
    244                  */
    245          #if (BSP_COM1_REN == DEF_ENABLED)
    246                  
    247                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       WriteEN_485
    248          #endif
    249                  break;
   \   0000008A   0xE02C             B.N      ??MB_CommPortCfg_4
    250                  
    251              case 2:
    252                  USARTx      = (LPC_UART_TypeDef *)LPC_UART2;        
   \                     ??MB_CommPortCfg_1: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40098000
   \   00000090   0x4682             MOV      R10,R0
    253                  UARTx_IRQn  = UART2_IRQn;
   \   00000092   0x2007             MOVS     R0,#+7
   \   00000094   0x4683             MOV      R11,R0
    254                  
    255                  //配置端口为UART和收发控制端口为GPIO
    256                  GPIO_PinselConfig(RXD2,1);
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x200B             MOVS     R0,#+11
   \   0000009A   0x.... 0x....      BL       GPIO_PinselConfig
    257                  GPIO_PinselConfig(TXD2,1);	
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x200A             MOVS     R0,#+10
   \   000000A2   0x.... 0x....      BL       GPIO_PinselConfig
    258                  GPIO_PinselConfig(EN_485_2,0);	
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x2080             MOVS     R0,#+128
   \   000000AA   0x.... 0x....      BL       GPIO_PinselConfig
    259                  
    260                  /***********************************************
    261                  * 描述： 接收发送使能信号
    262                  */
    263          #if (BSP_COM2_REN == DEF_ENABLED)
    264                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       WriteEN_485
    265          #endif
    266                  break;
   \   000000B8   0xE015             B.N      ??MB_CommPortCfg_4
    267                  
    268              case 3:
    269                  USARTx      = (LPC_UART_TypeDef *)LPC_UART3;
   \                     ??MB_CommPortCfg_3: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable13_9  ;; 0x4009c000
   \   000000BE   0x4682             MOV      R10,R0
    270                  UARTx_IRQn  = UART3_IRQn;
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x4683             MOV      R11,R0
    271                  
    272                  //配置端口为UART和收发控制端口为GPIO
    273                  GPIO_PinselConfig(RXD3,2);
   \   000000C4   0x2102             MOVS     R1,#+2
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       GPIO_PinselConfig
    274                  GPIO_PinselConfig(TXD3,2);	
   \   000000CC   0x2102             MOVS     R1,#+2
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      BL       GPIO_PinselConfig
    275                  GPIO_PinselConfig(EN_485_3,0);
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x2081             MOVS     R0,#+129
   \   000000D8   0x.... 0x....      BL       GPIO_PinselConfig
    276                  
    277                  /***********************************************
    278                  * 描述： 接收发送使能信号
    279                  */
    280          #if (BSP_COM3_REN == DEF_ENABLED)
    281                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x.... 0x....      BL       WriteEN_485
    282          #endif
    283                  break;
    284              default:
    285              }
    286              
    287              
    288              //串口格式配置
    289              UART_ConfigStruct_Test.Baud_rate  = baud;
   \                     ??MB_CommPortCfg_4: (+1)
   \   000000E6   0xF8CD 0x8008      STR      R8,[SP, #+8]
    290              UART_ConfigStruct_Test.Databits   = (UART_DATABIT_Type)bits;
   \   000000EA   0xF88D 0x900D      STRB     R9,[SP, #+13]
    291              UART_ConfigStruct_Test.Parity     = (UART_PARITY_Type)parity;
   \   000000EE   0xF88D 0x400C      STRB     R4,[SP, #+12]
    292              UART_ConfigStruct_Test.Stopbits   = (UART_STOPBIT_Type)stops;  
   \   000000F2   0xF88D 0x500E      STRB     R5,[SP, #+14]
    293              
    294              UART_Init((LPC_UART_TypeDef *)USARTs[port_nbr],(UART_CFG_Type *)&UART_ConfigStruct_Test);
   \   000000F6   0xA902             ADD      R1,SP,#+8
   \   000000F8   0xA804             ADD      R0,SP,#+16
   \   000000FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FC   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000100   0x.... 0x....      BL       UART_Init
    295              UART_TxCmd((LPC_UART_TypeDef *)USARTs[port_nbr],ENABLE);
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0xA804             ADD      R0,SP,#+16
   \   00000108   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010A   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   0000010E   0x.... 0x....      BL       UART_TxCmd
    296              
    297              //收发缓存配置
    298              FIFOCfg_Test.FIFO_DMAMode         = DISABLE;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF88D 0x0002      STRB     R0,[SP, #+2]
    299              FIFOCfg_Test.FIFO_Level           = UART_FIFO_TRGLEV0;     //fifo len 1
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    300              FIFOCfg_Test.FIFO_ResetRxBuf      = DISABLE;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF88D 0x0000      STRB     R0,[SP, #+0]
    301              FIFOCfg_Test.FIFO_ResetTxBuf      = DISABLE;	 
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF88D 0x0001      STRB     R0,[SP, #+1]
    302              
    303              UART_FIFOConfig((LPC_UART_TypeDef *)USARTs[port_nbr], (UART_FIFO_CFG_Type *)&FIFOCfg_Test);
   \   0000012A   0x4669             MOV      R1,SP
   \   0000012C   0xA804             ADD      R0,SP,#+16
   \   0000012E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000130   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000134   0x.... 0x....      BL       UART_FIFOConfig
    304              
    305              //中断类型配置
    306              UARTIntCfg_Test = UART_INTCFG_RBR;	
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    307              UART_IntConfig((LPC_UART_TypeDef *)USARTs[port_nbr], UARTIntCfg_Test,ENABLE);   
   \   0000013E   0x2201             MOVS     R2,#+1
   \   00000140   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000144   0xA804             ADD      R0,SP,#+16
   \   00000146   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000148   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   0000014C   0x.... 0x....      BL       UART_IntConfig
    308              //UARTIntCfg_Test = UART_INTCFG_THRE;	
    309              //UART_IntConfig((LPC_UART_TypeDef *)USARTs[port_nbr], UARTIntCfg_Test,DISABLE);    
    310              
    311              if (pch != (MODBUS_CH *)0) {
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD00C             BEQ.N    ??MB_CommPortCfg_5
    312                  pch->PortNbr            = port_nbr;                                 /* Store configuration in channel             */
   \   00000154   0x7277             STRB     R7,[R6, #+9]
    313                  pch->BaudRate           = baud;
   \   00000156   0xF8C6 0x800C      STR      R8,[R6, #+12]
    314                  pch->Parity             = parity;
   \   0000015A   0x7434             STRB     R4,[R6, #+16]
    315                  pch->Bits               = bits;
   \   0000015C   0xF886 0x9011      STRB     R9,[R6, #+17]
    316                  pch->Stops              = stops;
   \   00000160   0x74B5             STRB     R5,[R6, #+18]
    317                  pch->USARTx             = USARTx;                
   \   00000162   0xF8C6 0xA460      STR      R10,[R6, #+1120]
    318                  MB_ChPortMap[port_nbr]  = pch;
   \   00000166   0x....             LDR.N    R0,??DataTable13_10
   \   00000168   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000016A   0xF840 0x6027      STR      R6,[R0, R7, LSL #+2]
    319              }
    320                  
    321              //配置中断向量
    322              NVIC_SetPriority(UARTx_IRQn, UARTx_IRQn);
   \                     ??MB_CommPortCfg_5: (+1)
   \   0000016E   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   00000172   0x4659             MOV      R1,R11
   \   00000174   0x4658             MOV      R0,R11
   \   00000176   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000178   0x.... 0x....      BL       NVIC_SetPriority
    323              NVIC_EnableIRQ(UARTx_IRQn);
   \   0000017C   0x4658             MOV      R0,R11
   \   0000017E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000180   0x.... 0x....      BL       NVIC_EnableIRQ
    324              return;
   \   00000184   0xB009             ADD      SP,SP,#+36
   \   00000186   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    325          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4000C000         DC32 4000C000H, 40010000H, 40098000H, 4009C000H
   \              0x40010000   
   \              0x40098000   
   \              0x4009C000   
    326          
    327          /*$PAGE*/
    328          /*
    329          *********************************************************************************************************
    330          *                                         MB_CommRxIntDis()
    331          *
    332          * Description : This function disables Rx interrupts.
    333          *
    334          * Argument(s) : pch        is a pointer to the Modbus channel
    335          *
    336          * Return(s)   : none.
    337          *
    338          * Caller(s)   : MB_CommExit()
    339          *
    340          * Note(s)     : none.
    341          *********************************************************************************************************
    342          */

   \                                 In section .text, align 2, keep-with-next
    343          void  MB_CommRxIntDis (MODBUS_CH  *pch)
    344          {
   \                     MB_CommRxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    345              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    346          
    347              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    348              switch (pch->PortNbr) {
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??MB_CommRxIntDis_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD017             BEQ.N    ??MB_CommRxIntDis_1
   \   0000001A   0xD30C             BCC.N    ??MB_CommRxIntDis_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD01E             BEQ.N    ??MB_CommRxIntDis_3
   \   00000020   0xE026             B.N      ??MB_CommRxIntDis_4
    349              case 0:
    350                  /***********************************************
    351                  * 描述： 收发送使能控制信号
    352                  */
    353          #if (BSP_COM0_REN == DEF_ENABLED)
    354                  //GPIO_SetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);        // 高电平发送使能 
    355                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x7A60             LDRB     R0,[R4, #+9]
   \   00000026   0x.... 0x....      BL       WriteEN_485
    356          #endif
    357                  //USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
    358                  UART_IntConfig(LPC_UART0,UART_INTCFG_RBR,DISABLE);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable13_6  ;; 0x4000c000
   \   00000030   0x.... 0x....      BL       UART_IntConfig
    359                  break;
   \   00000034   0xE01C             B.N      ??MB_CommRxIntDis_4
    360                  
    361              case 1:
    362                  /***********************************************
    363                  * 描述： 收发送使能控制信号
    364                  */
    365          #if (BSP_COM1_REN == DEF_ENABLED)
    366                  //GPIO_SetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);        // 高电平发送使能 
    367                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_2: (+1)
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x7A60             LDRB     R0,[R4, #+9]
   \   0000003A   0x.... 0x....      BL       WriteEN_485
    368          
    369          #endif
    370                  //USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
    371                  UART_IntConfig((LPC_UART_TypeDef *) LPC_UART1,UART_INTCFG_RBR,DISABLE);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40010000
   \   00000044   0x.... 0x....      BL       UART_IntConfig
    372                  break;
   \   00000048   0xE012             B.N      ??MB_CommRxIntDis_4
    373                  
    374              case 2:
    375                  /***********************************************
    376                  * 描述： 收发送使能控制信号
    377                  */
    378          #if (BSP_COM2_REN == DEF_ENABLED)
    379                  //GPIO_SetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);        // 高电平发送使能 
    380                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_1: (+1)
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000004E   0x.... 0x....      BL       WriteEN_485
    381          #endif
    382                  //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
    383                  UART_IntConfig(LPC_UART2,UART_INTCFG_RBR,DISABLE);
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40098000
   \   00000058   0x.... 0x....      BL       UART_IntConfig
    384                  break;
   \   0000005C   0xE008             B.N      ??MB_CommRxIntDis_4
    385                  
    386              case 3:
    387                  /***********************************************
    388                  * 描述： 收发送使能控制信号
    389                  */
    390          #if (BSP_COM3_REN == DEF_ENABLED)
    391                  //GPIO_SetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);        // 高电平发送使能 
    392                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_3: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x7A60             LDRB     R0,[R4, #+9]
   \   00000062   0x.... 0x....      BL       WriteEN_485
    393          
    394          #endif
    395                  //USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);
    396                  UART_IntConfig(LPC_UART3,UART_INTCFG_RBR,DISABLE);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x....             LDR.N    R0,??DataTable13_9  ;; 0x4009c000
   \   0000006C   0x.... 0x....      BL       UART_IntConfig
    397                  break;
    398              }
    399              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntDis_4: (+1)
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    400          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    401          
    402          /*$PAGE*/
    403          /*
    404          *********************************************************************************************************
    405          *                                          MB_CommRxIntEn()
    406          *
    407          * Description : This function enables Rx interrupts.
    408          *
    409          * Argument(s) : pch        is a pointer to the Modbus channel
    410          *
    411          * Return(s)   : none.
    412          *
    413          * Caller(s)   : MB_TxByte()
    414          *
    415          * Note(s)     : none.
    416          *********************************************************************************************************
    417          */

   \                                 In section .text, align 2, keep-with-next
    418          void  MB_CommRxIntEn (MODBUS_CH  *pch)
    419          {
   \                     MB_CommRxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    420              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    421          
    422              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    423              switch (pch->PortNbr) {
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??MB_CommRxIntEn_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD017             BEQ.N    ??MB_CommRxIntEn_1
   \   0000001A   0xD30C             BCC.N    ??MB_CommRxIntEn_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD01E             BEQ.N    ??MB_CommRxIntEn_3
   \   00000020   0xE026             B.N      ??MB_CommRxIntEn_4
    424              case 0:
    425          #if (BSP_COM0_REN == DEF_ENABLED)
    426                  //GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
    427                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_0: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x7A60             LDRB     R0,[R4, #+9]
   \   00000026   0x.... 0x....      BL       WriteEN_485
    428          
    429          #endif
    430                  //USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);     
    431                  UART_IntConfig(LPC_UART0,UART_INTCFG_RBR,ENABLE);
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable13_6  ;; 0x4000c000
   \   00000030   0x.... 0x....      BL       UART_IntConfig
    432                  break;
   \   00000034   0xE01C             B.N      ??MB_CommRxIntEn_4
    433                  
    434              case 1:
    435          #if (BSP_COM1_REN == DEF_ENABLED)
    436                  //GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能 
    437                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_2: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7A60             LDRB     R0,[R4, #+9]
   \   0000003A   0x.... 0x....      BL       WriteEN_485
    438          
    439          #endif
    440                  //USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    441                  UART_IntConfig((LPC_UART_TypeDef *) LPC_UART1,UART_INTCFG_RBR,ENABLE);
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40010000
   \   00000044   0x.... 0x....      BL       UART_IntConfig
    442                  break;
   \   00000048   0xE012             B.N      ??MB_CommRxIntEn_4
    443                  
    444              case 2:
    445          #if (BSP_COM2_REN == DEF_ENABLED)
    446                  //GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能 
    447                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_1: (+1)
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000004E   0x.... 0x....      BL       WriteEN_485
    448          
    449          #endif
    450                  //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    451                UART_IntConfig(LPC_UART2,UART_INTCFG_RBR,ENABLE);
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40098000
   \   00000058   0x.... 0x....      BL       UART_IntConfig
    452          
    453                  break;
   \   0000005C   0xE008             B.N      ??MB_CommRxIntEn_4
    454                  
    455              case 3:
    456          #if (BSP_COM3_REN == DEF_ENABLED)
    457                  //GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能 
    458                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_3: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x7A60             LDRB     R0,[R4, #+9]
   \   00000062   0x.... 0x....      BL       WriteEN_485
    459          
    460          #endif
    461                  //USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    462                UART_IntConfig(LPC_UART3,UART_INTCFG_RBR,ENABLE);
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x....             LDR.N    R0,??DataTable13_9  ;; 0x4009c000
   \   0000006C   0x.... 0x....      BL       UART_IntConfig
    463          
    464                  break;
    465              }
    466              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntEn_4: (+1)
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    467          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    468          
    469          /*$PAGE*/
    470          /*
    471          *********************************************************************************************************
    472          *                                       MB_CommRxTxISR_Handler()
    473          *
    474          * Description : This function is the ISR for either a received or transmitted character.
    475          *
    476          * Argument(s) : none.
    477          *
    478          * Return(s)   : none.
    479          *
    480          * Caller(s)   : This is a ISR
    481          *
    482          * Note(s)     : (1) The pseudo-code for this function should be:  
    483          *
    484          *               if (Rx Byte has been received) {
    485          *                  c = get byte from serial port;
    486          *                  Clear receive interrupt;
    487          *                  pch->RxCtr++;                      Increment the number of bytes received
    488          *                  MB_RxByte(pch, c);                 Pass character to Modbus to process
    489          *              }
    490          *
    491          *              if (Byte has been transmitted) {
    492          *                  pch->TxCtr++;                      Increment the number of bytes transmitted
    493          *                  MB_TxByte(pch);                    Send next byte in response
    494          *                  Clear transmit interrupt           Clear Transmit Interrupt flag
    495          *              }
    496          *********************************************************************************************************
    497          */

   \                                 In section .text, align 2, keep-with-next
    498          void  USARTx_RxTxISRHandler (MODBUS_CH *pch)
    499          {
   \                     USARTx_RxTxISRHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    500              volatile            CPU_INT08U    rx_data;
    501              volatile            CPU_INT08U    RecNumCom;
    502              
    503              USART_TypeDef*       USARTx  = pch->USARTx;
   \   00000004   0xF8D4 0x5460      LDR      R5,[R4, #+1120]
    504              
    505             // while ((USARTx->IIR & 0x01) == 0)
    506              {                                                            /* 是否有中断       */
    507                  
    508                  switch (USARTx->IIR & 0x0E){                            /*                */
   \   00000008   0x68A8             LDR      R0,[R5, #+8]
   \   0000000A   0xF010 0x000E      ANDS     R0,R0,#0xE
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD023             BEQ.N    ??USARTx_RxTxISRHandler_0
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD002             BEQ.N    ??USARTx_RxTxISRHandler_1
   \   00000016   0x280C             CMP      R0,#+12
   \   00000018   0xD00C             BEQ.N    ??USARTx_RxTxISRHandler_2
   \   0000001A   0xE027             B.N      ??USARTx_RxTxISRHandler_3
    509                      /***********************************************
    510                      * 描述：接收中断
    511                      */ 
    512                  case 0x04:       //接收中断 
    513                      //while ((USARTx->LSR & 0x01) == 0x01){               /*  判断数据是否接收完毕        */ 
    514                          rx_data = USARTx->RBR;  
   \                     ??USARTx_RxTxISRHandler_1: (+1)
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    515                          pch->RxCtr++;
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x62E0             STR      R0,[R4, #+44]
    516                          MB_RxByte(pch, rx_data);                          /* Pass character to Modbus to process                  */
   \   00000028   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       MB_RxByte
    517                      //}
    518                      break;
   \   00000032   0xE01B             B.N      ??USARTx_RxTxISRHandler_4
    519                  case 0x0C:       //超时中断
    520                      while ((USARTx->LSR & 0x01) == 0x01){               /*  判断数据是否接收完毕        */ 
   \                     ??USARTx_RxTxISRHandler_2: (+1)
   \   00000034   0x7D28             LDRB     R0,[R5, #+20]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   \   00000038   0xD50B             BPL.N    ??USARTx_RxTxISRHandler_5
    521                          rx_data = USARTx->RBR;  
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    522                          pch->RxCtr++;
   \   00000040   0x6AE0             LDR      R0,[R4, #+44]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x62E0             STR      R0,[R4, #+44]
    523                          MB_RxByte(pch, rx_data);                          /* Pass character to Modbus to process                  */
   \   00000046   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       MB_RxByte
   \   00000050   0xE7F0             B.N      ??USARTx_RxTxISRHandler_2
    524                      }
    525                      
    526                      rx_data = USARTx->RBR;                      //清中断,初次有效，mcubug
   \                     ??USARTx_RxTxISRHandler_5: (+1)
   \   00000052   0x7828             LDRB     R0,[R5, #+0]
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    527                      break;
   \   00000058   0xE008             B.N      ??USARTx_RxTxISRHandler_4
    528                      
    529                      /***********************************************
    530                      * 描述：发送中断
    531                      */
    532                  case 0x02:	                                    // 发送中断
    533                      pch->TxCtr++;                           //?计数器加
   \                     ??USARTx_RxTxISRHandler_0: (+1)
   \   0000005A   0xF8D4 0x0138      LDR      R0,[R4, #+312]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xF8C4 0x0138      STR      R0,[R4, #+312]
    534                      MB_TxByte(pch);                         //
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       MB_TxByte
    535                      break;
   \   0000006A   0xE7FF             B.N      ??USARTx_RxTxISRHandler_4
    536                  default:
    537                      break;
    538                  } 
    539              }
    540          }
   \                     ??USARTx_RxTxISRHandler_3: (+1)
   \                     ??USARTx_RxTxISRHandler_4: (+1)
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    541          
    542          /*$PAGE*/
    543          /*
    544          *********************************************************************************************************
    545          *                                UART #0 Rx/Tx Communication handler for Modbus
    546          *********************************************************************************************************
    547          */
    548          
    549          /***********************************************
    550          * 描述： UART0中断服务程序
    551          */

   \                                 In section .text, align 2, keep-with-next
    552          void UART0_IRQHandler (void)
    553          {
   \                     UART0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    554            USARTx_RxTxISRHandler(MB_ChPortMap[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    555          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    556          
    557          /***********************************************
    558          * 描述： UART1中断服务程序
    559          */

   \                                 In section .text, align 2, keep-with-next
    560          void UART1_IRQHandler (void)
    561          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    562            USARTx_RxTxISRHandler(MB_ChPortMap[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    563          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    564          /***********************************************
    565          * 描述： UART2中断服务程序
    566          */

   \                                 In section .text, align 2, keep-with-next
    567          void UART2_IRQHandler (void)
    568          {
   \                     UART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    569            USARTx_RxTxISRHandler(MB_ChPortMap[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    570          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    571          /***********************************************
    572          * 描述： UART3中断服务程序
    573          */

   \                                 In section .text, align 2, keep-with-next
    574          void UART3_IRQHandler (void)
    575          {  
   \                     UART3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    576            USARTx_RxTxISRHandler(MB_ChPortMap[3]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    577          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    578           
    579          
    580          /*$PAGE*/
    581          /*
    582          *********************************************************************************************************
    583          *                                             MB_CommTx1()
    584          *
    585          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    586          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    587          *               is enabled to accept the next Modbus request.
    588          *
    589          * Argument(s) : c     is the byte to send to the serial port
    590          *
    591          * Return(s)   : none.
    592          *
    593          * Caller(s)   : MB_TxByte()
    594          *
    595          * Note(s)     : none.
    596          *********************************************************************************************************
    597          */
    598          

   \                                 In section .text, align 2, keep-with-next
    599          void  MB_CommTx1 (MODBUS_CH  *pch,
    600                            CPU_INT08U  c)
    601          {
   \                     MB_CommTx1: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    602              
    603              UART_SendByte(pch->USARTx,c);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   0000000E   0x.... 0x....      BL       UART_SendByte
    604              return;
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    605              
    606              switch (pch->PortNbr) {
    607              case 0:
    608                  /* Transmit Data */
    609                  //USART1->DR = (c & (u16)0x01FF);
    610                  UART_SendByte(LPC_UART0,c);         
    611                  break;
    612                  
    613              case 1:
    614                  /* Transmit Data */
    615                  //USART2->DR = (c & (u16)0x01FF);
    616                  UART_SendByte((LPC_UART_TypeDef*) LPC_UART1,c);         
    617          
    618                  break;
    619                  
    620              case 2:
    621                  /* Transmit Data */
    622                  //USART3->DR = (c & (u16)0x01FF);
    623                  UART_SendByte(LPC_UART2,c);         
    624          
    625                  break;
    626                  
    627              case 3:
    628                  /* Transmit Data */
    629                  //UART4->DR = (c & (u16)0x01FF);
    630                  UART_SendByte(LPC_UART3,c);         
    631          
    632                  break;
    633              }
    634          }
    635          
    636          /*$PAGE*/
    637          /*
    638          *********************************************************************************************************
    639          *                                         MB_CommTxIntDis()
    640          *
    641          * Description : This function disables Tx interrupts.
    642          *
    643          * Argument(s) : pch        is a pointer to the Modbus channel
    644          *
    645          * Return(s)   : none.
    646          *
    647          * Caller(s)   : MB_CommExit()
    648          *               MB_TxByte()
    649          *
    650          * Note(s)     : none.
    651          *********************************************************************************************************
    652          */
    653          

   \                                 In section .text, align 2, keep-with-next
    654          void  MB_CommTxIntDis (MODBUS_CH  *pch)
    655          {
   \                     MB_CommTxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    656              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    657          
    658              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    659              
    660              UART_IntConfig(pch->USARTx,UART_INTCFG_THRE,DISABLE);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       UART_IntConfig
    661                  
    662              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    663              return;
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    664              
    665              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    666              case 0:
    667          //        USART_ITConfig(USART1, USART_IT_TC, DISABLE);
    668          //        USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
    669                  UART_IntConfig(LPC_UART0,UART_INTCFG_THRE,DISABLE);
    670                
    671                  break;
    672                  
    673              case 1:
    674          //        USART_ITConfig(USART2, USART_IT_TC, DISABLE);
    675          //        USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    676                  UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1,UART_INTCFG_THRE,DISABLE);
    677          
    678                  break;
    679                  
    680              case 2:
    681          //        USART_ITConfig(USART3, USART_IT_TC, DISABLE);
    682          //        USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
    683                  UART_IntConfig(LPC_UART2,UART_INTCFG_THRE,DISABLE);
    684          
    685                  break;
    686                  
    687              case 3:
    688          //        USART_ITConfig(UART4, USART_IT_TC, DISABLE);
    689          //        USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
    690                  UART_IntConfig(LPC_UART3,UART_INTCFG_THRE,DISABLE);
    691          
    692                  break;
    693              }
    694              CPU_CRITICAL_EXIT();
    695          }
    696          
    697          /*$PAGE*/
    698          /*
    699          *********************************************************************************************************
    700          *                                         MB_CommTxIntEn()
    701          *
    702          * Description : This function enables Tx interrupts.
    703          *
    704          * Argument(s) : pch        is a pointer to the Modbus channel
    705          *
    706          * Return(s)   : none.
    707          *
    708          * Caller(s)   : MB_Tx()
    709          *
    710          * Note(s)     : none.
    711          *********************************************************************************************************
    712          */

   \                                 In section .text, align 2, keep-with-next
    713          void  MB_CommTxIntEn (MODBUS_CH  *pch)
    714          {
   \                     MB_CommTxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    715              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    716          
    717              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    718              
    719              UART_IntConfig(pch->USARTx,UART_INTCFG_THRE,ENABLE);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       UART_IntConfig
    720                  
    721              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    722              return;
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    723              
    724              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    725              case 0:
    726          //        USART_ITConfig(USART1, USART_IT_TC, ENABLE);
    727          //        USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
    728                  UART_IntConfig(LPC_UART0,UART_INTCFG_THRE,ENABLE);
    729          
    730                  break;
    731                  
    732              case 1:
    733          //        USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    734          //        USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    735                  UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1,UART_INTCFG_THRE,ENABLE);
    736                  break;
    737                  
    738              case 2:
    739          //        USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    740          //        USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
    741                  UART_IntConfig(LPC_UART2,UART_INTCFG_THRE,ENABLE);
    742                  break;
    743                  
    744              case 3:
    745          //        USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    746          //        USART_ITConfig(UART4, USART_IT_TXE, ENABLE);
    747                  UART_IntConfig(LPC_UART3,UART_INTCFG_THRE,ENABLE);
    748          
    749                  break;
    750              }
    751              CPU_CRITICAL_EXIT();
    752          }
    753          
    754          /*$PAGE*/
    755          /*
    756          *********************************************************************************************************
    757          *                                           MB_RTU_TmrInit()
    758          *
    759          * Description : This function is called to initialize the RTU timeout timer.
    760          *
    761          * Argument(s) : freq          Is the frequency of the modbus RTU timer interrupt.
    762          *
    763          * Return(s)   : none.
    764          *
    765          * Caller(s)   : MB_Init().
    766          *
    767          * Note(s)     : none.
    768          *********************************************************************************************************
    769          */
    770          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    771          void  MB_RTU_TmrInit (void)
    772          {
   \                     MB_RTU_TmrInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    773              TIM_TIMERCFG_Type TIM_ConfigStruct;
    774              TIM_MATCHCFG_Type TIM_MatchConfigStruct;
    775          
    776          //	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCTIM0,ENABLE);
    777          
    778          	// Initialize timer 0, prescale count time of 1000000uS = 1S
    779          	TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x000C      STRB     R0,[SP, #+12]
    780          //	TIM_ConfigStruct.PrescaleValue	= 1000000;
    781          	TIM_ConfigStruct.PrescaleValue	= 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x9004             STR      R0,[SP, #+16]
    782              
    783              TIM_Init(LPC_TIM3, TIM_TIMER_MODE,&TIM_ConfigStruct);
   \   0000000E   0xAA03             ADD      R2,SP,#+12
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000014   0x.... 0x....      BL       TIM_Init
    784          
    785          	// Configure 3 match channels
    786          	// use channel 0, MR0
    787          	TIM_MatchConfigStruct.MatchChannel = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    788          	// Enable interrupt when MR0 matches the value in TC register
    789          	TIM_MatchConfigStruct.IntOnMatch   = TRUE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0001      STRB     R0,[SP, #+1]
    790          	//Enable reset on MR0: TIMER will reset if MR0 matches it
    791          	TIM_MatchConfigStruct.ResetOnMatch = TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x0003      STRB     R0,[SP, #+3]
    792          	//Stop on MR0 if MR0 matches it
    793          	TIM_MatchConfigStruct.StopOnMatch  = FALSE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    794          	//时间到后，端口不操作
    795          	TIM_MatchConfigStruct.ExtMatchOutputType = TIM_EXTMATCH_NOTHING;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF88D 0x0004      STRB     R0,[SP, #+4]
    796          	// Set Match value
    797          	TIM_MatchConfigStruct.MatchValue   = 1000;
   \   00000036   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003A   0x9002             STR      R0,[SP, #+8]
    798          
    799              TIM_ConfigMatch(LPC_TIM3, &TIM_MatchConfigStruct);
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000040   0x.... 0x....      BL       TIM_ConfigMatch
    800          
    801          	// Set configuration for Tim_config and Tim_MatchConfig
    802          	TIM_ResetCounter(LPC_TIM3);
   \   00000044   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000046   0x.... 0x....      BL       TIM_ResetCounter
    803          
    804          	/* preemption = 1, sub-priority = 1 */
    805          	NVIC_SetPriority(TIMER3_IRQn, TIMER3_IRQn+10);
   \   0000004A   0x210E             MOVS     R1,#+14
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x.... 0x....      BL       NVIC_SetPriority
    806          	/* Enable interrupt for timer 0 */
    807          	NVIC_EnableIRQ(TIMER3_IRQn);
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    808          	// To start timer 1
    809          	TIM_Cmd(LPC_TIM3,ENABLE);							
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   0000005C   0x.... 0x....      BL       TIM_Cmd
    810          
    811              MB_RTU_TmrResetAll();                                     /* Reset all the RTU timers, we changed freq. */
   \   00000060   0x.... 0x....      BL       MB_RTU_TmrResetAll
    812          }
   \   00000064   0xB005             ADD      SP,SP,#+20
   \   00000066   0xBD00             POP      {PC}             ;; return
    813          #endif
    814          
    815          /*$PAGE*/
    816          /*
    817          *********************************************************************************************************
    818          *                                           MB_RTU_TmrExit()
    819          *
    820          * Description : This function is called to disable the RTU timeout timer.
    821          *
    822          * Argument(s) : none.
    823          *
    824          * Return(s)   : none.
    825          *
    826          * Caller(s)   : MB_Exit()
    827          *
    828          * Note(s)     : none.
    829          *********************************************************************************************************
    830          */
    831          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    832          void  MB_RTU_TmrExit (void)
    833          {
   \                     MB_RTU_TmrExit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    834              //TIM_Cmd(TIM3,DISABLE);              //禁止计数器 
    835              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, DISABLE);
    836            TIM_DeInit(LPC_TIM3);
   \   00000002   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000004   0x.... 0x....      BL       TIM_DeInit
    837          
    838          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    839          #endif
    840          
    841          /*$PAGE*/
    842          /*
    843          *********************************************************************************************************
    844          *                                       MB_RTU_TmrISR_Handler()
    845          *
    846          * Description : This function handles the case when the RTU timeout timer expires.
    847          *
    848          * Arguments   : none.
    849          *
    850          * Returns     : none.
    851          *
    852          * Caller(s)   : This is a ISR.
    853          *
    854          * Note(s)     : none.
    855          *********************************************************************************************************
    856          */
    857          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    858          

   \                                 In section .text, align 2, keep-with-next
    859          void TIMER3_IRQHandler(void)
    860          {
   \                     TIMER3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    861              MB_RTU_TmrISR_Handler();
   \   00000002   0x.... 0x....      BL       MB_RTU_TmrISR_Handler
    862          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    863          

   \                                 In section .text, align 2, keep-with-next
    864          void  MB_RTU_TmrISR_Handler (void)
    865          {
   \                     MB_RTU_TmrISR_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    866          //    if(TIM_GetITStatus(TIM3, TIM_IT_Update)== SET) {//检测是否发生溢出更新事件
    867          //      TIM_ClearITPendingBit(TIM3 , TIM_FLAG_Update);/* Clear timer #1 interrupt                           */
    868          //      MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
    869          //      MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
    870          //    }
    871           
    872          //   TIM_Cmd(LPC_TIM3,DISABLE);
    873          	TIM_ClearIntPending(LPC_TIM3, TIM_MR0_INT);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000006   0x.... 0x....      BL       TIM_ClearIntPending
    874          	TIM_ResetCounter(LPC_TIM3);
   \   0000000A   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   0000000C   0x.... 0x....      BL       TIM_ResetCounter
    875              
    876              MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
   \   00000010   0x....             LDR.N    R0,??DataTable13_12
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable13_12
   \   00000018   0x6008             STR      R0,[R1, #+0]
    877              MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
   \   0000001A   0x.... 0x....      BL       MB_RTU_TmrUpdate
    878          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    879          
    880          #endif
    881                                

   \                                 In section .text, align 2, keep-with-next
    882          void    UARTPutString(MODBUS_CH  *pch, const char *printfbuf)              
    883          {
   \                     UARTPutString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    884              int nbr_bytes   = strlen(printfbuf);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0006             MOVS     R6,R0
    885              
    886              if ( (nbr_bytes > 0) && (nbr_bytes < MB_DATA_NBR_REGS * 2 ) ) {  
   \   0000000E   0x2E01             CMP      R6,#+1
   \   00000010   0xDB08             BLT.N    ??UARTPutString_0
   \   00000012   0x2EFA             CMP      R6,#+250
   \   00000014   0xDA06             BGE.N    ??UARTPutString_0
    887                  NMB_Tx((MODBUS_CH   *)pch,
    888                         (CPU_INT08U  *)printfbuf,
    889                         (CPU_INT16U   )nbr_bytes);
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x0002             MOVS     R2,R0
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       NMB_Tx
    890              }
    891          }
   \                     ??UARTPutString_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    892          
    893          //////////////////////////////////////////////////////////////
    894          

   \                                 In section .text, align 2, keep-with-next
    895          void WriteEN_485_3(uint8 temp)
    896          {	
   \                     WriteEN_485_3: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    897          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteEN_485_3_0
    898          	{
    899          		GPIO_SetOrClearValue(EN_485_3,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2081             MOVS     R0,#+129
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteEN_485_3_1
    900          	}
    901          	else
    902          	{
    903          		GPIO_SetOrClearValue(EN_485_3,0);		
   \                     ??WriteEN_485_3_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2081             MOVS     R0,#+129
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    904          	}	
    905          }
   \                     ??WriteEN_485_3_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     MB_ChPortMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     MB_RTU_TmrCtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0xAC 0x7A          DC8 172, 122, 128, 129, 0, 0, 0, 0
   \              0x80 0x81    
   \              0x00 0x00    
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MB_CommExit
        16   -> MB_CommRxIntDis
        16   -> MB_CommTxIntDis
      72   MB_CommPortCfg
        72   -> GPIO_PinselConfig
        72   -> NVIC_EnableIRQ
        72   -> NVIC_SetPriority
        72   -> UART_FIFOConfig
        72   -> UART_Init
        72   -> UART_IntConfig
        72   -> UART_TxCmd
        72   -> WriteEN_485
        72   -> __aeabi_memcpy4
      16   MB_CommRxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
        16   -> WriteEN_485
      16   MB_CommRxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
        16   -> WriteEN_485
      16   MB_CommTx1
        16   -> UART_SendByte
      16   MB_CommTxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
      16   MB_CommTxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
       8   MB_RTU_TmrExit
         8   -> TIM_DeInit
       8   MB_RTU_TmrISR_Handler
         8   -> MB_RTU_TmrUpdate
         8   -> TIM_ClearIntPending
         8   -> TIM_ResetCounter
      24   MB_RTU_TmrInit
        24   -> MB_RTU_TmrResetAll
        24   -> NVIC_EnableIRQ
        24   -> NVIC_SetPriority
        24   -> TIM_Cmd
        24   -> TIM_ConfigMatch
        24   -> TIM_Init
        24   -> TIM_ResetCounter
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       8   TIMER3_IRQHandler
         8   -> MB_RTU_TmrISR_Handler
       8   UART0_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART1_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART2_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART3_IRQHandler
         8   -> USARTx_RxTxISRHandler
      16   UARTPutString
        16   -> NMB_Tx
        16   -> strlen
      16   USARTx_RxTxISRHandler
        16   -> MB_RxByte
        16   -> MB_TxByte
      24   WriteEN_485
        24   -> GPIO_SetOrClearValue
       8   WriteEN_485_3
         8   -> GPIO_SetOrClearValue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  ?_0
      16  ?_1
      20  MB_ChPortMap
      40  MB_CommExit
     394  MB_CommPortCfg
     124  MB_CommRxIntDis
     124  MB_CommRxIntEn
      20  MB_CommTx1
      40  MB_CommTxIntDis
      40  MB_CommTxIntEn
      10  MB_RTU_TmrExit
      32  MB_RTU_TmrISR_Handler
     104  MB_RTU_TmrInit
      22  NVIC_EnableIRQ
      42  NVIC_SetPriority
       8  TIMER3_IRQHandler
      12  UART0_IRQHandler
      12  UART1_IRQHandler
      12  UART2_IRQHandler
      12  UART3_IRQHandler
      38  UARTPutString
     110  USARTx_RxTxISRHandler
      56  WriteEN_485
      30  WriteEN_485_3

 
    20 bytes in section .bss
    24 bytes in section .rodata
 1 334 bytes in section .text
 
 1 334 bytes of CODE  memory
    24 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: 7
