###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/Aug/2017  10:56:48
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C
#    Command line =  
#        "F:\iar\NC136B-310
#        统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C" -lCN
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -I "F:\iar\NC136B-310 统计模块\Application\Library\csnr_package_deal\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MB_BSP.lst
#    Object file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MB_BSP.o
#
###############################################################################

F:\iar\NC136B-310 统计模块\Software\uC-MB\Ports\NXP\LPC1768\IAR\MB_BSP.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL               
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                            uC/Modbus
     19          *
     20          *                                      MODBUS BOARD SUPPORT PACKAGE
     21          *                                         Philips LPC2000 (ARM7)
     22          *
     23          * Filename    : mb_bsp.c
     24          * Version     : V2.12
     25          * Programmers : JJL
     26          *********************************************************************************************************
     27          */
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          #include <global.h>
     35          #include <includes.h>

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable13  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     NVIC_SetPriority: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD509             BPL.N    ??NVIC_SetPriority_0
   \   00000008   0x00CA             LSLS     R2,R1,#+3
   \   0000000A   0x.... 0x....      LDR.W    R3,??DataTable13_1  ;; 0xe000ed18
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0xF010 0x040F      ANDS     R4,R0,#0xF
   \   00000014   0x18E3             ADDS     R3,R4,R3
   \   00000016   0xF803 0x2C04      STRB     R2,[R3, #-4]
   \   0000001A   0xE004             B.N      ??NVIC_SetPriority_1
   \                     ??NVIC_SetPriority_0: (+1)
   \   0000001C   0x00CA             LSLS     R2,R1,#+3
   \   0000001E   0x.... 0x....      LDR.W    R3,??DataTable13_2  ;; 0xe000e400
   \   00000022   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000024   0x54C2             STRB     R2,[R0, R3]
   \                     ??NVIC_SetPriority_1: (+1)
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
     36          #include <lpc17xx_uart.h>
     37          #include <lpc17xx_gpio.h>
     38          #include <GPIO_APP.h>
     39          
     40          /*
     41          *********************************************************************************************************
     42          *                                            LOCAL DEFINES 
     43          *********************************************************************************************************
     44          */
     45          
     46          #define  BIT0               0x01
     47          #define  BIT1               0x02
     48          #define  BIT2               0x04
     49          #define  BIT3               0x08
     50          #define  BIT4               0x10
     51          #define  BIT5               0x20
     52          #define  BIT6               0x40
     53          #define  BIT7               0x80
     54          
     55          
     56          #define UARAT_CFG_MAX_PORT  5       // 定义最大串口数量
     57          
     58          /***********************************************
     59          * 描述： 
     60          */
     61          #define  BSP_COM0_REN       DEF_ENABLED
     62          #define  BSP_COM1_REN       DEF_ENABLED
     63          #define  BSP_COM2_REN       DEF_ENABLED
     64          #define  BSP_COM3_REN       DEF_ENABLED
     65          
     66          
     67          //0号串口引脚配置
     68          #define     TXD0	        2
     69          #define     RXD0	        3
     70          #define     EN_485_0		27
     71          
     72          //1号串口引脚配置
     73          #define		TXD1            15
     74          #define		RXD1            16
     75          #define		EN_485_1        122
     76          
     77          //2号串口引脚配置
     78          #define		TXD2            10
     79          #define		RXD2            11
     80          #define		EN_485_2        128
     81          
     82          //3号串口引脚配置
     83          #define		TXD3			0
     84          #define		RXD3			1
     85          #define		EN_485_3		129
     86          
     87          
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                             LOCAL VARIABLES
     93          *********************************************************************************************************
     94          */
     95          
     96          static  CPU_INT32U  MB_Tmr_ReloadCnts;

   \                                 In section .bss, align 4
     97          static  MODBUS_CH  *MB_ChPortMap[UARAT_CFG_MAX_PORT] = {NULL,NULL,NULL,NULL,NULL};
   \                     MB_ChPortMap:
   \   00000000                      DS8 20
     98          
     99          
    100          void    USARTx_RxTxISRHandler   (MODBUS_CH *pch);
    101          
    102          /*$PAGE*/
    103          /*
    104          *********************************************************************************************************
    105          *                                             MB_CommExit()
    106          *
    107          * Description : This function is called to terminate Modbus communications.  All Modbus channels are close.
    108          *
    109          * Argument(s) : none
    110          *
    111          * Return(s)   : none.
    112          *
    113          * Caller(s)   : MB_Exit()
    114          *
    115          * Note(s)     : none.
    116          *********************************************************************************************************
    117          */

   \                                 In section .text, align 2, keep-with-next
    118          void  MB_CommExit (void)
    119          {
   \                     MB_CommExit: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    120              CPU_INT08U   ch;
    121              MODBUS_CH   *pch;
    122          
    123          
    124              pch = &MB_ChTbl[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable13_3
   \   00000006   0x0005             MOVS     R5,R0
    125              for (ch = 0; ch < MODBUS_CFG_MAX_CH; ch++) {
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x0004             MOVS     R4,R0
   \                     ??MB_CommExit_0: (+1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xDA09             BGE.N    ??MB_CommExit_1
    126                  MB_CommTxIntDis(pch);
   \   00000012   0x0028             MOVS     R0,R5
   \   00000014   0x.... 0x....      BL       MB_CommTxIntDis
    127                  MB_CommRxIntDis(pch);
   \   00000018   0x0028             MOVS     R0,R5
   \   0000001A   0x.... 0x....      BL       MB_CommRxIntDis
    128                  pch++;
   \   0000001E   0xF515 0x658D      ADDS     R5,R5,#+1128
    129              }
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0xE7F2             B.N      ??MB_CommExit_0
    130          }
   \                     ??MB_CommExit_1: (+1)
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                            WriteEN_485()
    135          *
    136          * Description : 485  收发控制.
    137          *
    138          * Argument(s) : pornum：串口号
    139                          ctl：  0，接收；1发送
    140          *
    141          * Return(s)   : none.
    142          *
    143          * Caller(s)   : MB_Exit()
    144          *
    145          * Note(s)     : none.
    146          *********************************************************************************************************
    147          */
    148          

   \                                 In section .text, align 2, keep-with-next
    149          void    WriteEN_485(CPU_INT08U port_nbr,CPU_INT08U ctl)
    150          {
   \                     WriteEN_485: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    151              CPU_INT08U  en485_pins[5] = {EN_485_0,EN_485_1,EN_485_2,EN_485_3};
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable13_4
   \   0000000E   0xC90C             LDM      R1!,{R2,R3}
   \   00000010   0xC00C             STM      R0!,{R2,R3}
   \   00000012   0x3908             SUBS     R1,R1,#+8
   \   00000014   0x3808             SUBS     R0,R0,#+8
    152          
    153              if(ctl)		
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD006             BEQ.N    ??WriteEN_485_0
    154          	{
    155          		GPIO_SetOrClearValue(en485_pins[port_nbr],1);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x5C20             LDRB     R0,[R4, R0]
   \   00000024   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000028   0xE005             B.N      ??WriteEN_485_1
    156          	}
    157          	else
    158          	{
    159          		GPIO_SetOrClearValue(en485_pins[port_nbr],0);		
   \                     ??WriteEN_485_0: (+1)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x4668             MOV      R0,SP
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x5C20             LDRB     R0,[R4, R0]
   \   00000032   0x.... 0x....      BL       GPIO_SetOrClearValue
    160          	}	
    161          }
   \                     ??WriteEN_485_1: (+1)
   \   00000036   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    162          
    163          /*$PAGE*/
    164          /*
    165          *********************************************************************************************************
    166          *                                           MB_CommPortCfg()
    167          *
    168          * Description : This function initializes the serial port to the desired baud rate and the UART will be
    169          *               configured for N, 8, 1 (No parity, 8 bits, 1 stop).
    170          *
    171          * Argument(s) : pch        is a pointer to the Modbus channel
    172          *               port_nbr   is the desired serial port number.  This argument allows you to assign a
    173          *                          specific serial port to a sepcific Modbus channel.
    174          *               baud       is the desired baud rate for the serial port.
    175          *               parity     is the desired parity and can be either:
    176          *
    177          *                          MODBUS_PARITY_NONE
    178          *                          MODBUS_PARITY_ODD
    179          *                          MODBUS_PARITY_EVEN
    180          *
    181          *               bits       specifies the number of bit and can be either 7 or 8.
    182          *               stops      specifies the number of stop bits and can either be 1 or 2
    183          *
    184          * Return(s)   : none.
    185          *
    186          * Caller(s)   : MB_CfgCh()
    187          *
    188          * Note(s)     : none.
    189          *********************************************************************************************************
    190          */
    191                  

   \                                 In section .text, align 2, keep-with-next
    192          void  MB_CommPortCfg (MODBUS_CH  *pch,
    193                                CPU_INT08U  port_nbr,
    194                                CPU_INT32U  baud,
    195                                CPU_INT08U  bits,
    196                                CPU_INT08U  parity,
    197                                CPU_INT08U  stops)
    198          {
   \                     MB_CommPortCfg: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x000F             MOVS     R7,R1
   \   0000000A   0x4690             MOV      R8,R2
   \   0000000C   0x4699             MOV      R9,R3
   \   0000000E   0x9C12             LDR      R4,[SP, #+72]
   \   00000010   0x9D13             LDR      R5,[SP, #+76]
    199              UART_CFG_Type		    UART_ConfigStruct_Test;
    200              UART_FIFO_CFG_Type 	    FIFOCfg_Test;
    201              UART_INT_Type 		    UARTIntCfg_Test;
    202              LPC_UART_TypeDef*       USARTx;
    203              IRQn_Type               UARTx_IRQn;
    204              LPC_UART_TypeDef*       USARTs[4]   = {
    205                  (LPC_UART_TypeDef *)LPC_UART0,
    206                  (LPC_UART_TypeDef *)LPC_UART1,
    207                  (LPC_UART_TypeDef *)LPC_UART2,
    208                  (LPC_UART_TypeDef *)LPC_UART3
    209              };
   \   00000012   0xA804             ADD      R0,SP,#+16
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable13_5
   \   00000018   0x2210             MOVS     R2,#+16
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy4
    210              
    211              /***********************************************
    212              * 描述： 
    213              */
    214              switch ( port_nbr ) {
   \   0000001E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD005             BEQ.N    ??MB_CommPortCfg_0
   \   00000024   0x2F02             CMP      R7,#+2
   \   00000026   0xD031             BEQ.N    ??MB_CommPortCfg_1
   \   00000028   0xD319             BCC.N    ??MB_CommPortCfg_2
   \   0000002A   0x2F03             CMP      R7,#+3
   \   0000002C   0xD045             BEQ.N    ??MB_CommPortCfg_3
   \   0000002E   0xE05A             B.N      ??MB_CommPortCfg_4
    215              case 0:  
    216                  USARTx      = (LPC_UART_TypeDef *)LPC_UART0;
   \                     ??MB_CommPortCfg_0: (+1)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable13_6  ;; 0x4000c000
   \   00000034   0x4682             MOV      R10,R0
    217                  UARTx_IRQn  = UART0_IRQn;
   \   00000036   0x2005             MOVS     R0,#+5
   \   00000038   0x4683             MOV      R11,R0
    218                  
    219                  //配置端口为UART和收发控制端口为GPIO
    220                  GPIO_PinselConfig(RXD0,1);
   \   0000003A   0x2101             MOVS     R1,#+1
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      BL       GPIO_PinselConfig
    221                  GPIO_PinselConfig(TXD0,1);	
   \   00000042   0x2101             MOVS     R1,#+1
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x.... 0x....      BL       GPIO_PinselConfig
    222                  GPIO_PinselConfig(EN_485_0,0);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x201B             MOVS     R0,#+27
   \   0000004E   0x.... 0x....      BL       GPIO_PinselConfig
    223                  
    224                  /***********************************************
    225                  * 描述： 接收发送使能信号
    226                  */
    227          #if (BSP_COM0_REN == DEF_ENABLED)
    228                  WriteEN_485(port_nbr,0);  // 低电平接收使能 
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x0038             MOVS     R0,R7
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       WriteEN_485
    229          #endif
    230                  break;
   \   0000005C   0xE043             B.N      ??MB_CommPortCfg_4
    231                  
    232              case 1:
    233                  USARTx      = (LPC_UART_TypeDef *)LPC_UART1;
   \                     ??MB_CommPortCfg_2: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable13_7  ;; 0x40010000
   \   00000062   0x4682             MOV      R10,R0
    234                  UARTx_IRQn  = UART1_IRQn;
   \   00000064   0x2006             MOVS     R0,#+6
   \   00000066   0x4683             MOV      R11,R0
    235                  
    236                  //配置端口为UART和收发控制端口为GPIO
    237                  GPIO_PinselConfig(RXD1,1);
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0x2010             MOVS     R0,#+16
   \   0000006C   0x.... 0x....      BL       GPIO_PinselConfig
    238                  GPIO_PinselConfig(TXD1,1);	
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x200F             MOVS     R0,#+15
   \   00000074   0x.... 0x....      BL       GPIO_PinselConfig
    239                  GPIO_PinselConfig(EN_485_1,0);
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x207A             MOVS     R0,#+122
   \   0000007C   0x.... 0x....      BL       GPIO_PinselConfig
    240                  
    241                  /***********************************************
    242                  * 描述： 接收发送使能信号
    243                  */
    244          #if (BSP_COM1_REN == DEF_ENABLED)
    245                  
    246                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000086   0x.... 0x....      BL       WriteEN_485
    247          #endif
    248                  break;
   \   0000008A   0xE02C             B.N      ??MB_CommPortCfg_4
    249                  
    250              case 2:
    251                  USARTx      = (LPC_UART_TypeDef *)LPC_UART2;        
   \                     ??MB_CommPortCfg_1: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable13_8  ;; 0x40098000
   \   00000090   0x4682             MOV      R10,R0
    252                  UARTx_IRQn  = UART2_IRQn;
   \   00000092   0x2007             MOVS     R0,#+7
   \   00000094   0x4683             MOV      R11,R0
    253                  
    254                  //配置端口为UART和收发控制端口为GPIO
    255                  GPIO_PinselConfig(RXD2,1);
   \   00000096   0x2101             MOVS     R1,#+1
   \   00000098   0x200B             MOVS     R0,#+11
   \   0000009A   0x.... 0x....      BL       GPIO_PinselConfig
    256                  GPIO_PinselConfig(TXD2,1);	
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x200A             MOVS     R0,#+10
   \   000000A2   0x.... 0x....      BL       GPIO_PinselConfig
    257                  GPIO_PinselConfig(EN_485_2,0);	
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x2080             MOVS     R0,#+128
   \   000000AA   0x.... 0x....      BL       GPIO_PinselConfig
    258                  
    259                  /***********************************************
    260                  * 描述： 接收发送使能信号
    261                  */
    262          #if (BSP_COM2_REN == DEF_ENABLED)
    263                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B4   0x.... 0x....      BL       WriteEN_485
    264          #endif
    265                  break;
   \   000000B8   0xE015             B.N      ??MB_CommPortCfg_4
    266                  
    267              case 3:
    268                  USARTx      = (LPC_UART_TypeDef *)LPC_UART3;
   \                     ??MB_CommPortCfg_3: (+1)
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable13_9  ;; 0x4009c000
   \   000000BE   0x4682             MOV      R10,R0
    269                  UARTx_IRQn  = UART3_IRQn;
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x4683             MOV      R11,R0
    270                  
    271                  //配置端口为UART和收发控制端口为GPIO
    272                  GPIO_PinselConfig(RXD3,2);
   \   000000C4   0x2102             MOVS     R1,#+2
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0x.... 0x....      BL       GPIO_PinselConfig
    273                  GPIO_PinselConfig(TXD3,2);	
   \   000000CC   0x2102             MOVS     R1,#+2
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x.... 0x....      BL       GPIO_PinselConfig
    274                  GPIO_PinselConfig(EN_485_3,0);
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x2081             MOVS     R0,#+129
   \   000000D8   0x.... 0x....      BL       GPIO_PinselConfig
    275                  
    276                  /***********************************************
    277                  * 描述： 接收发送使能信号
    278                  */
    279          #if (BSP_COM3_REN == DEF_ENABLED)
    280                  WriteEN_485(port_nbr,0);                                   // 低电平接收使能 
   \   000000DC   0x2100             MOVS     R1,#+0
   \   000000DE   0x0038             MOVS     R0,R7
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x.... 0x....      BL       WriteEN_485
    281          #endif
    282                  break;
    283              default:
    284              }
    285              
    286              
    287              //串口格式配置
    288              UART_ConfigStruct_Test.Baud_rate  = baud;
   \                     ??MB_CommPortCfg_4: (+1)
   \   000000E6   0xF8CD 0x8008      STR      R8,[SP, #+8]
    289              UART_ConfigStruct_Test.Databits   = (UART_DATABIT_Type)bits;
   \   000000EA   0xF88D 0x900D      STRB     R9,[SP, #+13]
    290              UART_ConfigStruct_Test.Parity     = (UART_PARITY_Type)parity;
   \   000000EE   0xF88D 0x400C      STRB     R4,[SP, #+12]
    291              UART_ConfigStruct_Test.Stopbits   = (UART_STOPBIT_Type)stops;  
   \   000000F2   0xF88D 0x500E      STRB     R5,[SP, #+14]
    292              
    293              UART_Init((LPC_UART_TypeDef *)USARTs[port_nbr],(UART_CFG_Type *)&UART_ConfigStruct_Test);
   \   000000F6   0xA902             ADD      R1,SP,#+8
   \   000000F8   0xA804             ADD      R0,SP,#+16
   \   000000FA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000FC   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000100   0x.... 0x....      BL       UART_Init
    294              UART_TxCmd((LPC_UART_TypeDef *)USARTs[port_nbr],ENABLE);
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0xA804             ADD      R0,SP,#+16
   \   00000108   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010A   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   0000010E   0x.... 0x....      BL       UART_TxCmd
    295              
    296              //收发缓存配置
    297              FIFOCfg_Test.FIFO_DMAMode         = DISABLE;
   \   00000112   0x2000             MOVS     R0,#+0
   \   00000114   0xF88D 0x0002      STRB     R0,[SP, #+2]
    298              FIFOCfg_Test.FIFO_Level           = UART_FIFO_TRGLEV0;     //fifo len 1
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    299              FIFOCfg_Test.FIFO_ResetRxBuf      = DISABLE;
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xF88D 0x0000      STRB     R0,[SP, #+0]
    300              FIFOCfg_Test.FIFO_ResetTxBuf      = DISABLE;	 
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xF88D 0x0001      STRB     R0,[SP, #+1]
    301              
    302              UART_FIFOConfig((LPC_UART_TypeDef *)USARTs[port_nbr], (UART_FIFO_CFG_Type *)&FIFOCfg_Test);
   \   0000012A   0x4669             MOV      R1,SP
   \   0000012C   0xA804             ADD      R0,SP,#+16
   \   0000012E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000130   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   00000134   0x.... 0x....      BL       UART_FIFOConfig
    303              
    304              //中断类型配置
    305              UARTIntCfg_Test = UART_INTCFG_RBR;	
   \   00000138   0x2000             MOVS     R0,#+0
   \   0000013A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    306              UART_IntConfig((LPC_UART_TypeDef *)USARTs[port_nbr], UARTIntCfg_Test,ENABLE);   
   \   0000013E   0x2201             MOVS     R2,#+1
   \   00000140   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   00000144   0xA804             ADD      R0,SP,#+16
   \   00000146   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000148   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   0000014C   0x.... 0x....      BL       UART_IntConfig
    307              //UARTIntCfg_Test = UART_INTCFG_THRE;	
    308              //UART_IntConfig((LPC_UART_TypeDef *)USARTs[port_nbr], UARTIntCfg_Test,DISABLE);    
    309              
    310              if (pch != (MODBUS_CH *)0) {
   \   00000150   0x2E00             CMP      R6,#+0
   \   00000152   0xD00C             BEQ.N    ??MB_CommPortCfg_5
    311                  pch->PortNbr            = port_nbr;                                 /* Store configuration in channel             */
   \   00000154   0x7277             STRB     R7,[R6, #+9]
    312                  pch->BaudRate           = baud;
   \   00000156   0xF8C6 0x800C      STR      R8,[R6, #+12]
    313                  pch->Parity             = parity;
   \   0000015A   0x7434             STRB     R4,[R6, #+16]
    314                  pch->Bits               = bits;
   \   0000015C   0xF886 0x9011      STRB     R9,[R6, #+17]
    315                  pch->Stops              = stops;
   \   00000160   0x74B5             STRB     R5,[R6, #+18]
    316                  pch->USARTx             = USARTx;                
   \   00000162   0xF8C6 0xA460      STR      R10,[R6, #+1120]
    317                  MB_ChPortMap[port_nbr]  = pch;
   \   00000166   0x....             LDR.N    R0,??DataTable13_10
   \   00000168   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000016A   0xF840 0x6027      STR      R6,[R0, R7, LSL #+2]
    318              }
    319                  
    320              //配置中断向量
    321              NVIC_SetPriority(UARTx_IRQn, UARTx_IRQn);
   \                     ??MB_CommPortCfg_5: (+1)
   \   0000016E   0xFA4F 0xFB8B      SXTB     R11,R11          ;; SignExt  R11,R11,#+24,#+24
   \   00000172   0x4659             MOV      R1,R11
   \   00000174   0x4658             MOV      R0,R11
   \   00000176   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000178   0x.... 0x....      BL       NVIC_SetPriority
    322              NVIC_EnableIRQ(UARTx_IRQn);
   \   0000017C   0x4658             MOV      R0,R11
   \   0000017E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000180   0x.... 0x....      BL       NVIC_EnableIRQ
    323              return;
   \   00000184   0xB009             ADD      SP,SP,#+36
   \   00000186   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    324          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x4000C000         DC32 4000C000H, 40010000H, 40098000H, 4009C000H
   \              0x40010000   
   \              0x40098000   
   \              0x4009C000   
    325          
    326          /*$PAGE*/
    327          /*
    328          *********************************************************************************************************
    329          *                                         MB_CommRxIntDis()
    330          *
    331          * Description : This function disables Rx interrupts.
    332          *
    333          * Argument(s) : pch        is a pointer to the Modbus channel
    334          *
    335          * Return(s)   : none.
    336          *
    337          * Caller(s)   : MB_CommExit()
    338          *
    339          * Note(s)     : none.
    340          *********************************************************************************************************
    341          */

   \                                 In section .text, align 2, keep-with-next
    342          void  MB_CommRxIntDis (MODBUS_CH  *pch)
    343          {
   \                     MB_CommRxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    344              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    345          
    346              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    347              switch (pch->PortNbr) {
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??MB_CommRxIntDis_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD017             BEQ.N    ??MB_CommRxIntDis_1
   \   0000001A   0xD30C             BCC.N    ??MB_CommRxIntDis_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD01E             BEQ.N    ??MB_CommRxIntDis_3
   \   00000020   0xE026             B.N      ??MB_CommRxIntDis_4
    348              case 0:
    349                  /***********************************************
    350                  * 描述： 收发送使能控制信号
    351                  */
    352          #if (BSP_COM0_REN == DEF_ENABLED)
    353                  //GPIO_SetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);        // 高电平发送使能 
    354                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_0: (+1)
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0x7A60             LDRB     R0,[R4, #+9]
   \   00000026   0x.... 0x....      BL       WriteEN_485
    355          #endif
    356                  //USART_ITConfig(USART1, USART_IT_RXNE, DISABLE);
    357                  UART_IntConfig(LPC_UART0,UART_INTCFG_RBR,DISABLE);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable13_6  ;; 0x4000c000
   \   00000030   0x.... 0x....      BL       UART_IntConfig
    358                  break;
   \   00000034   0xE01C             B.N      ??MB_CommRxIntDis_4
    359                  
    360              case 1:
    361                  /***********************************************
    362                  * 描述： 收发送使能控制信号
    363                  */
    364          #if (BSP_COM1_REN == DEF_ENABLED)
    365                  //GPIO_SetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);        // 高电平发送使能 
    366                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_2: (+1)
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x7A60             LDRB     R0,[R4, #+9]
   \   0000003A   0x.... 0x....      BL       WriteEN_485
    367          
    368          #endif
    369                  //USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
    370                  UART_IntConfig((LPC_UART_TypeDef *) LPC_UART1,UART_INTCFG_RBR,DISABLE);
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40010000
   \   00000044   0x.... 0x....      BL       UART_IntConfig
    371                  break;
   \   00000048   0xE012             B.N      ??MB_CommRxIntDis_4
    372                  
    373              case 2:
    374                  /***********************************************
    375                  * 描述： 收发送使能控制信号
    376                  */
    377          #if (BSP_COM2_REN == DEF_ENABLED)
    378                  //GPIO_SetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);        // 高电平发送使能 
    379                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_1: (+1)
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000004E   0x.... 0x....      BL       WriteEN_485
    380          #endif
    381                  //USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
    382                  UART_IntConfig(LPC_UART2,UART_INTCFG_RBR,DISABLE);
   \   00000052   0x2200             MOVS     R2,#+0
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40098000
   \   00000058   0x.... 0x....      BL       UART_IntConfig
    383                  break;
   \   0000005C   0xE008             B.N      ??MB_CommRxIntDis_4
    384                  
    385              case 3:
    386                  /***********************************************
    387                  * 描述： 收发送使能控制信号
    388                  */
    389          #if (BSP_COM3_REN == DEF_ENABLED)
    390                  //GPIO_SetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);        // 高电平发送使能 
    391                  WriteEN_485(pch->PortNbr,1);
   \                     ??MB_CommRxIntDis_3: (+1)
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0x7A60             LDRB     R0,[R4, #+9]
   \   00000062   0x.... 0x....      BL       WriteEN_485
    392          
    393          #endif
    394                  //USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);
    395                  UART_IntConfig(LPC_UART3,UART_INTCFG_RBR,DISABLE);
   \   00000066   0x2200             MOVS     R2,#+0
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x....             LDR.N    R0,??DataTable13_9  ;; 0x4009c000
   \   0000006C   0x.... 0x....      BL       UART_IntConfig
    396                  break;
    397              }
    398              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntDis_4: (+1)
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    399          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    400          
    401          /*$PAGE*/
    402          /*
    403          *********************************************************************************************************
    404          *                                          MB_CommRxIntEn()
    405          *
    406          * Description : This function enables Rx interrupts.
    407          *
    408          * Argument(s) : pch        is a pointer to the Modbus channel
    409          *
    410          * Return(s)   : none.
    411          *
    412          * Caller(s)   : MB_TxByte()
    413          *
    414          * Note(s)     : none.
    415          *********************************************************************************************************
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          void  MB_CommRxIntEn (MODBUS_CH  *pch)
    418          {
   \                     MB_CommRxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    419              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    420          
    421              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    422              switch (pch->PortNbr) {
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??MB_CommRxIntEn_0
   \   00000016   0x2802             CMP      R0,#+2
   \   00000018   0xD017             BEQ.N    ??MB_CommRxIntEn_1
   \   0000001A   0xD30C             BCC.N    ??MB_CommRxIntEn_2
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD01E             BEQ.N    ??MB_CommRxIntEn_3
   \   00000020   0xE026             B.N      ??MB_CommRxIntEn_4
    423              case 0:
    424          #if (BSP_COM0_REN == DEF_ENABLED)
    425                  //GPIO_ResetBits(MBREN1_GPIO_PORT, MBREN1_GPIO_PIN);  // 低电平接收使能 
    426                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_0: (+1)
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x7A60             LDRB     R0,[R4, #+9]
   \   00000026   0x.... 0x....      BL       WriteEN_485
    427          
    428          #endif
    429                  //USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);     
    430                  UART_IntConfig(LPC_UART0,UART_INTCFG_RBR,ENABLE);
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable13_6  ;; 0x4000c000
   \   00000030   0x.... 0x....      BL       UART_IntConfig
    431                  break;
   \   00000034   0xE01C             B.N      ??MB_CommRxIntEn_4
    432                  
    433              case 1:
    434          #if (BSP_COM1_REN == DEF_ENABLED)
    435                  //GPIO_ResetBits(MBREN2_GPIO_PORT, MBREN2_GPIO_PIN);  // 低电平接收使能 
    436                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_2: (+1)
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x7A60             LDRB     R0,[R4, #+9]
   \   0000003A   0x.... 0x....      BL       WriteEN_485
    437          
    438          #endif
    439                  //USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    440                  UART_IntConfig((LPC_UART_TypeDef *) LPC_UART1,UART_INTCFG_RBR,ENABLE);
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x....             LDR.N    R0,??DataTable13_7  ;; 0x40010000
   \   00000044   0x.... 0x....      BL       UART_IntConfig
    441                  break;
   \   00000048   0xE012             B.N      ??MB_CommRxIntEn_4
    442                  
    443              case 2:
    444          #if (BSP_COM2_REN == DEF_ENABLED)
    445                  //GPIO_ResetBits(MBREN3_GPIO_PORT, MBREN3_GPIO_PIN);  // 低电平接收使能 
    446                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_1: (+1)
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000004E   0x.... 0x....      BL       WriteEN_485
    447          
    448          #endif
    449                  //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    450                UART_IntConfig(LPC_UART2,UART_INTCFG_RBR,ENABLE);
   \   00000052   0x2201             MOVS     R2,#+1
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x....             LDR.N    R0,??DataTable13_8  ;; 0x40098000
   \   00000058   0x.... 0x....      BL       UART_IntConfig
    451          
    452                  break;
   \   0000005C   0xE008             B.N      ??MB_CommRxIntEn_4
    453                  
    454              case 3:
    455          #if (BSP_COM3_REN == DEF_ENABLED)
    456                  //GPIO_ResetBits(MBREN4_GPIO_PORT, MBREN4_GPIO_PIN);  // 低电平接收使能 
    457                WriteEN_485(pch->PortNbr,0);
   \                     ??MB_CommRxIntEn_3: (+1)
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x7A60             LDRB     R0,[R4, #+9]
   \   00000062   0x.... 0x....      BL       WriteEN_485
    458          
    459          #endif
    460                  //USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    461                UART_IntConfig(LPC_UART3,UART_INTCFG_RBR,ENABLE);
   \   00000066   0x2201             MOVS     R2,#+1
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x....             LDR.N    R0,??DataTable13_9  ;; 0x4009c000
   \   0000006C   0x.... 0x....      BL       UART_IntConfig
    462          
    463                  break;
    464              }
    465              CPU_CRITICAL_EXIT();
   \                     ??MB_CommRxIntEn_4: (+1)
   \   00000070   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000074   0x0028             MOVS     R0,R5
   \   00000076   0x.... 0x....      BL       CPU_SR_Restore
    466          }
   \   0000007A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    467          
    468          /*$PAGE*/
    469          /*
    470          *********************************************************************************************************
    471          *                                       MB_CommRxTxISR_Handler()
    472          *
    473          * Description : This function is the ISR for either a received or transmitted character.
    474          *
    475          * Argument(s) : none.
    476          *
    477          * Return(s)   : none.
    478          *
    479          * Caller(s)   : This is a ISR
    480          *
    481          * Note(s)     : (1) The pseudo-code for this function should be:  
    482          *
    483          *               if (Rx Byte has been received) {
    484          *                  c = get byte from serial port;
    485          *                  Clear receive interrupt;
    486          *                  pch->RxCtr++;                      Increment the number of bytes received
    487          *                  MB_RxByte(pch, c);                 Pass character to Modbus to process
    488          *              }
    489          *
    490          *              if (Byte has been transmitted) {
    491          *                  pch->TxCtr++;                      Increment the number of bytes transmitted
    492          *                  MB_TxByte(pch);                    Send next byte in response
    493          *                  Clear transmit interrupt           Clear Transmit Interrupt flag
    494          *              }
    495          *********************************************************************************************************
    496          */

   \                                 In section .text, align 2, keep-with-next
    497          void  USARTx_RxTxISRHandler (MODBUS_CH *pch)
    498          {
   \                     USARTx_RxTxISRHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    499              volatile            CPU_INT08U    rx_data;
    500              volatile            CPU_INT08U    RecNumCom;
    501              
    502              USART_TypeDef*       USARTx  = pch->USARTx;
   \   00000004   0xF8D4 0x5460      LDR      R5,[R4, #+1120]
    503              
    504             // while ((USARTx->IIR & 0x01) == 0)
    505              {                                                            /* 是否有中断       */
    506                  
    507                  switch (USARTx->IIR & 0x0E){                            /*                */
   \   00000008   0x68A8             LDR      R0,[R5, #+8]
   \   0000000A   0xF010 0x000E      ANDS     R0,R0,#0xE
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD023             BEQ.N    ??USARTx_RxTxISRHandler_0
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD002             BEQ.N    ??USARTx_RxTxISRHandler_1
   \   00000016   0x280C             CMP      R0,#+12
   \   00000018   0xD00C             BEQ.N    ??USARTx_RxTxISRHandler_2
   \   0000001A   0xE027             B.N      ??USARTx_RxTxISRHandler_3
    508                      /***********************************************
    509                      * 描述：接收中断
    510                      */ 
    511                  case 0x04:       //接收中断 
    512                      //while ((USARTx->LSR & 0x01) == 0x01){               /*  判断数据是否接收完毕        */ 
    513                          rx_data = USARTx->RBR;  
   \                     ??USARTx_RxTxISRHandler_1: (+1)
   \   0000001C   0x7828             LDRB     R0,[R5, #+0]
   \   0000001E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    514                          pch->RxCtr++;
   \   00000022   0x6AE0             LDR      R0,[R4, #+44]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x62E0             STR      R0,[R4, #+44]
    515                          MB_RxByte(pch, rx_data);                          /* Pass character to Modbus to process                  */
   \   00000028   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       MB_RxByte
    516                      //}
    517                      break;
   \   00000032   0xE01B             B.N      ??USARTx_RxTxISRHandler_4
    518                  case 0x0C:       //超时中断
    519                      while ((USARTx->LSR & 0x01) == 0x01){               /*  判断数据是否接收完毕        */ 
   \                     ??USARTx_RxTxISRHandler_2: (+1)
   \   00000034   0x7D28             LDRB     R0,[R5, #+20]
   \   00000036   0x07C0             LSLS     R0,R0,#+31
   \   00000038   0xD50B             BPL.N    ??USARTx_RxTxISRHandler_5
    520                          rx_data = USARTx->RBR;  
   \   0000003A   0x7828             LDRB     R0,[R5, #+0]
   \   0000003C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    521                          pch->RxCtr++;
   \   00000040   0x6AE0             LDR      R0,[R4, #+44]
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x62E0             STR      R0,[R4, #+44]
    522                          MB_RxByte(pch, rx_data);                          /* Pass character to Modbus to process                  */
   \   00000046   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x.... 0x....      BL       MB_RxByte
   \   00000050   0xE7F0             B.N      ??USARTx_RxTxISRHandler_2
    523                      }
    524                      
    525                      rx_data = USARTx->RBR;                      //清中断,初次有效，mcubug
   \                     ??USARTx_RxTxISRHandler_5: (+1)
   \   00000052   0x7828             LDRB     R0,[R5, #+0]
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    526                      break;
   \   00000058   0xE008             B.N      ??USARTx_RxTxISRHandler_4
    527                      
    528                      /***********************************************
    529                      * 描述：发送中断
    530                      */
    531                  case 0x02:	                                    // 发送中断
    532                      pch->TxCtr++;                           //?计数器加
   \                     ??USARTx_RxTxISRHandler_0: (+1)
   \   0000005A   0xF8D4 0x0138      LDR      R0,[R4, #+312]
   \   0000005E   0x1C40             ADDS     R0,R0,#+1
   \   00000060   0xF8C4 0x0138      STR      R0,[R4, #+312]
    533                      MB_TxByte(pch);                         //
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       MB_TxByte
    534                      break;
   \   0000006A   0xE7FF             B.N      ??USARTx_RxTxISRHandler_4
    535                  default:
    536                      break;
    537                  } 
    538              }
    539          }
   \                     ??USARTx_RxTxISRHandler_3: (+1)
   \                     ??USARTx_RxTxISRHandler_4: (+1)
   \   0000006C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    540          
    541          /*$PAGE*/
    542          /*
    543          *********************************************************************************************************
    544          *                                UART #0 Rx/Tx Communication handler for Modbus
    545          *********************************************************************************************************
    546          */
    547          
    548          /***********************************************
    549          * 描述： UART0中断服务程序
    550          */

   \                                 In section .text, align 2, keep-with-next
    551          void UART0_IRQHandler (void)
    552          {
   \                     UART0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    553            USARTx_RxTxISRHandler(MB_ChPortMap[0]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    554          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    555          
    556          /***********************************************
    557          * 描述： UART1中断服务程序
    558          */

   \                                 In section .text, align 2, keep-with-next
    559          void UART1_IRQHandler (void)
    560          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    561            USARTx_RxTxISRHandler(MB_ChPortMap[1]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    562          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    563          /***********************************************
    564          * 描述： UART2中断服务程序
    565          */

   \                                 In section .text, align 2, keep-with-next
    566          void UART2_IRQHandler (void)
    567          {
   \                     UART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    568            USARTx_RxTxISRHandler(MB_ChPortMap[2]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    569          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    570          /***********************************************
    571          * 描述： UART3中断服务程序
    572          */

   \                                 In section .text, align 2, keep-with-next
    573          void UART3_IRQHandler (void)
    574          {  
   \                     UART3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    575            USARTx_RxTxISRHandler(MB_ChPortMap[3]);
   \   00000002   0x....             LDR.N    R0,??DataTable13_10
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x.... 0x....      BL       USARTx_RxTxISRHandler
    576          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    577           
    578          
    579          /*$PAGE*/
    580          /*
    581          *********************************************************************************************************
    582          *                                             MB_CommTx1()
    583          *
    584          * Description : This function is called to obtain the next byte to send from the transmit buffer.  When
    585          *               all bytes in the reply have been sent, transmit interrupts are disabled and the receiver
    586          *               is enabled to accept the next Modbus request.
    587          *
    588          * Argument(s) : c     is the byte to send to the serial port
    589          *
    590          * Return(s)   : none.
    591          *
    592          * Caller(s)   : MB_TxByte()
    593          *
    594          * Note(s)     : none.
    595          *********************************************************************************************************
    596          */
    597          

   \                                 In section .text, align 2, keep-with-next
    598          void  MB_CommTx1 (MODBUS_CH  *pch,
    599                            CPU_INT08U  c)
    600          {
   \                     MB_CommTx1: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    601              
    602              UART_SendByte(pch->USARTx,c);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   0000000E   0x.... 0x....      BL       UART_SendByte
    603              return;
   \   00000012   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    604              
    605              switch (pch->PortNbr) {
    606              case 0:
    607                  /* Transmit Data */
    608                  //USART1->DR = (c & (u16)0x01FF);
    609                  UART_SendByte(LPC_UART0,c);         
    610                  break;
    611                  
    612              case 1:
    613                  /* Transmit Data */
    614                  //USART2->DR = (c & (u16)0x01FF);
    615                  UART_SendByte((LPC_UART_TypeDef*) LPC_UART1,c);         
    616          
    617                  break;
    618                  
    619              case 2:
    620                  /* Transmit Data */
    621                  //USART3->DR = (c & (u16)0x01FF);
    622                  UART_SendByte(LPC_UART2,c);         
    623          
    624                  break;
    625                  
    626              case 3:
    627                  /* Transmit Data */
    628                  //UART4->DR = (c & (u16)0x01FF);
    629                  UART_SendByte(LPC_UART3,c);         
    630          
    631                  break;
    632              }
    633          }
    634          
    635          /*$PAGE*/
    636          /*
    637          *********************************************************************************************************
    638          *                                         MB_CommTxIntDis()
    639          *
    640          * Description : This function disables Tx interrupts.
    641          *
    642          * Argument(s) : pch        is a pointer to the Modbus channel
    643          *
    644          * Return(s)   : none.
    645          *
    646          * Caller(s)   : MB_CommExit()
    647          *               MB_TxByte()
    648          *
    649          * Note(s)     : none.
    650          *********************************************************************************************************
    651          */
    652          

   \                                 In section .text, align 2, keep-with-next
    653          void  MB_CommTxIntDis (MODBUS_CH  *pch)
    654          {
   \                     MB_CommTxIntDis: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    655              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    656          
    657              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    658              
    659              UART_IntConfig(pch->USARTx,UART_INTCFG_THRE,DISABLE);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       UART_IntConfig
    660                  
    661              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    662              return;
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    663              
    664              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    665              case 0:
    666          //        USART_ITConfig(USART1, USART_IT_TC, DISABLE);
    667          //        USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
    668                  UART_IntConfig(LPC_UART0,UART_INTCFG_THRE,DISABLE);
    669                
    670                  break;
    671                  
    672              case 1:
    673          //        USART_ITConfig(USART2, USART_IT_TC, DISABLE);
    674          //        USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
    675                  UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1,UART_INTCFG_THRE,DISABLE);
    676          
    677                  break;
    678                  
    679              case 2:
    680          //        USART_ITConfig(USART3, USART_IT_TC, DISABLE);
    681          //        USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
    682                  UART_IntConfig(LPC_UART2,UART_INTCFG_THRE,DISABLE);
    683          
    684                  break;
    685                  
    686              case 3:
    687          //        USART_ITConfig(UART4, USART_IT_TC, DISABLE);
    688          //        USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
    689                  UART_IntConfig(LPC_UART3,UART_INTCFG_THRE,DISABLE);
    690          
    691                  break;
    692              }
    693              CPU_CRITICAL_EXIT();
    694          }
    695          
    696          /*$PAGE*/
    697          /*
    698          *********************************************************************************************************
    699          *                                         MB_CommTxIntEn()
    700          *
    701          * Description : This function enables Tx interrupts.
    702          *
    703          * Argument(s) : pch        is a pointer to the Modbus channel
    704          *
    705          * Return(s)   : none.
    706          *
    707          * Caller(s)   : MB_Tx()
    708          *
    709          * Note(s)     : none.
    710          *********************************************************************************************************
    711          */

   \                                 In section .text, align 2, keep-with-next
    712          void  MB_CommTxIntEn (MODBUS_CH  *pch)
    713          {
   \                     MB_CommTxIntEn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    714              CPU_SR  cpu_sr = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    715          
    716              CPU_CRITICAL_ENTER();
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
   \   0000000A   0x0005             MOVS     R5,R0
   \   0000000C   0x.... 0x....      BL       CPU_IntDisMeasStart
    717              
    718              UART_IntConfig(pch->USARTx,UART_INTCFG_THRE,ENABLE);
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000018   0x.... 0x....      BL       UART_IntConfig
    719                  
    720              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000020   0x0028             MOVS     R0,R5
   \   00000022   0x.... 0x....      BL       CPU_SR_Restore
    721              return;
   \   00000026   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    722              
    723              switch (pch->PortNbr) {                       /* Just enable the receiver interrupt                */
    724              case 0:
    725          //        USART_ITConfig(USART1, USART_IT_TC, ENABLE);
    726          //        USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
    727                  UART_IntConfig(LPC_UART0,UART_INTCFG_THRE,ENABLE);
    728          
    729                  break;
    730                  
    731              case 1:
    732          //        USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    733          //        USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
    734                  UART_IntConfig((LPC_UART_TypeDef *)LPC_UART1,UART_INTCFG_THRE,ENABLE);
    735                  break;
    736                  
    737              case 2:
    738          //        USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    739          //        USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
    740                  UART_IntConfig(LPC_UART2,UART_INTCFG_THRE,ENABLE);
    741                  break;
    742                  
    743              case 3:
    744          //        USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    745          //        USART_ITConfig(UART4, USART_IT_TXE, ENABLE);
    746                  UART_IntConfig(LPC_UART3,UART_INTCFG_THRE,ENABLE);
    747          
    748                  break;
    749              }
    750              CPU_CRITICAL_EXIT();
    751          }
    752          
    753          /*$PAGE*/
    754          /*
    755          *********************************************************************************************************
    756          *                                           MB_RTU_TmrInit()
    757          *
    758          * Description : This function is called to initialize the RTU timeout timer.
    759          *
    760          * Argument(s) : freq          Is the frequency of the modbus RTU timer interrupt.
    761          *
    762          * Return(s)   : none.
    763          *
    764          * Caller(s)   : MB_Init().
    765          *
    766          * Note(s)     : none.
    767          *********************************************************************************************************
    768          */
    769          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    770          void  MB_RTU_TmrInit (void)
    771          {
   \                     MB_RTU_TmrInit: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    772              TIM_TIMERCFG_Type TIM_ConfigStruct;
    773              TIM_MATCHCFG_Type TIM_MatchConfigStruct;
    774          
    775          //	CLKPWR_ConfigPPWR(CLKPWR_PCONP_PCTIM0,ENABLE);
    776          
    777          	// Initialize timer 0, prescale count time of 1000000uS = 1S
    778          	TIM_ConfigStruct.PrescaleOption = TIM_PRESCALE_USVAL;
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xF88D 0x000C      STRB     R0,[SP, #+12]
    779          //	TIM_ConfigStruct.PrescaleValue	= 1000000;
    780          	TIM_ConfigStruct.PrescaleValue	= 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x9004             STR      R0,[SP, #+16]
    781              
    782              TIM_Init(LPC_TIM3, TIM_TIMER_MODE,&TIM_ConfigStruct);
   \   0000000E   0xAA03             ADD      R2,SP,#+12
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000014   0x.... 0x....      BL       TIM_Init
    783          
    784          	// Configure 3 match channels
    785          	// use channel 0, MR0
    786          	TIM_MatchConfigStruct.MatchChannel = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
    787          	// Enable interrupt when MR0 matches the value in TC register
    788          	TIM_MatchConfigStruct.IntOnMatch   = TRUE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0001      STRB     R0,[SP, #+1]
    789          	//Enable reset on MR0: TIMER will reset if MR0 matches it
    790          	TIM_MatchConfigStruct.ResetOnMatch = TRUE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xF88D 0x0003      STRB     R0,[SP, #+3]
    791          	//Stop on MR0 if MR0 matches it
    792          	TIM_MatchConfigStruct.StopOnMatch  = FALSE;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    793          	//时间到后，端口不操作
    794          	TIM_MatchConfigStruct.ExtMatchOutputType = TIM_EXTMATCH_NOTHING;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xF88D 0x0004      STRB     R0,[SP, #+4]
    795          	// Set Match value
    796          	TIM_MatchConfigStruct.MatchValue   = 1000;
   \   00000036   0xF44F 0x707A      MOV      R0,#+1000
   \   0000003A   0x9002             STR      R0,[SP, #+8]
    797          
    798              TIM_ConfigMatch(LPC_TIM3, &TIM_MatchConfigStruct);
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000040   0x.... 0x....      BL       TIM_ConfigMatch
    799          
    800          	// Set configuration for Tim_config and Tim_MatchConfig
    801          	TIM_ResetCounter(LPC_TIM3);
   \   00000044   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000046   0x.... 0x....      BL       TIM_ResetCounter
    802          
    803          	/* preemption = 1, sub-priority = 1 */
    804          	NVIC_SetPriority(TIMER3_IRQn, TIMER3_IRQn+10);
   \   0000004A   0x210E             MOVS     R1,#+14
   \   0000004C   0x2004             MOVS     R0,#+4
   \   0000004E   0x.... 0x....      BL       NVIC_SetPriority
    805          	/* Enable interrupt for timer 0 */
    806          	NVIC_EnableIRQ(TIMER3_IRQn);
   \   00000052   0x2004             MOVS     R0,#+4
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    807          	// To start timer 1
    808          	TIM_Cmd(LPC_TIM3,ENABLE);							
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   0000005C   0x.... 0x....      BL       TIM_Cmd
    809          
    810              MB_RTU_TmrResetAll();                                     /* Reset all the RTU timers, we changed freq. */
   \   00000060   0x.... 0x....      BL       MB_RTU_TmrResetAll
    811          }
   \   00000064   0xB005             ADD      SP,SP,#+20
   \   00000066   0xBD00             POP      {PC}             ;; return
    812          #endif
    813          
    814          /*$PAGE*/
    815          /*
    816          *********************************************************************************************************
    817          *                                           MB_RTU_TmrExit()
    818          *
    819          * Description : This function is called to disable the RTU timeout timer.
    820          *
    821          * Argument(s) : none.
    822          *
    823          * Return(s)   : none.
    824          *
    825          * Caller(s)   : MB_Exit()
    826          *
    827          * Note(s)     : none.
    828          *********************************************************************************************************
    829          */
    830          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    831          void  MB_RTU_TmrExit (void)
    832          {
   \                     MB_RTU_TmrExit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    833              //TIM_Cmd(TIM3,DISABLE);              //禁止计数器 
    834              //RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, DISABLE);
    835            TIM_DeInit(LPC_TIM3);
   \   00000002   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000004   0x.... 0x....      BL       TIM_DeInit
    836          
    837          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    838          #endif
    839          
    840          /*$PAGE*/
    841          /*
    842          *********************************************************************************************************
    843          *                                       MB_RTU_TmrISR_Handler()
    844          *
    845          * Description : This function handles the case when the RTU timeout timer expires.
    846          *
    847          * Arguments   : none.
    848          *
    849          * Returns     : none.
    850          *
    851          * Caller(s)   : This is a ISR.
    852          *
    853          * Note(s)     : none.
    854          *********************************************************************************************************
    855          */
    856          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
    857          

   \                                 In section .text, align 2, keep-with-next
    858          void TIMER3_IRQHandler(void)
    859          {
   \                     TIMER3_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    860              MB_RTU_TmrISR_Handler();
   \   00000002   0x.... 0x....      BL       MB_RTU_TmrISR_Handler
    861          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    862          

   \                                 In section .text, align 2, keep-with-next
    863          void  MB_RTU_TmrISR_Handler (void)
    864          {
   \                     MB_RTU_TmrISR_Handler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    865          //    if(TIM_GetITStatus(TIM3, TIM_IT_Update)== SET) {//检测是否发生溢出更新事件
    866          //      TIM_ClearITPendingBit(TIM3 , TIM_FLAG_Update);/* Clear timer #1 interrupt                           */
    867          //      MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
    868          //      MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
    869          //    }
    870           
    871          //   TIM_Cmd(LPC_TIM3,DISABLE);
    872          	TIM_ClearIntPending(LPC_TIM3, TIM_MR0_INT);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   00000006   0x.... 0x....      BL       TIM_ClearIntPending
    873          	TIM_ResetCounter(LPC_TIM3);
   \   0000000A   0x....             LDR.N    R0,??DataTable13_11  ;; 0x40094000
   \   0000000C   0x.... 0x....      BL       TIM_ResetCounter
    874              
    875              MB_RTU_TmrCtr++;                              /* Indicate that we had activities on this interrupt. */
   \   00000010   0x....             LDR.N    R0,??DataTable13_12
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x1C40             ADDS     R0,R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable13_12
   \   00000018   0x6008             STR      R0,[R1, #+0]
    876              MB_RTU_TmrUpdate();                           /* Check for RTU timers that have expired             */
   \   0000001A   0x.... 0x....      BL       MB_RTU_TmrUpdate
    877          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    878          
    879          #endif
    880                                

   \                                 In section .text, align 2, keep-with-next
    881          void    UARTPutString(MODBUS_CH  *pch, const char *printfbuf)              
    882          {
   \                     UARTPutString: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    883              int nbr_bytes   = strlen(printfbuf);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0x.... 0x....      BL       strlen
   \   0000000C   0x0006             MOVS     R6,R0
    884              
    885              if ( (nbr_bytes > 0) && (nbr_bytes < MB_DATA_NBR_REGS * 2 ) ) {  
   \   0000000E   0x2E01             CMP      R6,#+1
   \   00000010   0xDB08             BLT.N    ??UARTPutString_0
   \   00000012   0x2EFA             CMP      R6,#+250
   \   00000014   0xDA06             BGE.N    ??UARTPutString_0
    886                  NMB_Tx((MODBUS_CH   *)pch,
    887                         (CPU_INT08U  *)printfbuf,
    888                         (CPU_INT16U   )nbr_bytes);
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x0002             MOVS     R2,R0
   \   0000001A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x.... 0x....      BL       NMB_Tx
    889              }
    890          }
   \                     ??UARTPutString_0: (+1)
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
    891          
    892          //////////////////////////////////////////////////////////////
    893          

   \                                 In section .text, align 2, keep-with-next
    894          void WriteEN_485_3(uint8 temp)
    895          {	
   \                     WriteEN_485_3: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    896          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteEN_485_3_0
    897          	{
    898          		GPIO_SetOrClearValue(EN_485_3,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2081             MOVS     R0,#+129
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteEN_485_3_1
    899          	}
    900          	else
    901          	{
    902          		GPIO_SetOrClearValue(EN_485_3,0);		
   \                     ??WriteEN_485_3_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2081             MOVS     R0,#+129
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    903          	}	
    904          }
   \                     ??WriteEN_485_3_1: (+1)
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x........         DC32     MB_ChTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x4000C000         DC32     0x4000c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \   00000000   0x4009C000         DC32     0x4009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \   00000000   0x........         DC32     MB_ChPortMap

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \   00000000   0x........         DC32     MB_RTU_TmrCtr

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x1B 0x7A          DC8 27, 122, 128, 129, 0, 0, 0, 0
   \              0x80 0x81    
   \              0x00 0x00    
   \              0x00 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   MB_CommExit
        16   -> MB_CommRxIntDis
        16   -> MB_CommTxIntDis
      72   MB_CommPortCfg
        72   -> GPIO_PinselConfig
        72   -> NVIC_EnableIRQ
        72   -> NVIC_SetPriority
        72   -> UART_FIFOConfig
        72   -> UART_Init
        72   -> UART_IntConfig
        72   -> UART_TxCmd
        72   -> WriteEN_485
        72   -> __aeabi_memcpy4
      16   MB_CommRxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
        16   -> WriteEN_485
      16   MB_CommRxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
        16   -> WriteEN_485
      16   MB_CommTx1
        16   -> UART_SendByte
      16   MB_CommTxIntDis
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
      16   MB_CommTxIntEn
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> UART_IntConfig
       8   MB_RTU_TmrExit
         8   -> TIM_DeInit
       8   MB_RTU_TmrISR_Handler
         8   -> MB_RTU_TmrUpdate
         8   -> TIM_ClearIntPending
         8   -> TIM_ResetCounter
      24   MB_RTU_TmrInit
        24   -> MB_RTU_TmrResetAll
        24   -> NVIC_EnableIRQ
        24   -> NVIC_SetPriority
        24   -> TIM_Cmd
        24   -> TIM_ConfigMatch
        24   -> TIM_Init
        24   -> TIM_ResetCounter
       0   NVIC_EnableIRQ
       4   NVIC_SetPriority
       8   TIMER3_IRQHandler
         8   -> MB_RTU_TmrISR_Handler
       8   UART0_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART1_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART2_IRQHandler
         8   -> USARTx_RxTxISRHandler
       8   UART3_IRQHandler
         8   -> USARTx_RxTxISRHandler
      16   UARTPutString
        16   -> NMB_Tx
        16   -> strlen
      16   USARTx_RxTxISRHandler
        16   -> MB_RxByte
        16   -> MB_TxByte
      24   WriteEN_485
        24   -> GPIO_SetOrClearValue
       8   WriteEN_485_3
         8   -> GPIO_SetOrClearValue


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       8  ?_0
      16  ?_1
      20  MB_ChPortMap
      40  MB_CommExit
     394  MB_CommPortCfg
     124  MB_CommRxIntDis
     124  MB_CommRxIntEn
      20  MB_CommTx1
      40  MB_CommTxIntDis
      40  MB_CommTxIntEn
      10  MB_RTU_TmrExit
      32  MB_RTU_TmrISR_Handler
     104  MB_RTU_TmrInit
      22  NVIC_EnableIRQ
      42  NVIC_SetPriority
       8  TIMER3_IRQHandler
      12  UART0_IRQHandler
      12  UART1_IRQHandler
      12  UART2_IRQHandler
      12  UART3_IRQHandler
      38  UARTPutString
     110  USARTx_RxTxISRHandler
      56  WriteEN_485
      30  WriteEN_485_3

 
    20 bytes in section .bss
    24 bytes in section .rodata
 1 334 bytes in section .text
 
 1 334 bytes of CODE  memory
    24 bytes of CONST memory
    20 bytes of DATA  memory

Errors: none
Warnings: 5
