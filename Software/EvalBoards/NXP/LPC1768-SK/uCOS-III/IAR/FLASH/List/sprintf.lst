###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       19/Sep/2017  19:02:42
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-310统计模块\Software\APP\User\sprintf.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\APP\User\sprintf.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\sprintf.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\sprintf.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\APP\User\sprintf.c
      1          
      2          //#include "stdafx.h"
      3          
      4          #include <mb.h>
      5          
      6          #ifndef TRUE
      7            #define TRUE    1
      8          #endif
      9          #ifndef FALSE
     10            #define FALSE   0
     11          #endif 
     12          #ifndef BOOL
     13            #define BOOL    unsigned char
     14          #endif
     15          #define INCLUDE_STRING
     16          
     17          #ifdef INCLUDE_STRING
     18              #include "string.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char const *, int)
   \                     strchr: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       __iar_Strchr
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     19          #endif
     20          
     21          #ifdef KERNEL
     22              #define NOFLOAT
     23          #endif
     24          
     25          #define sprintf  my_sprintf
     26          #define vsprintf my_vsprintf
     27          #define atoi     my_atoi
     28          #define ftoa     my_ftoa
     29          #define strnlen  my_strnlen
     30          
     31          #define DOUBLE_ZERO 1E-307
     32          
     33          #define IS_DOUBLE_ZERO(D) (((double)D <= 1E-307) && ((double)D >= -1E-307))
     34          
     35          typedef char* va_list;
     36          #ifndef __va_rounded_size
     37          #define __va_rounded_size(TYPE) (((sizeof(TYPE)+sizeof(int)-1)/sizeof(int))*sizeof(int))
     38          #endif
     39          
     40          #ifndef va_start
     41          #define va_start(AP, LASTARG)   (AP = ((char *)& (LASTARG) + __va_rounded_size(LASTARG)))
     42          #endif
     43          
     44          #ifndef va_arg
     45          #define va_arg(AP, TYPE)        (AP += __va_rounded_size(TYPE), *((TYPE *)(AP - __va_rounded_size(TYPE))))
     46          #endif
     47          
     48          #ifndef va_end
     49          #define va_end(AP)              (AP = (va_list)0 )
     50          #endif
     51          
     52          
     53          #define ZEROPAD 1               // Pad with zero
     54          #define SIGN    2               // Unsigned/signed long
     55          #define PLUS    4               // Show plus
     56          #define SPACE   8               // Space if plus
     57          #define LEFT    16              // Left justified
     58          #define SPECIAL 32              // 0x
     59          #define LARGE   64              // Use 'ABCDEF' instead of 'abcdef'
     60          
     61          #define abs(a)  ((a) < 0 ?  -(a) :(a))
     62          #define is_digit(c) ((c) >= '0' && (c) <= '9')
     63          /////////////////////////////////////////////////////////////////////////////
     64          
     65          #define FLT_MAX_10_EXP     38
     66          #define DBL_MAX_10_EXP     308
     67          #define LDBL_MAX_10_EXP    308
     68          

   \                                 In section .data, align 4
     69          static char *digits = "0123456789abcdefghijklmnopqrstuvwxyz";
   \                     digits:
   \   00000000   0x........         DC32 ?_0

   \                                 In section .data, align 4
     70          static char *upper_digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
   \                     upper_digits:
   \   00000000   0x........         DC32 ?_1

   \                                 In section .text, align 2, keep-with-next
     71          static int is_space( int ch )
     72          {
     73              return (unsigned long)(ch - 9) < 5u || ' ' == ch;
   \                     is_space: (+1)
   \   00000000   0xF1B0 0x0109      SUBS     R1,R0,#+9
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xD301             BCC.N    ??is_space_0
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD101             BNE.N    ??is_space_1
   \                     ??is_space_0: (+1)
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xE000             B.N      ??is_space_2
   \                     ??is_space_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??is_space_2: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          static int atoi(char *str)
     77          {
   \                     my_atoi: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
     78             int sign;
     79             int n;
     80             char *p = str;
   \   00000004   0x0027             MOVS     R7,R4
     81          
     82             while (is_space(*p) ) p++;
   \                     ??my_atoi_0: (+1)
   \   00000006   0x7838             LDRB     R0,[R7, #+0]
   \   00000008   0x.... 0x....      BL       is_space
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD001             BEQ.N    ??my_atoi_1
   \   00000010   0x1C7F             ADDS     R7,R7,#+1
   \   00000012   0xE7F8             B.N      ??my_atoi_0
     83          
     84             sign = ('-' == *p) ? -1 : 1;
   \                     ??my_atoi_1: (+1)
   \   00000014   0x7838             LDRB     R0,[R7, #+0]
   \   00000016   0x282D             CMP      R0,#+45
   \   00000018   0xD102             BNE.N    ??my_atoi_2
   \   0000001A   0xF05F 0x36FF      MOVS     R6,#-1
   \   0000001E   0xE000             B.N      ??my_atoi_3
   \                     ??my_atoi_2: (+1)
   \   00000020   0x2601             MOVS     R6,#+1
     85             if ('+' == *p || '-' == *p) p++;
   \                     ??my_atoi_3: (+1)
   \   00000022   0x7838             LDRB     R0,[R7, #+0]
   \   00000024   0x282B             CMP      R0,#+43
   \   00000026   0xD002             BEQ.N    ??my_atoi_4
   \   00000028   0x7838             LDRB     R0,[R7, #+0]
   \   0000002A   0x282D             CMP      R0,#+45
   \   0000002C   0xD100             BNE.N    ??my_atoi_5
   \                     ??my_atoi_4: (+1)
   \   0000002E   0x1C7F             ADDS     R7,R7,#+1
     86          
     87             for (n = 0; is_digit(*p); p++)
   \                     ??my_atoi_5: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0005             MOVS     R5,R0
   \                     ??my_atoi_6: (+1)
   \   00000034   0x7838             LDRB     R0,[R7, #+0]
   \   00000036   0x2830             CMP      R0,#+48
   \   00000038   0xDB0A             BLT.N    ??my_atoi_7
   \   0000003A   0x7838             LDRB     R0,[R7, #+0]
   \   0000003C   0x283A             CMP      R0,#+58
   \   0000003E   0xDA07             BGE.N    ??my_atoi_7
     88                n = 10 * n + (*p - '0');
   \   00000040   0x200A             MOVS     R0,#+10
   \   00000042   0x7839             LDRB     R1,[R7, #+0]
   \   00000044   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000048   0xF1B0 0x0530      SUBS     R5,R0,#+48
   \   0000004C   0x1C7F             ADDS     R7,R7,#+1
   \   0000004E   0xE7F1             B.N      ??my_atoi_6
     89          
     90             return sign*n;
   \                     ??my_atoi_7: (+1)
   \   00000050   0xFB05 0xF006      MUL      R0,R5,R6
   \   00000054   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
     91          }
     92          #ifndef INCLUDE_STRING
     93              #define memset   my_memset
     94              #define memcpy   my_memcpy
     95              #define strlen   my_strlen
     96              #define strcmp   my_strcmp
     97              #define strchr   my_strchr
     98          
     99          static char * strchr(const char *str, int ch)
    100          {
    101              while (*str && *str != (char)ch) str++;
    102          
    103              if (*str == (char)ch)
    104                  return((char *)str);
    105          
    106              return 0;
    107          }
    108          static void * memset(void *dst, int val, unsigned long ulcount)
    109          {
    110              if(!dst) return 0;
    111              char * pchdst = (char*)dst;
    112              while(ulcount--) *pchdst++ = (char)val;
    113          
    114              return dst;
    115          }
    116          
    117          static void * memcpy(void *dst, const void *src, unsigned long ulcount)
    118          {
    119             if(!(dst && src)) return 0;
    120             char * pchdst = (char*)dst;
    121             char * pchsrc = (char*)src;
    122             while(ulcount--) *pchdst++ = *pchsrc++;
    123             
    124             return dst;
    125          }
    126          
    127          static int strlen(const char * str)
    128          {
    129              const char *p = str;
    130              while(*p++);
    131          
    132              return (int)(p - str - 1);
    133          }
    134          
    135          int strcmp(const char *source,const char *dest)
    136          {
    137              int ret = 0;
    138              if(!source || !dest) return -2;
    139              while( ! (ret = *( unsigned char *)source - *(unsigned char *)dest) && *dest)
    140              {
    141                  source++;
    142                  dest++;
    143              }
    144              
    145              if ( ret < 0 )
    146                  ret = -1 ;
    147              else if ( ret > 0 )
    148                  ret = 1 ;
    149          
    150              return(ret);
    151          }
    152          
    153          static int strncmp(const char *first,const char *last,int count)
    154          {
    155             if (!count)  return 0;
    156          
    157             while (--count && *first && *first == *last) first++,last++;
    158          
    159             return ( *(unsigned char *)first - *(unsigned char *)last );
    160          }
    161          
    162          #endif  /*NO_INCLUDE_STRING*/

   \                                 In section .text, align 2, keep-with-next
    163          static unsigned long strnlen(const char *s, int count)
    164          {
    165              const char *sc;
    166              for (sc = s; *sc != '\0' && count--; ++sc);
   \                     my_strnlen: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   \                     ??my_strnlen_0: (+1)
   \   00000002   0x7813             LDRB     R3,[R2, #+0]
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD005             BEQ.N    ??my_strnlen_1
   \   00000008   0x000B             MOVS     R3,R1
   \   0000000A   0x1E59             SUBS     R1,R3,#+1
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD001             BEQ.N    ??my_strnlen_1
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \   00000012   0xE7F6             B.N      ??my_strnlen_0
    167              return sc - s;
   \                     ??my_strnlen_1: (+1)
   \   00000014   0x1A10             SUBS     R0,R2,R0
   \   00000016   0x4770             BX       LR               ;; return
    168          }
    169          

   \                                 In section .text, align 2, keep-with-next
    170          static char * itoa(int n, char * chBuffer)
    171          {
   \                     itoa: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
    172              int i = 1;
   \   00000004   0x2301             MOVS     R3,#+1
    173              char * pch = chBuffer;
   \   00000006   0x000C             MOVS     R4,R1
    174              if(!pch) return 0;
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??itoa_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE022             B.N      ??itoa_1
    175              while(n / i) i *= 10;
   \                     ??itoa_0: (+1)
   \   00000010   0xFB92 0xF0F3      SDIV     R0,R2,R3
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??itoa_2
   \   00000018   0x200A             MOVS     R0,#+10
   \   0000001A   0x4343             MULS     R3,R0,R3
   \   0000001C   0xE7F8             B.N      ??itoa_0
    176              
    177              if(n < 0)
   \                     ??itoa_2: (+1)
   \   0000001E   0x2A00             CMP      R2,#+0
   \   00000020   0xD503             BPL.N    ??itoa_3
    178              {
    179                  n = -n;
   \   00000022   0x4252             RSBS     R2,R2,#+0
    180                  *pch++ = '-';
   \   00000024   0x202D             MOVS     R0,#+45
   \   00000026   0x7020             STRB     R0,[R4, #+0]
   \   00000028   0x1C64             ADDS     R4,R4,#+1
    181              }
    182              if (0 == n) i = 10;
   \                     ??itoa_3: (+1)
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD101             BNE.N    ??itoa_4
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0x0003             MOVS     R3,R0
    183              
    184              while(i /= 10)
   \                     ??itoa_4: (+1)
   \   00000032   0x200A             MOVS     R0,#+10
   \   00000034   0xFB93 0xF3F0      SDIV     R3,R3,R0
   \   00000038   0x2B00             CMP      R3,#+0
   \   0000003A   0xD009             BEQ.N    ??itoa_5
    185              {
    186                  *pch++ = n / i + '0';
   \   0000003C   0xFB92 0xF0F3      SDIV     R0,R2,R3
   \   00000040   0x3030             ADDS     R0,R0,#+48
   \   00000042   0x7020             STRB     R0,[R4, #+0]
   \   00000044   0x1C64             ADDS     R4,R4,#+1
    187                  n %= i;
   \   00000046   0xFB92 0xF0F3      SDIV     R0,R2,R3
   \   0000004A   0xFB03 0x2210      MLS      R2,R3,R0,R2
   \   0000004E   0xE7F0             B.N      ??itoa_4
    188              }
    189              *pch = '\0';
   \                     ??itoa_5: (+1)
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x7020             STRB     R0,[R4, #+0]
    190              return chBuffer;
   \   00000054   0x0008             MOVS     R0,R1
   \                     ??itoa_1: (+1)
   \   00000056   0xBC10             POP      {R4}
   \   00000058   0x4770             BX       LR               ;; return
    191          }
    192          

   \                                 In section .text, align 2, keep-with-next
    193          static int skip_atoi(const char **s)
    194          {
   \                     skip_atoi: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    195              int i = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    196              while (is_digit(**s))
   \                     ??skip_atoi_0: (+1)
   \   00000004   0x680A             LDR      R2,[R1, #+0]
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0x2A30             CMP      R2,#+48
   \   0000000A   0xDB0C             BLT.N    ??skip_atoi_1
   \   0000000C   0x680A             LDR      R2,[R1, #+0]
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0x2A3A             CMP      R2,#+58
   \   00000012   0xDA08             BGE.N    ??skip_atoi_1
    197              {
    198                  i = i*10 + *((*s)++) - '0';
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x1C53             ADDS     R3,R2,#+1
   \   00000018   0x600B             STR      R3,[R1, #+0]
   \   0000001A   0x230A             MOVS     R3,#+10
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0xFB03 0x2000      MLA      R0,R3,R0,R2
   \   00000022   0x3830             SUBS     R0,R0,#+48
   \   00000024   0xE7EE             B.N      ??skip_atoi_0
    199              }
    200              return i;
   \                     ??skip_atoi_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    201          }
    202          

   \                                 In section .text, align 2, keep-with-next
    203          static char * number(char *str, long num, int base, int size, int precision, int type)
    204          {
   \                     number: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB091             SUB      SP,SP,#+68
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0xF8DD 0xE060      LDR      LR,[SP, #+96]
   \   0000000C   0x9F19             LDR      R7,[SP, #+100]
    205              char c, sign, tmp[66];
    206              char *dig = digits;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable7
   \   00000012   0x6806             LDR      R6,[R0, #+0]
    207              int i;
    208          
    209              if (type & LARGE)  dig = upper_digits;
   \   00000014   0x0678             LSLS     R0,R7,#+25
   \   00000016   0xD503             BPL.N    ??number_0
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x0006             MOVS     R6,R0
    210              if (type & LEFT) type &= ~ZEROPAD;
   \                     ??number_0: (+1)
   \   00000020   0x06F8             LSLS     R0,R7,#+27
   \   00000022   0xD501             BPL.N    ??number_1
   \   00000024   0xF037 0x0701      BICS     R7,R7,#0x1
    211              if (base < 2 || base > 36) return 0;
   \                     ??number_1: (+1)
   \   00000028   0x2A02             CMP      R2,#+2
   \   0000002A   0xDB01             BLT.N    ??number_2
   \   0000002C   0x2A25             CMP      R2,#+37
   \   0000002E   0xDB01             BLT.N    ??number_3
   \                     ??number_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE08F             B.N      ??number_4
    212          
    213              c = (type & ZEROPAD) ? '0' : ' ';
   \                     ??number_3: (+1)
   \   00000034   0x07F8             LSLS     R0,R7,#+31
   \   00000036   0xD502             BPL.N    ??number_5
   \   00000038   0xF05F 0x0C30      MOVS     R12,#+48
   \   0000003C   0xE001             B.N      ??number_6
   \                     ??number_5: (+1)
   \   0000003E   0xF05F 0x0C20      MOVS     R12,#+32
    214              sign = 0;
   \                     ??number_6: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0005             MOVS     R5,R0
    215              if (type & SIGN)
   \   00000046   0x07B8             LSLS     R0,R7,#+30
   \   00000048   0xD511             BPL.N    ??number_7
    216              {
    217                  if (num < 0)
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD504             BPL.N    ??number_8
    218                  {
    219                      sign = '-';
   \   0000004E   0x202D             MOVS     R0,#+45
   \   00000050   0x0005             MOVS     R5,R0
    220                      num = -num;
   \   00000052   0x4249             RSBS     R1,R1,#+0
    221                      size--;
   \   00000054   0x1E5B             SUBS     R3,R3,#+1
   \   00000056   0xE00A             B.N      ??number_7
    222                  }
    223                  else if (type & PLUS)
   \                     ??number_8: (+1)
   \   00000058   0x0778             LSLS     R0,R7,#+29
   \   0000005A   0xD503             BPL.N    ??number_9
    224                  {
    225                      sign = '+';
   \   0000005C   0x202B             MOVS     R0,#+43
   \   0000005E   0x0005             MOVS     R5,R0
    226                      size--;
   \   00000060   0x1E5B             SUBS     R3,R3,#+1
   \   00000062   0xE004             B.N      ??number_7
    227                  }
    228                  else if (type & SPACE)
   \                     ??number_9: (+1)
   \   00000064   0x0738             LSLS     R0,R7,#+28
   \   00000066   0xD502             BPL.N    ??number_7
    229                  {
    230                      sign = ' ';
   \   00000068   0x2020             MOVS     R0,#+32
   \   0000006A   0x0005             MOVS     R5,R0
    231                      size--;
   \   0000006C   0x1E5B             SUBS     R3,R3,#+1
    232                  }
    233              }
    234          
    235              if (type & SPECIAL)
   \                     ??number_7: (+1)
   \   0000006E   0x06B8             LSLS     R0,R7,#+26
   \   00000070   0xD506             BPL.N    ??number_10
    236              {
    237                  if (16 == base)
   \   00000072   0x2A10             CMP      R2,#+16
   \   00000074   0xD101             BNE.N    ??number_11
    238                      size -= 2;
   \   00000076   0x1E9B             SUBS     R3,R3,#+2
   \   00000078   0xE002             B.N      ??number_10
    239                  else if (8 == base)
   \                     ??number_11: (+1)
   \   0000007A   0x2A08             CMP      R2,#+8
   \   0000007C   0xD100             BNE.N    ??number_10
    240                      size--;
   \   0000007E   0x1E5B             SUBS     R3,R3,#+1
    241              }
    242          
    243              i = 0;
   \                     ??number_10: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x4680             MOV      R8,R0
    244          
    245              if (0 == num)
   \   00000084   0x2900             CMP      R1,#+0
   \   00000086   0xD106             BNE.N    ??number_12
    246              {
    247                  tmp[i++] = '0';
   \   00000088   0x2030             MOVS     R0,#+48
   \   0000008A   0x46E9             MOV      R9,SP
   \   0000008C   0xF808 0x0009      STRB     R0,[R8, R9]
   \   00000090   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000094   0xE00E             B.N      ??number_13
    248              }
    249              else
    250              {
    251                  while (num != 0)
   \                     ??number_12: (+1)
   \   00000096   0x2900             CMP      R1,#+0
   \   00000098   0xD00C             BEQ.N    ??number_13
    252                  {
    253                      tmp[i++] = dig[((unsigned long) num) % (unsigned) base];
   \   0000009A   0xFBB1 0xF0F2      UDIV     R0,R1,R2
   \   0000009E   0xFB02 0x1010      MLS      R0,R2,R0,R1
   \   000000A2   0x5D80             LDRB     R0,[R0, R6]
   \   000000A4   0x46E9             MOV      R9,SP
   \   000000A6   0xF808 0x0009      STRB     R0,[R8, R9]
   \   000000AA   0xF118 0x0801      ADDS     R8,R8,#+1
    254                      num = ((unsigned long) num) / (unsigned) base;
   \   000000AE   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   000000B2   0xE7F0             B.N      ??number_12
    255                  }
    256              }
    257          
    258              if (i > precision) precision = i;
   \                     ??number_13: (+1)
   \   000000B4   0x45C6             CMP      LR,R8
   \   000000B6   0xDA00             BGE.N    ??number_14
   \   000000B8   0x46C6             MOV      LR,R8
    259              size -= precision;
   \                     ??number_14: (+1)
   \   000000BA   0xEBB3 0x030E      SUBS     R3,R3,LR
    260              if (!(type & (ZEROPAD | LEFT)))
   \   000000BE   0xF017 0x0F11      TST      R7,#0x11
   \   000000C2   0xD107             BNE.N    ??number_15
    261              {
    262                  while(size-- > 0) *str++ = ' ';
   \                     ??number_16: (+1)
   \   000000C4   0x0018             MOVS     R0,R3
   \   000000C6   0x1E43             SUBS     R3,R0,#+1
   \   000000C8   0x2801             CMP      R0,#+1
   \   000000CA   0xDB03             BLT.N    ??number_15
   \   000000CC   0x2020             MOVS     R0,#+32
   \   000000CE   0x7020             STRB     R0,[R4, #+0]
   \   000000D0   0x1C64             ADDS     R4,R4,#+1
   \   000000D2   0xE7F7             B.N      ??number_16
    263              }
    264              if (sign) *str++ = sign;
   \                     ??number_15: (+1)
   \   000000D4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D6   0x2D00             CMP      R5,#+0
   \   000000D8   0xD001             BEQ.N    ??number_17
   \   000000DA   0x7025             STRB     R5,[R4, #+0]
   \   000000DC   0x1C64             ADDS     R4,R4,#+1
    265          
    266              if (type & SPECIAL)
   \                     ??number_17: (+1)
   \   000000DE   0x06B8             LSLS     R0,R7,#+26
   \   000000E0   0xD511             BPL.N    ??number_18
    267              {
    268                  if (8 == base)
   \   000000E2   0x2A08             CMP      R2,#+8
   \   000000E4   0xD103             BNE.N    ??number_19
    269                  {
    270                      *str++ = '0';
   \   000000E6   0x2030             MOVS     R0,#+48
   \   000000E8   0x7020             STRB     R0,[R4, #+0]
   \   000000EA   0x1C64             ADDS     R4,R4,#+1
   \   000000EC   0xE00B             B.N      ??number_18
    271                  }
    272                  else if (16 == base)
   \                     ??number_19: (+1)
   \   000000EE   0x2A10             CMP      R2,#+16
   \   000000F0   0xD109             BNE.N    ??number_18
    273                  {
    274                      *str++ = '0';
   \   000000F2   0x2030             MOVS     R0,#+48
   \   000000F4   0x7020             STRB     R0,[R4, #+0]
   \   000000F6   0x1C64             ADDS     R4,R4,#+1
    275                      *str++ = digits[33];
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable7
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF890 0x0021      LDRB     R0,[R0, #+33]
   \   00000102   0x7020             STRB     R0,[R4, #+0]
   \   00000104   0x1C64             ADDS     R4,R4,#+1
    276                  }
    277              }
    278          
    279              if(!(type & LEFT))
   \                     ??number_18: (+1)
   \   00000106   0x06F8             LSLS     R0,R7,#+27
   \   00000108   0xD407             BMI.N    ??number_20
    280              {
    281                  while(size-- > 0) *str++ = c;
   \                     ??number_21: (+1)
   \   0000010A   0x0018             MOVS     R0,R3
   \   0000010C   0x1E43             SUBS     R3,R0,#+1
   \   0000010E   0x2801             CMP      R0,#+1
   \   00000110   0xDB03             BLT.N    ??number_20
   \   00000112   0xF884 0xC000      STRB     R12,[R4, #+0]
   \   00000116   0x1C64             ADDS     R4,R4,#+1
   \   00000118   0xE7F7             B.N      ??number_21
    282              }
    283              while(i < precision--) *str++ = '0';
   \                     ??number_20: (+1)
   \   0000011A   0x4670             MOV      R0,LR
   \   0000011C   0xF1B0 0x0E01      SUBS     LR,R0,#+1
   \   00000120   0x4580             CMP      R8,R0
   \   00000122   0xDA03             BGE.N    ??number_22
   \   00000124   0x2030             MOVS     R0,#+48
   \   00000126   0x7020             STRB     R0,[R4, #+0]
   \   00000128   0x1C64             ADDS     R4,R4,#+1
   \   0000012A   0xE7F6             B.N      ??number_20
    284              while(i-- > 0) *str++ = tmp[i];
   \                     ??number_22: (+1)
   \   0000012C   0x4640             MOV      R0,R8
   \   0000012E   0xF1B0 0x0801      SUBS     R8,R0,#+1
   \   00000132   0x2801             CMP      R0,#+1
   \   00000134   0xDB05             BLT.N    ??number_23
   \   00000136   0x4668             MOV      R0,SP
   \   00000138   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000013C   0x7020             STRB     R0,[R4, #+0]
   \   0000013E   0x1C64             ADDS     R4,R4,#+1
   \   00000140   0xE7F4             B.N      ??number_22
    285              while(size-- > 0) *str++ = ' ';
   \                     ??number_23: (+1)
   \   00000142   0x0018             MOVS     R0,R3
   \   00000144   0x1E43             SUBS     R3,R0,#+1
   \   00000146   0x2801             CMP      R0,#+1
   \   00000148   0xDB03             BLT.N    ??number_24
   \   0000014A   0x2020             MOVS     R0,#+32
   \   0000014C   0x7020             STRB     R0,[R4, #+0]
   \   0000014E   0x1C64             ADDS     R4,R4,#+1
   \   00000150   0xE7F7             B.N      ??number_23
    286          
    287              return str;
   \                     ??number_24: (+1)
   \   00000152   0x0020             MOVS     R0,R4
   \                     ??number_4: (+1)
   \   00000154   0xB011             ADD      SP,SP,#+68
   \   00000156   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    288          }
    289          

   \                                 In section .text, align 2, keep-with-next
    290          static char * eaddr(char *str, unsigned char *addr, int size, int precision, int type)
    291          {
   \                     eaddr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x9C0B             LDR      R4,[SP, #+44]
    292              char tmp[24];
    293              char *dig = digits;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable7
   \   0000000A   0x682D             LDR      R5,[R5, #+0]
    294              int len = 0;
   \   0000000C   0x2600             MOVS     R6,#+0
    295              if (type & LARGE)  dig = upper_digits;
   \   0000000E   0x0667             LSLS     R7,R4,#+25
   \   00000010   0xD503             BPL.N    ??eaddr_0
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable7_1
   \   00000016   0x683F             LDR      R7,[R7, #+0]
   \   00000018   0x003D             MOVS     R5,R7
    296              for (int i = 0; i < 6; i++)
   \                     ??eaddr_0: (+1)
   \   0000001A   0x2700             MOVS     R7,#+0
   \                     ??eaddr_1: (+1)
   \   0000001C   0x2F06             CMP      R7,#+6
   \   0000001E   0xDA1D             BGE.N    ??eaddr_2
    297              {
    298                  if (i != 0) tmp[len++] = ':';
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD005             BEQ.N    ??eaddr_3
   \   00000024   0xF05F 0x0C3A      MOVS     R12,#+58
   \   00000028   0x46EE             MOV      LR,SP
   \   0000002A   0xF806 0xC00E      STRB     R12,[R6, LR]
   \   0000002E   0x1C76             ADDS     R6,R6,#+1
    299                  tmp[len++] = dig[addr[i] >> 4];
   \                     ??eaddr_3: (+1)
   \   00000030   0xF817 0xC001      LDRB     R12,[R7, R1]
   \   00000034   0xEA5F 0x1C2C      ASRS     R12,R12,#+4
   \   00000038   0xF81C 0xC005      LDRB     R12,[R12, R5]
   \   0000003C   0x46EE             MOV      LR,SP
   \   0000003E   0xF806 0xC00E      STRB     R12,[R6, LR]
   \   00000042   0x1C76             ADDS     R6,R6,#+1
    300                  tmp[len++] = dig[addr[i] & 0x0F];
   \   00000044   0xF817 0xC001      LDRB     R12,[R7, R1]
   \   00000048   0xF01C 0x0C0F      ANDS     R12,R12,#0xF
   \   0000004C   0xF81C 0xC005      LDRB     R12,[R12, R5]
   \   00000050   0x46EE             MOV      LR,SP
   \   00000052   0xF806 0xC00E      STRB     R12,[R6, LR]
   \   00000056   0x1C76             ADDS     R6,R6,#+1
    301              }
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \   0000005A   0xE7DF             B.N      ??eaddr_1
    302          
    303              if (!(type & LEFT))
   \                     ??eaddr_2: (+1)
   \   0000005C   0x06E7             LSLS     R7,R4,#+27
   \   0000005E   0xD407             BMI.N    ??eaddr_4
    304              {
    305                  while (len < size--) *str++ = ' ';
   \                     ??eaddr_5: (+1)
   \   00000060   0x0017             MOVS     R7,R2
   \   00000062   0x1E7A             SUBS     R2,R7,#+1
   \   00000064   0x42BE             CMP      R6,R7
   \   00000066   0xDA03             BGE.N    ??eaddr_4
   \   00000068   0x2720             MOVS     R7,#+32
   \   0000006A   0x7007             STRB     R7,[R0, #+0]
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0xE7F7             B.N      ??eaddr_5
    306              }
    307              
    308              for (int i = 0; i < len; ++i)
   \                     ??eaddr_4: (+1)
   \   00000070   0x2700             MOVS     R7,#+0
   \                     ??eaddr_6: (+1)
   \   00000072   0x42B7             CMP      R7,R6
   \   00000074   0xDA07             BGE.N    ??eaddr_7
    309              {
    310                  *str++ = tmp[i];
   \   00000076   0x46EC             MOV      R12,SP
   \   00000078   0xF817 0xC00C      LDRB     R12,[R7, R12]
   \   0000007C   0xF880 0xC000      STRB     R12,[R0, #+0]
   \   00000080   0x1C40             ADDS     R0,R0,#+1
    311              }
   \   00000082   0x1C7F             ADDS     R7,R7,#+1
   \   00000084   0xE7F5             B.N      ??eaddr_6
    312              
    313              while (len < size--) *str++ = ' ';
   \                     ??eaddr_7: (+1)
   \   00000086   0x0017             MOVS     R7,R2
   \   00000088   0x1E7A             SUBS     R2,R7,#+1
   \   0000008A   0x42BE             CMP      R6,R7
   \   0000008C   0xDA03             BGE.N    ??eaddr_8
   \   0000008E   0x2720             MOVS     R7,#+32
   \   00000090   0x7007             STRB     R7,[R0, #+0]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0xE7F7             B.N      ??eaddr_7
    314          
    315              return str;
   \                     ??eaddr_8: (+1)
   \   00000096   0xB006             ADD      SP,SP,#+24
   \   00000098   0xBDF0             POP      {R4-R7,PC}       ;; return
    316          }
    317          

   \                                 In section .text, align 2, keep-with-next
    318          static char * iaddr(char *str, unsigned char *addr, int size, int precision, int type)
    319          {
   \                     iaddr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x9C0B             LDR      R4,[SP, #+44]
    320              char tmp[24];
    321              int len = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    322              for (int i = 0; i < 4; i++)
   \   00000008   0x2600             MOVS     R6,#+0
   \                     ??iaddr_0: (+1)
   \   0000000A   0x2E04             CMP      R6,#+4
   \   0000000C   0xDA62             BGE.N    ??iaddr_1
    323              {
    324                  int n = addr[i];
   \   0000000E   0x5C77             LDRB     R7,[R6, R1]
    325                  if (i != 0) tmp[len++] = '.';
   \   00000010   0x2E00             CMP      R6,#+0
   \   00000012   0xD005             BEQ.N    ??iaddr_2
   \   00000014   0xF05F 0x0C2E      MOVS     R12,#+46
   \   00000018   0x46EE             MOV      LR,SP
   \   0000001A   0xF805 0xC00E      STRB     R12,[R5, LR]
   \   0000001E   0x1C6D             ADDS     R5,R5,#+1
    326                  
    327                  if (0 == n)
   \                     ??iaddr_2: (+1)
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD10A             BNE.N    ??iaddr_3
    328                  {
    329                      tmp[len++] = digits[0];
   \   00000024   0x.... 0x....      LDR.W    R12,??DataTable7
   \   00000028   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   0000002C   0xF89C 0xC000      LDRB     R12,[R12, #+0]
   \   00000030   0x46EE             MOV      LR,SP
   \   00000032   0xF805 0xC00E      STRB     R12,[R5, LR]
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
   \   00000038   0xE04A             B.N      ??iaddr_4
    330                  }
    331                  else
    332                  {
    333                      if (n >= 100) 
   \                     ??iaddr_3: (+1)
   \   0000003A   0x2F64             CMP      R7,#+100
   \   0000003C   0xDB28             BLT.N    ??iaddr_5
    334                      {
    335                          tmp[len++] = digits[n / 100];
   \   0000003E   0xF05F 0x0C64      MOVS     R12,#+100
   \   00000042   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   00000046   0x.... 0x....      LDR.W    LR,??DataTable7
   \   0000004A   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   0000004E   0xF81C 0xC00E      LDRB     R12,[R12, LR]
   \   00000052   0x46EE             MOV      LR,SP
   \   00000054   0xF805 0xC00E      STRB     R12,[R5, LR]
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
    336                          n %= 100;
   \   0000005A   0xF05F 0x0C64      MOVS     R12,#+100
   \   0000005E   0xFB97 0xFEFC      SDIV     LR,R7,R12
   \   00000062   0xFB0C 0x771E      MLS      R7,R12,LR,R7
    337                          tmp[len++] = digits[n / 10];
   \   00000066   0xF05F 0x0C0A      MOVS     R12,#+10
   \   0000006A   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   0000006E   0x.... 0x....      LDR.W    LR,??DataTable7
   \   00000072   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   00000076   0xF81C 0xC00E      LDRB     R12,[R12, LR]
   \   0000007A   0x46EE             MOV      LR,SP
   \   0000007C   0xF805 0xC00E      STRB     R12,[R5, LR]
   \   00000080   0x1C6D             ADDS     R5,R5,#+1
    338                          n %= 10;
   \   00000082   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000086   0xFB97 0xFEFC      SDIV     LR,R7,R12
   \   0000008A   0xFB0C 0x771E      MLS      R7,R12,LR,R7
   \   0000008E   0xE015             B.N      ??iaddr_6
    339                      }
    340                      else if (n >= 10)
   \                     ??iaddr_5: (+1)
   \   00000090   0x2F0A             CMP      R7,#+10
   \   00000092   0xDB13             BLT.N    ??iaddr_6
    341                      {
    342                          tmp[len++] = digits[n / 10];
   \   00000094   0xF05F 0x0C0A      MOVS     R12,#+10
   \   00000098   0xFB97 0xFCFC      SDIV     R12,R7,R12
   \   0000009C   0x.... 0x....      LDR.W    LR,??DataTable7
   \   000000A0   0xF8DE 0xE000      LDR      LR,[LR, #+0]
   \   000000A4   0xF81C 0xC00E      LDRB     R12,[R12, LR]
   \   000000A8   0x46EE             MOV      LR,SP
   \   000000AA   0xF805 0xC00E      STRB     R12,[R5, LR]
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
    343                          n %= 10;
   \   000000B0   0xF05F 0x0C0A      MOVS     R12,#+10
   \   000000B4   0xFB97 0xFEFC      SDIV     LR,R7,R12
   \   000000B8   0xFB0C 0x771E      MLS      R7,R12,LR,R7
    344                      }
    345          
    346                      tmp[len++] = digits[n];
   \                     ??iaddr_6: (+1)
   \   000000BC   0x.... 0x....      LDR.W    R12,??DataTable7
   \   000000C0   0xF8DC 0xC000      LDR      R12,[R12, #+0]
   \   000000C4   0xF817 0x700C      LDRB     R7,[R7, R12]
   \   000000C8   0x46EC             MOV      R12,SP
   \   000000CA   0xF805 0x700C      STRB     R7,[R5, R12]
   \   000000CE   0x1C6D             ADDS     R5,R5,#+1
    347                  }
    348              }
   \                     ??iaddr_4: (+1)
   \   000000D0   0x1C76             ADDS     R6,R6,#+1
   \   000000D2   0xE79A             B.N      ??iaddr_0
    349          
    350              if (!(type & LEFT))
   \                     ??iaddr_1: (+1)
   \   000000D4   0x06E6             LSLS     R6,R4,#+27
   \   000000D6   0xD407             BMI.N    ??iaddr_7
    351              {
    352                  while(len < size--) *str++ = ' ';
   \                     ??iaddr_8: (+1)
   \   000000D8   0x0016             MOVS     R6,R2
   \   000000DA   0x1E72             SUBS     R2,R6,#+1
   \   000000DC   0x42B5             CMP      R5,R6
   \   000000DE   0xDA03             BGE.N    ??iaddr_7
   \   000000E0   0x2620             MOVS     R6,#+32
   \   000000E2   0x7006             STRB     R6,[R0, #+0]
   \   000000E4   0x1C40             ADDS     R0,R0,#+1
   \   000000E6   0xE7F7             B.N      ??iaddr_8
    353              }
    354              
    355              for (int i = 0; i < len; ++i)
   \                     ??iaddr_7: (+1)
   \   000000E8   0x2600             MOVS     R6,#+0
   \                     ??iaddr_9: (+1)
   \   000000EA   0x42AE             CMP      R6,R5
   \   000000EC   0xDA05             BGE.N    ??iaddr_10
    356              {
    357                  *str++ = tmp[i];
   \   000000EE   0x466F             MOV      R7,SP
   \   000000F0   0x5DF7             LDRB     R7,[R6, R7]
   \   000000F2   0x7007             STRB     R7,[R0, #+0]
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
    358              }
   \   000000F6   0x1C76             ADDS     R6,R6,#+1
   \   000000F8   0xE7F7             B.N      ??iaddr_9
    359              
    360              while (len < size--) *str++ = ' ';
   \                     ??iaddr_10: (+1)
   \   000000FA   0x0016             MOVS     R6,R2
   \   000000FC   0x1E72             SUBS     R2,R6,#+1
   \   000000FE   0x42B5             CMP      R5,R6
   \   00000100   0xDA03             BGE.N    ??iaddr_11
   \   00000102   0x2620             MOVS     R6,#+32
   \   00000104   0x7006             STRB     R6,[R0, #+0]
   \   00000106   0x1C40             ADDS     R0,R0,#+1
   \   00000108   0xE7F7             B.N      ??iaddr_10
    361              
    362              return str;
   \                     ??iaddr_11: (+1)
   \   0000010A   0xB006             ADD      SP,SP,#+24
   \   0000010C   0xBDF0             POP      {R4-R7,PC}       ;; return
    363          }
    364          
    365          #ifndef NOFLOAT

   \                                 In section .text, align 2, keep-with-next
    366          static char * ftoaE(char* pchBuffer, int dppos, double value)
    367          {
   \                     ftoaE: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x0006             MOVS     R6,R0
   \   00000008   0x0014             MOVS     R4,R2
   \   0000000A   0x001D             MOVS     R5,R3
    368              double roundingValue = 0.5;
   \   0000000C   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000010   0x.... 0x....      LDR.W    R11,??DataTable7_2  ;; 0x3fe00000
    369              int roundingPos = dppos;
   \   00000014   0x9804             LDR      R0,[SP, #+16]
   \   00000016   0x9001             STR      R0,[SP, #+4]
    370              double temp = value;
   \   00000018   0x46A0             MOV      R8,R4
   \   0000001A   0x46A9             MOV      R9,R5
    371              int exp = 0;    // Exponent value
   \   0000001C   0x2700             MOVS     R7,#+0
    372              char * pch = pchBuffer;
   \   0000001E   0x9602             STR      R6,[SP, #+8]
    373              if(0 == pchBuffer) return 0;
   \   00000020   0x2E00             CMP      R6,#+0
   \   00000022   0xD101             BNE.N    ??ftoaE_0
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE0D2             B.N      ??ftoaE_1
    374              // Process value sign
    375              if (value < 0.0)
   \                     ??ftoaE_0: (+1)
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2300             MOVS     R3,#+0
   \   00000030   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000034   0xD205             BCS.N    ??ftoaE_2
    376              {
    377                  value = -value;
   \   00000036   0xF095 0x4500      EORS     R5,R5,#0x80000000
    378                  *pchBuffer++ = '-';
   \   0000003A   0x202D             MOVS     R0,#+45
   \   0000003C   0x7030             STRB     R0,[R6, #+0]
   \   0000003E   0x1C76             ADDS     R6,R6,#+1
   \   00000040   0xE002             B.N      ??ftoaE_3
    379              }
    380              else
    381              {
    382                  *pchBuffer++ = '+';
   \                     ??ftoaE_2: (+1)
   \   00000042   0x202B             MOVS     R0,#+43
   \   00000044   0x7030             STRB     R0,[R6, #+0]
   \   00000046   0x1C76             ADDS     R6,R6,#+1
    383              }
    384          
    385              // Round value and get exponent
    386              if(!IS_DOUBLE_ZERO(value))  /*if (value != 0.0)*/
   \                     ??ftoaE_3: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x0029             MOVS     R1,R5
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable7_3  ;; 0x2c40c60e
   \   00000050   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x31fa18
   \   00000054   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000058   0xD208             BCS.N    ??ftoaE_4
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x0029             MOVS     R1,R5
   \   0000005E   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x2c40c60d
   \   00000062   0x.... 0x....      LDR.W    R3,??DataTable8_1  ;; 0x8031fa18
   \   00000066   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000006A   0xD974             BLS.N    ??ftoaE_5
    387              {
    388                  // Get exponent of unrounded value for rounding
    389                  temp = value;
   \                     ??ftoaE_4: (+1)
   \   0000006C   0x46A0             MOV      R8,R4
   \   0000006E   0x46A9             MOV      R9,R5
    390                  exp = 0;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x0007             MOVS     R7,R0
    391                  while(temp < 1.0)
   \                     ??ftoaE_6: (+1)
   \   00000074   0x4640             MOV      R0,R8
   \   00000076   0x4649             MOV      R1,R9
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x.... 0x....      LDR.W    R3,??DataTable8_2  ;; 0x3ff00000
   \   0000007E   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000082   0xD20A             BCS.N    ??ftoaE_7
    392                  {
    393                      temp *= 10.0;
   \   00000084   0x4642             MOV      R2,R8
   \   00000086   0x464B             MOV      R3,R9
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x40240000
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x4680             MOV      R8,R0
   \   00000094   0x4689             MOV      R9,R1
    394                      exp--;
   \   00000096   0x1E7F             SUBS     R7,R7,#+1
   \   00000098   0xE7EC             B.N      ??ftoaE_6
    395                  }
    396                  while(temp >= 10.0)
   \                     ??ftoaE_7: (+1)
   \   0000009A   0x4640             MOV      R0,R8
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x2200             MOVS     R2,#+0
   \   000000A0   0x.... 0x....      LDR.W    R3,??DataTable8_3  ;; 0x40240000
   \   000000A4   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000A8   0xD80B             BHI.N    ??ftoaE_8
    397                  {
    398                      temp *= 0.1;
   \   000000AA   0x4642             MOV      R2,R8
   \   000000AC   0x464B             MOV      R3,R9
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x9999999a
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x3fb99999
   \   000000B6   0x.... 0x....      BL       __aeabi_dmul
   \   000000BA   0x4680             MOV      R8,R0
   \   000000BC   0x4689             MOV      R9,R1
    399                      exp++;
   \   000000BE   0x1C7F             ADDS     R7,R7,#+1
   \   000000C0   0xE7EB             B.N      ??ftoaE_7
    400                  }
    401          
    402                  // Round value
    403                  if(dppos < 0) roundingPos = 0;
   \                     ??ftoaE_8: (+1)
   \   000000C2   0x9804             LDR      R0,[SP, #+16]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD501             BPL.N    ??ftoaE_9
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x9001             STR      R0,[SP, #+4]
    404                  
    405                  for(int i = (roundingPos - exp); i > 0; i--)
   \                     ??ftoaE_9: (+1)
   \   000000CC   0x9801             LDR      R0,[SP, #+4]
   \   000000CE   0x1BC0             SUBS     R0,R0,R7
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \                     ??ftoaE_10: (+1)
   \   000000D2   0x9800             LDR      R0,[SP, #+0]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xDB0D             BLT.N    ??ftoaE_11
    406                  {
    407                      roundingValue *= 0.1;
   \   000000D8   0x4652             MOV      R2,R10
   \   000000DA   0x465B             MOV      R3,R11
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x9999999a
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x3fb99999
   \   000000E4   0x.... 0x....      BL       __aeabi_dmul
   \   000000E8   0x4682             MOV      R10,R0
   \   000000EA   0x468B             MOV      R11,R1
    408                  }
   \   000000EC   0x9800             LDR      R0,[SP, #+0]
   \   000000EE   0x1E40             SUBS     R0,R0,#+1
   \   000000F0   0x9000             STR      R0,[SP, #+0]
   \   000000F2   0xE7EE             B.N      ??ftoaE_10
    409                  value += roundingValue;
   \                     ??ftoaE_11: (+1)
   \   000000F4   0x4652             MOV      R2,R10
   \   000000F6   0x465B             MOV      R3,R11
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x0029             MOVS     R1,R5
   \   000000FC   0x.... 0x....      BL       __aeabi_dadd
   \   00000100   0x0004             MOVS     R4,R0
   \   00000102   0x000D             MOVS     R5,R1
    410          
    411                  // Get exponent of rounded value and limit value to 9.999...1.000
    412                  exp = 0;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x0007             MOVS     R7,R0
    413                  while(value < 1.0)
   \                     ??ftoaE_12: (+1)
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0x0029             MOVS     R1,R5
   \   0000010C   0x2200             MOVS     R2,#+0
   \   0000010E   0x.... 0x....      LDR.W    R3,??DataTable8_2  ;; 0x3ff00000
   \   00000112   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000116   0xD20A             BCS.N    ??ftoaE_13
    414                  {
    415                      value *= 10.0;
   \   00000118   0x0022             MOVS     R2,R4
   \   0000011A   0x002B             MOVS     R3,R5
   \   0000011C   0x2000             MOVS     R0,#+0
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x40240000
   \   00000122   0x.... 0x....      BL       __aeabi_dmul
   \   00000126   0x0004             MOVS     R4,R0
   \   00000128   0x000D             MOVS     R5,R1
    416                      exp--;
   \   0000012A   0x1E7F             SUBS     R7,R7,#+1
   \   0000012C   0xE7EC             B.N      ??ftoaE_12
    417                  }
    418                  while(value >= 10.0)
   \                     ??ftoaE_13: (+1)
   \   0000012E   0x0020             MOVS     R0,R4
   \   00000130   0x0029             MOVS     R1,R5
   \   00000132   0x2200             MOVS     R2,#+0
   \   00000134   0x.... 0x....      LDR.W    R3,??DataTable8_3  ;; 0x40240000
   \   00000138   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000013C   0xD80B             BHI.N    ??ftoaE_5
    419                  {
    420                      value *= 0.1;
   \   0000013E   0x0022             MOVS     R2,R4
   \   00000140   0x002B             MOVS     R3,R5
   \   00000142   0x.... 0x....      LDR.W    R0,??DataTable8_4  ;; 0x9999999a
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable8_5  ;; 0x3fb99999
   \   0000014A   0x.... 0x....      BL       __aeabi_dmul
   \   0000014E   0x0004             MOVS     R4,R0
   \   00000150   0x000D             MOVS     R5,R1
    421                      exp++;
   \   00000152   0x1C7F             ADDS     R7,R7,#+1
   \   00000154   0xE7EB             B.N      ??ftoaE_13
    422                  }
    423              }
    424          
    425              // Compose mantissa output string
    426              for (int i = ((dppos < 0) ? 1 : (dppos + 1) - 1); i >= 0; i--)
   \                     ??ftoaE_5: (+1)
   \   00000156   0x9804             LDR      R0,[SP, #+16]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD502             BPL.N    ??ftoaE_14
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x9000             STR      R0,[SP, #+0]
   \   00000160   0xE001             B.N      ??ftoaE_15
   \                     ??ftoaE_14: (+1)
   \   00000162   0x9804             LDR      R0,[SP, #+16]
   \   00000164   0x9000             STR      R0,[SP, #+0]
   \                     ??ftoaE_15: (+1)
   \   00000166   0x9800             LDR      R0,[SP, #+0]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD428             BMI.N    ??ftoaE_16
    427              {
    428                  // Output digit
    429                  int digit = (int)value % 10;
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x0029             MOVS     R1,R5
   \   00000170   0x.... 0x....      BL       __aeabi_d2iz
   \   00000174   0x210A             MOVS     R1,#+10
   \   00000176   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \   0000017A   0xFB01 0x0012      MLS      R0,R1,R2,R0
    430                  *pchBuffer++ = (char)(digit + '0');
   \   0000017E   0xF110 0x0130      ADDS     R1,R0,#+48
   \   00000182   0x7031             STRB     R1,[R6, #+0]
   \   00000184   0x1C76             ADDS     R6,R6,#+1
    431          
    432                  // Output decimal point
    433                  if (i == dppos) *pchBuffer++ = '.';
   \   00000186   0x9900             LDR      R1,[SP, #+0]
   \   00000188   0x9A04             LDR      R2,[SP, #+16]
   \   0000018A   0x4291             CMP      R1,R2
   \   0000018C   0xD102             BNE.N    ??ftoaE_17
   \   0000018E   0x212E             MOVS     R1,#+46
   \   00000190   0x7031             STRB     R1,[R6, #+0]
   \   00000192   0x1C76             ADDS     R6,R6,#+1
    434          
    435                  value = (value - (double)digit) * 10.0;
   \                     ??ftoaE_17: (+1)
   \   00000194   0x.... 0x....      BL       __aeabi_i2d
   \   00000198   0x0002             MOVS     R2,R0
   \   0000019A   0x000B             MOVS     R3,R1
   \   0000019C   0x0020             MOVS     R0,R4
   \   0000019E   0x0029             MOVS     R1,R5
   \   000001A0   0x.... 0x....      BL       __aeabi_dsub
   \   000001A4   0x0002             MOVS     R2,R0
   \   000001A6   0x000B             MOVS     R3,R1
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0x.... 0x....      LDR.W    R1,??DataTable8_3  ;; 0x40240000
   \   000001AE   0x.... 0x....      BL       __aeabi_dmul
   \   000001B2   0x0004             MOVS     R4,R0
   \   000001B4   0x000D             MOVS     R5,R1
    436              }
   \   000001B6   0x9800             LDR      R0,[SP, #+0]
   \   000001B8   0x1E40             SUBS     R0,R0,#+1
   \   000001BA   0x9000             STR      R0,[SP, #+0]
   \   000001BC   0xE7D3             B.N      ??ftoaE_15
    437          
    438              // Compose exponent output string
    439              *pchBuffer++ = 'E';
   \                     ??ftoaE_16: (+1)
   \   000001BE   0x2045             MOVS     R0,#+69
   \   000001C0   0x7030             STRB     R0,[R6, #+0]
   \   000001C2   0x1C76             ADDS     R6,R6,#+1
    440              itoa(exp, pchBuffer);
   \   000001C4   0x0031             MOVS     R1,R6
   \   000001C6   0x0038             MOVS     R0,R7
   \   000001C8   0x.... 0x....      BL       itoa
    441          
    442              return pch;
   \   000001CC   0x9802             LDR      R0,[SP, #+8]
   \                     ??ftoaE_1: (+1)
   \   000001CE   0xB005             ADD      SP,SP,#+20
   \   000001D0   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    443          }
    444          
    445          #define MAX_DIGITS     15

   \                                 In section .text, align 2, keep-with-next
    446          static char * ftoa(double dValue, char * chBuffer)
    447          {
   \                     my_ftoa: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x4693             MOV      R11,R2
    448              char * pch = chBuffer;
   \   0000000A   0x465E             MOV      R6,R11
    449              if(!pch) return 0;
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD101             BNE.N    ??my_ftoa_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE08E             B.N      ??my_ftoa_1
    450              if(!IS_DOUBLE_ZERO(dValue))
   \                     ??my_ftoa_0: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0x0029             MOVS     R1,R5
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable7_3  ;; 0x2c40c60e
   \   0000001C   0x.... 0x....      LDR.W    R3,??DataTable7_4  ;; 0x31fa18
   \   00000020   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000024   0xD208             BCS.N    ??my_ftoa_2
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x0029             MOVS     R1,R5
   \   0000002A   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x2c40c60d
   \   0000002E   0x.... 0x....      LDR.W    R3,??DataTable8_1  ;; 0x8031fa18
   \   00000032   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000036   0xD975             BLS.N    ??my_ftoa_3
    451              {
    452                  double dRound = 5;
   \                     ??my_ftoa_2: (+1)
   \   00000038   0xF05F 0x0800      MOVS     R8,#+0
   \   0000003C   0x.... 0x....      LDR.W    R9,??DataTable8_6  ;; 0x40140000
    453                  if(dValue < 0)
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x0029             MOVS     R1,R5
   \   00000044   0x2200             MOVS     R2,#+0
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000004C   0xD205             BCS.N    ??my_ftoa_4
    454                  {
    455                      *pch++ = '-';
   \   0000004E   0x202D             MOVS     R0,#+45
   \   00000050   0x7030             STRB     R0,[R6, #+0]
   \   00000052   0x1C76             ADDS     R6,R6,#+1
    456                      dValue = -dValue;
   \   00000054   0xF095 0x4500      EORS     R5,R5,#0x80000000
   \   00000058   0xE002             B.N      ??my_ftoa_5
    457                  }
    458                  else
    459                  {
    460                      *pch++ = '+';
   \                     ??my_ftoa_4: (+1)
   \   0000005A   0x202B             MOVS     R0,#+43
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
    461                  }
    462                  itoa((int)dValue, pch);
   \                     ??my_ftoa_5: (+1)
   \   00000060   0x0031             MOVS     R1,R6
   \   00000062   0x000E             MOVS     R6,R1
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x0029             MOVS     R1,R5
   \   00000068   0x.... 0x....      BL       __aeabi_d2iz
   \   0000006C   0x0031             MOVS     R1,R6
   \   0000006E   0x.... 0x....      BL       itoa
    463                  unsigned char ucLen = strlen(pch);
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0x.... 0x....      BL       strlen
   \   00000078   0x4682             MOV      R10,R0
    464                  pch += ucLen;
   \   0000007A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000007E   0xEB1A 0x0606      ADDS     R6,R10,R6
    465                  *pch++ = '.';
   \   00000082   0x202E             MOVS     R0,#+46
   \   00000084   0x7030             STRB     R0,[R6, #+0]
   \   00000086   0x1C76             ADDS     R6,R6,#+1
    466                  dValue -= (int)dValue;
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x0029             MOVS     R1,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000090   0x.... 0x....      BL       __aeabi_i2d
   \   00000094   0x0002             MOVS     R2,R0
   \   00000096   0x000B             MOVS     R3,R1
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x0029             MOVS     R1,R5
   \   0000009C   0x.... 0x....      BL       __aeabi_dsub
   \   000000A0   0x0004             MOVS     R4,R0
   \   000000A2   0x000D             MOVS     R5,R1
    467                  ucLen = MAX_DIGITS - ucLen;
   \   000000A4   0xF1DA 0x0A0F      RSBS     R10,R10,#+15
    468                  for(int i = 0; i < MAX_DIGITS; i++) dRound *= 0.1;
   \   000000A8   0x2700             MOVS     R7,#+0
   \                     ??my_ftoa_6: (+1)
   \   000000AA   0x2F0F             CMP      R7,#+15
   \   000000AC   0xDA0B             BGE.N    ??my_ftoa_7
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0x4649             MOV      R1,R9
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable8_4  ;; 0x9999999a
   \   000000B6   0x.... 0x....      LDR.W    R3,??DataTable8_5  ;; 0x3fb99999
   \   000000BA   0x.... 0x....      BL       __aeabi_dmul
   \   000000BE   0x4680             MOV      R8,R0
   \   000000C0   0x4689             MOV      R9,R1
   \   000000C2   0x1C7F             ADDS     R7,R7,#+1
   \   000000C4   0xE7F1             B.N      ??my_ftoa_6
    469                  
    470                  for(int i = 0; i < ucLen; i++)
   \                     ??my_ftoa_7: (+1)
   \   000000C6   0x2700             MOVS     R7,#+0
   \                     ??my_ftoa_8: (+1)
   \   000000C8   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000CC   0x4557             CMP      R7,R10
   \   000000CE   0xDA2E             BGE.N    ??my_ftoa_9
    471                  {
    472                      dValue = (dValue + dRound) * 10;
   \   000000D0   0x4642             MOV      R2,R8
   \   000000D2   0x464B             MOV      R3,R9
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x0029             MOVS     R1,R5
   \   000000D8   0x.... 0x....      BL       __aeabi_dadd
   \   000000DC   0x2200             MOVS     R2,#+0
   \   000000DE   0x.... 0x....      LDR.W    R3,??DataTable8_3  ;; 0x40240000
   \   000000E2   0x.... 0x....      BL       __aeabi_dmul
   \   000000E6   0x0004             MOVS     R4,R0
   \   000000E8   0x000D             MOVS     R5,R1
    473                      itoa((int)dValue, pch);
   \   000000EA   0x0031             MOVS     R1,R6
   \   000000EC   0x000E             MOVS     R6,R1
   \   000000EE   0x0020             MOVS     R0,R4
   \   000000F0   0x0029             MOVS     R1,R5
   \   000000F2   0x.... 0x....      BL       __aeabi_d2iz
   \   000000F6   0x0031             MOVS     R1,R6
   \   000000F8   0x.... 0x....      BL       itoa
    474                      pch += strlen(pch);
   \   000000FC   0x0030             MOVS     R0,R6
   \   000000FE   0x.... 0x....      BL       strlen
   \   00000102   0x1986             ADDS     R6,R0,R6
    475                      dValue -= (int)dValue;
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x0029             MOVS     R1,R5
   \   00000108   0x.... 0x....      BL       __aeabi_d2iz
   \   0000010C   0x.... 0x....      BL       __aeabi_i2d
   \   00000110   0x0002             MOVS     R2,R0
   \   00000112   0x000B             MOVS     R3,R1
   \   00000114   0x0020             MOVS     R0,R4
   \   00000116   0x0029             MOVS     R1,R5
   \   00000118   0x.... 0x....      BL       __aeabi_dsub
   \   0000011C   0x0004             MOVS     R4,R0
   \   0000011E   0x000D             MOVS     R5,R1
    476                  }
   \   00000120   0x1C7F             ADDS     R7,R7,#+1
   \   00000122   0xE7D1             B.N      ??my_ftoa_8
    477              }
    478              else
    479              {
    480                  *pch++ = '0';
   \                     ??my_ftoa_3: (+1)
   \   00000124   0x2030             MOVS     R0,#+48
   \   00000126   0x7030             STRB     R0,[R6, #+0]
   \   00000128   0x1C76             ADDS     R6,R6,#+1
    481                  *pch = '\0';
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x7030             STRB     R0,[R6, #+0]
    482              }
    483              pch--;
   \                     ??my_ftoa_9: (+1)
   \   0000012E   0x1E76             SUBS     R6,R6,#+1
    484              //while ('0' == *pch) *pch-- = '\0';
    485              return chBuffer;
   \   00000130   0x4658             MOV      R0,R11
   \                     ??my_ftoa_1: (+1)
   \   00000132   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          static void __ecvround(char *numbuf, char *last_digit, const char *after_last, int *decpt)
    489          {
   \                     __ecvround: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    490              /* Do we have at all to round the last digit?  */
    491              if (*after_last > '4')
   \   00000002   0x7814             LDRB     R4,[R2, #+0]
   \   00000004   0x2C35             CMP      R4,#+53
   \   00000006   0xDB1A             BLT.N    ??__ecvround_0
    492              {
    493                  char *p = last_digit;
   \   00000008   0x000C             MOVS     R4,R1
    494                  int carry = 1;
   \   0000000A   0x2501             MOVS     R5,#+1
    495          
    496                  /* Propagate the rounding through trailing '9' digits.  */
    497                  do
    498                  {
    499                      int sum = *p + carry;
   \                     ??__ecvround_1: (+1)
   \   0000000C   0x7826             LDRB     R6,[R4, #+0]
   \   0000000E   0x19AE             ADDS     R6,R5,R6
    500                      carry = sum > '9';
   \   00000010   0x2E3A             CMP      R6,#+58
   \   00000012   0xDB01             BLT.N    ??__ecvround_2
   \   00000014   0x2501             MOVS     R5,#+1
   \   00000016   0xE000             B.N      ??__ecvround_3
   \                     ??__ecvround_2: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
    501                      *p-- = sum - carry * 10;
   \                     ??__ecvround_3: (+1)
   \   0000001A   0x270A             MOVS     R7,#+10
   \   0000001C   0xFB07 0x6615      MLS      R6,R7,R5,R6
   \   00000020   0x7026             STRB     R6,[R4, #+0]
   \   00000022   0x1E64             SUBS     R4,R4,#+1
    502                  } while (carry && p >= numbuf);
   \   00000024   0x2D00             CMP      R5,#+0
   \   00000026   0xD001             BEQ.N    ??__ecvround_4
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD2EF             BCS.N    ??__ecvround_1
    503          
    504                  /* We have 9999999... which needs to be rounded to 100000..  */
    505                  if (carry && p == numbuf)
   \                     ??__ecvround_4: (+1)
   \   0000002C   0x2D00             CMP      R5,#+0
   \   0000002E   0xD006             BEQ.N    ??__ecvround_0
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xD104             BNE.N    ??__ecvround_0
    506                  {
    507                      *p = '1';
   \   00000034   0x2631             MOVS     R6,#+49
   \   00000036   0x7026             STRB     R6,[R4, #+0]
    508                      *decpt += 1;
   \   00000038   0x681E             LDR      R6,[R3, #+0]
   \   0000003A   0x1C76             ADDS     R6,R6,#+1
   \   0000003C   0x601E             STR      R6,[R3, #+0]
    509                  }
    510              }
    511          }
   \                     ??__ecvround_0: (+1)
   \   0000003E   0xBCF0             POP      {R4-R7}
   \   00000040   0x4770             BX       LR               ;; return
    512          
    513          //char *ecvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);
    514          //char *fcvtbuf(double arg, int ndigits, int *decpt, int *sign, char *buf);

   \                                 In section .text, align 2, keep-with-next
    515          static char * ecvtbuf (double value, int ndigits, int *decpt, int *sign, char *buf)
    516          {
   \                     ecvtbuf: (+1)
   \   00000000   0xE92D 0x4FFB      PUSH     {R0,R1,R3-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x0014             MOVS     R4,R2
   \   00000008   0x001D             MOVS     R5,R3
   \   0000000A   0x9E13             LDR      R6,[SP, #+76]
    517              static char INFINITY[] = "Infinity";
    518              char chBuffer[20];
    519              char decimal = '.' /* localeconv()->decimal_point[0] */;
   \   0000000C   0x202E             MOVS     R0,#+46
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    520              //char *cvtbuf = (char *)malloc(ndigits + 20); /* +3 for sign, dot, null; */
    521              if (ndigits > 15) ndigits = 15;
   \   00000012   0x2C10             CMP      R4,#+16
   \   00000014   0xDB01             BLT.N    ??ecvtbuf_0
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0x0004             MOVS     R4,R0
    522              memset(chBuffer, 0, sizeof(chBuffer));
   \                     ??ecvtbuf_0: (+1)
   \   0000001A   0xF05F 0x0B14      MOVS     R11,#+20
   \   0000001E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000022   0xAF01             ADD      R7,SP,#+4
   \   00000024   0x4652             MOV      R2,R10
   \   00000026   0x4659             MOV      R1,R11
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x.... 0x....      BL       __aeabi_memset
    523              char *cvtbuf = chBuffer; /* new char(ndigits + 20 + 1);*/
   \   0000002E   0xAF01             ADD      R7,SP,#+4
    524              /* two extra for rounding */
    525              /* 15 extra for alignment */
    526              char *s = cvtbuf, *d = buf;
   \   00000030   0x46B8             MOV      R8,R7
   \   00000032   0x46B1             MOV      R9,R6
    527              
    528              /* Produce two extra digits, so we could round properly.  */
    529              //sprintf (cvtbuf, "%-+.*E", ndigits + 2, value);
    530              /* add by wdg*/
    531              ftoaE(cvtbuf, ndigits + 2, value);
   \   00000034   0xE9DD 0x2306      LDRD     R2,R3,[SP, #+24]
   \   00000038   0x1CA1             ADDS     R1,R4,#+2
   \   0000003A   0x0038             MOVS     R0,R7
   \   0000003C   0x.... 0x....      BL       ftoaE
    532          
    533              /* add end*/
    534              *decpt = 0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x6028             STR      R0,[R5, #+0]
    535              
    536              /* The sign.  */
    537              *sign = ('=' == *s++) ? 1 : 0;
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0xF110 0x0801      ADDS     R8,R0,#+1
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x283D             CMP      R0,#+61
   \   0000004E   0xD101             BNE.N    ??ecvtbuf_1
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE000             B.N      ??ecvtbuf_2
   \                     ??ecvtbuf_1: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??ecvtbuf_2: (+1)
   \   00000056   0x9912             LDR      R1,[SP, #+72]
   \   00000058   0x6008             STR      R0,[R1, #+0]
    538              /* Special values get special treatment.  */
    539              if (strncmp(s, "Inf", 3) == 0)
   \   0000005A   0x2203             MOVS     R2,#+3
   \   0000005C   0x....             ADR.N    R1,??DataTable6  ;; "Inf"
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       strncmp
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD112             BNE.N    ??ecvtbuf_3
    540              {
    541                  /* SunOS docs says we have return "Infinity" for NDIGITS >= 8.  */
    542                  memcpy (buf, INFINITY, ndigits >= 8 ? 9 : 3);
   \   00000068   0x2C08             CMP      R4,#+8
   \   0000006A   0xDB02             BLT.N    ??ecvtbuf_4
   \   0000006C   0xF05F 0x0A09      MOVS     R10,#+9
   \   00000070   0xE001             B.N      ??ecvtbuf_5
   \                     ??ecvtbuf_4: (+1)
   \   00000072   0xF05F 0x0A03      MOVS     R10,#+3
   \                     ??ecvtbuf_5: (+1)
   \   00000076   0x.... 0x....      LDR.W    R11,??DataTable8_7
   \   0000007A   0x4652             MOV      R2,R10
   \   0000007C   0x4659             MOV      R1,R11
   \   0000007E   0x0030             MOVS     R0,R6
   \   00000080   0x.... 0x....      BL       __aeabi_memcpy
    543                  if (ndigits < 8) buf[3] = '\0';
   \   00000084   0x2C08             CMP      R4,#+8
   \   00000086   0xDA6F             BGE.N    ??ecvtbuf_6
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x70F0             STRB     R0,[R6, #+3]
   \   0000008C   0xE06C             B.N      ??ecvtbuf_6
    544              }
    545              else if (strcmp(s, "NaN") == 0)
   \                     ??ecvtbuf_3: (+1)
   \   0000008E   0x....             ADR.N    R1,??DataTable6_1  ;; "NaN"
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       strcmp
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD107             BNE.N    ??ecvtbuf_7
    546              {
    547                  memcpy(buf, s, 4);
   \   0000009A   0xF05F 0x0A04      MOVS     R10,#+4
   \   0000009E   0x4652             MOV      R2,R10
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x0030             MOVS     R0,R6
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy
    548              }
   \   000000A8   0xE05E             B.N      ??ecvtbuf_6
    549              else
    550              {
    551                  char *last_digit, *digit_after_last;
    552                  
    553                  /* Copy (the single) digit before the decimal.  */
    554                  while (*s && *s != decimal && d - buf < ndigits)
   \                     ??ecvtbuf_7: (+1)
   \                     ??ecvtbuf_8: (+1)
   \   000000AA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD012             BEQ.N    ??ecvtbuf_9
   \   000000B2   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000B6   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   000000BA   0x4288             CMP      R0,R1
   \   000000BC   0xD00C             BEQ.N    ??ecvtbuf_9
   \   000000BE   0xEBB9 0x0006      SUBS     R0,R9,R6
   \   000000C2   0x42A0             CMP      R0,R4
   \   000000C4   0xDA08             BGE.N    ??ecvtbuf_9
    555                      *d++ = *s++;
   \   000000C6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000CA   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000CE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000D2   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000D6   0xE7E8             B.N      ??ecvtbuf_8
    556                  
    557                  /* If we don't see any exponent, here's our decimal point.  */
    558                  *decpt = d - buf;
   \                     ??ecvtbuf_9: (+1)
   \   000000D8   0xEBB9 0x0006      SUBS     R0,R9,R6
   \   000000DC   0x6028             STR      R0,[R5, #+0]
    559                  if(*s) s++;
   \   000000DE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD001             BEQ.N    ??ecvtbuf_10
   \   000000E6   0xF118 0x0801      ADDS     R8,R8,#+1
    560                  
    561                  /* Copy the fraction digits.  */
    562                  while (*s && *s != 'E' && d - buf < ndigits)
   \                     ??ecvtbuf_10: (+1)
   \   000000EA   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD010             BEQ.N    ??ecvtbuf_11
   \   000000F2   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000F6   0x2845             CMP      R0,#+69
   \   000000F8   0xD00C             BEQ.N    ??ecvtbuf_11
   \   000000FA   0xEBB9 0x0006      SUBS     R0,R9,R6
   \   000000FE   0x42A0             CMP      R0,R4
   \   00000100   0xDA08             BGE.N    ??ecvtbuf_11
    563                      *d++ = *s++;
   \   00000102   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000106   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   0000010A   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000010E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000112   0xE7EA             B.N      ??ecvtbuf_10
    564                  
    565                  /* Remember the last digit copied and the one after it.  */
    566                  last_digit = d > buf ? (d - 1) : d;
   \                     ??ecvtbuf_11: (+1)
   \   00000114   0x454E             CMP      R6,R9
   \   00000116   0xD202             BCS.N    ??ecvtbuf_12
   \   00000118   0xF1B9 0x0B01      SUBS     R11,R9,#+1
   \   0000011C   0xE000             B.N      ??ecvtbuf_13
   \                     ??ecvtbuf_12: (+1)
   \   0000011E   0x46CB             MOV      R11,R9
    567                  digit_after_last = s;
   \                     ??ecvtbuf_13: (+1)
   \   00000120   0x46C2             MOV      R10,R8
    568                  
    569                  /* Get past the E in exponent field.  */
    570                  while (*s && *s++ != 'E');
   \                     ??ecvtbuf_14: (+1)
   \   00000122   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000126   0x2800             CMP      R0,#+0
   \   00000128   0xD005             BEQ.N    ??ecvtbuf_15
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0xF110 0x0801      ADDS     R8,R0,#+1
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x2845             CMP      R0,#+69
   \   00000134   0xD1F5             BNE.N    ??ecvtbuf_14
    571                  
    572                  /* Adjust the decimal point by the exponent value.  */
    573                  *decpt += atoi (s);
   \                     ??ecvtbuf_15: (+1)
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0x.... 0x....      BL       my_atoi
   \   0000013C   0x6829             LDR      R1,[R5, #+0]
   \   0000013E   0x1840             ADDS     R0,R0,R1
   \   00000140   0x6028             STR      R0,[R5, #+0]
    574                  
    575                  /* Pad with zeroes if needed.  */
    576                  while (d - buf < ndigits) *d++ = '0';
   \                     ??ecvtbuf_16: (+1)
   \   00000142   0xEBB9 0x0006      SUBS     R0,R9,R6
   \   00000146   0x42A0             CMP      R0,R4
   \   00000148   0xDA05             BGE.N    ??ecvtbuf_17
   \   0000014A   0x2030             MOVS     R0,#+48
   \   0000014C   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   00000150   0xF119 0x0901      ADDS     R9,R9,#+1
   \   00000154   0xE7F5             B.N      ??ecvtbuf_16
    577                  
    578                  /* Zero-terminate.  */
    579                  *d = '\0';
   \                     ??ecvtbuf_17: (+1)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xF889 0x0000      STRB     R0,[R9, #+0]
    580                  /* Round if necessary.  */
    581                  __ecvround (buf, last_digit, digit_after_last, decpt);
   \   0000015C   0x002B             MOVS     R3,R5
   \   0000015E   0x4652             MOV      R2,R10
   \   00000160   0x4659             MOV      R1,R11
   \   00000162   0x0030             MOVS     R0,R6
   \   00000164   0x.... 0x....      BL       __ecvround
    582              }
    583          
    584              return buf;
   \                     ??ecvtbuf_6: (+1)
   \   00000168   0x0030             MOVS     R0,R6
   \   0000016A   0xB009             ADD      SP,SP,#+36
   \   0000016C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    585          }

   \                                 In section .data, align 4
   \                     ??INFINITY:
   \   00000000   0x49 0x6E          DC8 "Infinity"
   \              0x66 0x69    
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    586          

   \                                 In section .text, align 2, keep-with-next
    587          static char * fcvtbuf (double value, int ndigits, int *decpt, int *sign, char *buf)
    588          {
   \                     fcvtbuf: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0x001D             MOVS     R5,R3
   \   0000000E   0x9E15             LDR      R6,[SP, #+84]
    589              static char INFINITY[] = "Infinity";
    590              char decimal = '.' /* localeconv()->decimal_point[0] */;
   \   00000010   0x202E             MOVS     R0,#+46
   \   00000012   0xF88D 0x0008      STRB     R0,[SP, #+8]
    591              //int digits = ndigits >= 0 ? ndigits : 0;
    592              //char *cvtbuf = (char *)malloc(2*DBL_MAX_10_EXP + 16);
    593              char chBuffer[20];
    594              char *cvtbuf = chBuffer;
   \   00000016   0xA805             ADD      R0,SP,#+20
   \   00000018   0x9004             STR      R0,[SP, #+16]
    595              char *s = cvtbuf;
   \   0000001A   0x9F04             LDR      R7,[SP, #+16]
    596              char *dot;
    597              char *pchRet = 0;
   \   0000001C   0xF05F 0x0A00      MOVS     R10,#+0
    598              //sprintf (cvtbuf, "%-+#.*f", DBL_MAX_10_EXP + digits + 1, value);
    599              //ftoa(cvtbuf, DBL_MAX_10_EXP + digits + 1, value);
    600              ftoa(value, cvtbuf);
   \   00000020   0x9A04             LDR      R2,[SP, #+16]
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x4649             MOV      R1,R9
   \   00000026   0x.... 0x....      BL       my_ftoa
    601              
    602              *sign = ('-' == *s++) ? 1 : 0; /* The sign.  */
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x1C47             ADDS     R7,R0,#+1
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0x282D             CMP      R0,#+45
   \   00000032   0xD101             BNE.N    ??fcvtbuf_0
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0xE000             B.N      ??fcvtbuf_1
   \                     ??fcvtbuf_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \                     ??fcvtbuf_1: (+1)
   \   0000003A   0x9914             LDR      R1,[SP, #+80]
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    603              /* Where's the decimal point?  */
    604              dot = strchr(s, decimal);
   \   0000003E   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000042   0x0038             MOVS     R0,R7
   \   00000044   0x.... 0x....      BL       strchr
   \   00000048   0x9003             STR      R0,[SP, #+12]
    605              
    606              *decpt = dot ? (dot - s) : strlen(s);
   \   0000004A   0x9803             LDR      R0,[SP, #+12]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??fcvtbuf_2
   \   00000050   0x9803             LDR      R0,[SP, #+12]
   \   00000052   0x1BC0             SUBS     R0,R0,R7
   \   00000054   0xE002             B.N      ??fcvtbuf_3
   \                     ??fcvtbuf_2: (+1)
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       strlen
   \                     ??fcvtbuf_3: (+1)
   \   0000005C   0x6028             STR      R0,[R5, #+0]
    607              
    608              /* SunOS docs says if NDIGITS is 8 or more, produce "Infinity"   instead of "Inf".  */
    609              if (strncmp (s, "Inf", 3) == 0)
   \   0000005E   0x2203             MOVS     R2,#+3
   \   00000060   0x....             ADR.N    R1,??DataTable6  ;; "Inf"
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x.... 0x....      BL       strncmp
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD114             BNE.N    ??fcvtbuf_4
    610              {
    611                  memcpy (buf, INFINITY, ndigits >= 8 ? 9 : 3);
   \   0000006C   0x2C08             CMP      R4,#+8
   \   0000006E   0xDB02             BLT.N    ??fcvtbuf_5
   \   00000070   0xF05F 0x0B09      MOVS     R11,#+9
   \   00000074   0xE001             B.N      ??fcvtbuf_6
   \                     ??fcvtbuf_5: (+1)
   \   00000076   0xF05F 0x0B03      MOVS     R11,#+3
   \                     ??fcvtbuf_6: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable8_8
   \   0000007E   0x9000             STR      R0,[SP, #+0]
   \   00000080   0x465A             MOV      R2,R11
   \   00000082   0x9900             LDR      R1,[SP, #+0]
   \   00000084   0x0030             MOVS     R0,R6
   \   00000086   0x.... 0x....      BL       __aeabi_memcpy
    612                  if (ndigits < 8) buf[3] = '\0';
   \   0000008A   0x2C08             CMP      R4,#+8
   \   0000008C   0xDA01             BGE.N    ??fcvtbuf_7
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x70F0             STRB     R0,[R6, #+3]
    613                  pchRet = buf; /*return buf;*/
   \                     ??fcvtbuf_7: (+1)
   \   00000092   0x46B2             MOV      R10,R6
   \   00000094   0xE059             B.N      ??fcvtbuf_8
    614              }
    615              else if (ndigits < 0)
   \                     ??fcvtbuf_4: (+1)
   \   00000096   0x2C00             CMP      R4,#+0
   \   00000098   0xD50B             BPL.N    ??fcvtbuf_9
    616              {/*return ecvtbuf (value, *decpt + ndigits, decpt, sign, buf);*/
    617                  pchRet = ecvtbuf (value, *decpt + ndigits, decpt, sign, buf);
   \   0000009A   0x9601             STR      R6,[SP, #+4]
   \   0000009C   0x9814             LDR      R0,[SP, #+80]
   \   0000009E   0x9000             STR      R0,[SP, #+0]
   \   000000A0   0x002B             MOVS     R3,R5
   \   000000A2   0x6828             LDR      R0,[R5, #+0]
   \   000000A4   0x1822             ADDS     R2,R4,R0
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x4649             MOV      R1,R9
   \   000000AA   0x.... 0x....      BL       ecvtbuf
   \   000000AE   0x4682             MOV      R10,R0
   \   000000B0   0xE04B             B.N      ??fcvtbuf_8
    618              }
    619              else if (*s == '0' && !IS_DOUBLE_ZERO(value)/*value != 0.0*/)
   \                     ??fcvtbuf_9: (+1)
   \   000000B2   0x7838             LDRB     R0,[R7, #+0]
   \   000000B4   0x2830             CMP      R0,#+48
   \   000000B6   0xD11A             BNE.N    ??fcvtbuf_10
   \   000000B8   0x4640             MOV      R0,R8
   \   000000BA   0x4649             MOV      R1,R9
   \   000000BC   0x....             LDR.N    R2,??DataTable7_3  ;; 0x2c40c60e
   \   000000BE   0x....             LDR.N    R3,??DataTable7_4  ;; 0x31fa18
   \   000000C0   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000C4   0xD208             BCS.N    ??fcvtbuf_11
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x4649             MOV      R1,R9
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x2c40c60d
   \   000000CE   0x.... 0x....      LDR.W    R3,??DataTable8_1  ;; 0x8031fa18
   \   000000D2   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000D6   0xD90A             BLS.N    ??fcvtbuf_10
    620              {/*return ecvtbuf (value, ndigits, decpt, sign, buf);*/
    621                  pchRet = ecvtbuf(value, ndigits, decpt, sign, buf);
   \                     ??fcvtbuf_11: (+1)
   \   000000D8   0x9601             STR      R6,[SP, #+4]
   \   000000DA   0x9814             LDR      R0,[SP, #+80]
   \   000000DC   0x9000             STR      R0,[SP, #+0]
   \   000000DE   0x002B             MOVS     R3,R5
   \   000000E0   0x0022             MOVS     R2,R4
   \   000000E2   0x4640             MOV      R0,R8
   \   000000E4   0x4649             MOV      R1,R9
   \   000000E6   0x.... 0x....      BL       ecvtbuf
   \   000000EA   0x4682             MOV      R10,R0
   \   000000EC   0xE02D             B.N      ??fcvtbuf_8
    622              }
    623              else
    624              {
    625                  memcpy (buf, s, *decpt);
   \                     ??fcvtbuf_10: (+1)
   \   000000EE   0xF8D5 0xB000      LDR      R11,[R5, #+0]
   \   000000F2   0x465A             MOV      R2,R11
   \   000000F4   0x0039             MOVS     R1,R7
   \   000000F6   0x0030             MOVS     R0,R6
   \   000000F8   0x.... 0x....      BL       __aeabi_memcpy
    626                  if (s[*decpt] == decimal)
   \   000000FC   0x6828             LDR      R0,[R5, #+0]
   \   000000FE   0x5DC0             LDRB     R0,[R0, R7]
   \   00000100   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000104   0x4288             CMP      R0,R1
   \   00000106   0xD110             BNE.N    ??fcvtbuf_12
    627                  {
    628                      memcpy (buf + *decpt, s + *decpt + 1, ndigits);
   \   00000108   0x6828             LDR      R0,[R5, #+0]
   \   0000010A   0x19C0             ADDS     R0,R0,R7
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   \   0000010E   0x9000             STR      R0,[SP, #+0]
   \   00000110   0x6828             LDR      R0,[R5, #+0]
   \   00000112   0xEB10 0x0B06      ADDS     R11,R0,R6
   \   00000116   0x0022             MOVS     R2,R4
   \   00000118   0x9900             LDR      R1,[SP, #+0]
   \   0000011A   0x4658             MOV      R0,R11
   \   0000011C   0x.... 0x....      BL       __aeabi_memcpy
    629                      buf[*decpt + ndigits] = '\0';
   \   00000120   0x2000             MOVS     R0,#+0
   \   00000122   0x6829             LDR      R1,[R5, #+0]
   \   00000124   0x1861             ADDS     R1,R4,R1
   \   00000126   0x5588             STRB     R0,[R1, R6]
   \   00000128   0xE002             B.N      ??fcvtbuf_13
    630                  }
    631                  else
    632                  {
    633                      buf[*decpt] = '\0';
   \                     ??fcvtbuf_12: (+1)
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x6829             LDR      R1,[R5, #+0]
   \   0000012E   0x5588             STRB     R0,[R1, R6]
    634                  }
    635                  __ecvround (buf, buf + *decpt + ndigits - 1,
    636                      s + *decpt + ndigits + 1, decpt);
   \                     ??fcvtbuf_13: (+1)
   \   00000130   0x002B             MOVS     R3,R5
   \   00000132   0x6828             LDR      R0,[R5, #+0]
   \   00000134   0x19C0             ADDS     R0,R0,R7
   \   00000136   0x1820             ADDS     R0,R4,R0
   \   00000138   0x1C42             ADDS     R2,R0,#+1
   \   0000013A   0x6828             LDR      R0,[R5, #+0]
   \   0000013C   0x1980             ADDS     R0,R0,R6
   \   0000013E   0x1820             ADDS     R0,R4,R0
   \   00000140   0x1E41             SUBS     R1,R0,#+1
   \   00000142   0x0030             MOVS     R0,R6
   \   00000144   0x.... 0x....      BL       __ecvround
    637                  pchRet = buf; /*return buf;*/
   \   00000148   0x46B2             MOV      R10,R6
    638              }
    639              /*delete [] cvtbuf; */
    640              return pchRet;
   \                     ??fcvtbuf_8: (+1)
   \   0000014A   0x4650             MOV      R0,R10
   \   0000014C   0xB00B             ADD      SP,SP,#+44
   \   0000014E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    641          }

   \                                 In section .data, align 4
   \                     ??INFINITY_1:
   \   00000000   0x49 0x6E          DC8 "Infinity"
   \              0x66 0x69    
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    642          

   \                                 In section .text, align 2, keep-with-next
    643          static void cfltcvt(double value, char *buffer, char fmt, int precision)
    644          {
   \                     cfltcvt: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0x001D             MOVS     R5,R3
   \   0000000E   0x9E22             LDR      R6,[SP, #+136]
    645              int decpt, sign;
    646              char cvtbuf[80];
    647              int capexp = 0;
   \   00000010   0xF05F 0x0B00      MOVS     R11,#+0
    648          
    649              if ('G' == fmt || 'E' == fmt)
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D47             CMP      R5,#+71
   \   00000018   0xD002             BEQ.N    ??cfltcvt_0
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D45             CMP      R5,#+69
   \   0000001E   0xD102             BNE.N    ??cfltcvt_1
    650              {
    651                  capexp = 1;
   \                     ??cfltcvt_0: (+1)
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x4683             MOV      R11,R0
    652                  fmt += 'a' - 'A';
   \   00000024   0x3520             ADDS     R5,R5,#+32
    653              }
    654          
    655              if (fmt == 'g')
   \                     ??cfltcvt_1: (+1)
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2D67             CMP      R5,#+103
   \   0000002A   0xD119             BNE.N    ??cfltcvt_2
    656              {
    657                  char * digits = ecvtbuf(value, precision, &decpt, &sign, cvtbuf);
   \   0000002C   0xA804             ADD      R0,SP,#+16
   \   0000002E   0x9001             STR      R0,[SP, #+4]
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x9000             STR      R0,[SP, #+0]
   \   00000034   0xAB02             ADD      R3,SP,#+8
   \   00000036   0x0032             MOVS     R2,R6
   \   00000038   0x4640             MOV      R0,R8
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0x.... 0x....      BL       ecvtbuf
    658                  int magnitude = decpt - 1;
   \   00000040   0x9902             LDR      R1,[SP, #+8]
   \   00000042   0x1E49             SUBS     R1,R1,#+1
    659                  if (magnitude < -4  ||  magnitude > precision - 1)
   \   00000044   0xF111 0x0F04      CMN      R1,#+4
   \   00000048   0xDB02             BLT.N    ??cfltcvt_3
   \   0000004A   0x1E72             SUBS     R2,R6,#+1
   \   0000004C   0x428A             CMP      R2,R1
   \   0000004E   0xDA03             BGE.N    ??cfltcvt_4
    660                  {
    661                      fmt = 'e';
   \                     ??cfltcvt_3: (+1)
   \   00000050   0x2265             MOVS     R2,#+101
   \   00000052   0x0015             MOVS     R5,R2
    662                      precision -= 1;
   \   00000054   0x1E76             SUBS     R6,R6,#+1
   \   00000056   0xE003             B.N      ??cfltcvt_2
    663                  }
    664                  else
    665                  {
    666                      fmt = 'f';
   \                     ??cfltcvt_4: (+1)
   \   00000058   0x2266             MOVS     R2,#+102
   \   0000005A   0x0015             MOVS     R5,R2
    667                      precision -= decpt;
   \   0000005C   0x9A02             LDR      R2,[SP, #+8]
   \   0000005E   0x1AB6             SUBS     R6,R6,R2
    668                  }
    669              }
    670          
    671              if ('e' == fmt)
   \                     ??cfltcvt_2: (+1)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D65             CMP      R5,#+101
   \   00000064   0xD16E             BNE.N    ??cfltcvt_5
    672              {
    673                  char * digits = ecvtbuf(value, precision + 1, &decpt, &sign, cvtbuf);
   \   00000066   0xA804             ADD      R0,SP,#+16
   \   00000068   0x9001             STR      R0,[SP, #+4]
   \   0000006A   0xA803             ADD      R0,SP,#+12
   \   0000006C   0x9000             STR      R0,[SP, #+0]
   \   0000006E   0xAB02             ADD      R3,SP,#+8
   \   00000070   0x1C72             ADDS     R2,R6,#+1
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x4649             MOV      R1,R9
   \   00000076   0x.... 0x....      BL       ecvtbuf
   \   0000007A   0x4682             MOV      R10,R0
    674                  int exp = 0;
   \   0000007C   0x2700             MOVS     R7,#+0
    675                  if (sign) *buffer++ = '-';
   \   0000007E   0x9803             LDR      R0,[SP, #+12]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??cfltcvt_6
   \   00000084   0x202D             MOVS     R0,#+45
   \   00000086   0x7020             STRB     R0,[R4, #+0]
   \   00000088   0x1C64             ADDS     R4,R4,#+1
    676                  *buffer++ = *digits;
   \                     ??cfltcvt_6: (+1)
   \   0000008A   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000008E   0x7020             STRB     R0,[R4, #+0]
   \   00000090   0x1C64             ADDS     R4,R4,#+1
    677                  if (precision > 0) *buffer++ = '.';
   \   00000092   0x2E01             CMP      R6,#+1
   \   00000094   0xDB02             BLT.N    ??cfltcvt_7
   \   00000096   0x202E             MOVS     R0,#+46
   \   00000098   0x7020             STRB     R0,[R4, #+0]
   \   0000009A   0x1C64             ADDS     R4,R4,#+1
    678                  memcpy(buffer, digits + 1, precision);
   \                     ??cfltcvt_7: (+1)
   \   0000009C   0xF11A 0x0001      ADDS     R0,R10,#+1
   \   000000A0   0x9000             STR      R0,[SP, #+0]
   \   000000A2   0x0032             MOVS     R2,R6
   \   000000A4   0x9900             LDR      R1,[SP, #+0]
   \   000000A6   0x0020             MOVS     R0,R4
   \   000000A8   0x.... 0x....      BL       __aeabi_memcpy
    679                  buffer += precision;
   \   000000AC   0x1934             ADDS     R4,R6,R4
    680                  *buffer++ = capexp ? 'E' : 'e';
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x1C44             ADDS     R4,R0,#+1
   \   000000B2   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000B6   0xD001             BEQ.N    ??cfltcvt_8
   \   000000B8   0x2145             MOVS     R1,#+69
   \   000000BA   0xE000             B.N      ??cfltcvt_9
   \                     ??cfltcvt_8: (+1)
   \   000000BC   0x2165             MOVS     R1,#+101
   \                     ??cfltcvt_9: (+1)
   \   000000BE   0x7001             STRB     R1,[R0, #+0]
    681          
    682                  if (decpt == 0)
   \   000000C0   0x9802             LDR      R0,[SP, #+8]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD114             BNE.N    ??cfltcvt_10
    683                  {
    684                      exp = (IS_DOUBLE_ZERO(value)) ? 0 : -1; /*       if (value == 0.0)*/
   \   000000C6   0x4640             MOV      R0,R8
   \   000000C8   0x4649             MOV      R1,R9
   \   000000CA   0x....             LDR.N    R2,??DataTable7_3  ;; 0x2c40c60e
   \   000000CC   0x....             LDR.N    R3,??DataTable7_4  ;; 0x31fa18
   \   000000CE   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000D2   0xD20A             BCS.N    ??cfltcvt_11
   \   000000D4   0x4640             MOV      R0,R8
   \   000000D6   0x4649             MOV      R1,R9
   \   000000D8   0x.... 0x....      LDR.W    R2,??DataTable8  ;; 0x2c40c60d
   \   000000DC   0x.... 0x....      LDR.W    R3,??DataTable8_1  ;; 0x8031fa18
   \   000000E0   0x.... 0x....      BL       __aeabi_cdrcmple
   \   000000E4   0xD801             BHI.N    ??cfltcvt_11
   \   000000E6   0x2700             MOVS     R7,#+0
   \   000000E8   0xE005             B.N      ??cfltcvt_12
   \                     ??cfltcvt_11: (+1)
   \   000000EA   0xF05F 0x37FF      MOVS     R7,#-1
   \   000000EE   0xE002             B.N      ??cfltcvt_12
    685                  }
    686                  else
    687                  {
    688                      exp = decpt - 1;
   \                     ??cfltcvt_10: (+1)
   \   000000F0   0x9802             LDR      R0,[SP, #+8]
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0x0007             MOVS     R7,R0
    689                  }
    690                  
    691                  if (exp < 0)
   \                     ??cfltcvt_12: (+1)
   \   000000F6   0x2F00             CMP      R7,#+0
   \   000000F8   0xD504             BPL.N    ??cfltcvt_13
    692                  {
    693                      *buffer++ = '-';
   \   000000FA   0x202D             MOVS     R0,#+45
   \   000000FC   0x7020             STRB     R0,[R4, #+0]
   \   000000FE   0x1C64             ADDS     R4,R4,#+1
    694                      exp = -exp;
   \   00000100   0x427F             RSBS     R7,R7,#+0
   \   00000102   0xE002             B.N      ??cfltcvt_14
    695                  }
    696                  else
    697                  {
    698                      *buffer++ = '+';
   \                     ??cfltcvt_13: (+1)
   \   00000104   0x202B             MOVS     R0,#+43
   \   00000106   0x7020             STRB     R0,[R4, #+0]
   \   00000108   0x1C64             ADDS     R4,R4,#+1
    699                  }
    700                  
    701                  buffer[2] = (exp % 10) + '0';
   \                     ??cfltcvt_14: (+1)
   \   0000010A   0x200A             MOVS     R0,#+10
   \   0000010C   0xFB97 0xF1F0      SDIV     R1,R7,R0
   \   00000110   0xFB00 0x7011      MLS      R0,R0,R1,R7
   \   00000114   0x3030             ADDS     R0,R0,#+48
   \   00000116   0x70A0             STRB     R0,[R4, #+2]
    702                  exp /= 10;
   \   00000118   0x200A             MOVS     R0,#+10
   \   0000011A   0xFB97 0xF7F0      SDIV     R7,R7,R0
    703                  buffer[1] = (exp % 10) + '0';
   \   0000011E   0x200A             MOVS     R0,#+10
   \   00000120   0xFB97 0xF1F0      SDIV     R1,R7,R0
   \   00000124   0xFB00 0x7011      MLS      R0,R0,R1,R7
   \   00000128   0x3030             ADDS     R0,R0,#+48
   \   0000012A   0x7060             STRB     R0,[R4, #+1]
    704                  exp /= 10;
   \   0000012C   0x200A             MOVS     R0,#+10
   \   0000012E   0xFB97 0xF7F0      SDIV     R7,R7,R0
    705                  buffer[0] = (exp % 10) + '0';
   \   00000132   0x200A             MOVS     R0,#+10
   \   00000134   0xFB97 0xF1F0      SDIV     R1,R7,R0
   \   00000138   0xFB00 0x7011      MLS      R0,R0,R1,R7
   \   0000013C   0x3030             ADDS     R0,R0,#+48
   \   0000013E   0x7020             STRB     R0,[R4, #+0]
    706                  buffer += 3;
   \   00000140   0x1CE4             ADDS     R4,R4,#+3
   \   00000142   0xE050             B.N      ??cfltcvt_15
    707              }
    708              else if ('f' == fmt)
   \                     ??cfltcvt_5: (+1)
   \   00000144   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000146   0x2D66             CMP      R5,#+102
   \   00000148   0xD14D             BNE.N    ??cfltcvt_15
    709              {
    710                  char * digits = fcvtbuf(value, precision, &decpt, &sign, cvtbuf);
   \   0000014A   0xA804             ADD      R0,SP,#+16
   \   0000014C   0x9001             STR      R0,[SP, #+4]
   \   0000014E   0xA803             ADD      R0,SP,#+12
   \   00000150   0x9000             STR      R0,[SP, #+0]
   \   00000152   0xAB02             ADD      R3,SP,#+8
   \   00000154   0x0032             MOVS     R2,R6
   \   00000156   0x4640             MOV      R0,R8
   \   00000158   0x4649             MOV      R1,R9
   \   0000015A   0x.... 0x....      BL       fcvtbuf
    711                  if (sign) *buffer++ = '-';
   \   0000015E   0x9903             LDR      R1,[SP, #+12]
   \   00000160   0x2900             CMP      R1,#+0
   \   00000162   0xD002             BEQ.N    ??cfltcvt_16
   \   00000164   0x212D             MOVS     R1,#+45
   \   00000166   0x7021             STRB     R1,[R4, #+0]
   \   00000168   0x1C64             ADDS     R4,R4,#+1
    712                  if (*digits)
   \                     ??cfltcvt_16: (+1)
   \   0000016A   0x7801             LDRB     R1,[R0, #+0]
   \   0000016C   0x2900             CMP      R1,#+0
   \   0000016E   0xD02A             BEQ.N    ??cfltcvt_17
    713                  {
    714                      if (decpt <= 0)
   \   00000170   0x9902             LDR      R1,[SP, #+8]
   \   00000172   0x2901             CMP      R1,#+1
   \   00000174   0xDA16             BGE.N    ??cfltcvt_18
    715                      {
    716                          *buffer++ = '0';
   \   00000176   0x2130             MOVS     R1,#+48
   \   00000178   0x7021             STRB     R1,[R4, #+0]
   \   0000017A   0x1C64             ADDS     R4,R4,#+1
    717                          *buffer++ = '.';
   \   0000017C   0x212E             MOVS     R1,#+46
   \   0000017E   0x7021             STRB     R1,[R4, #+0]
   \   00000180   0x1C64             ADDS     R4,R4,#+1
    718                          for (int pos = 0; pos < -decpt; pos++)
   \   00000182   0x2100             MOVS     R1,#+0
   \                     ??cfltcvt_19: (+1)
   \   00000184   0x9A02             LDR      R2,[SP, #+8]
   \   00000186   0x42D1             CMN      R1,R2
   \   00000188   0xDA04             BGE.N    ??cfltcvt_20
    719                          {
    720                              *buffer++ = '0';
   \   0000018A   0x2230             MOVS     R2,#+48
   \   0000018C   0x7022             STRB     R2,[R4, #+0]
   \   0000018E   0x1C64             ADDS     R4,R4,#+1
    721                          }
   \   00000190   0x1C49             ADDS     R1,R1,#+1
   \   00000192   0xE7F7             B.N      ??cfltcvt_19
    722                          while(*digits) *buffer++ = *digits++;
   \                     ??cfltcvt_20: (+1)
   \   00000194   0x7801             LDRB     R1,[R0, #+0]
   \   00000196   0x2900             CMP      R1,#+0
   \   00000198   0xD025             BEQ.N    ??cfltcvt_15
   \   0000019A   0x7801             LDRB     R1,[R0, #+0]
   \   0000019C   0x7021             STRB     R1,[R4, #+0]
   \   0000019E   0x1C40             ADDS     R0,R0,#+1
   \   000001A0   0x1C64             ADDS     R4,R4,#+1
   \   000001A2   0xE7F7             B.N      ??cfltcvt_20
    723                      }
    724                      else
    725                      {
    726                          int pos = 0;
   \                     ??cfltcvt_18: (+1)
   \   000001A4   0x2100             MOVS     R1,#+0
    727                          while(*digits)
   \                     ??cfltcvt_21: (+1)
   \   000001A6   0x7802             LDRB     R2,[R0, #+0]
   \   000001A8   0x2A00             CMP      R2,#+0
   \   000001AA   0xD01C             BEQ.N    ??cfltcvt_15
    728                          {
    729                              if (pos++ == decpt) *buffer++ = '.';
   \   000001AC   0x000A             MOVS     R2,R1
   \   000001AE   0x1C51             ADDS     R1,R2,#+1
   \   000001B0   0x9B02             LDR      R3,[SP, #+8]
   \   000001B2   0x429A             CMP      R2,R3
   \   000001B4   0xD102             BNE.N    ??cfltcvt_22
   \   000001B6   0x222E             MOVS     R2,#+46
   \   000001B8   0x7022             STRB     R2,[R4, #+0]
   \   000001BA   0x1C64             ADDS     R4,R4,#+1
    730                              *buffer++ = *digits++;
   \                     ??cfltcvt_22: (+1)
   \   000001BC   0x7802             LDRB     R2,[R0, #+0]
   \   000001BE   0x7022             STRB     R2,[R4, #+0]
   \   000001C0   0x1C40             ADDS     R0,R0,#+1
   \   000001C2   0x1C64             ADDS     R4,R4,#+1
   \   000001C4   0xE7EF             B.N      ??cfltcvt_21
    731                          }
    732                      }
    733                  }
    734                  else
    735                  {
    736                      *buffer++ = '0';
   \                     ??cfltcvt_17: (+1)
   \   000001C6   0x2130             MOVS     R1,#+48
   \   000001C8   0x7021             STRB     R1,[R4, #+0]
   \   000001CA   0x1C64             ADDS     R4,R4,#+1
    737                      if(precision > 0)
   \   000001CC   0x2E01             CMP      R6,#+1
   \   000001CE   0xDB0A             BLT.N    ??cfltcvt_15
    738                      {
    739                          *buffer++ = '.';
   \   000001D0   0x212E             MOVS     R1,#+46
   \   000001D2   0x7021             STRB     R1,[R4, #+0]
   \   000001D4   0x1C64             ADDS     R4,R4,#+1
    740                          for(int pos = 0; pos < precision; pos++)
   \   000001D6   0x2100             MOVS     R1,#+0
   \                     ??cfltcvt_23: (+1)
   \   000001D8   0x42B1             CMP      R1,R6
   \   000001DA   0xDA04             BGE.N    ??cfltcvt_15
    741                          {
    742                              *buffer++ = '0';
   \   000001DC   0x2230             MOVS     R2,#+48
   \   000001DE   0x7022             STRB     R2,[R4, #+0]
   \   000001E0   0x1C64             ADDS     R4,R4,#+1
    743                          }
   \   000001E2   0x1C49             ADDS     R1,R1,#+1
   \   000001E4   0xE7F8             B.N      ??cfltcvt_23
    744                      }
    745                  }
    746              }
    747          
    748              *buffer = '\0';
   \                     ??cfltcvt_15: (+1)
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x7020             STRB     R0,[R4, #+0]
    749          }
   \   000001EA   0xB019             ADD      SP,SP,#+100
   \   000001EC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    750          

   \                                 In section .text, align 2, keep-with-next
    751          static void forcdecpt(char *buffer)
    752          {
   \                     forcdecpt: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    753              while (*buffer)
   \                     ??forcdecpt_0: (+1)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00B             BEQ.N    ??forcdecpt_1
    754              {
    755                  if (*buffer == '.') return;
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x282E             CMP      R0,#+46
   \   0000000E   0xD01D             BEQ.N    ??forcdecpt_2
    756                  if (*buffer == 'e' || *buffer == 'E') break;
   \                     ??forcdecpt_3: (+1)
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2865             CMP      R0,#+101
   \   00000014   0xD002             BEQ.N    ??forcdecpt_4
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2845             CMP      R0,#+69
   \   0000001A   0xD100             BNE.N    ??forcdecpt_5
   \                     ??forcdecpt_4: (+1)
   \   0000001C   0xE001             B.N      ??forcdecpt_1
    757                  buffer++;
   \                     ??forcdecpt_5: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \   00000020   0xE7F0             B.N      ??forcdecpt_0
    758              }
    759          
    760              if(*buffer)
   \                     ??forcdecpt_1: (+1)
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD00C             BEQ.N    ??forcdecpt_6
    761              {
    762                  int n = strlen(buffer);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       strlen
    763                  while(n > 0) 
   \                     ??forcdecpt_7: (+1)
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xDB04             BLT.N    ??forcdecpt_8
    764                  {
    765                      buffer[n + 1] = buffer[n];
   \   00000032   0x5D01             LDRB     R1,[R0, R4]
   \   00000034   0x1902             ADDS     R2,R0,R4
   \   00000036   0x7051             STRB     R1,[R2, #+1]
    766                      n--;
   \   00000038   0x1E40             SUBS     R0,R0,#+1
   \   0000003A   0xE7F8             B.N      ??forcdecpt_7
    767                  }
    768          
    769                  *buffer = '.';
   \                     ??forcdecpt_8: (+1)
   \   0000003C   0x212E             MOVS     R1,#+46
   \   0000003E   0x7021             STRB     R1,[R4, #+0]
   \   00000040   0xE004             B.N      ??forcdecpt_9
    770              }
    771              else
    772              {
    773                  *buffer++ = '.';
   \                     ??forcdecpt_6: (+1)
   \   00000042   0x202E             MOVS     R0,#+46
   \   00000044   0x7020             STRB     R0,[R4, #+0]
   \   00000046   0x1C64             ADDS     R4,R4,#+1
    774                  *buffer = '\0';
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x7020             STRB     R0,[R4, #+0]
    775              }
    776          }
   \                     ??forcdecpt_9: (+1)
   \                     ??forcdecpt_2: (+1)
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    777          

   \                                 In section .text, align 2, keep-with-next
    778          static void cropzeros(char *buffer)
    779          {
    780              char *stop;
    781              while (*buffer && *buffer != '.') buffer++;
   \                     cropzeros: (+1)
   \                     ??cropzeros_0: (+1)
   \   00000000   0x7802             LDRB     R2,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD004             BEQ.N    ??cropzeros_1
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A2E             CMP      R2,#+46
   \   0000000A   0xD001             BEQ.N    ??cropzeros_1
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0xE7F7             B.N      ??cropzeros_0
    782          
    783              if (*buffer++)
   \                     ??cropzeros_1: (+1)
   \   00000010   0x0002             MOVS     R2,R0
   \   00000012   0x1C50             ADDS     R0,R2,#+1
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD01C             BEQ.N    ??cropzeros_2
    784              {
    785                  while (*buffer && *buffer != 'e' && *buffer != 'E') buffer++;
   \                     ??cropzeros_3: (+1)
   \   0000001A   0x7802             LDRB     R2,[R0, #+0]
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0xD007             BEQ.N    ??cropzeros_4
   \   00000020   0x7802             LDRB     R2,[R0, #+0]
   \   00000022   0x2A65             CMP      R2,#+101
   \   00000024   0xD004             BEQ.N    ??cropzeros_4
   \   00000026   0x7802             LDRB     R2,[R0, #+0]
   \   00000028   0x2A45             CMP      R2,#+69
   \   0000002A   0xD001             BEQ.N    ??cropzeros_4
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0xE7F4             B.N      ??cropzeros_3
    786                  stop = buffer--;
   \                     ??cropzeros_4: (+1)
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x1E40             SUBS     R0,R0,#+1
    787                  while('0' == *buffer) buffer--;
   \                     ??cropzeros_5: (+1)
   \   00000034   0x7802             LDRB     R2,[R0, #+0]
   \   00000036   0x2A30             CMP      R2,#+48
   \   00000038   0xD101             BNE.N    ??cropzeros_6
   \   0000003A   0x1E40             SUBS     R0,R0,#+1
   \   0000003C   0xE7FA             B.N      ??cropzeros_5
    788                  if('.' == *buffer) buffer--;
   \                     ??cropzeros_6: (+1)
   \   0000003E   0x7802             LDRB     R2,[R0, #+0]
   \   00000040   0x2A2E             CMP      R2,#+46
   \   00000042   0xD100             BNE.N    ??cropzeros_7
   \   00000044   0x1E40             SUBS     R0,R0,#+1
    789                  while(*++buffer = *stop++);
   \                     ??cropzeros_7: (+1)
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x780A             LDRB     R2,[R1, #+0]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x7002             STRB     R2,[R0, #+0]
   \   0000004E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000050   0x2A00             CMP      R2,#+0
   \   00000052   0xD1F8             BNE.N    ??cropzeros_7
    790              }
    791          }
   \                     ??cropzeros_2: (+1)
   \   00000054   0x4770             BX       LR               ;; return
    792          

   \                                 In section .text, align 2, keep-with-next
    793          static char * flt(char *str, double num, int size, int precision, char fmt, int flags)
    794          {
   \                     flt: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB097             SUB      SP,SP,#+92
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x4699             MOV      R9,R3
   \   0000000C   0x9D20             LDR      R5,[SP, #+128]
   \   0000000E   0xF8DD 0xB084      LDR      R11,[SP, #+132]
   \   00000012   0x9E23             LDR      R6,[SP, #+140]
    795              char tmp[80];
    796              char c, sign;
    797              int n, i;
    798          
    799              /* Left align means no zero padding */
    800              if (flags & LEFT) flags &= ~ZEROPAD;
   \   00000014   0x06F0             LSLS     R0,R6,#+27
   \   00000016   0xD501             BPL.N    ??flt_0
   \   00000018   0xF036 0x0601      BICS     R6,R6,#0x1
    801          
    802              /* Determine padding and sign char */
    803              c = (flags & ZEROPAD) ? '0' : ' ';
   \                     ??flt_0: (+1)
   \   0000001C   0x07F0             LSLS     R0,R6,#+31
   \   0000001E   0xD502             BPL.N    ??flt_1
   \   00000020   0xF05F 0x0A30      MOVS     R10,#+48
   \   00000024   0xE001             B.N      ??flt_2
   \                     ??flt_1: (+1)
   \   00000026   0xF05F 0x0A20      MOVS     R10,#+32
    804              sign = 0;
   \                     ??flt_2: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF88D 0x0004      STRB     R0,[SP, #+4]
    805              if (flags & SIGN)
   \   00000030   0x07B0             LSLS     R0,R6,#+30
   \   00000032   0xD51A             BPL.N    ??flt_3
    806              {
    807                  if (num < 0.0)
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000040   0xD206             BCS.N    ??flt_4
    808                  {
    809                      sign = '-';
   \   00000042   0x202D             MOVS     R0,#+45
   \   00000044   0xF88D 0x0004      STRB     R0,[SP, #+4]
    810                      num = -num;
   \   00000048   0xF099 0x4900      EORS     R9,R9,#0x80000000
    811                      size--;
   \   0000004C   0x1E6D             SUBS     R5,R5,#+1
   \   0000004E   0xE00C             B.N      ??flt_3
    812                  }
    813                  else if (flags & PLUS)
   \                     ??flt_4: (+1)
   \   00000050   0x0770             LSLS     R0,R6,#+29
   \   00000052   0xD504             BPL.N    ??flt_5
    814                  {
    815                      sign = '+';
   \   00000054   0x202B             MOVS     R0,#+43
   \   00000056   0xF88D 0x0004      STRB     R0,[SP, #+4]
    816                      size--;
   \   0000005A   0x1E6D             SUBS     R5,R5,#+1
   \   0000005C   0xE005             B.N      ??flt_3
    817                  }
    818                  else if (flags & SPACE)
   \                     ??flt_5: (+1)
   \   0000005E   0x0730             LSLS     R0,R6,#+28
   \   00000060   0xD503             BPL.N    ??flt_3
    819                  {
    820                      sign = ' ';
   \   00000062   0x2020             MOVS     R0,#+32
   \   00000064   0xF88D 0x0004      STRB     R0,[SP, #+4]
    821                      size--;
   \   00000068   0x1E6D             SUBS     R5,R5,#+1
    822                  }
    823              }
    824          
    825              /* Compute the precision value */
    826              if (precision < 0)
   \                     ??flt_3: (+1)
   \   0000006A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000006E   0xD502             BPL.N    ??flt_6
    827              {
    828                  precision = 6; /* Default precision: 6 */
   \   00000070   0x2006             MOVS     R0,#+6
   \   00000072   0x4683             MOV      R11,R0
   \   00000074   0xE008             B.N      ??flt_7
    829              }
    830              else if (precision == 0 && fmt == 'g')
   \                     ??flt_6: (+1)
   \   00000076   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000007A   0xD105             BNE.N    ??flt_7
   \   0000007C   0xF89D 0x0088      LDRB     R0,[SP, #+136]
   \   00000080   0x2867             CMP      R0,#+103
   \   00000082   0xD101             BNE.N    ??flt_7
    831              {
    832                  precision = 1; /* ANSI specified */
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x4683             MOV      R11,R0
    833              }
    834              /* Convert floating point number to text */
    835              cfltcvt(num, tmp, fmt, precision);
   \                     ??flt_7: (+1)
   \   00000088   0xF8CD 0xB000      STR      R11,[SP, #+0]
   \   0000008C   0xF89D 0x3088      LDRB     R3,[SP, #+136]
   \   00000090   0xAA03             ADD      R2,SP,#+12
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x4649             MOV      R1,R9
   \   00000096   0x.... 0x....      BL       cfltcvt
    836          
    837              /* '#' and precision == 0 means force a decimal point */
    838              if ((flags & SPECIAL) && precision == 0) forcdecpt(tmp);
   \   0000009A   0x06B0             LSLS     R0,R6,#+26
   \   0000009C   0xD505             BPL.N    ??flt_8
   \   0000009E   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000A2   0xD102             BNE.N    ??flt_8
   \   000000A4   0xA803             ADD      R0,SP,#+12
   \   000000A6   0x.... 0x....      BL       forcdecpt
    839          
    840              /* 'g' format means crop zero unless '#' given */
    841              if (fmt == 'g' && !(flags & SPECIAL)) cropzeros(tmp);
   \                     ??flt_8: (+1)
   \   000000AA   0xF89D 0x0088      LDRB     R0,[SP, #+136]
   \   000000AE   0x2867             CMP      R0,#+103
   \   000000B0   0xD104             BNE.N    ??flt_9
   \   000000B2   0x06B0             LSLS     R0,R6,#+26
   \   000000B4   0xD402             BMI.N    ??flt_9
   \   000000B6   0xA803             ADD      R0,SP,#+12
   \   000000B8   0x.... 0x....      BL       cropzeros
    842          
    843              n = strlen(tmp);
   \                     ??flt_9: (+1)
   \   000000BC   0xA803             ADD      R0,SP,#+12
   \   000000BE   0x.... 0x....      BL       strlen
   \   000000C2   0x9002             STR      R0,[SP, #+8]
    844          
    845              /* Output number with alignment and padding */
    846              size -= n;
   \   000000C4   0x9802             LDR      R0,[SP, #+8]
   \   000000C6   0x1A2D             SUBS     R5,R5,R0
    847              if(!(flags & (ZEROPAD | LEFT)))
   \   000000C8   0xF016 0x0F11      TST      R6,#0x11
   \   000000CC   0xD107             BNE.N    ??flt_10
    848              {
    849                  while(size-- > 0) *str++ = ' ';
   \                     ??flt_11: (+1)
   \   000000CE   0x0028             MOVS     R0,R5
   \   000000D0   0x1E45             SUBS     R5,R0,#+1
   \   000000D2   0x2801             CMP      R0,#+1
   \   000000D4   0xDB03             BLT.N    ??flt_10
   \   000000D6   0x2020             MOVS     R0,#+32
   \   000000D8   0x7020             STRB     R0,[R4, #+0]
   \   000000DA   0x1C64             ADDS     R4,R4,#+1
   \   000000DC   0xE7F7             B.N      ??flt_11
    850              }
    851              if(sign) *str++ = sign;
   \                     ??flt_10: (+1)
   \   000000DE   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD003             BEQ.N    ??flt_12
   \   000000E6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000EA   0x7020             STRB     R0,[R4, #+0]
   \   000000EC   0x1C64             ADDS     R4,R4,#+1
    852              
    853              if(!(flags & LEFT))
   \                     ??flt_12: (+1)
   \   000000EE   0x06F0             LSLS     R0,R6,#+27
   \   000000F0   0xD407             BMI.N    ??flt_13
    854              {
    855                  while(size-- > 0) *str++ = c;
   \                     ??flt_14: (+1)
   \   000000F2   0x0028             MOVS     R0,R5
   \   000000F4   0x1E45             SUBS     R5,R0,#+1
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xDB03             BLT.N    ??flt_13
   \   000000FA   0xF884 0xA000      STRB     R10,[R4, #+0]
   \   000000FE   0x1C64             ADDS     R4,R4,#+1
   \   00000100   0xE7F7             B.N      ??flt_14
    856              }
    857              for(i = 0; i < n; i++)
   \                     ??flt_13: (+1)
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x0007             MOVS     R7,R0
   \                     ??flt_15: (+1)
   \   00000106   0x9802             LDR      R0,[SP, #+8]
   \   00000108   0x4287             CMP      R7,R0
   \   0000010A   0xDA05             BGE.N    ??flt_16
    858              {
    859                  *str++ = tmp[i];
   \   0000010C   0xA803             ADD      R0,SP,#+12
   \   0000010E   0x5C38             LDRB     R0,[R7, R0]
   \   00000110   0x7020             STRB     R0,[R4, #+0]
   \   00000112   0x1C64             ADDS     R4,R4,#+1
    860              }
   \   00000114   0x1C7F             ADDS     R7,R7,#+1
   \   00000116   0xE7F6             B.N      ??flt_15
    861              
    862              while(size-- > 0) *str++ = ' ';
   \                     ??flt_16: (+1)
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x1E45             SUBS     R5,R0,#+1
   \   0000011C   0x2801             CMP      R0,#+1
   \   0000011E   0xDB03             BLT.N    ??flt_17
   \   00000120   0x2020             MOVS     R0,#+32
   \   00000122   0x7020             STRB     R0,[R4, #+0]
   \   00000124   0x1C64             ADDS     R4,R4,#+1
   \   00000126   0xE7F7             B.N      ??flt_16
    863          
    864              return str;
   \                     ??flt_17: (+1)
   \   00000128   0x0020             MOVS     R0,R4
   \   0000012A   0xB017             ADD      SP,SP,#+92
   \   0000012C   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    865          }
    866          
    867          #endif
    868          

   \                                 In section .text, align 2, keep-with-next
    869          static int vsprintf(char *buf, const char *fmt, va_list args)
    870          {
   \                     my_vsprintf: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x0014             MOVS     R4,R2
    871              char *str;
    872              int field_width;      /* Width of output field */
    873          
    874              for (str = buf; *fmt; fmt++)
   \   00000008   0x9807             LDR      R0,[SP, #+28]
   \   0000000A   0x0005             MOVS     R5,R0
   \                     ??my_vsprintf_0: (+1)
   \   0000000C   0x9808             LDR      R0,[SP, #+32]
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xF000 0x81AF      BEQ.W    ??my_vsprintf_1
    875              {
    876                  unsigned long num;
    877                  int base = 10;
   \   00000016   0x200A             MOVS     R0,#+10
   \   00000018   0x9005             STR      R0,[SP, #+20]
    878                  int flags = 0; /* Flags to number()    Process flags */
   \   0000001A   0x2700             MOVS     R7,#+0
    879                  int qualifier = -1;        /* 'h', 'l', or 'L' for integer fields */
   \   0000001C   0xF05F 0x38FF      MOVS     R8,#-1
    880                  int precision = -1;     /* Min. # of digits for integers; max number of chars for from string */
   \   00000020   0xF05F 0x39FF      MOVS     R9,#-1
    881                  BOOL bFmt = TRUE;
   \   00000024   0xF05F 0x0A01      MOVS     R10,#+1
    882                  if (*fmt != '%')
   \   00000028   0x9808             LDR      R0,[SP, #+32]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2825             CMP      R0,#+37
   \   0000002E   0xD004             BEQ.N    ??my_vsprintf_2
    883                  {
    884                      *str++ = *fmt;
   \   00000030   0x9808             LDR      R0,[SP, #+32]
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x7028             STRB     R0,[R5, #+0]
   \   00000036   0x1C6D             ADDS     R5,R5,#+1
    885                      continue;
   \   00000038   0xE198             B.N      ??my_vsprintf_3
    886                  }
    887                  
    888                  bFmt = TRUE;
   \                     ??my_vsprintf_2: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x4682             MOV      R10,R0
    889                  while(bFmt)
   \                     ??my_vsprintf_4: (+1)
   \   0000003E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000042   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000046   0xD021             BEQ.N    ??my_vsprintf_5
    890                  {
    891                      fmt++; /* This also skips first '%' */
   \   00000048   0x9808             LDR      R0,[SP, #+32]
   \   0000004A   0x1C40             ADDS     R0,R0,#+1
   \   0000004C   0x9008             STR      R0,[SP, #+32]
    892                      switch (*fmt)
   \   0000004E   0x9808             LDR      R0,[SP, #+32]
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x2820             CMP      R0,#+32
   \   00000054   0xD00E             BEQ.N    ??my_vsprintf_6
   \   00000056   0x2823             CMP      R0,#+35
   \   00000058   0xD00F             BEQ.N    ??my_vsprintf_7
   \   0000005A   0x282B             CMP      R0,#+43
   \   0000005C   0xD007             BEQ.N    ??my_vsprintf_8
   \   0000005E   0x282D             CMP      R0,#+45
   \   00000060   0xD002             BEQ.N    ??my_vsprintf_9
   \   00000062   0x2830             CMP      R0,#+48
   \   00000064   0xD00C             BEQ.N    ??my_vsprintf_10
   \   00000066   0xE00E             B.N      ??my_vsprintf_11
    893                      {
    894                          case '-': flags |= LEFT; break;
   \                     ??my_vsprintf_9: (+1)
   \   00000068   0xF057 0x0710      ORRS     R7,R7,#0x10
   \   0000006C   0xE7E7             B.N      ??my_vsprintf_4
    895                          case '+': flags |= PLUS; break;
   \                     ??my_vsprintf_8: (+1)
   \   0000006E   0xF057 0x0704      ORRS     R7,R7,#0x4
   \   00000072   0xE7E4             B.N      ??my_vsprintf_4
    896                          case ' ': flags |= SPACE; break;
   \                     ??my_vsprintf_6: (+1)
   \   00000074   0xF057 0x0708      ORRS     R7,R7,#0x8
   \   00000078   0xE7E1             B.N      ??my_vsprintf_4
    897                          case '#': flags |= SPECIAL; break;
   \                     ??my_vsprintf_7: (+1)
   \   0000007A   0xF057 0x0720      ORRS     R7,R7,#0x20
   \   0000007E   0xE7DE             B.N      ??my_vsprintf_4
    898                          case '0': flags |= ZEROPAD; break;
   \                     ??my_vsprintf_10: (+1)
   \   00000080   0xF057 0x0701      ORRS     R7,R7,#0x1
   \   00000084   0xE7DB             B.N      ??my_vsprintf_4
    899                          default:  bFmt = FALSE;
   \                     ??my_vsprintf_11: (+1)
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x4682             MOV      R10,R0
   \   0000008A   0xE7D8             B.N      ??my_vsprintf_4
    900                      }
    901                  }
    902                  
    903                  /* Get field width */
    904                  field_width = -1;
   \                     ??my_vsprintf_5: (+1)
   \   0000008C   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000090   0x0006             MOVS     R6,R0
    905                  if (is_digit(*fmt))
   \   00000092   0x9808             LDR      R0,[SP, #+32]
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x2830             CMP      R0,#+48
   \   00000098   0xDB08             BLT.N    ??my_vsprintf_12
   \   0000009A   0x9808             LDR      R0,[SP, #+32]
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x283A             CMP      R0,#+58
   \   000000A0   0xDA04             BGE.N    ??my_vsprintf_12
    906                  {
    907                      field_width = skip_atoi(&fmt);
   \   000000A2   0xA808             ADD      R0,SP,#+32
   \   000000A4   0x.... 0x....      BL       skip_atoi
   \   000000A8   0x0006             MOVS     R6,R0
   \   000000AA   0xE00F             B.N      ??my_vsprintf_13
    908                  }
    909                  else if ('*' == *fmt)
   \                     ??my_vsprintf_12: (+1)
   \   000000AC   0x9808             LDR      R0,[SP, #+32]
   \   000000AE   0x7800             LDRB     R0,[R0, #+0]
   \   000000B0   0x282A             CMP      R0,#+42
   \   000000B2   0xD10B             BNE.N    ??my_vsprintf_13
    910                  {
    911                      fmt++;
   \   000000B4   0x9808             LDR      R0,[SP, #+32]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x9008             STR      R0,[SP, #+32]
    912                      field_width = va_arg(args, int);
   \   000000BA   0x1D24             ADDS     R4,R4,#+4
   \   000000BC   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   000000C0   0x0006             MOVS     R6,R0
    913                      if (field_width < 0)
   \   000000C2   0x2E00             CMP      R6,#+0
   \   000000C4   0xD502             BPL.N    ??my_vsprintf_13
    914                      {
    915                          field_width = -field_width;
   \   000000C6   0x4276             RSBS     R6,R6,#+0
    916                          flags |= LEFT;
   \   000000C8   0xF057 0x0710      ORRS     R7,R7,#0x10
    917                      }
    918                  }
    919          
    920                  /* Get the precision */
    921                  precision = -1;
   \                     ??my_vsprintf_13: (+1)
   \   000000CC   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000D0   0x4681             MOV      R9,R0
    922                  if ('.' == *fmt)
   \   000000D2   0x9808             LDR      R0,[SP, #+32]
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0x282E             CMP      R0,#+46
   \   000000D8   0xD11F             BNE.N    ??my_vsprintf_14
    923                  {
    924                      ++fmt;
   \   000000DA   0x9808             LDR      R0,[SP, #+32]
   \   000000DC   0x1C40             ADDS     R0,R0,#+1
   \   000000DE   0x9008             STR      R0,[SP, #+32]
    925                      if (is_digit(*fmt))
   \   000000E0   0x9808             LDR      R0,[SP, #+32]
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x2830             CMP      R0,#+48
   \   000000E6   0xDB08             BLT.N    ??my_vsprintf_15
   \   000000E8   0x9808             LDR      R0,[SP, #+32]
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x283A             CMP      R0,#+58
   \   000000EE   0xDA04             BGE.N    ??my_vsprintf_15
    926                      {
    927                          precision = skip_atoi(&fmt);
   \   000000F0   0xA808             ADD      R0,SP,#+32
   \   000000F2   0x.... 0x....      BL       skip_atoi
   \   000000F6   0x4681             MOV      R9,R0
   \   000000F8   0xE00A             B.N      ??my_vsprintf_16
    928                      }
    929                      else if ('*' == *fmt)
   \                     ??my_vsprintf_15: (+1)
   \   000000FA   0x9808             LDR      R0,[SP, #+32]
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x282A             CMP      R0,#+42
   \   00000100   0xD106             BNE.N    ??my_vsprintf_16
    930                      {
    931                          ++fmt;
   \   00000102   0x9808             LDR      R0,[SP, #+32]
   \   00000104   0x1C40             ADDS     R0,R0,#+1
   \   00000106   0x9008             STR      R0,[SP, #+32]
    932                          precision = va_arg(args, int);
   \   00000108   0x1D24             ADDS     R4,R4,#+4
   \   0000010A   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   0000010E   0x4681             MOV      R9,R0
    933                      }
    934                      if (precision < 0) precision = 0;
   \                     ??my_vsprintf_16: (+1)
   \   00000110   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000114   0xD501             BPL.N    ??my_vsprintf_14
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0x4681             MOV      R9,R0
    935                  }
    936          
    937                  /* Get the conversion qualifier */
    938                  qualifier = -1;
   \                     ??my_vsprintf_14: (+1)
   \   0000011A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000011E   0x4680             MOV      R8,R0
    939                  if ('h' == *fmt || 'l' == *fmt || 'L' == *fmt)
   \   00000120   0x9808             LDR      R0,[SP, #+32]
   \   00000122   0x7800             LDRB     R0,[R0, #+0]
   \   00000124   0x2868             CMP      R0,#+104
   \   00000126   0xD007             BEQ.N    ??my_vsprintf_17
   \   00000128   0x9808             LDR      R0,[SP, #+32]
   \   0000012A   0x7800             LDRB     R0,[R0, #+0]
   \   0000012C   0x286C             CMP      R0,#+108
   \   0000012E   0xD003             BEQ.N    ??my_vsprintf_17
   \   00000130   0x9808             LDR      R0,[SP, #+32]
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x284C             CMP      R0,#+76
   \   00000136   0xD105             BNE.N    ??my_vsprintf_18
    940                  {
    941                      qualifier = *fmt;
   \                     ??my_vsprintf_17: (+1)
   \   00000138   0x9808             LDR      R0,[SP, #+32]
   \   0000013A   0x7800             LDRB     R0,[R0, #+0]
   \   0000013C   0x4680             MOV      R8,R0
    942                      fmt++;
   \   0000013E   0x9808             LDR      R0,[SP, #+32]
   \   00000140   0x1C40             ADDS     R0,R0,#+1
   \   00000142   0x9008             STR      R0,[SP, #+32]
    943                  }
    944          
    945                  /* Default base */
    946                  base = 10;
   \                     ??my_vsprintf_18: (+1)
   \   00000144   0x200A             MOVS     R0,#+10
   \   00000146   0x9005             STR      R0,[SP, #+20]
    947                  switch (*fmt)
   \   00000148   0x9808             LDR      R0,[SP, #+32]
   \   0000014A   0x7800             LDRB     R0,[R0, #+0]
   \   0000014C   0x2841             CMP      R0,#+65
   \   0000014E   0xF000 0x8096      BEQ.W    ??my_vsprintf_19
   \   00000152   0x2845             CMP      R0,#+69
   \   00000154   0xF000 0x80B9      BEQ.W    ??my_vsprintf_20
   \   00000158   0x2847             CMP      R0,#+71
   \   0000015A   0xF000 0x80B6      BEQ.W    ??my_vsprintf_20
   \   0000015E   0x2858             CMP      R0,#+88
   \   00000160   0xF000 0x80AB      BEQ.W    ??my_vsprintf_21
   \   00000164   0x2861             CMP      R0,#+97
   \   00000166   0xF000 0x808C      BEQ.W    ??my_vsprintf_22
   \   0000016A   0x2863             CMP      R0,#+99
   \   0000016C   0xD01E             BEQ.N    ??my_vsprintf_23
   \   0000016E   0x2864             CMP      R0,#+100
   \   00000170   0xF000 0x80A8      BEQ.W    ??my_vsprintf_24
   \   00000174   0x2865             CMP      R0,#+101
   \   00000176   0xF000 0x80A8      BEQ.W    ??my_vsprintf_20
   \   0000017A   0x2866             CMP      R0,#+102
   \   0000017C   0xF000 0x80A5      BEQ.W    ??my_vsprintf_20
   \   00000180   0x2867             CMP      R0,#+103
   \   00000182   0xF000 0x80A2      BEQ.W    ??my_vsprintf_20
   \   00000186   0x2869             CMP      R0,#+105
   \   00000188   0xF000 0x809C      BEQ.W    ??my_vsprintf_24
   \   0000018C   0x286E             CMP      R0,#+110
   \   0000018E   0xD065             BEQ.N    ??my_vsprintf_25
   \   00000190   0x286F             CMP      R0,#+111
   \   00000192   0xF000 0x808F      BEQ.W    ??my_vsprintf_26
   \   00000196   0x2870             CMP      R0,#+112
   \   00000198   0xD04C             BEQ.N    ??my_vsprintf_27
   \   0000019A   0x2873             CMP      R0,#+115
   \   0000019C   0xD01C             BEQ.N    ??my_vsprintf_28
   \   0000019E   0x2875             CMP      R0,#+117
   \   000001A0   0xF000 0x8092      BEQ.W    ??my_vsprintf_29
   \   000001A4   0x2878             CMP      R0,#+120
   \   000001A6   0xF000 0x808A      BEQ.W    ??my_vsprintf_30
   \   000001AA   0xE09F             B.N      ??my_vsprintf_31
    948                  {
    949                      case 'c':
    950                      {
    951                          if (!(flags & LEFT)) while (--field_width > 0) *str++ = ' ';
   \                     ??my_vsprintf_23: (+1)
   \   000001AC   0x06F8             LSLS     R0,R7,#+27
   \   000001AE   0xD406             BMI.N    ??my_vsprintf_32
   \                     ??my_vsprintf_33: (+1)
   \   000001B0   0x1E76             SUBS     R6,R6,#+1
   \   000001B2   0x2E01             CMP      R6,#+1
   \   000001B4   0xDB03             BLT.N    ??my_vsprintf_32
   \   000001B6   0x2020             MOVS     R0,#+32
   \   000001B8   0x7028             STRB     R0,[R5, #+0]
   \   000001BA   0x1C6D             ADDS     R5,R5,#+1
   \   000001BC   0xE7F8             B.N      ??my_vsprintf_33
    952                          *str++ = (unsigned char) va_arg(args, int);
   \                     ??my_vsprintf_32: (+1)
   \   000001BE   0x1D24             ADDS     R4,R4,#+4
   \   000001C0   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   000001C4   0x7028             STRB     R0,[R5, #+0]
   \   000001C6   0x1C6D             ADDS     R5,R5,#+1
    953                          while (--field_width > 0) *str++ = ' ';
   \                     ??my_vsprintf_34: (+1)
   \   000001C8   0x1E76             SUBS     R6,R6,#+1
   \   000001CA   0x2E01             CMP      R6,#+1
   \   000001CC   0xDB03             BLT.N    ??my_vsprintf_35
   \   000001CE   0x2020             MOVS     R0,#+32
   \   000001D0   0x7028             STRB     R0,[R5, #+0]
   \   000001D2   0x1C6D             ADDS     R5,R5,#+1
   \   000001D4   0xE7F8             B.N      ??my_vsprintf_34
    954                          continue;
   \                     ??my_vsprintf_35: (+1)
   \   000001D6   0xE0C9             B.N      ??my_vsprintf_3
    955                      }
    956                      case 's':
    957                      {
    958                          int len;
    959                          char * s = va_arg(args, char *);
   \                     ??my_vsprintf_28: (+1)
   \   000001D8   0x1D24             ADDS     R4,R4,#+4
   \   000001DA   0xF854 0xBC04      LDR      R11,[R4, #-4]
    960                          if (!s) s = "<NULL>";
   \   000001DE   0xF1BB 0x0F00      CMP      R11,#+0
   \   000001E2   0xD101             BNE.N    ??my_vsprintf_36
   \   000001E4   0x....             LDR.N    R0,??DataTable8_9
   \   000001E6   0x4683             MOV      R11,R0
    961                          len = strnlen(s, precision);
   \                     ??my_vsprintf_36: (+1)
   \   000001E8   0x4649             MOV      R1,R9
   \   000001EA   0x4658             MOV      R0,R11
   \   000001EC   0x.... 0x....      BL       my_strnlen
   \   000001F0   0x9000             STR      R0,[SP, #+0]
    962                          if (!(flags & LEFT)) while (len < field_width--) *str++ = ' ';
   \   000001F2   0x06F8             LSLS     R0,R7,#+27
   \   000001F4   0xD408             BMI.N    ??my_vsprintf_37
   \                     ??my_vsprintf_38: (+1)
   \   000001F6   0x0030             MOVS     R0,R6
   \   000001F8   0x1E46             SUBS     R6,R0,#+1
   \   000001FA   0x9900             LDR      R1,[SP, #+0]
   \   000001FC   0x4281             CMP      R1,R0
   \   000001FE   0xDA03             BGE.N    ??my_vsprintf_37
   \   00000200   0x2020             MOVS     R0,#+32
   \   00000202   0x7028             STRB     R0,[R5, #+0]
   \   00000204   0x1C6D             ADDS     R5,R5,#+1
   \   00000206   0xE7F6             B.N      ??my_vsprintf_38
    963                          for (int i = 0; i < len; ++i) *str++ = *s++;
   \                     ??my_vsprintf_37: (+1)
   \   00000208   0x2000             MOVS     R0,#+0
   \                     ??my_vsprintf_39: (+1)
   \   0000020A   0x9900             LDR      R1,[SP, #+0]
   \   0000020C   0x4288             CMP      R0,R1
   \   0000020E   0xDA07             BGE.N    ??my_vsprintf_40
   \   00000210   0xF89B 0x1000      LDRB     R1,[R11, #+0]
   \   00000214   0x7029             STRB     R1,[R5, #+0]
   \   00000216   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   0000021A   0x1C6D             ADDS     R5,R5,#+1
   \   0000021C   0x1C40             ADDS     R0,R0,#+1
   \   0000021E   0xE7F4             B.N      ??my_vsprintf_39
    964                          while (len < field_width--) *str++ = ' ';
   \                     ??my_vsprintf_40: (+1)
   \   00000220   0x0030             MOVS     R0,R6
   \   00000222   0x1E46             SUBS     R6,R0,#+1
   \   00000224   0x9900             LDR      R1,[SP, #+0]
   \   00000226   0x4281             CMP      R1,R0
   \   00000228   0xDA03             BGE.N    ??my_vsprintf_41
   \   0000022A   0x2020             MOVS     R0,#+32
   \   0000022C   0x7028             STRB     R0,[R5, #+0]
   \   0000022E   0x1C6D             ADDS     R5,R5,#+1
   \   00000230   0xE7F6             B.N      ??my_vsprintf_40
    965                          continue;
   \                     ??my_vsprintf_41: (+1)
   \   00000232   0xE09B             B.N      ??my_vsprintf_3
    966                      }
    967                      case 'p':
    968                      {
    969                          if (-1 == field_width)
   \                     ??my_vsprintf_27: (+1)
   \   00000234   0xF116 0x0F01      CMN      R6,#+1
   \   00000238   0xD103             BNE.N    ??my_vsprintf_42
    970                          {
    971                              field_width = 2 * sizeof(void *);
   \   0000023A   0x2008             MOVS     R0,#+8
   \   0000023C   0x0006             MOVS     R6,R0
    972                              flags |= ZEROPAD;
   \   0000023E   0xF057 0x0701      ORRS     R7,R7,#0x1
    973                          }
    974                          str = number(str, (unsigned long) va_arg(args, void *), 16, field_width, precision, flags);
   \                     ??my_vsprintf_42: (+1)
   \   00000242   0x1D24             ADDS     R4,R4,#+4
   \   00000244   0x9701             STR      R7,[SP, #+4]
   \   00000246   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000024A   0x0033             MOVS     R3,R6
   \   0000024C   0x2210             MOVS     R2,#+16
   \   0000024E   0xF854 0x1C04      LDR      R1,[R4, #-4]
   \   00000252   0x0028             MOVS     R0,R5
   \   00000254   0x.... 0x....      BL       number
   \   00000258   0x0005             MOVS     R5,R0
    975                          continue;
   \   0000025A   0xE087             B.N      ??my_vsprintf_3
    976                      }
    977                      case 'n':
    978                      {
    979                          if ('l' == qualifier)
   \                     ??my_vsprintf_25: (+1)
   \   0000025C   0xF1B8 0x0F6C      CMP      R8,#+108
   \   00000260   0xD106             BNE.N    ??my_vsprintf_43
    980                          {
    981                              long *ip = va_arg(args, long *);
   \   00000262   0x1D24             ADDS     R4,R4,#+4
   \   00000264   0xF854 0x0C04      LDR      R0,[R4, #-4]
    982                              *ip = (str - buf);
   \   00000268   0x9907             LDR      R1,[SP, #+28]
   \   0000026A   0x1A69             SUBS     R1,R5,R1
   \   0000026C   0x6001             STR      R1,[R0, #+0]
   \   0000026E   0xE005             B.N      ??my_vsprintf_44
    983                          }
    984                          else
    985                          {
    986                              int *ip = va_arg(args, int *);
   \                     ??my_vsprintf_43: (+1)
   \   00000270   0x1D24             ADDS     R4,R4,#+4
   \   00000272   0xF854 0x0C04      LDR      R0,[R4, #-4]
    987                              *ip = (str - buf);
   \   00000276   0x9907             LDR      R1,[SP, #+28]
   \   00000278   0x1A69             SUBS     R1,R5,R1
   \   0000027A   0x6001             STR      R1,[R0, #+0]
    988                          }
    989                          continue;
   \                     ??my_vsprintf_44: (+1)
   \   0000027C   0xE076             B.N      ??my_vsprintf_3
    990                      }
    991                      case 'A':
    992                      {
    993                          flags |= LARGE; /* no break */
   \                     ??my_vsprintf_19: (+1)
   \   0000027E   0xF057 0x0740      ORRS     R7,R7,#0x40
    994                      }
    995                      case 'a':
    996                      {
    997                          if ('l' == qualifier)
   \                     ??my_vsprintf_22: (+1)
   \   00000282   0xF1B8 0x0F6C      CMP      R8,#+108
   \   00000286   0xD10A             BNE.N    ??my_vsprintf_45
    998                          {
    999                              str = eaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
   \   00000288   0x1D24             ADDS     R4,R4,#+4
   \   0000028A   0x9700             STR      R7,[SP, #+0]
   \   0000028C   0x464B             MOV      R3,R9
   \   0000028E   0x0032             MOVS     R2,R6
   \   00000290   0xF854 0x1C04      LDR      R1,[R4, #-4]
   \   00000294   0x0028             MOVS     R0,R5
   \   00000296   0x.... 0x....      BL       eaddr
   \   0000029A   0x0005             MOVS     R5,R0
   \   0000029C   0xE009             B.N      ??my_vsprintf_46
   1000                          }
   1001                          else
   1002                          {
   1003                              str = iaddr(str, va_arg(args, unsigned char *), field_width, precision, flags);
   \                     ??my_vsprintf_45: (+1)
   \   0000029E   0x1D24             ADDS     R4,R4,#+4
   \   000002A0   0x9700             STR      R7,[SP, #+0]
   \   000002A2   0x464B             MOV      R3,R9
   \   000002A4   0x0032             MOVS     R2,R6
   \   000002A6   0xF854 0x1C04      LDR      R1,[R4, #-4]
   \   000002AA   0x0028             MOVS     R0,R5
   \   000002AC   0x.... 0x....      BL       iaddr
   \   000002B0   0x0005             MOVS     R5,R0
   1004                          }
   1005                          continue;
   \                     ??my_vsprintf_46: (+1)
   \   000002B2   0xE05B             B.N      ??my_vsprintf_3
   1006                      }
   1007                          /* Integer number formats - set up the flags and "break" */
   1008                      case 'o':
   1009                      {
   1010                          base = 8;
   \                     ??my_vsprintf_26: (+1)
   \   000002B4   0x2008             MOVS     R0,#+8
   \   000002B6   0x9005             STR      R0,[SP, #+20]
   1011                          break;
   \   000002B8   0xE02C             B.N      ??my_vsprintf_47
   1012                      }
   1013                      case 'X':
   1014                      {
   1015                          flags |= LARGE; /* no break */
   \                     ??my_vsprintf_21: (+1)
   \   000002BA   0xF057 0x0740      ORRS     R7,R7,#0x40
   1016                      }
   1017                      case 'x':
   1018                      {
   1019                          base = 16;
   \                     ??my_vsprintf_30: (+1)
   \   000002BE   0x2010             MOVS     R0,#+16
   \   000002C0   0x9005             STR      R0,[SP, #+20]
   1020                          break;
   \   000002C2   0xE027             B.N      ??my_vsprintf_47
   1021                      }
   1022                      case 'd':
   1023                      case 'i':
   1024                      {
   1025                          flags |= SIGN; /* no break */
   \                     ??my_vsprintf_24: (+1)
   \   000002C4   0xF057 0x0702      ORRS     R7,R7,#0x2
   1026                      }
   1027                      case 'u':
   1028                      {
   1029                          break;
   \                     ??my_vsprintf_29: (+1)
   \   000002C8   0xE024             B.N      ??my_vsprintf_47
   1030                      }
   1031          #ifndef NOFLOAT
   1032                      case 'E':
   1033                      case 'G':
   1034                      case 'e':
   1035                      case 'f':
   1036                      case 'g':
   1037                      {
   1038                          str = flt(str, va_arg(args, double), field_width, precision, *fmt, flags | SIGN);
   \                     ??my_vsprintf_20: (+1)
   \   000002CA   0x3408             ADDS     R4,R4,#+8
   \   000002CC   0xF057 0x0002      ORRS     R0,R7,#0x2
   \   000002D0   0x9003             STR      R0,[SP, #+12]
   \   000002D2   0x9808             LDR      R0,[SP, #+32]
   \   000002D4   0x7800             LDRB     R0,[R0, #+0]
   \   000002D6   0x9002             STR      R0,[SP, #+8]
   \   000002D8   0xF8CD 0x9004      STR      R9,[SP, #+4]
   \   000002DC   0x9600             STR      R6,[SP, #+0]
   \   000002DE   0xE954 0x2302      LDRD     R2,R3,[R4, #-8]
   \   000002E2   0x0028             MOVS     R0,R5
   \   000002E4   0x.... 0x....      BL       flt
   \   000002E8   0x0005             MOVS     R5,R0
   1039                          continue;
   \   000002EA   0xE03F             B.N      ??my_vsprintf_3
   1040                      }
   1041          #endif
   1042                      default:
   1043                      {
   1044                          if (*fmt != '%') *str++ = '%';
   \                     ??my_vsprintf_31: (+1)
   \   000002EC   0x9808             LDR      R0,[SP, #+32]
   \   000002EE   0x7800             LDRB     R0,[R0, #+0]
   \   000002F0   0x2825             CMP      R0,#+37
   \   000002F2   0xD002             BEQ.N    ??my_vsprintf_48
   \   000002F4   0x2025             MOVS     R0,#+37
   \   000002F6   0x7028             STRB     R0,[R5, #+0]
   \   000002F8   0x1C6D             ADDS     R5,R5,#+1
   1045                          if (*fmt)
   \                     ??my_vsprintf_48: (+1)
   \   000002FA   0x9808             LDR      R0,[SP, #+32]
   \   000002FC   0x7800             LDRB     R0,[R0, #+0]
   \   000002FE   0x2800             CMP      R0,#+0
   \   00000300   0xD004             BEQ.N    ??my_vsprintf_49
   1046                          {
   1047                              *str++ = *fmt;
   \   00000302   0x9808             LDR      R0,[SP, #+32]
   \   00000304   0x7800             LDRB     R0,[R0, #+0]
   \   00000306   0x7028             STRB     R0,[R5, #+0]
   \   00000308   0x1C6D             ADDS     R5,R5,#+1
   \   0000030A   0xE002             B.N      ??my_vsprintf_50
   1048                          }
   1049                          else
   1050                          {
   1051                              --fmt;
   \                     ??my_vsprintf_49: (+1)
   \   0000030C   0x9808             LDR      R0,[SP, #+32]
   \   0000030E   0x1E40             SUBS     R0,R0,#+1
   \   00000310   0x9008             STR      R0,[SP, #+32]
   1052                          }
   1053                          continue;
   \                     ??my_vsprintf_50: (+1)
   \   00000312   0xE02B             B.N      ??my_vsprintf_3
   1054                      }
   1055                  }  /* end of switch (*fmt) */
   1056          
   1057                  if (qualifier == 'l')
   \                     ??my_vsprintf_47: (+1)
   \   00000314   0xF1B8 0x0F6C      CMP      R8,#+108
   \   00000318   0xD104             BNE.N    ??my_vsprintf_51
   1058                  {
   1059                      num = va_arg(args, unsigned long);
   \   0000031A   0x1D24             ADDS     R4,R4,#+4
   \   0000031C   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   00000320   0x9004             STR      R0,[SP, #+16]
   \   00000322   0xE019             B.N      ??my_vsprintf_52
   1060                  }
   1061                  else if (qualifier == 'h')
   \                     ??my_vsprintf_51: (+1)
   \   00000324   0xF1B8 0x0F68      CMP      R8,#+104
   \   00000328   0xD10B             BNE.N    ??my_vsprintf_53
   1062                  {
   1063                      if (flags & SIGN)
   \   0000032A   0x07B8             LSLS     R0,R7,#+30
   \   0000032C   0xD504             BPL.N    ??my_vsprintf_54
   1064                          num = va_arg(args, short);
   \   0000032E   0x1D24             ADDS     R4,R4,#+4
   \   00000330   0xF934 0x0C04      LDRSH    R0,[R4, #-4]
   \   00000334   0x9004             STR      R0,[SP, #+16]
   \   00000336   0xE00F             B.N      ??my_vsprintf_52
   1065                      else
   1066                          num = va_arg(args, unsigned short);
   \                     ??my_vsprintf_54: (+1)
   \   00000338   0x1D24             ADDS     R4,R4,#+4
   \   0000033A   0xF834 0x0C04      LDRH     R0,[R4, #-4]
   \   0000033E   0x9004             STR      R0,[SP, #+16]
   \   00000340   0xE00A             B.N      ??my_vsprintf_52
   1067                  }
   1068                  else if (flags & SIGN)
   \                     ??my_vsprintf_53: (+1)
   \   00000342   0x07B8             LSLS     R0,R7,#+30
   \   00000344   0xD504             BPL.N    ??my_vsprintf_55
   1069                  {
   1070                      num = va_arg(args, int);
   \   00000346   0x1D24             ADDS     R4,R4,#+4
   \   00000348   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   0000034C   0x9004             STR      R0,[SP, #+16]
   \   0000034E   0xE003             B.N      ??my_vsprintf_52
   1071                  }
   1072                  else
   1073                  {
   1074                      num = va_arg(args, unsigned long);
   \                     ??my_vsprintf_55: (+1)
   \   00000350   0x1D24             ADDS     R4,R4,#+4
   \   00000352   0xF854 0x0C04      LDR      R0,[R4, #-4]
   \   00000356   0x9004             STR      R0,[SP, #+16]
   1075                  }
   1076                  
   1077                  str = number(str, num, base, field_width, precision, flags);
   \                     ??my_vsprintf_52: (+1)
   \   00000358   0x9701             STR      R7,[SP, #+4]
   \   0000035A   0xF8CD 0x9000      STR      R9,[SP, #+0]
   \   0000035E   0x0033             MOVS     R3,R6
   \   00000360   0x9A05             LDR      R2,[SP, #+20]
   \   00000362   0x9904             LDR      R1,[SP, #+16]
   \   00000364   0x0028             MOVS     R0,R5
   \   00000366   0x.... 0x....      BL       number
   \   0000036A   0x0005             MOVS     R5,R0
   1078              } /* end of for (str = buf; *fmt; fmt++) */
   \                     ??my_vsprintf_3: (+1)
   \   0000036C   0x9808             LDR      R0,[SP, #+32]
   \   0000036E   0x1C40             ADDS     R0,R0,#+1
   \   00000370   0x9008             STR      R0,[SP, #+32]
   \   00000372   0xE64B             B.N      ??my_vsprintf_0
   1079          
   1080              *str = '\0';
   \                     ??my_vsprintf_1: (+1)
   \   00000374   0x2000             MOVS     R0,#+0
   \   00000376   0x7028             STRB     R0,[R5, #+0]
   1081              return str - buf;
   \   00000378   0x9807             LDR      R0,[SP, #+28]
   \   0000037A   0x1A28             SUBS     R0,R5,R0
   \   0000037C   0xB009             ADD      SP,SP,#+36
   \   0000037E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1082          }
   1083          

   \                                 In section .text, align 2, keep-with-next
   1084          int usprintf(char *buf, const char *fmt, ...)
   1085          {
   \                     usprintf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB578             PUSH     {R3-R6,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1086              va_list args;
   1087              int n;
   1088          
   1089              va_start(args, fmt);
   \   00000006   0xA806             ADD      R0,SP,#+24
   \   00000008   0x0005             MOVS     R5,R0
   1090              n = vsprintf(buf, fmt, args);
   \   0000000A   0x002A             MOVS     R2,R5
   \   0000000C   0x9905             LDR      R1,[SP, #+20]
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       my_vsprintf
   \   00000014   0x0006             MOVS     R6,R0
   1091              va_end(args);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
   1092          
   1093              return n;
   \   0000001A   0x0030             MOVS     R0,R6
   \   0000001C   0xBC72             POP      {R1,R4-R6}
   \   0000001E   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
   1094          }
   1095          
   1096          extern void WIN_DispMsg(const char *msg);
   1097          

   \                                 In section .text, align 2, keep-with-next
   1098          void uprintf(const char *fmt, ...)
   1099          {
   \                     uprintf: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB510             PUSH     {R4,LR}
   \   00000004   0xB09A             SUB      SP,SP,#+104
   1100              char printfbuf[100];
   1101              
   1102              va_list args;
   1103              va_start(args, fmt);
   \   00000006   0xA81D             ADD      R0,SP,#+116
   \   00000008   0x0004             MOVS     R4,R0
   1104              vsprintf(printfbuf, fmt, args);
   \   0000000A   0x0022             MOVS     R2,R4
   \   0000000C   0x991C             LDR      R1,[SP, #+112]
   \   0000000E   0x4668             MOV      R0,SP
   \   00000010   0x.... 0x....      BL       my_vsprintf
   1105              va_end(args);
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x0004             MOVS     R4,R0
   1106              printfbuf[99] = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0063      STRB     R0,[SP, #+99]
   1107              WIN_DispMsg((const char *)printfbuf);
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x.... 0x....      BL       WIN_DispMsg
   1108          }
   \   00000024   0xB01A             ADD      SP,SP,#+104
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
   1109          

   \                                 In section .text, align 2, keep-with-next
   1110          void uartprintf(MODBUS_CH  *pch,const char *fmt, ...)
   1111          {
   \                     uartprintf: (+1)
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
   \   00000006   0x0004             MOVS     R4,R0
   1112              char printfbuf[200];
   1113              
   1114              va_list args;
   1115              va_start(args, fmt);
   \   00000008   0xA836             ADD      R0,SP,#+216
   \   0000000A   0x0005             MOVS     R5,R0
   1116              vsprintf(printfbuf, fmt, args);
   \   0000000C   0x002A             MOVS     R2,R5
   \   0000000E   0x9935             LDR      R1,[SP, #+212]
   \   00000010   0x4668             MOV      R0,SP
   \   00000012   0x.... 0x....      BL       my_vsprintf
   1117              va_end(args);
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x0005             MOVS     R5,R0
   1118              printfbuf[199] = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF88D 0x00C7      STRB     R0,[SP, #+199]
   1119              UARTPutString(pch, (const char *)printfbuf);
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       UARTPutString
   1120          }
   \   00000028   0xB032             ADD      SP,SP,#+200
   \   0000002A   0xBC30             POP      {R4,R5}
   \   0000002C   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x49 0x6E          DC8      "Inf"
   \              0x66 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x4E 0x61          DC8      "NaN"
   \              0x4E 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     digits

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     upper_digits

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x2C40C60E         DC32     0x2c40c60e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x0031FA18         DC32     0x31fa18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x2C40C60D         DC32     0x2c40c60d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x8031FA18         DC32     0x8031fa18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x3FB99999         DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x40140000         DC32     0x40140000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     ??INFINITY

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     ??INFINITY_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x30 0x31          DC8 "0123456789abcdefghijklmnopqrstuvwxyz"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x67 0x68    
   \              0x69 0x6A    
   \              0x6B 0x6C    
   \              0x6D 0x6E    
   \              0x6F 0x70    
   \              0x71 0x72    
   \              0x73 0x74    
   \              0x75 0x76    
   \              0x77 0x78    
   \              0x79 0x7A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x30 0x31          DC8 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x47 0x48    
   \              0x49 0x4A    
   \              0x4B 0x4C    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x54    
   \              0x55 0x56    
   \              0x57 0x58    
   \              0x59 0x5A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x49 0x6E          DC8 "Inf"
   \              0x66 0x00    

   \                                 In section .rodata, align 4
   \   00000000   0x4E 0x61          DC8 "NaN"
   \              0x4E 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x3C 0x4E          DC8 "<NULL>"
   \              0x55 0x4C    
   \              0x4C 0x3E    
   \              0x00         
   \   00000007   0x00               DC8 0
   1121          /* ///////////////////////////////////////////////////////////////////////////// */
   1122          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   __ecvround
     136   cfltcvt
       136   -> __aeabi_memcpy
       136   -> ecvtbuf
       136   -> fcvtbuf
       136 __aeabi_cdcmple
       136 __aeabi_cdrcmple
       0   cropzeros
      44   eaddr
      72   ecvtbuf
        72   -> __aeabi_memcpy
        72   -> __aeabi_memset
        72   -> __ecvround
        72   -> ftoaE
        72   -> my_atoi
        72   -> strcmp
        72   -> strncmp
      80   fcvtbuf
        80   -> __aeabi_memcpy
        80   -> __ecvround
        80   -> ecvtbuf
        80   -> my_ftoa
        80   -> strchr
        80   -> strlen
        80   -> strncmp
        80 __aeabi_cdcmple
        80 __aeabi_cdrcmple
     128   flt
       128   -> cfltcvt
       128   -> cropzeros
       128   -> forcdecpt
       128   -> strlen
       128 __aeabi_cdcmple
       8   forcdecpt
         8   -> strlen
      56   ftoaE
        56   -> __aeabi_d2iz
        56   -> __aeabi_dadd
        56   -> __aeabi_dmul
        56   -> __aeabi_dsub
        56   -> __aeabi_i2d
        56   -> itoa
        56 __aeabi_cdcmple
        56 __aeabi_cdrcmple
      44   iaddr
       0   is_space
       4   itoa
      24   my_atoi
        24   -> is_space
      40   my_ftoa
        40   -> __aeabi_d2iz
        40   -> __aeabi_dadd
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_i2d
        40   -> itoa
        40   -> strlen
        40 __aeabi_cdcmple
        40 __aeabi_cdrcmple
       0   my_strnlen
      72   my_vsprintf
        72   -> eaddr
        72   -> flt
        72   -> iaddr
        72   -> my_strnlen
        72   -> number
        72   -> skip_atoi
      96   number
       0   skip_atoi
      16   strchr
        16   -> __iar_Strchr
     224   uartprintf
       224   -> UARTPutString
       224   -> my_vsprintf
     128   uprintf
       128   -> WIN_DispMsg
       128   -> my_vsprintf
      32   usprintf
        32   -> my_vsprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      40  ?_0
      40  ?_1
       4  ?_2
       4  ?_3
       8  ?_4
      12  INFINITY
      12  INFINITY
      66  __ecvround
     496  cfltcvt
      86  cropzeros
       4  digits
     154  eaddr
     368  ecvtbuf
     338  fcvtbuf
     304  flt
      78  forcdecpt
     468  ftoaE
     270  iaddr
      22  is_space
      90  itoa
      86  my_atoi
     310  my_ftoa
      24  my_strnlen
     898  my_vsprintf
     346  number
      40  skip_atoi
      16  strchr
      48  uartprintf
       4  upper_digits
      44  uprintf
      34  usprintf

 
    32 bytes in section .data
    96 bytes in section .rodata
 4 654 bytes in section .text
 
 4 638 bytes of CODE  memory (+ 16 bytes shared)
    96 bytes of CONST memory
    32 bytes of DATA  memory

Errors: none
Warnings: 1
