###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       07/Sep/2017  21:02:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_gpio.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_gpio.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_gpio.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_gpio.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_gpio.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_gpio.c				2010-05-21
      3          *//**
      4          * @file		lpc17xx_gpio.c
      5          * @brief	Contains all functions support for GPIO firmware
      6          * 			library on LPC17xx
      7          * @version	2.0
      8          * @date		21. May. 2010
      9          * @author	NXP MCU SW Application Team
     10          *
     11          * Copyright(C) 2010, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          * Permission to use, copy, modify, and distribute this software and its
     26          * documentation is hereby granted, under NXP Semiconductors'
     27          * relevant copyright in the software, without fee, provided that it
     28          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     29          * copyright, permission, and disclaimer notice must appear in all copies of
     30          * this code.
     31          **********************************************************************/
     32          
     33          /* Peripheral group ----------------------------------------------------------- */
     34          /** @addtogroup GPIO
     35           * @{
     36           */
     37          
     38          /* Includes ------------------------------------------------------------------- */
     39          #include "lpc17xx_gpio.h"
     40          
     41          /* If this source file built with example, the LPC17xx FW library configuration
     42           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     43           * otherwise the default FW library configuration file must be included instead
     44           */
     45          #ifdef __BUILD_WITH_EXAMPLE__
     46          #include "lpc17xx_libcfg.h"
     47          #else
     48          #include "lpc17xx_libcfg_default.h"
     49          #endif /* __BUILD_WITH_EXAMPLE__ */
     50          
     51          
     52          #ifdef _GPIO
     53          
     54          /* Private Functions ---------------------------------------------------------- */
     55          
     56          static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum);
     57          static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum);
     58          static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum);
     59          
     60          /*********************************************************************//**
     61           * @brief		Get pointer to GPIO peripheral due to GPIO port
     62           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
     63           * @return		Pointer to GPIO peripheral
     64           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     65          static LPC_GPIO_TypeDef *GPIO_GetPointer(uint8_t portNum)
     66          {
   \                     GPIO_GetPointer: (+1)
   \   00000000   0x0001             MOVS     R1,R0
     67          	LPC_GPIO_TypeDef *pGPIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
     68          
     69          	switch (portNum) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD006             BEQ.N    ??GPIO_GetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00A             BEQ.N    ??GPIO_GetPointer_1
   \   0000000E   0xD306             BCC.N    ??GPIO_GetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00D             BEQ.N    ??GPIO_GetPointer_3
   \   00000014   0xD309             BCC.N    ??GPIO_GetPointer_4
   \   00000016   0xE00E             B.N      ??GPIO_GetPointer_5
     70          	case 0:
     71          		pGPIO = LPC_GPIO0;
   \                     ??GPIO_GetPointer_0: (+1)
   \   00000018   0x....             LDR.N    R2,??DataTable5  ;; 0x2009c000
   \   0000001A   0x0010             MOVS     R0,R2
     72          		break;
   \   0000001C   0xE00B             B.N      ??GPIO_GetPointer_6
     73          	case 1:
     74          		pGPIO = LPC_GPIO1;
   \                     ??GPIO_GetPointer_2: (+1)
   \   0000001E   0x....             LDR.N    R2,??DataTable5_1  ;; 0x2009c020
   \   00000020   0x0010             MOVS     R0,R2
     75          		break;
   \   00000022   0xE008             B.N      ??GPIO_GetPointer_6
     76          	case 2:
     77          		pGPIO = LPC_GPIO2;
   \                     ??GPIO_GetPointer_1: (+1)
   \   00000024   0x....             LDR.N    R2,??DataTable5_2  ;; 0x2009c040
   \   00000026   0x0010             MOVS     R0,R2
     78          		break;
   \   00000028   0xE005             B.N      ??GPIO_GetPointer_6
     79          	case 3:
     80          		pGPIO = LPC_GPIO3;
   \                     ??GPIO_GetPointer_4: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable5_3  ;; 0x2009c060
   \   0000002C   0x0010             MOVS     R0,R2
     81          		break;
   \   0000002E   0xE002             B.N      ??GPIO_GetPointer_6
     82          	case 4:
     83          		pGPIO = LPC_GPIO4;
   \                     ??GPIO_GetPointer_3: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable5_4  ;; 0x2009c080
   \   00000032   0x0010             MOVS     R0,R2
     84          		break;
   \   00000034   0xE7FF             B.N      ??GPIO_GetPointer_6
     85          	default:
     86          		break;
     87          	}
     88          
     89          	return pGPIO;
   \                     ??GPIO_GetPointer_5: (+1)
   \                     ??GPIO_GetPointer_6: (+1)
   \   00000036   0x4770             BX       LR               ;; return
     90          }
     91          
     92          /*********************************************************************//**
     93           * @brief		Get pointer to FIO peripheral in halfword accessible style
     94           * 				due to FIO port
     95           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
     96           * @return		Pointer to FIO peripheral
     97           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     98          static GPIO_HalfWord_TypeDef *FIO_HalfWordGetPointer(uint8_t portNum)
     99          {
   \                     FIO_HalfWordGetPointer: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    100          	GPIO_HalfWord_TypeDef *pFIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
    101          
    102          	switch (portNum) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD006             BEQ.N    ??FIO_HalfWordGetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00A             BEQ.N    ??FIO_HalfWordGetPointer_1
   \   0000000E   0xD306             BCC.N    ??FIO_HalfWordGetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00D             BEQ.N    ??FIO_HalfWordGetPointer_3
   \   00000014   0xD309             BCC.N    ??FIO_HalfWordGetPointer_4
   \   00000016   0xE00E             B.N      ??FIO_HalfWordGetPointer_5
    103          	case 0:
    104          		pFIO = GPIO0_HalfWord;
   \                     ??FIO_HalfWordGetPointer_0: (+1)
   \   00000018   0x....             LDR.N    R2,??DataTable5  ;; 0x2009c000
   \   0000001A   0x0010             MOVS     R0,R2
    105          		break;
   \   0000001C   0xE00B             B.N      ??FIO_HalfWordGetPointer_6
    106          	case 1:
    107          		pFIO = GPIO1_HalfWord;
   \                     ??FIO_HalfWordGetPointer_2: (+1)
   \   0000001E   0x....             LDR.N    R2,??DataTable5_1  ;; 0x2009c020
   \   00000020   0x0010             MOVS     R0,R2
    108          		break;
   \   00000022   0xE008             B.N      ??FIO_HalfWordGetPointer_6
    109          	case 2:
    110          		pFIO = GPIO2_HalfWord;
   \                     ??FIO_HalfWordGetPointer_1: (+1)
   \   00000024   0x....             LDR.N    R2,??DataTable5_2  ;; 0x2009c040
   \   00000026   0x0010             MOVS     R0,R2
    111          		break;
   \   00000028   0xE005             B.N      ??FIO_HalfWordGetPointer_6
    112          	case 3:
    113          		pFIO = GPIO3_HalfWord;
   \                     ??FIO_HalfWordGetPointer_4: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable5_3  ;; 0x2009c060
   \   0000002C   0x0010             MOVS     R0,R2
    114          		break;
   \   0000002E   0xE002             B.N      ??FIO_HalfWordGetPointer_6
    115          	case 4:
    116          		pFIO = GPIO4_HalfWord;
   \                     ??FIO_HalfWordGetPointer_3: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable5_4  ;; 0x2009c080
   \   00000032   0x0010             MOVS     R0,R2
    117          		break;
   \   00000034   0xE7FF             B.N      ??FIO_HalfWordGetPointer_6
    118          	default:
    119          		break;
    120          	}
    121          
    122          	return pFIO;
   \                     ??FIO_HalfWordGetPointer_5: (+1)
   \                     ??FIO_HalfWordGetPointer_6: (+1)
   \   00000036   0x4770             BX       LR               ;; return
    123          }
    124          
    125          /*********************************************************************//**
    126           * @brief		Get pointer to FIO peripheral in byte accessible style
    127           * 				due to FIO port
    128           * @param[in]	portNum		Port Number value, should be in range from 0 to 4.
    129           * @return		Pointer to FIO peripheral
    130           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    131          static GPIO_Byte_TypeDef *FIO_ByteGetPointer(uint8_t portNum)
    132          {
   \                     FIO_ByteGetPointer: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    133          	GPIO_Byte_TypeDef *pFIO = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
    134          
    135          	switch (portNum) {
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD006             BEQ.N    ??FIO_ByteGetPointer_0
   \   0000000A   0x2902             CMP      R1,#+2
   \   0000000C   0xD00A             BEQ.N    ??FIO_ByteGetPointer_1
   \   0000000E   0xD306             BCC.N    ??FIO_ByteGetPointer_2
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xD00D             BEQ.N    ??FIO_ByteGetPointer_3
   \   00000014   0xD309             BCC.N    ??FIO_ByteGetPointer_4
   \   00000016   0xE00E             B.N      ??FIO_ByteGetPointer_5
    136          	case 0:
    137          		pFIO = GPIO0_Byte;
   \                     ??FIO_ByteGetPointer_0: (+1)
   \   00000018   0x....             LDR.N    R2,??DataTable5  ;; 0x2009c000
   \   0000001A   0x0010             MOVS     R0,R2
    138          		break;
   \   0000001C   0xE00B             B.N      ??FIO_ByteGetPointer_6
    139          	case 1:
    140          		pFIO = GPIO1_Byte;
   \                     ??FIO_ByteGetPointer_2: (+1)
   \   0000001E   0x....             LDR.N    R2,??DataTable5_1  ;; 0x2009c020
   \   00000020   0x0010             MOVS     R0,R2
    141          		break;
   \   00000022   0xE008             B.N      ??FIO_ByteGetPointer_6
    142          	case 2:
    143          		pFIO = GPIO2_Byte;
   \                     ??FIO_ByteGetPointer_1: (+1)
   \   00000024   0x....             LDR.N    R2,??DataTable5_2  ;; 0x2009c040
   \   00000026   0x0010             MOVS     R0,R2
    144          		break;
   \   00000028   0xE005             B.N      ??FIO_ByteGetPointer_6
    145          	case 3:
    146          		pFIO = GPIO3_Byte;
   \                     ??FIO_ByteGetPointer_4: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable5_3  ;; 0x2009c060
   \   0000002C   0x0010             MOVS     R0,R2
    147          		break;
   \   0000002E   0xE002             B.N      ??FIO_ByteGetPointer_6
    148          	case 4:
    149          		pFIO = GPIO4_Byte;
   \                     ??FIO_ByteGetPointer_3: (+1)
   \   00000030   0x....             LDR.N    R2,??DataTable5_4  ;; 0x2009c080
   \   00000032   0x0010             MOVS     R0,R2
    150          		break;
   \   00000034   0xE7FF             B.N      ??FIO_ByteGetPointer_6
    151          	default:
    152          		break;
    153          	}
    154          
    155          	return pFIO;
   \                     ??FIO_ByteGetPointer_5: (+1)
   \                     ??FIO_ByteGetPointer_6: (+1)
   \   00000036   0x4770             BX       LR               ;; return
    156          }
    157          
    158          /* End of Private Functions --------------------------------------------------- */
    159          
    160          
    161          /* Public Functions ----------------------------------------------------------- */
    162          /** @addtogroup GPIO_Public_Functions
    163           * @{
    164           */
    165          
    166          
    167          /* GPIO ------------------------------------------------------------------------------ */
    168          
    169          /*********************************************************************//**
    170           * @brief		Set Direction for GPIO port.
    171           * @param[in]	portNum		Port Number value, should be in range from 0 to 4
    172           * @param[in]	bitValue	Value that contains all bits to set direction,
    173           * 							in range from 0 to 0xFFFFFFFF.
    174           * 							example: value 0x5 to set direction for bit 0 and bit 1.
    175           * @param[in]	dir			Direction value, should be:
    176           * 							- 0: Input.
    177           * 							- 1: Output.
    178           * @return		None
    179           *
    180           * Note: All remaining bits that are not activated in bitValue (value '0')
    181           * will not be effected by this function.
    182           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    183          void GPIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
    184          {
   \                     GPIO_SetDir: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    185          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_GetPointer
    186          
    187          	if (pGPIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??GPIO_SetDir_0
    188          		// Enable Output
    189          		if (dir) {
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD003             BEQ.N    ??GPIO_SetDir_1
    190          			pGPIO->FIODIR |= bitValue;
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x4329             ORRS     R1,R5,R1
   \   0000001E   0x6001             STR      R1,[R0, #+0]
   \   00000020   0xE002             B.N      ??GPIO_SetDir_0
    191          		}
    192          		// Enable Input
    193          		else {
    194          			pGPIO->FIODIR &= ~bitValue;
   \                     ??GPIO_SetDir_1: (+1)
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x43A9             BICS     R1,R1,R5
   \   00000026   0x6001             STR      R1,[R0, #+0]
    195          		}
    196          	}
    197          }
   \                     ??GPIO_SetDir_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    198          
    199          
    200          /*********************************************************************//**
    201           * @brief		Set Value for bits that have output direction on GPIO port.
    202           * @param[in]	portNum		Port number value, should be in range from 0 to 4
    203           * @param[in]	bitValue	Value that contains all bits on GPIO to set,
    204           * 							in range from 0 to 0xFFFFFFFF.
    205           * 							example: value 0x5 to set bit 0 and bit 1.
    206           * @return		None
    207           *
    208           * Note:
    209           * - For all bits that has been set as input direction, this function will
    210           * not effect.
    211           * - For all remaining bits that are not activated in bitValue (value '0')
    212           * will not be effected by this function.
    213           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          void GPIO_SetValue(uint8_t portNum, uint32_t bitValue)
    215          {
   \                     GPIO_SetValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    216          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       GPIO_GetPointer
    217          
    218          	if (pGPIO != NULL) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??GPIO_SetValue_0
    219          		pGPIO->FIOSET = bitValue;
   \   00000012   0x6185             STR      R5,[R0, #+24]
    220          	}
    221          }
   \                     ??GPIO_SetValue_0: (+1)
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    222          
    223          /*********************************************************************//**
    224           * @brief		Clear Value for bits that have output direction on GPIO port.
    225           * @param[in]	portNum		Port number value, should be in range from 0 to 4
    226           * @param[in]	bitValue	Value that contains all bits on GPIO to clear,
    227           * 							in range from 0 to 0xFFFFFFFF.
    228           * 							example: value 0x5 to clear bit 0 and bit 1.
    229           * @return		None
    230           *
    231           * Note:
    232           * - For all bits that has been set as input direction, this function will
    233           * not effect.
    234           * - For all remaining bits that are not activated in bitValue (value '0')
    235           * will not be effected by this function.
    236           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    237          void GPIO_ClearValue(uint8_t portNum, uint32_t bitValue)
    238          {
   \                     GPIO_ClearValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    239          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       GPIO_GetPointer
    240          
    241          	if (pGPIO != NULL) {
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD000             BEQ.N    ??GPIO_ClearValue_0
    242          		pGPIO->FIOCLR = bitValue;
   \   00000012   0x61C5             STR      R5,[R0, #+28]
    243          	}
    244          }
   \                     ??GPIO_ClearValue_0: (+1)
   \   00000014   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    245          
    246          /*********************************************************************//**
    247           * @brief		Read Current state on port pin that have input direction of GPIO
    248           * @param[in]	portNum		Port number to read value, in range from 0 to 4
    249           * @return		Current value of GPIO port.
    250           *
    251           * Note: Return value contain state of each port pin (bit) on that GPIO regardless
    252           * its direction is input or output.
    253           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    254          uint32_t GPIO_ReadValue(uint8_t portNum)
    255          {
   \                     GPIO_ReadValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    256          	LPC_GPIO_TypeDef *pGPIO = GPIO_GetPointer(portNum);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       GPIO_GetPointer
   \   0000000C   0x0001             MOVS     R1,R0
    257          
    258          	if (pGPIO != NULL) {
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD001             BEQ.N    ??GPIO_ReadValue_0
    259          		return pGPIO->FIOPIN;
   \   00000012   0x6948             LDR      R0,[R1, #+20]
   \   00000014   0xE000             B.N      ??GPIO_ReadValue_1
    260          	}
    261          
    262          	return (0);
   \                     ??GPIO_ReadValue_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \                     ??GPIO_ReadValue_1: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    263          }
    264          
    265          /*********************************************************************//**
    266           * @brief		Enable GPIO interrupt (just used for P0.0-P0.30, P2.0-P2.13)
    267           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    268           * @param[in]	bitValue	Value that contains all bits on GPIO to enable,
    269           * 							in range from 0 to 0xFFFFFFFF.
    270           * @param[in]	edgeState	state of edge, should be:
    271           * 							- 0: Rising edge
    272           * 							- 1: Falling edge
    273           * @return		None
    274           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    275          void GPIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
    276          {
    277          	if((portNum == 0)&&(edgeState == 0))
   \                     GPIO_IntCmd: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD105             BNE.N    ??GPIO_IntCmd_0
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD102             BNE.N    ??GPIO_IntCmd_0
    278          		LPC_GPIOINT->IO0IntEnR = bitValue;
   \   0000000C   0x....             LDR.N    R3,??DataTable5_5  ;; 0x40028090
   \   0000000E   0x6019             STR      R1,[R3, #+0]
   \   00000010   0xE01B             B.N      ??GPIO_IntCmd_1
    279          	else if ((portNum == 2)&&(edgeState == 0))
   \                     ??GPIO_IntCmd_0: (+1)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD105             BNE.N    ??GPIO_IntCmd_2
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD102             BNE.N    ??GPIO_IntCmd_2
    280          		LPC_GPIOINT->IO2IntEnR = bitValue;
   \   0000001E   0x....             LDR.N    R3,??DataTable5_6  ;; 0x400280b0
   \   00000020   0x6019             STR      R1,[R3, #+0]
   \   00000022   0xE012             B.N      ??GPIO_IntCmd_1
    281          	else if ((portNum == 0)&&(edgeState == 1))
   \                     ??GPIO_IntCmd_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD105             BNE.N    ??GPIO_IntCmd_3
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x2A01             CMP      R2,#+1
   \   0000002E   0xD102             BNE.N    ??GPIO_IntCmd_3
    282          		LPC_GPIOINT->IO0IntEnF = bitValue;
   \   00000030   0x....             LDR.N    R3,??DataTable5_7  ;; 0x40028094
   \   00000032   0x6019             STR      R1,[R3, #+0]
   \   00000034   0xE009             B.N      ??GPIO_IntCmd_1
    283          	else if ((portNum == 2)&&(edgeState == 1))
   \                     ??GPIO_IntCmd_3: (+1)
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2802             CMP      R0,#+2
   \   0000003A   0xD105             BNE.N    ??GPIO_IntCmd_4
   \   0000003C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003E   0x2A01             CMP      R2,#+1
   \   00000040   0xD102             BNE.N    ??GPIO_IntCmd_4
    284          		LPC_GPIOINT->IO2IntEnF = bitValue;
   \   00000042   0x....             LDR.N    R3,??DataTable5_8  ;; 0x400280b4
   \   00000044   0x6019             STR      R1,[R3, #+0]
   \   00000046   0xE000             B.N      ??GPIO_IntCmd_1
    285          	else
    286          		//Error
    287          		while(1);
   \                     ??GPIO_IntCmd_4: (+1)
   \   00000048   0xE7FE             B.N      ??GPIO_IntCmd_4
    288          }
   \                     ??GPIO_IntCmd_1: (+1)
   \   0000004A   0x4770             BX       LR               ;; return
    289          
    290          /*********************************************************************//**
    291           * @brief		Get GPIO Interrupt Status (just used for P0.0-P0.30, P2.0-P2.13)
    292           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    293           * @param[in]	pinNum		Pin number, should be: 0..30(with port 0) and 0..13
    294           * 							(with port 2)
    295           * @param[in]	edgeState	state of edge, should be:
    296           * 							- 0: Rising edge
    297           * 							- 1: Falling edge
    298           * @return		Bool	could be:
    299           * 						- ENABLE: Interrupt has been generated due to a rising
    300           * 								edge on P0.0
    301           * 						- DISABLE: A rising edge has not been detected on P0.0
    302           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          FunctionalState GPIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
    304          {
   \                     GPIO_GetIntStatus: (+1)
   \   00000000   0x0003             MOVS     R3,R0
    305          	if((portNum == 0) && (edgeState == 0))//Rising Edge
   \   00000002   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000004   0x2B00             CMP      R3,#+0
   \   00000006   0xD108             BNE.N    ??GPIO_GetIntStatus_0
   \   00000008   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD105             BNE.N    ??GPIO_GetIntStatus_0
    306          		return ((FunctionalState)(((LPC_GPIOINT->IO0IntStatR)>>pinNum)& 0x1));
   \   0000000E   0x....             LDR.N    R0,??DataTable5_9  ;; 0x40028084
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x40C8             LSRS     R0,R0,R1
   \   00000014   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000018   0xE024             B.N      ??GPIO_GetIntStatus_1
    307          	else if ((portNum == 2) && (edgeState == 0))
   \                     ??GPIO_GetIntStatus_0: (+1)
   \   0000001A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000001C   0x2B02             CMP      R3,#+2
   \   0000001E   0xD108             BNE.N    ??GPIO_GetIntStatus_2
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD105             BNE.N    ??GPIO_GetIntStatus_2
    308          		return ((FunctionalState)(((LPC_GPIOINT->IO2IntStatR)>>pinNum)& 0x1));
   \   00000026   0x....             LDR.N    R0,??DataTable5_10  ;; 0x400280a4
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x40C8             LSRS     R0,R0,R1
   \   0000002C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000030   0xE018             B.N      ??GPIO_GetIntStatus_1
    309          	else if ((portNum == 0) && (edgeState == 1))//Falling Edge
   \                     ??GPIO_GetIntStatus_2: (+1)
   \   00000032   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000034   0x2B00             CMP      R3,#+0
   \   00000036   0xD108             BNE.N    ??GPIO_GetIntStatus_3
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x2A01             CMP      R2,#+1
   \   0000003C   0xD105             BNE.N    ??GPIO_GetIntStatus_3
    310          		return ((FunctionalState)(((LPC_GPIOINT->IO0IntStatF)>>pinNum)& 0x1));
   \   0000003E   0x....             LDR.N    R0,??DataTable5_11  ;; 0x40028088
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x40C8             LSRS     R0,R0,R1
   \   00000044   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000048   0xE00C             B.N      ??GPIO_GetIntStatus_1
    311          	else if ((portNum == 2) && (edgeState == 1))
   \                     ??GPIO_GetIntStatus_3: (+1)
   \   0000004A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000004C   0x2B02             CMP      R3,#+2
   \   0000004E   0xD108             BNE.N    ??GPIO_GetIntStatus_4
   \   00000050   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000052   0x2A01             CMP      R2,#+1
   \   00000054   0xD105             BNE.N    ??GPIO_GetIntStatus_4
    312          		return ((FunctionalState)(((LPC_GPIOINT->IO2IntStatF)>>pinNum)& 0x1));
   \   00000056   0x....             LDR.N    R0,??DataTable5_12  ;; 0x400280a8
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x40C8             LSRS     R0,R0,R1
   \   0000005C   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000060   0xE000             B.N      ??GPIO_GetIntStatus_1
    313          	else
    314          		//Error
    315          		while(1);
   \                     ??GPIO_GetIntStatus_4: (+1)
   \   00000062   0xE7FE             B.N      ??GPIO_GetIntStatus_4
   \                     ??GPIO_GetIntStatus_1: (+1)
   \   00000064   0x4770             BX       LR               ;; return
    316          }
    317          /*********************************************************************//**
    318           * @brief		Clear GPIO interrupt (just used for P0.0-P0.30, P2.0-P2.13)
    319           * @param[in]	portNum		Port number to read value, should be: 0 or 2
    320           * @param[in]	bitValue	Value that contains all bits on GPIO to enable,
    321           * 							in range from 0 to 0xFFFFFFFF.
    322           * @return		None
    323           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    324          void GPIO_ClearInt(uint8_t portNum, uint32_t bitValue)
    325          {
    326          	if(portNum == 0)
   \                     GPIO_ClearInt: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD102             BNE.N    ??GPIO_ClearInt_0
    327          		LPC_GPIOINT->IO0IntClr = bitValue;
   \   00000006   0x....             LDR.N    R2,??DataTable5_13  ;; 0x4002808c
   \   00000008   0x6011             STR      R1,[R2, #+0]
   \   0000000A   0xE006             B.N      ??GPIO_ClearInt_1
    328          	else if (portNum == 2)
   \                     ??GPIO_ClearInt_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2802             CMP      R0,#+2
   \   00000010   0xD102             BNE.N    ??GPIO_ClearInt_2
    329          		LPC_GPIOINT->IO2IntClr = bitValue;
   \   00000012   0x....             LDR.N    R2,??DataTable5_14  ;; 0x400280ac
   \   00000014   0x6011             STR      R1,[R2, #+0]
   \   00000016   0xE000             B.N      ??GPIO_ClearInt_1
    330          	else
    331          		//Invalid portNum
    332          		while(1);
   \                     ??GPIO_ClearInt_2: (+1)
   \   00000018   0xE7FE             B.N      ??GPIO_ClearInt_2
    333          }
   \                     ??GPIO_ClearInt_1: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    334          
    335          /* FIO word accessible ----------------------------------------------------------------- */
    336          /* Stub function for FIO (word-accessible) style */
    337          
    338          /**
    339           * @brief The same with GPIO_SetDir()
    340           */

   \                                 In section .text, align 2, keep-with-next
    341          void FIO_SetDir(uint8_t portNum, uint32_t bitValue, uint8_t dir)
    342          {
   \                     FIO_SetDir: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    343          	GPIO_SetDir(portNum, bitValue, dir);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_SetDir
    344          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    345          
    346          /**
    347           * @brief The same with GPIO_SetValue()
    348           */

   \                                 In section .text, align 2, keep-with-next
    349          void FIO_SetValue(uint8_t portNum, uint32_t bitValue)
    350          {
   \                     FIO_SetValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    351          	GPIO_SetValue(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_SetValue
    352          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    353          
    354          /**
    355           * @brief The same with GPIO_ClearValue()
    356           */

   \                                 In section .text, align 2, keep-with-next
    357          void FIO_ClearValue(uint8_t portNum, uint32_t bitValue)
    358          {
   \                     FIO_ClearValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    359          	GPIO_ClearValue(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_ClearValue
    360          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    361          
    362          /**
    363           * @brief The same with GPIO_ReadValue()
    364           */

   \                                 In section .text, align 2, keep-with-next
    365          uint32_t FIO_ReadValue(uint8_t portNum)
    366          {
   \                     FIO_ReadValue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    367          	return (GPIO_ReadValue(portNum));
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       GPIO_ReadValue
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    368          }
    369          
    370          /**
    371           * @brief The same with GPIO_IntCmd()
    372           */

   \                                 In section .text, align 2, keep-with-next
    373          void FIO_IntCmd(uint8_t portNum, uint32_t bitValue, uint8_t edgeState)
    374          {
   \                     FIO_IntCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    375          	GPIO_IntCmd(portNum, bitValue, edgeState);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_IntCmd
    376          }
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    377          
    378          /**
    379           * @brief The same with GPIO_GetIntStatus()
    380           */

   \                                 In section .text, align 2, keep-with-next
    381          FunctionalState FIO_GetIntStatus(uint8_t portNum, uint32_t pinNum, uint8_t edgeState)
    382          {
   \                     FIO_GetIntStatus: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    383          	return (GPIO_GetIntStatus(portNum, pinNum, edgeState));
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x.... 0x....      BL       GPIO_GetIntStatus
   \   00000016   0xBD70             POP      {R4-R6,PC}       ;; return
    384          }
    385          
    386          /**
    387           * @brief The same with GPIO_ClearInt()
    388           */

   \                                 In section .text, align 2, keep-with-next
    389          void FIO_ClearInt(uint8_t portNum, uint32_t bitValue)
    390          {
   \                     FIO_ClearInt: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    391          	GPIO_ClearInt(portNum, bitValue);
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_ClearInt
    392          }
   \   00000010   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    393          /*********************************************************************//**
    394           * @brief		Set mask value for bits in FIO port
    395           * @param[in]	portNum		Port number, in range from 0 to 4
    396           * @param[in]	bitValue	Value that contains all bits in to set,
    397           * 							in range from 0 to 0xFFFFFFFF.
    398           * @param[in]	maskValue	Mask value contains state value for each bit:
    399           * 							- 0: not mask.
    400           * 							- 1: mask.
    401           * @return		None
    402           *
    403           * Note:
    404           * - All remaining bits that are not activated in bitValue (value '0')
    405           * will not be effected by this function.
    406           * - After executing this function, in mask register, value '0' on each bit
    407           * enables an access to the corresponding physical pin via a read or write access,
    408           * while value '1' on bit (masked) that corresponding pin will not be changed
    409           * with write access and if read, will not be reflected in the updated pin.
    410           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    411          void FIO_SetMask(uint8_t portNum, uint32_t bitValue, uint8_t maskValue)
    412          {
   \                     FIO_SetMask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    413          	LPC_GPIO_TypeDef *pFIO = GPIO_GetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       GPIO_GetPointer
    414          	if(pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??FIO_SetMask_0
    415          		// Mask
    416          		if (maskValue){
   \   00000014   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD003             BEQ.N    ??FIO_SetMask_1
    417          			pFIO->FIOMASK |= bitValue;
   \   0000001A   0x6901             LDR      R1,[R0, #+16]
   \   0000001C   0x4329             ORRS     R1,R5,R1
   \   0000001E   0x6101             STR      R1,[R0, #+16]
   \   00000020   0xE002             B.N      ??FIO_SetMask_0
    418          		}
    419          		// Un-mask
    420          		else {
    421          			pFIO->FIOMASK &= ~bitValue;
   \                     ??FIO_SetMask_1: (+1)
   \   00000022   0x6901             LDR      R1,[R0, #+16]
   \   00000024   0x43A9             BICS     R1,R1,R5
   \   00000026   0x6101             STR      R1,[R0, #+16]
    422          		}
    423          	}
    424          }
   \                     ??FIO_SetMask_0: (+1)
   \   00000028   0xBD70             POP      {R4-R6,PC}       ;; return
    425          
    426          
    427          /* FIO halfword accessible ------------------------------------------------------------- */
    428          
    429          /*********************************************************************//**
    430           * @brief		Set direction for FIO port in halfword accessible style
    431           * @param[in]	portNum		Port number, in range from 0 to 4
    432           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    433           * @param[in]	bitValue	Value that contains all bits in to set direction,
    434           * 							in range from 0 to 0xFFFF.
    435           * @param[in]	dir			Direction value, should be:
    436           * 							- 0: Input.
    437           * 							- 1: Output.
    438           * @return		None
    439           *
    440           * Note: All remaining bits that are not activated in bitValue (value '0')
    441           * will not be effected by this function.
    442           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    443          void FIO_HalfWordSetDir(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t dir)
    444          {
   \                     FIO_HalfWordSetDir: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    445          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_HalfWordGetPointer
    446          	if(pFIO != NULL) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_HalfWordSetDir_0
    447          		// Output direction
    448          		if (dir) {
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_HalfWordSetDir_1
    449          			// Upper
    450          			if(halfwordNum) {
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD003             BEQ.N    ??FIO_HalfWordSetDir_2
    451          				pFIO->FIODIRU |= bitValue;
   \   00000022   0x8841             LDRH     R1,[R0, #+2]
   \   00000024   0x4331             ORRS     R1,R6,R1
   \   00000026   0x8041             STRH     R1,[R0, #+2]
   \   00000028   0xE00D             B.N      ??FIO_HalfWordSetDir_0
    452          			}
    453          			// lower
    454          			else {
    455          				pFIO->FIODIRL |= bitValue;
   \                     ??FIO_HalfWordSetDir_2: (+1)
   \   0000002A   0x8801             LDRH     R1,[R0, #+0]
   \   0000002C   0x4331             ORRS     R1,R6,R1
   \   0000002E   0x8001             STRH     R1,[R0, #+0]
   \   00000030   0xE009             B.N      ??FIO_HalfWordSetDir_0
    456          			}
    457          		}
    458          		// Input direction
    459          		else {
    460          			// Upper
    461          			if(halfwordNum) {
   \                     ??FIO_HalfWordSetDir_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD003             BEQ.N    ??FIO_HalfWordSetDir_3
    462          				pFIO->FIODIRU &= ~bitValue;
   \   00000038   0x8841             LDRH     R1,[R0, #+2]
   \   0000003A   0x43B1             BICS     R1,R1,R6
   \   0000003C   0x8041             STRH     R1,[R0, #+2]
   \   0000003E   0xE002             B.N      ??FIO_HalfWordSetDir_0
    463          			}
    464          			// lower
    465          			else {
    466          				pFIO->FIODIRL &= ~bitValue;
   \                     ??FIO_HalfWordSetDir_3: (+1)
   \   00000040   0x8801             LDRH     R1,[R0, #+0]
   \   00000042   0x43B1             BICS     R1,R1,R6
   \   00000044   0x8001             STRH     R1,[R0, #+0]
    467          			}
    468          		}
    469          	}
    470          }
   \                     ??FIO_HalfWordSetDir_0: (+1)
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    471          
    472          
    473          /*********************************************************************//**
    474           * @brief		Set mask value for bits in FIO port in halfword accessible style
    475           * @param[in]	portNum		Port number, in range from 0 to 4
    476           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    477           * @param[in]	bitValue	Value that contains all bits in to set,
    478           * 							in range from 0 to 0xFFFF.
    479           * @param[in]	maskValue	Mask value contains state value for each bit:
    480           * 					- 0: not mask.
    481           * 					- 1: mask.
    482           * @return		None
    483           *
    484           * Note:
    485           * - All remaining bits that are not activated in bitValue (value '0')
    486           * will not be effected by this function.
    487           * - After executing this function, in mask register, value '0' on each bit
    488           * enables an access to the corresponding physical pin via a read or write access,
    489           * while value '1' on bit (masked) that corresponding pin will not be changed
    490           * with write access and if read, will not be reflected in the updated pin.
    491           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    492          void FIO_HalfWordSetMask(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue, uint8_t maskValue)
    493          {
   \                     FIO_HalfWordSetMask: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    494          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_HalfWordGetPointer
    495          	if(pFIO != NULL) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_HalfWordSetMask_0
    496          		// Mask
    497          		if (maskValue){
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_HalfWordSetMask_1
    498          			// Upper
    499          			if(halfwordNum) {
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD003             BEQ.N    ??FIO_HalfWordSetMask_2
    500          				pFIO->FIOMASKU |= bitValue;
   \   00000022   0x8A41             LDRH     R1,[R0, #+18]
   \   00000024   0x4331             ORRS     R1,R6,R1
   \   00000026   0x8241             STRH     R1,[R0, #+18]
   \   00000028   0xE00D             B.N      ??FIO_HalfWordSetMask_0
    501          			}
    502          			// lower
    503          			else {
    504          				pFIO->FIOMASKL |= bitValue;
   \                     ??FIO_HalfWordSetMask_2: (+1)
   \   0000002A   0x8A01             LDRH     R1,[R0, #+16]
   \   0000002C   0x4331             ORRS     R1,R6,R1
   \   0000002E   0x8201             STRH     R1,[R0, #+16]
   \   00000030   0xE009             B.N      ??FIO_HalfWordSetMask_0
    505          			}
    506          		}
    507          		// Un-mask
    508          		else {
    509          			// Upper
    510          			if(halfwordNum) {
   \                     ??FIO_HalfWordSetMask_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD003             BEQ.N    ??FIO_HalfWordSetMask_3
    511          				pFIO->FIOMASKU &= ~bitValue;
   \   00000038   0x8A41             LDRH     R1,[R0, #+18]
   \   0000003A   0x43B1             BICS     R1,R1,R6
   \   0000003C   0x8241             STRH     R1,[R0, #+18]
   \   0000003E   0xE002             B.N      ??FIO_HalfWordSetMask_0
    512          			}
    513          			// lower
    514          			else {
    515          				pFIO->FIOMASKL &= ~bitValue;
   \                     ??FIO_HalfWordSetMask_3: (+1)
   \   00000040   0x8A01             LDRH     R1,[R0, #+16]
   \   00000042   0x43B1             BICS     R1,R1,R6
   \   00000044   0x8201             STRH     R1,[R0, #+16]
    516          			}
    517          		}
    518          	}
    519          }
   \                     ??FIO_HalfWordSetMask_0: (+1)
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    520          
    521          
    522          /*********************************************************************//**
    523           * @brief		Set bits for FIO port in halfword accessible style
    524           * @param[in]	portNum		Port number, in range from 0 to 4
    525           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    526           * @param[in]	bitValue	Value that contains all bits in to set,
    527           * 							in range from 0 to 0xFFFF.
    528           * @return		None
    529           *
    530           * Note:
    531           * - For all bits that has been set as input direction, this function will
    532           * not effect.
    533           * - For all remaining bits that are not activated in bitValue (value '0')
    534           * will not be effected by this function.
    535           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    536          void FIO_HalfWordSetValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
    537          {
   \                     FIO_HalfWordSetValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    538          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_HalfWordGetPointer
    539          	if(pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_HalfWordSetValue_0
    540          		// Upper
    541          		if(halfwordNum) {
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordSetValue_1
    542          			pFIO->FIOSETU = bitValue;
   \   0000001A   0x8346             STRH     R6,[R0, #+26]
   \   0000001C   0xE000             B.N      ??FIO_HalfWordSetValue_0
    543          		}
    544          		// lower
    545          		else {
    546          			pFIO->FIOSETL = bitValue;
   \                     ??FIO_HalfWordSetValue_1: (+1)
   \   0000001E   0x8306             STRH     R6,[R0, #+24]
    547          		}
    548          	}
    549          }
   \                     ??FIO_HalfWordSetValue_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    550          
    551          
    552          /*********************************************************************//**
    553           * @brief		Clear bits for FIO port in halfword accessible style
    554           * @param[in]	portNum		Port number, in range from 0 to 4
    555           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    556           * @param[in]	bitValue	Value that contains all bits in to clear,
    557           * 							in range from 0 to 0xFFFF.
    558           * @return		None
    559           *
    560           * Note:
    561           * - For all bits that has been set as input direction, this function will
    562           * not effect.
    563           * - For all remaining bits that are not activated in bitValue (value '0')
    564           * will not be effected by this function.
    565           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    566          void FIO_HalfWordClearValue(uint8_t portNum, uint8_t halfwordNum, uint16_t bitValue)
    567          {
   \                     FIO_HalfWordClearValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    568          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_HalfWordGetPointer
    569          	if(pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_HalfWordClearValue_0
    570          		// Upper
    571          		if(halfwordNum) {
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordClearValue_1
    572          			pFIO->FIOCLRU = bitValue;
   \   0000001A   0x83C6             STRH     R6,[R0, #+30]
   \   0000001C   0xE000             B.N      ??FIO_HalfWordClearValue_0
    573          		}
    574          		// lower
    575          		else {
    576          			pFIO->FIOCLRL = bitValue;
   \                     ??FIO_HalfWordClearValue_1: (+1)
   \   0000001E   0x8386             STRH     R6,[R0, #+28]
    577          		}
    578          	}
    579          }
   \                     ??FIO_HalfWordClearValue_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    580          
    581          
    582          /*********************************************************************//**
    583           * @brief		Read Current state on port pin that have input direction of GPIO
    584           * 				in halfword accessible style.
    585           * @param[in]	portNum		Port number, in range from 0 to 4
    586           * @param[in]	halfwordNum	HalfWord part number, should be 0 (lower) or 1(upper)
    587           * @return		Current value of FIO port pin of specified halfword.
    588           * Note: Return value contain state of each port pin (bit) on that FIO regardless
    589           * its direction is input or output.
    590           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    591          uint16_t FIO_HalfWordReadValue(uint8_t portNum, uint8_t halfwordNum)
    592          {
   \                     FIO_HalfWordReadValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    593          	GPIO_HalfWord_TypeDef *pFIO = FIO_HalfWordGetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       FIO_HalfWordGetPointer
   \   0000000E   0x0001             MOVS     R1,R0
    594          	if(pFIO != NULL) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD006             BEQ.N    ??FIO_HalfWordReadValue_0
    595          		// Upper
    596          		if(halfwordNum) {
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD001             BEQ.N    ??FIO_HalfWordReadValue_1
    597          			return (pFIO->FIOPINU);
   \   0000001A   0x8AC8             LDRH     R0,[R1, #+22]
   \   0000001C   0xE002             B.N      ??FIO_HalfWordReadValue_2
    598          		}
    599          		// lower
    600          		else {
    601          			return (pFIO->FIOPINL);
   \                     ??FIO_HalfWordReadValue_1: (+1)
   \   0000001E   0x8A88             LDRH     R0,[R1, #+20]
   \   00000020   0xE000             B.N      ??FIO_HalfWordReadValue_2
    602          		}
    603          	}
    604          	return (0);
   \                     ??FIO_HalfWordReadValue_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??FIO_HalfWordReadValue_2: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    605          }
    606          
    607          
    608          /* FIO Byte accessible ------------------------------------------------------------ */
    609          
    610          /*********************************************************************//**
    611           * @brief		Set direction for FIO port in byte accessible style
    612           * @param[in]	portNum		Port number, in range from 0 to 4
    613           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    614           * @param[in]	bitValue	Value that contains all bits in to set direction,
    615           * 							in range from 0 to 0xFF.
    616           * @param[in]	dir			Direction value, should be:
    617           * 							- 0: Input.
    618           * 							- 1: Output.
    619           * @return		None
    620           *
    621           * Note: All remaining bits that are not activated in bitValue (value '0')
    622           * will not be effected by this function.
    623           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    624          void FIO_ByteSetDir(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t dir)
    625          {
   \                     FIO_ByteSetDir: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    626          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_ByteGetPointer
    627          	if(pFIO != NULL) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD013             BEQ.N    ??FIO_ByteSetDir_0
    628          		// Output direction
    629          		if (dir) {
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD008             BEQ.N    ??FIO_ByteSetDir_1
    630          			if (byteNum <= 3) {
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDA0D             BGE.N    ??FIO_ByteSetDir_0
    631          				pFIO->FIODIR[byteNum] |= bitValue;
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x5C29             LDRB     R1,[R5, R0]
   \   00000026   0x4331             ORRS     R1,R6,R1
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x5429             STRB     R1,[R5, R0]
   \   0000002C   0xE007             B.N      ??FIO_ByteSetDir_0
    632          			}
    633          		}
    634          		// Input direction
    635          		else {
    636          			if (byteNum <= 3) {
   \                     ??FIO_ByteSetDir_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D04             CMP      R5,#+4
   \   00000032   0xDA04             BGE.N    ??FIO_ByteSetDir_0
    637          				pFIO->FIODIR[byteNum] &= ~bitValue;
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0x5C29             LDRB     R1,[R5, R0]
   \   00000038   0x43B1             BICS     R1,R1,R6
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x5429             STRB     R1,[R5, R0]
    638          			}
    639          		}
    640          	}
    641          }
   \                     ??FIO_ByteSetDir_0: (+1)
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    642          
    643          /*********************************************************************//**
    644           * @brief		Set mask value for bits in FIO port in byte accessible style
    645           * @param[in]	portNum		Port number, in range from 0 to 4
    646           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    647           * @param[in]	bitValue	Value that contains all bits in to set mask,
    648           * 							in range from 0 to 0xFF.
    649           * @param[in]	maskValue	Mask value contains state value for each bit:
    650           * 							- 0: not mask.
    651           * 							- 1: mask.
    652           * @return		None
    653           *
    654           * Note:
    655           * - All remaining bits that are not activated in bitValue (value '0')
    656           * will not be effected by this function.
    657           * - After executing this function, in mask register, value '0' on each bit
    658           * enables an access to the corresponding physical pin via a read or write access,
    659           * while value '1' on bit (masked) that corresponding pin will not be changed
    660           * with write access and if read, will not be reflected in the updated pin.
    661           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    662          void FIO_ByteSetMask(uint8_t portNum, uint8_t byteNum, uint8_t bitValue, uint8_t maskValue)
    663          {
   \                     FIO_ByteSetMask: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    664          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x.... 0x....      BL       FIO_ByteGetPointer
    665          	if(pFIO != NULL) {
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD017             BEQ.N    ??FIO_ByteSetMask_0
    666          		// Mask
    667          		if (maskValue) {
   \   00000016   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000018   0x2F00             CMP      R7,#+0
   \   0000001A   0xD00A             BEQ.N    ??FIO_ByteSetMask_1
    668          			if (byteNum <= 3) {
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDA11             BGE.N    ??FIO_ByteSetMask_0
    669          				pFIO->FIOMASK[byteNum] |= bitValue;
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x1829             ADDS     R1,R5,R0
   \   00000026   0x7C09             LDRB     R1,[R1, #+16]
   \   00000028   0x4331             ORRS     R1,R6,R1
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x182A             ADDS     R2,R5,R0
   \   0000002E   0x7411             STRB     R1,[R2, #+16]
   \   00000030   0xE009             B.N      ??FIO_ByteSetMask_0
    670          			}
    671          		}
    672          		// Un-mask
    673          		else {
    674          			if (byteNum <= 3) {
   \                     ??FIO_ByteSetMask_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D04             CMP      R5,#+4
   \   00000036   0xDA06             BGE.N    ??FIO_ByteSetMask_0
    675          				pFIO->FIOMASK[byteNum] &= ~bitValue;
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x1829             ADDS     R1,R5,R0
   \   0000003C   0x7C09             LDRB     R1,[R1, #+16]
   \   0000003E   0x43B1             BICS     R1,R1,R6
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x182A             ADDS     R2,R5,R0
   \   00000044   0x7411             STRB     R1,[R2, #+16]
    676          			}
    677          		}
    678          	}
    679          }
   \                     ??FIO_ByteSetMask_0: (+1)
   \   00000046   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    680          
    681          
    682          /*********************************************************************//**
    683           * @brief		Set bits for FIO port in byte accessible style
    684           * @param[in]	portNum		Port number, in range from 0 to 4
    685           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    686           * @param[in]	bitValue	Value that contains all bits in to set,
    687           * 							in range from 0 to 0xFF.
    688           * @return		None
    689           *
    690           * Note:
    691           * - For all bits that has been set as input direction, this function will
    692           * not effect.
    693           * - For all remaining bits that are not activated in bitValue (value '0')
    694           * will not be effected by this function.
    695           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    696          void FIO_ByteSetValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
    697          {
   \                     FIO_ByteSetValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    698          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_ByteGetPointer
    699          	if (pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_ByteSetValue_0
    700          		if (byteNum <= 3){
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA02             BGE.N    ??FIO_ByteSetValue_0
    701          			pFIO->FIOSET[byteNum] = bitValue;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1829             ADDS     R1,R5,R0
   \   0000001E   0x760E             STRB     R6,[R1, #+24]
    702          		}
    703          	}
    704          }
   \                     ??FIO_ByteSetValue_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    705          
    706          
    707          /*********************************************************************//**
    708           * @brief		Clear bits for FIO port in byte accessible style
    709           * @param[in]	portNum		Port number, in range from 0 to 4
    710           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    711           * @param[in]	bitValue	Value that contains all bits in to clear,
    712           * 							in range from 0 to 0xFF.
    713           * @return		None
    714           *
    715           * Note:
    716           * - For all bits that has been set as input direction, this function will
    717           * not effect.
    718           * - For all remaining bits that are not activated in bitValue (value '0')
    719           * will not be effected by this function.
    720           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    721          void FIO_ByteClearValue(uint8_t portNum, uint8_t byteNum, uint8_t bitValue)
    722          {
   \                     FIO_ByteClearValue: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    723          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x.... 0x....      BL       FIO_ByteGetPointer
    724          	if (pFIO != NULL) {
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD005             BEQ.N    ??FIO_ByteClearValue_0
    725          		if (byteNum <= 3){
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA02             BGE.N    ??FIO_ByteClearValue_0
    726          			pFIO->FIOCLR[byteNum] = bitValue;
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1829             ADDS     R1,R5,R0
   \   0000001E   0x770E             STRB     R6,[R1, #+28]
    727          		}
    728          	}
    729          }
   \                     ??FIO_ByteClearValue_0: (+1)
   \   00000020   0xBD70             POP      {R4-R6,PC}       ;; return
    730          
    731          
    732          /*********************************************************************//**
    733           * @brief		Read Current state on port pin that have input direction of GPIO
    734           * 				in byte accessible style.
    735           * @param[in]	portNum		Port number, in range from 0 to 4
    736           * @param[in]	byteNum		Byte part number, should be in range from 0 to 3
    737           * @return		Current value of FIO port pin of specified byte part.
    738           * Note: Return value contain state of each port pin (bit) on that FIO regardless
    739           * its direction is input or output.
    740           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    741          uint8_t FIO_ByteReadValue(uint8_t portNum, uint8_t byteNum)
    742          {
   \                     FIO_ByteReadValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    743          	GPIO_Byte_TypeDef *pFIO = FIO_ByteGetPointer(portNum);
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       FIO_ByteGetPointer
   \   0000000E   0x0001             MOVS     R1,R0
    744          	if (pFIO != NULL) {
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD006             BEQ.N    ??FIO_ByteReadValue_0
    745          		if (byteNum <= 3){
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D04             CMP      R5,#+4
   \   00000018   0xDA03             BGE.N    ??FIO_ByteReadValue_0
    746          			return (pFIO->FIOPIN[byteNum]);
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1868             ADDS     R0,R5,R1
   \   0000001E   0x7D00             LDRB     R0,[R0, #+20]
   \   00000020   0xE000             B.N      ??FIO_ByteReadValue_1
    747          		}
    748          	}
    749          	return (0);
   \                     ??FIO_ByteReadValue_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??FIO_ByteReadValue_1: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    750          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x2009C000         DC32     0x2009c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x2009C020         DC32     0x2009c020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x2009C040         DC32     0x2009c040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x2009C060         DC32     0x2009c060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x2009C080         DC32     0x2009c080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40028090         DC32     0x40028090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x400280B0         DC32     0x400280b0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40028094         DC32     0x40028094

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x400280B4         DC32     0x400280b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40028084         DC32     0x40028084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x400280A4         DC32     0x400280a4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x40028088         DC32     0x40028088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x400280A8         DC32     0x400280a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4002808C         DC32     0x4002808c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x400280AC         DC32     0x400280ac
    751          
    752          /**
    753           * @}
    754           */
    755          
    756          #endif /* _GPIO */
    757          
    758          /**
    759           * @}
    760           */
    761          
    762          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   FIO_ByteClearValue
        16   -> FIO_ByteGetPointer
       0   FIO_ByteGetPointer
      16   FIO_ByteReadValue
        16   -> FIO_ByteGetPointer
      24   FIO_ByteSetDir
        24   -> FIO_ByteGetPointer
      24   FIO_ByteSetMask
        24   -> FIO_ByteGetPointer
      16   FIO_ByteSetValue
        16   -> FIO_ByteGetPointer
      16   FIO_ClearInt
        16   -> GPIO_ClearInt
      16   FIO_ClearValue
        16   -> GPIO_ClearValue
      16   FIO_GetIntStatus
        16   -> GPIO_GetIntStatus
      16   FIO_HalfWordClearValue
        16   -> FIO_HalfWordGetPointer
       0   FIO_HalfWordGetPointer
      16   FIO_HalfWordReadValue
        16   -> FIO_HalfWordGetPointer
      24   FIO_HalfWordSetDir
        24   -> FIO_HalfWordGetPointer
      24   FIO_HalfWordSetMask
        24   -> FIO_HalfWordGetPointer
      16   FIO_HalfWordSetValue
        16   -> FIO_HalfWordGetPointer
      16   FIO_IntCmd
        16   -> GPIO_IntCmd
       8   FIO_ReadValue
         8   -> GPIO_ReadValue
      16   FIO_SetDir
        16   -> GPIO_SetDir
      16   FIO_SetMask
        16   -> GPIO_GetPointer
      16   FIO_SetValue
        16   -> GPIO_SetValue
       0   GPIO_ClearInt
      16   GPIO_ClearValue
        16   -> GPIO_GetPointer
       0   GPIO_GetIntStatus
       0   GPIO_GetPointer
       0   GPIO_IntCmd
       8   GPIO_ReadValue
         8   -> GPIO_GetPointer
      16   GPIO_SetDir
        16   -> GPIO_GetPointer
      16   GPIO_SetValue
        16   -> GPIO_GetPointer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      34  FIO_ByteClearValue
      56  FIO_ByteGetPointer
      38  FIO_ByteReadValue
      64  FIO_ByteSetDir
      72  FIO_ByteSetMask
      34  FIO_ByteSetValue
      18  FIO_ClearInt
      18  FIO_ClearValue
      24  FIO_GetIntStatus
      34  FIO_HalfWordClearValue
      56  FIO_HalfWordGetPointer
      38  FIO_HalfWordReadValue
      72  FIO_HalfWordSetDir
      72  FIO_HalfWordSetMask
      34  FIO_HalfWordSetValue
      24  FIO_IntCmd
      14  FIO_ReadValue
      24  FIO_SetDir
      42  FIO_SetMask
      18  FIO_SetValue
      28  GPIO_ClearInt
      22  GPIO_ClearValue
     102  GPIO_GetIntStatus
      56  GPIO_GetPointer
      76  GPIO_IntCmd
      26  GPIO_ReadValue
      42  GPIO_SetDir
      22  GPIO_SetValue

 
 1 220 bytes in section .text
 
 1 220 bytes of CODE memory

Errors: none
Warnings: none
