###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Oct/2017  19:05:45
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MBS_CORE.C
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MBS_CORE.C -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MBS_CORE.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MBS_CORE.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-MB\Source\MBS_CORE.C
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/Modbus
      4          *                                       The Embedded Modbus Stack
      5          *
      6          *                          (c) Copyright 2003-2009; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *               Knowledge of the source code may NOT be used to develop a similar product.
     10          *               Please help us continue to provide the Embedded community with the finest
     11          *               software available.  Your honesty is greatly appreciated.
     12          *********************************************************************************************************
     13          */
     14          
     15          /*
     16          *********************************************************************************************************
     17          *
     18          *                                     uC/MODBUS SLAVE COMMAND PROCESSOR
     19          *
     20          * Filename      : mbs_core.c
     21          * Version       : V2.12
     22          * Programmer(s) : JJL
     23          *********************************************************************************************************
     24          * Note(s)       :
     25          *********************************************************************************************************
     26          */
     27          // FILE MODIFIED BY SE
     28          // added code for SE specific functions and features
     29          
     30          /*
     31          *********************************************************************************************************
     32          *                                             INCLUDE FILES
     33          *********************************************************************************************************
     34          */
     35          
     36          #define  MBS_MODULE
     37          // Modified by SE
     38          #include <includes.h>
     39          #include <mb_app_hooks.h>
     40          #include <app_ctrl.h>
     41          /*
     42          *********************************************************************************************************
     43          *                                                MACROS
     44          *********************************************************************************************************
     45          */
     46          
     47          #define  MBS_RX_DATA_START     (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     48          #define  MBS_RX_DATA_START_H    (pch->RxFrameData[2])
     49          #define  MBS_RX_DATA_START_L    (pch->RxFrameData[3])
     50          
     51          #define  MBS_RX_DATA_POINTS    (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     52          #define  MBS_RX_DATA_POINTS_H   (pch->RxFrameData[4])
     53          #define  MBS_RX_DATA_POINTS_L   (pch->RxFrameData[5])
     54          
     55          #define  MBS_RX_DATA_BYTES      (pch->RxFrameData[6])
     56          
     57          #define  MBS_RX_DATA_COIL      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     58          #define  MBS_RX_DATA_COIL_H     (pch->RxFrameData[4])
     59          #define  MBS_RX_DATA_COIL_L     (pch->RxFrameData[5])
     60          
     61          #define  MBS_RX_DATA_REG       (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     62          #define  MBS_RX_DATA_REG_H      (pch->RxFrameData[4])
     63          #define  MBS_RX_DATA_REG_L      (pch->RxFrameData[5])
     64          
     65          #define  MBS_RX_DIAG_CODE      (((CPU_INT16U)pch->RxFrameData[2] << 8) + (CPU_INT16U)pch->RxFrameData[3])
     66          #define  MBS_RX_DIAG_CODE_H     (pch->RxFrameData[2])
     67          #define  MBS_RX_DIAG_CODE_L     (pch->RxFrameData[3])
     68          #define  MBS_RX_DIAG_DATA      (((CPU_INT16U)pch->RxFrameData[4] << 8) + (CPU_INT16U)pch->RxFrameData[5])
     69          #define  MBS_RX_DIAG_DATA_H     (pch->RxFrameData[4])
     70          #define  MBS_RX_DIAG_DATA_L     (pch->RxFrameData[5])
     71          
     72          #define  MBS_RX_FRAME          (&pch->RxFrame)
     73          #define  MBS_RX_FRAME_ADDR      (pch->RxFrameData[0])
     74          #define  MBS_RX_FRAME_FC        (pch->RxFrameData[1])
     75          #define  MBS_RX_FRAME_DATA      (pch->RxFrameData[2])
     76          #define  MBS_RX_FRAME_NBYTES    (pch->RxFrameNDataBytes)
     77          
     78          
     79          #define  MBS_TX_DATA_START_H    (pch->TxFrameData[2])
     80          #define  MBS_TX_DATA_START_L    (pch->TxFrameData[3])
     81          
     82          #define  MBS_TX_DATA_POINTS_H   (pch->TxFrameData[4])
     83          #define  MBS_TX_DATA_POINTS_L   (pch->TxFrameData[5])
     84          
     85          #define  MBS_TX_DATA_COIL_H     (pch->TxFrameData[4])
     86          #define  MBS_TX_DATA_COIL_L     (pch->TxFrameData[5])
     87          
     88          #define  MBS_TX_DATA_REG_H      (pch->TxFrameData[4])
     89          #define  MBS_TX_DATA_REG_L      (pch->TxFrameData[5])
     90          
     91          #define  MBS_TX_DIAG_CODE_H     (pch->TxFrameData[2])
     92          #define  MBS_TX_DIAG_CODE_L     (pch->TxFrameData[3])
     93          #define  MBS_TX_DIAG_DATA_H     (pch->TxFrameData[4])
     94          #define  MBS_TX_DIAG_DATA_L     (pch->TxFrameData[5])
     95          
     96          
     97          #define  MBS_TX_FRAME          (&pch->TxFrame)
     98          #define  MBS_TX_FRAME_ADDR      (pch->TxFrameData[0])
     99          #define  MBS_TX_FRAME_FC        (pch->TxFrameData[1])
    100          #define  MBS_TX_FRAME_DATA      (pch->TxFrameData[2])
    101          #define  MBS_TX_FRAME_NBYTES    (pch->TxFrameNDataBytes)
    102          
    103          //SE Added defines from this point forward
    104          #define  MBS_FC100_DATA_BYTES    (5u)
    105          
    106          /*$PAGE*/
    107          /*
    108          *********************************************************************************************************
    109          *                                    LOCAL FUNCTION PROTOTYPES
    110          *********************************************************************************************************
    111          */
    112          
    113          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    114          
    115          static  void                 MBS_ErrRespSet                (MODBUS_CH *pch, CPU_INT08U errcode);
    116          
    117          #if     (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    118          static  CPU_BOOLEAN          MBS_FC01_CoilRd               (MODBUS_CH *pch);
    119          #endif
    120          
    121          #if     (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    122          static  CPU_BOOLEAN          MBS_FC02_DIRd                 (MODBUS_CH *pch);
    123          #endif
    124          
    125          #if     (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    126          static  CPU_BOOLEAN          MBS_FC03_HoldingRegRd         (MODBUS_CH *pch);
    127          #endif
    128          
    129          #if     (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    130          static  CPU_BOOLEAN          MBS_FC04_InRegRd              (MODBUS_CH *pch);
    131          #endif
    132          
    133          #if     (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    134          static  CPU_BOOLEAN          MBS_FC05_CoilWr               (MODBUS_CH *pch);
    135          #endif
    136          
    137          #if     (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    138          static  CPU_BOOLEAN          MBS_FC06_HoldingRegWr         (MODBUS_CH *pch);
    139          #endif
    140          
    141          #if     (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    142          static  CPU_BOOLEAN          MBS_FC08_Loopback             (MODBUS_CH *pch);
    143          #endif
    144          
    145          #if     (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    146          static  CPU_BOOLEAN          MBS_FC15_CoilWrMultiple       (MODBUS_CH *pch);
    147          #endif
    148          
    149          #if     (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    150          static  CPU_BOOLEAN          MBS_FC16_HoldingRegWrMultiple (MODBUS_CH *pch);
    151          #endif
    152          
    153          #if     (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    154          static  CPU_BOOLEAN          MBS_FC20_FileRd               (MODBUS_CH *pch);
    155          #endif
    156          
    157          #if     (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    158          static  CPU_BOOLEAN          MBS_FC21_FileWr               (MODBUS_CH *pch);
    159          #endif
    160          
    161          
    162          #if     MODBUS_FC43_EN > 0
    163          // SE added
    164          static   CPU_BOOLEAN          MBS_FC43_readDeviceID         (MODBUS_CH  *pch);
    165          #endif
    166          
    167          #if     MODBUS_FC100_EN > 0
    168          //SE added
    169          static   CPU_BOOLEAN          MBS_FC100_scatteredRead       (MODBUS_CH  *pch);
    170          
    171          #endif
    172          
    173          #if     (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
    174          static  void                 MBS_ASCII_Task                (MODBUS_CH   *pch);
    175          #endif
    176          
    177          #if     (MODBUS_CFG_RTU_EN   == DEF_ENABLED)
    178          static  void                 MBS_RTU_Task                  (MODBUS_CH   *pch);
    179          #endif
    180          
    181          #endif
    182          
    183          /*$PAGE*/
    184          /*
    185          *********************************************************************************************************
    186          *                                         MBM_ErrRespSet()
    187          *
    188          * Description : This function sets the indicated error response code into the response frame.  Then the
    189          *               routine is called to calculate the error check value.
    190          *
    191          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
    192          *
    193          *               errcode     An unsigned byte value containing the error code that is to be placed in the
    194          *                           response frame.
    195          *
    196          * Return(s)   : none.
    197          *
    198          * Caller(s)   : MBM_FCxx_Handler()
    199          *             : Modbus Slave functions
    200          *
    201          * Note(s)     : none.
    202          *********************************************************************************************************
    203          */
    204          
    205          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    206          static  void  MBS_ErrRespSet (MODBUS_CH  *pch,
    207                                        CPU_INT08U  err_code)
    208          {
    209              pch->StatExceptCtr++;
   \                     MBS_ErrRespSet: (+1)
   \   00000000   0x8C42             LDRH     R2,[R0, #+34]
   \   00000002   0x1C52             ADDS     R2,R2,#+1
   \   00000004   0x8442             STRH     R2,[R0, #+34]
    210              //COM_incDiaCtr(COM_EXCEPTIONS);
    211              // TODO Frame address was new from Micrium
    212              MBS_TX_FRAME_ADDR   = MBS_RX_FRAME_ADDR;
   \   00000006   0xF890 0x2244      LDRB     R2,[R0, #+580]
   \   0000000A   0xF880 0x234E      STRB     R2,[R0, #+846]
    213              MBS_TX_FRAME_FC     = MBS_RX_FRAME_FC | 0x80;                /* Set the high order bit of the function code.     */
   \   0000000E   0xF890 0x2245      LDRB     R2,[R0, #+581]
   \   00000012   0xF052 0x0280      ORRS     R2,R2,#0x80
   \   00000016   0xF880 0x234F      STRB     R2,[R0, #+847]
    214              MBS_TX_FRAME_DATA   = err_code;                              /* Set the high order bit of the function code.     */
   \   0000001A   0xF880 0x1350      STRB     R1,[R0, #+848]
    215              MBS_TX_FRAME_NBYTES = 1;                                     /* Nbr of data bytes in exception response is 1.    */
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xF8A0 0x244E      STRH     R2,[R0, #+1102]
    216          }
   \   00000024   0x4770             BX       LR               ;; return
    217          #endif
    218          
    219          /*$PAGE*/
    220          /*
    221          *********************************************************************************************************
    222          *                                           MBS_FCxx_Handler()
    223          *
    224          * Description : This is the main processing function for MODBUS commands.  The message integrity is
    225          *               verified, and if valid, the function requested is processed.  Unimplemented functions
    226          *               will generate an Illegal Function Exception Response code (01).
    227          *
    228          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
    229          *
    230          * Return(s)   : none.
    231          *
    232          * Caller(s)   : MBS_ASCII_Task()
    233          *               MBS_RTU_Task
    234          *
    235          * Note(s)     : none.
    236          *********************************************************************************************************
    237          */
    238          
    239          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    240          CPU_BOOLEAN  MBS_FCxx_Handler (MODBUS_CH  *pch)
    241          {
   \                     MBS_FCxx_Handler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    242              CPU_BOOLEAN   send_reply;
    243          
    244          
    245              if ((MBS_RX_FRAME_ADDR == pch->NodeAddr) ||       /* Proper node address? (i.e. Is this message for us?)   */
    246                  (MBS_RX_FRAME_ADDR == 0) ||                   /* ... or a 'broadcast' address?                         */
    247                  (MBS_RX_FRAME_ADDR == MB_getPseudo( ) ) ) {
   \   00000004   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000008   0x7A21             LDRB     R1,[R4, #+8]
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD00F             BEQ.N    ??MBS_FCxx_Handler_0
   \   0000000E   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00B             BEQ.N    ??MBS_FCxx_Handler_0
   \   00000016   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   0000001A   0xF894 0x1246      LDRB     R1,[R4, #+582]
   \   0000001E   0xF894 0x2245      LDRB     R2,[R4, #+581]
   \   00000022   0xEB11 0x2102      ADDS     R1,R1,R2, LSL #+8
   \   00000026   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000028   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD16A             BNE.N    ??MBS_FCxx_Handler_1
    248                  pch->StatSlaveMsgCtr++;
   \                     ??MBS_FCxx_Handler_0: (+1)
   \   0000002E   0x8CA0             LDRH     R0,[R4, #+36]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
   \   00000032   0x84A0             STRH     R0,[R4, #+36]
    249                  //COM_incDiaCtr(COM_PACKETSTOUNIT);
    250          
    251                  switch (MBS_RX_FRAME_FC) {                           /* Handle the function requested in the frame.           */
   \   00000034   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD010             BEQ.N    ??MBS_FCxx_Handler_2
   \   0000003C   0x2803             CMP      R0,#+3
   \   0000003E   0xD013             BEQ.N    ??MBS_FCxx_Handler_3
   \   00000040   0x2805             CMP      R0,#+5
   \   00000042   0xD016             BEQ.N    ??MBS_FCxx_Handler_4
   \   00000044   0x2806             CMP      R0,#+6
   \   00000046   0xD01F             BEQ.N    ??MBS_FCxx_Handler_5
   \   00000048   0x2808             CMP      R0,#+8
   \   0000004A   0xD028             BEQ.N    ??MBS_FCxx_Handler_6
   \   0000004C   0x280F             CMP      R0,#+15
   \   0000004E   0xD02B             BEQ.N    ??MBS_FCxx_Handler_7
   \   00000050   0x2810             CMP      R0,#+16
   \   00000052   0xD034             BEQ.N    ??MBS_FCxx_Handler_8
   \   00000054   0x2814             CMP      R0,#+20
   \   00000056   0xD03D             BEQ.N    ??MBS_FCxx_Handler_9
   \   00000058   0x2815             CMP      R0,#+21
   \   0000005A   0xD040             BEQ.N    ??MBS_FCxx_Handler_10
   \   0000005C   0xE04A             B.N      ??MBS_FCxx_Handler_11
    252          #if (MODBUS_CFG_FC01_EN == DEF_ENABLED)
    253                      case MODBUS_FC01_COIL_RD:
    254                           send_reply = MBS_FC01_CoilRd(pch);
   \                     ??MBS_FCxx_Handler_2: (+1)
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       MBS_FC01_CoilRd
   \   00000064   0x0005             MOVS     R5,R0
    255                           break;
   \   00000066   0xE04D             B.N      ??MBS_FCxx_Handler_1
    256          #endif
    257          
    258          #if (MODBUS_CFG_FC02_EN == DEF_ENABLED)
    259                      case MODBUS_FC02_DI_RD:
    260                           send_reply = MBS_FC02_DIRd(pch);
    261                           break;
    262          #endif
    263          
    264          #if (MODBUS_CFG_FC03_EN == DEF_ENABLED)
    265                      case MODBUS_FC03_HOLDING_REG_RD:                 /* Process read output registers command.                   */
    266                           send_reply = MBS_FC03_HoldingRegRd(pch);
   \                     ??MBS_FCxx_Handler_3: (+1)
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x.... 0x....      BL       MBS_FC03_HoldingRegRd
   \   0000006E   0x0005             MOVS     R5,R0
    267                           break;
   \   00000070   0xE048             B.N      ??MBS_FCxx_Handler_1
    268          #endif
    269          
    270          #if (MODBUS_CFG_FC04_EN == DEF_ENABLED)
    271                      case MODBUS_FC04_IN_REG_RD:
    272                           send_reply = MBS_FC04_InRegRd(pch);
    273                           break;
    274          #endif
    275          
    276          #if (MODBUS_CFG_FC05_EN == DEF_ENABLED)
    277                      case MODBUS_FC05_COIL_WR:
    278                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_4: (+1)
   \   00000072   0x7860             LDRB     R0,[R4, #+1]
   \   00000074   0x2801             CMP      R0,#+1
   \   00000076   0xD104             BNE.N    ??MBS_FCxx_Handler_12
    279                               send_reply  = MBS_FC05_CoilWr(pch);
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0x.... 0x....      BL       MBS_FC05_CoilWr
   \   0000007E   0x0005             MOVS     R5,R0
   \   00000080   0xE001             B.N      ??MBS_FCxx_Handler_13
    280                           } else {
    281                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_12: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x0005             MOVS     R5,R0
    282                           }
    283                           break;
   \                     ??MBS_FCxx_Handler_13: (+1)
   \   00000086   0xE03D             B.N      ??MBS_FCxx_Handler_1
    284          #endif
    285          
    286          #if (MODBUS_CFG_FC06_EN == DEF_ENABLED)
    287                      case MODBUS_FC06_HOLDING_REG_WR:
    288                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_5: (+1)
   \   00000088   0x7860             LDRB     R0,[R4, #+1]
   \   0000008A   0x2801             CMP      R0,#+1
   \   0000008C   0xD104             BNE.N    ??MBS_FCxx_Handler_14
    289                               send_reply  = MBS_FC06_HoldingRegWr(pch);
   \   0000008E   0x0020             MOVS     R0,R4
   \   00000090   0x.... 0x....      BL       MBS_FC06_HoldingRegWr
   \   00000094   0x0005             MOVS     R5,R0
   \   00000096   0xE001             B.N      ??MBS_FCxx_Handler_15
    290                           } else {
    291                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_14: (+1)
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0x0005             MOVS     R5,R0
    292                           }
    293                           break;
   \                     ??MBS_FCxx_Handler_15: (+1)
   \   0000009C   0xE032             B.N      ??MBS_FCxx_Handler_1
    294          #endif
    295          
    296          #if (MODBUS_CFG_FC08_EN == DEF_ENABLED)
    297                      case MODBUS_FC08_LOOPBACK:
    298                           send_reply = MBS_FC08_Loopback(pch);        /* Process loopback command.                                */
   \                     ??MBS_FCxx_Handler_6: (+1)
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0x.... 0x....      BL       MBS_FC08_Loopback
   \   000000A4   0x0005             MOVS     R5,R0
    299                           break;
   \   000000A6   0xE02D             B.N      ??MBS_FCxx_Handler_1
    300          #endif
    301          
    302          #if (MODBUS_CFG_FC15_EN == DEF_ENABLED)
    303                      case MODBUS_FC15_COIL_WR_MULTIPLE:
    304                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_7: (+1)
   \   000000A8   0x7860             LDRB     R0,[R4, #+1]
   \   000000AA   0x2801             CMP      R0,#+1
   \   000000AC   0xD104             BNE.N    ??MBS_FCxx_Handler_16
    305                               send_reply  = MBS_FC15_CoilWrMultiple(pch);
   \   000000AE   0x0020             MOVS     R0,R4
   \   000000B0   0x.... 0x....      BL       MBS_FC15_CoilWrMultiple
   \   000000B4   0x0005             MOVS     R5,R0
   \   000000B6   0xE001             B.N      ??MBS_FCxx_Handler_17
    306                           } else {
    307                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_16: (+1)
   \   000000B8   0x2000             MOVS     R0,#+0
   \   000000BA   0x0005             MOVS     R5,R0
    308                           }
    309                           break;
   \                     ??MBS_FCxx_Handler_17: (+1)
   \   000000BC   0xE022             B.N      ??MBS_FCxx_Handler_1
    310          #endif
    311          
    312          #if (MODBUS_CFG_FC16_EN == DEF_ENABLED)
    313                      case MODBUS_FC16_HOLDING_REG_WR_MULTIPLE:
    314                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_8: (+1)
   \   000000BE   0x7860             LDRB     R0,[R4, #+1]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD104             BNE.N    ??MBS_FCxx_Handler_18
    315                               send_reply  = MBS_FC16_HoldingRegWrMultiple(pch);
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       MBS_FC16_HoldingRegWrMultiple
   \   000000CA   0x0005             MOVS     R5,R0
   \   000000CC   0xE001             B.N      ??MBS_FCxx_Handler_19
    316                           } else {
    317                               send_reply  = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_18: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x0005             MOVS     R5,R0
    318                           }
    319                           break;
   \                     ??MBS_FCxx_Handler_19: (+1)
   \   000000D2   0xE017             B.N      ??MBS_FCxx_Handler_1
    320          #endif
    321          
    322          #if (MODBUS_CFG_FC20_EN == DEF_ENABLED)
    323                      case MODBUS_FC20_FILE_RD:
    324                           send_reply  = MBS_FC20_FileRd(pch);
   \                     ??MBS_FCxx_Handler_9: (+1)
   \   000000D4   0x0020             MOVS     R0,R4
   \   000000D6   0x.... 0x....      BL       MBS_FC20_FileRd
   \   000000DA   0x0005             MOVS     R5,R0
    325                           break;
   \   000000DC   0xE012             B.N      ??MBS_FCxx_Handler_1
    326          #endif
    327          
    328          #if (MODBUS_CFG_FC21_EN == DEF_ENABLED)
    329                      case MODBUS_FC21_FILE_WR:
    330                           if (pch->WrEn == DEF_TRUE) {
   \                     ??MBS_FCxx_Handler_10: (+1)
   \   000000DE   0x7860             LDRB     R0,[R4, #+1]
   \   000000E0   0x2801             CMP      R0,#+1
   \   000000E2   0xD104             BNE.N    ??MBS_FCxx_Handler_20
    331                               send_reply = MBS_FC21_FileWr(pch);
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       MBS_FC21_FileWr
   \   000000EA   0x0005             MOVS     R5,R0
   \   000000EC   0xE001             B.N      ??MBS_FCxx_Handler_21
    332                           } else {
    333                               send_reply = DEF_FALSE;
   \                     ??MBS_FCxx_Handler_20: (+1)
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0x0005             MOVS     R5,R0
    334                           }
    335                           break;
   \                     ??MBS_FCxx_Handler_21: (+1)
   \   000000F2   0xE007             B.N      ??MBS_FCxx_Handler_1
    336          #endif
    337          
    338          #if MODBUS_FC43_EN > 0 // Read Device ID
    339                     case MODBUS_FC43_READ_DEV_ID:
    340                        send_reply  = MBS_FC43_readDeviceID(pch);
    341                      break;
    342          #endif
    343          
    344          #if MODBUS_FC100_EN > 0 // Scattered Read
    345                      case MODBUS_FC100_SCATTERED_READ:
    346                         send_reply = MBS_FC100_scatteredRead(pch);
    347                      break;
    348          #endif
    349          
    350                      default:                                         /* Function code not implemented, set error response. */
    351                           pch->Err   = MODBUS_ERR_ILLEGAL_FC;
   \                     ??MBS_FCxx_Handler_11: (+1)
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0x82E0             STRH     R0,[R4, #+22]
    352                           MBS_ErrRespSet(pch,
    353                                          MODBUS_ERR_ILLEGAL_FC);
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x.... 0x....      BL       MBS_ErrRespSet
    354                           //COM_incDiaCtr(COM_ILLEGALOPCODE);
    355                           send_reply = DEF_TRUE;
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x0005             MOVS     R5,R0
    356                           break;
    357                  }
    358              }
    359              else
    360              {
    361                 //COM_incDiaCtr( COM_PACKETSTOOTHERS );
    362              }
    363          
    364              if (MBS_RX_FRAME_ADDR == 0 ||
    365                  (MBS_RX_FRAME_ADDR == MB_getPseudo ( ) ) ) {     /* Was the command received a 'broadcast'?   */
   \                     ??MBS_FCxx_Handler_1: (+1)
   \   00000104   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD00B             BEQ.N    ??MBS_FCxx_Handler_22
   \   0000010C   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000110   0xF894 0x1246      LDRB     R1,[R4, #+582]
   \   00000114   0xF894 0x2245      LDRB     R2,[R4, #+581]
   \   00000118   0xEB11 0x2102      ADDS     R1,R1,R2, LSL #+8
   \   0000011C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000011E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xD101             BNE.N    ??MBS_FCxx_Handler_23
    366                  return (DEF_FALSE);                              /* Yes, don't reply                           */
   \                     ??MBS_FCxx_Handler_22: (+1)
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xE001             B.N      ??MBS_FCxx_Handler_24
    367              } else {
    368                  return (send_reply);                             /* No,  reply according to the outcome of the command    */
   \                     ??MBS_FCxx_Handler_23: (+1)
   \   00000128   0x0028             MOVS     R0,R5
   \   0000012A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MBS_FCxx_Handler_24: (+1)
   \   0000012C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    369              }
    370          }
    371          #endif
    372          
    373          /*$PAGE*/
    374          /*
    375          *********************************************************************************************************
    376          *                                           MBS_FC01_CoilRd()
    377          *
    378          * Description : Responds to a request to read the status of any number of coils.
    379          *
    380          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    381          *
    382          * Return(s)   : DEF_TRUE      If a response needs to be sent
    383          *               DEF_FALSE     If not
    384          *
    385          * Caller(s)   : MBS_FCxx_Handler()
    386          *
    387          * Note(s)     : none
    388          *********************************************************************************************************
    389          */
    390          
    391          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    392          #if (MODBUS_CFG_FC01_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    393          static  CPU_BOOLEAN  MBS_FC01_CoilRd (MODBUS_CH  *pch)
    394          {
   \                     MBS_FC01_CoilRd: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
    395              CPU_INT08U     *presp;
    396              CPU_INT16U      coil;
    397              CPU_BOOLEAN     coil_val;
    398              CPU_INT16U      err;
    399              CPU_INT16U      nbr_coils;
    400              CPU_INT16U      nbr_bytes;
    401              CPU_INT08U      bit_mask;
    402              CPU_INT16U      ix;
    403          
    404          
    405              if (pch->RxFrameNDataBytes != 4) {                           /* 4 data bytes for this message.                           */
   \   00000006   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD001             BEQ.N    ??MBS_FC01_CoilRd_0
    406                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE086             B.N      ??MBS_FC01_CoilRd_1
    407              }
    408              coil      = MBS_RX_DATA_START;                               /* Get the starting address of the desired coils            */
   \                     ??MBS_FC01_CoilRd_0: (+1)
   \   00000012   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000016   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   0000001A   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000001E   0x0006             MOVS     R6,R0
    409              nbr_coils = MBS_RX_DATA_POINTS;                              /* Find out how many coils                                  */
   \   00000020   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000024   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000028   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000002C   0x4680             MOV      R8,R0
    410              if (nbr_coils == 0 || nbr_coils > 2000) {                    /* Make sure we don't exceed the allowed limit per request  */
   \   0000002E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000032   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000036   0xD004             BEQ.N    ??MBS_FC01_CoilRd_2
   \   00000038   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000003C   0xF5B8 0x6FFA      CMP      R8,#+2000
   \   00000040   0xDD07             BLE.N    ??MBS_FC01_CoilRd_3
    411                  pch->Err = MODBUS_ERR_FC01_01;
   \                     ??MBS_FC01_CoilRd_2: (+1)
   \   00000042   0x2065             MOVS     R0,#+101
   \   00000044   0x82E0             STRH     R0,[R4, #+22]
    412                  MBS_ErrRespSet(pch,
    413                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000046   0x2103             MOVS     R1,#+3
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0x.... 0x....      BL       MBS_ErrRespSet
    414                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE066             B.N      ??MBS_FC01_CoilRd_1
    415              }
    416              nbr_bytes              = ((nbr_coils - 1) / 8) + 1;          /* Find #bytes needed for response.                         */
   \                     ??MBS_FC01_CoilRd_3: (+1)
   \   00000052   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000056   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   0000005A   0x2108             MOVS     R1,#+8
   \   0000005C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0x4681             MOV      R9,R0
    417              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
   \   00000064   0xF119 0x0001      ADDS     R0,R9,#+1
   \   00000068   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
    418              presp                  = &pch->TxFrameData[0];               /* Clear bytes in response                                  */
   \   0000006C   0xF204 0x304E      ADDW     R0,R4,#+846
   \   00000070   0x0005             MOVS     R5,R0
    419              for (ix = 0; ix < (nbr_bytes + 3); ix++) {
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4683             MOV      R11,R0
   \                     ??MBS_FC01_CoilRd_4: (+1)
   \   00000076   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000007A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007E   0xF119 0x0003      ADDS     R0,R9,#+3
   \   00000082   0x4583             CMP      R11,R0
   \   00000084   0xDA05             BGE.N    ??MBS_FC01_CoilRd_5
    420                  *presp++ = 0x00;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x7028             STRB     R0,[R5, #+0]
   \   0000008A   0x1C6D             ADDS     R5,R5,#+1
    421              }
   \   0000008C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000090   0xE7F1             B.N      ??MBS_FC01_CoilRd_4
    422              bit_mask = 0x01;                                             /* Start with bit 0 in response byte data mask.             */
   \                     ??MBS_FC01_CoilRd_5: (+1)
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0x4682             MOV      R10,R0
    423              ix       =    0;                                             /* Initialize loop counter.                                 */
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x4683             MOV      R11,R0
    424              presp    = &pch->TxFrameData[0];                             /* Reset the pointer to the start of the response           */
   \   0000009A   0xF204 0x304E      ADDW     R0,R4,#+846
   \   0000009E   0x0005             MOVS     R5,R0
    425              *presp++ = MBS_RX_FRAME_ADDR;                                /* Prepare response packet                                  */
   \   000000A0   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   000000A4   0x7028             STRB     R0,[R5, #+0]
   \   000000A6   0x1C6D             ADDS     R5,R5,#+1
    426              *presp++ = MBS_RX_FRAME_FC;
   \   000000A8   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   000000AC   0x7028             STRB     R0,[R5, #+0]
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
    427              *presp++ = (CPU_INT08U)nbr_bytes;                            /* Set number of data bytes in response message.            */
   \   000000B0   0xF885 0x9000      STRB     R9,[R5, #+0]
   \   000000B4   0x1C6D             ADDS     R5,R5,#+1
    428              while (ix < nbr_coils) {                                     /* Loop through each COIL requested.                        */
   \                     ??MBS_FC01_CoilRd_6: (+1)
   \   000000B6   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000BA   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000BE   0x45C3             CMP      R11,R8
   \   000000C0   0xD22B             BCS.N    ??MBS_FC01_CoilRd_7
    429                  coil_val = MB_CoilRd(coil,                               /* Get the current value of the coil                        */
    430                                       &err);
   \   000000C2   0x4669             MOV      R1,SP
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C8   0x.... 0x....      BL       MB_CoilRd
   \   000000CC   0x0007             MOVS     R7,R0
    431                  switch (err) {
   \   000000CE   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD119             BNE.N    ??MBS_FC01_CoilRd_8
    432                      case MODBUS_ERR_NONE:
    433                           if (coil_val == MODBUS_COIL_ON) {               /* Only set data response bit if COIL is on.                */
   \   000000D6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D8   0x2F01             CMP      R7,#+1
   \   000000DA   0xD103             BNE.N    ??MBS_FC01_CoilRd_9
    434                               *presp |= bit_mask;
   \   000000DC   0x7828             LDRB     R0,[R5, #+0]
   \   000000DE   0xEA5A 0x0000      ORRS     R0,R10,R0
   \   000000E2   0x7028             STRB     R0,[R5, #+0]
    435                           }
    436                           coil++;
   \                     ??MBS_FC01_CoilRd_9: (+1)
   \   000000E4   0x1C76             ADDS     R6,R6,#+1
    437                           ix++;                                           /* Increment COIL counter.                                  */
   \   000000E6   0xF11B 0x0B01      ADDS     R11,R11,#+1
    438                           if ((ix % 8) == 0) {                            /* Determine if 8 data bits have been filled.               */
   \   000000EA   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   000000EE   0x2008             MOVS     R0,#+8
   \   000000F0   0xFB9B 0xF1F0      SDIV     R1,R11,R0
   \   000000F4   0xFB01 0xB110      MLS      R1,R1,R0,R11
   \   000000F8   0x2900             CMP      R1,#+0
   \   000000FA   0xD103             BNE.N    ??MBS_FC01_CoilRd_10
    439                               bit_mask   = 0x01;                          /* Reset the data mask.                                     */
   \   000000FC   0x2001             MOVS     R0,#+1
   \   000000FE   0x4682             MOV      R10,R0
    440                               presp++;                                    /* Increment data frame index.                              */
   \   00000100   0x1C6D             ADDS     R5,R5,#+1
   \   00000102   0xE001             B.N      ??MBS_FC01_CoilRd_11
    441                           } else {                                        /* Still in same data byte, so                              */
    442                               bit_mask <<= 1;                             /* Shift the data mask to the next higher bit position.     */
   \                     ??MBS_FC01_CoilRd_10: (+1)
   \   00000104   0xEA5F 0x0A4A      LSLS     R10,R10,#+1
    443                           }
    444                           break;
   \                     ??MBS_FC01_CoilRd_11: (+1)
   \   00000108   0xE7D5             B.N      ??MBS_FC01_CoilRd_6
    445          
    446                      case MODBUS_ERR_RANGE:
    447                      default:
    448                           pch->Err = MODBUS_ERR_FC01_02;
   \                     ??MBS_FC01_CoilRd_8: (+1)
   \   0000010A   0x2066             MOVS     R0,#+102
   \   0000010C   0x82E0             STRH     R0,[R4, #+22]
    449                           MBS_ErrRespSet(pch,
    450                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0x0020             MOVS     R0,R4
   \   00000112   0x.... 0x....      BL       MBS_ErrRespSet
    451                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0xE002             B.N      ??MBS_FC01_CoilRd_1
    452                  }
    453              }
    454              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC01_CoilRd_7: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0x82E0             STRH     R0,[R4, #+22]
    455              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   0000011E   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC01_CoilRd_1: (+1)
   \   00000120   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    456          }
    457          #endif
    458          #endif
    459          
    460          /*$PAGE*/
    461          /*
    462          *********************************************************************************************************
    463          *                                            MBS_FC02_DIRd()
    464          *
    465          * Description : Responds to a request to read the status of any number of Discrete Inputs (DIs).
    466          *
    467          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    468          *
    469          * Return(s)   : DEF_TRUE      If a response needs to be sent
    470          *               DEF_FALSE     If not
    471          *
    472          * Caller(s)   : MBS_FCxx_Handler()
    473          *
    474          * Note(s)     : none
    475          *********************************************************************************************************
    476          */
    477          
    478          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    479          #if (MODBUS_CFG_FC02_EN  == DEF_ENABLED)
    480          static  CPU_BOOLEAN  MBS_FC02_DIRd (MODBUS_CH  *pch)
    481          {
    482              CPU_INT08U     *presp;
    483              CPU_INT16U      di;
    484              CPU_BOOLEAN     di_val;
    485              CPU_INT16U      err;
    486              CPU_INT16U      nbr_di;
    487              CPU_INT16U      nbr_bytes;
    488              CPU_INT08U      bit_mask;
    489              CPU_INT16U      ix;
    490          
    491          
    492              if (pch->RxFrameNDataBytes != 4) {                           /* 4 data bytes for this message.                           */
    493                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
    494              }
    495              di     = MBS_RX_DATA_START;                                  /* Get the starting address of the desired DIs              */
    496              nbr_di = MBS_RX_DATA_POINTS;                                 /* Find out how many DIs                                    */
    497              if (nbr_di == 0 || nbr_di > 2000) {                          /* Make sure we don't exceed the allowed limit per request  */
    498                  pch->Err = MODBUS_ERR_FC02_01;
    499                  MBS_ErrRespSet(pch,
    500                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
    501                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
    502              }
    503              nbr_bytes             = ((nbr_di - 1) / 8) + 1;              /* Find #bytes needed for response.                         */
    504              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
    505              presp                 = &pch->TxFrameData[0];                /* Clear bytes in response                                  */
    506              for (ix = 0; ix < (nbr_bytes + 3); ix++) {
    507                  *presp++ = 0x00;
    508              }
    509              bit_mask = 0x01;                                             /* Start with bit 0 in response byte data mask.             */
    510              ix       =    0;                                             /* Initialize loop counter.                                 */
    511              presp    = &pch->TxFrameData[0];                             /* Reset the pointer to the start of the response           */
    512              *presp++ =  MBS_RX_FRAME_ADDR;                               /* Prepare response packet                                  */
    513              *presp++ =  MBS_RX_FRAME_FC;
    514              *presp++ = (CPU_INT08U)nbr_bytes;                            /* Set number of data bytes in response message.            */
    515              while (ix < nbr_di) {                                        /* Loop through each DI requested.                          */
    516                  di_val = MB_DIRd(di,                                     /* Get the current value of the DI                          */
    517                                   &err);
    518                  switch (err) {
    519                      case MODBUS_ERR_NONE:
    520                           if (di_val == MODBUS_COIL_ON) {                 /* Only set data response bit if DI is on.                  */
    521                               *presp |= bit_mask;
    522                           }
    523                           di++;
    524                           ix++;                                           /* Increment DI counter.                                    */
    525                           if ((ix % 8) == 0) {                            /* Determine if 8 data bits have been filled.               */
    526                               bit_mask   = 0x01;                          /* Reset the data mask.                                     */
    527                               presp++;                                    /* Increment data frame index.                              */
    528                           } else {                                        /* Still in same data byte, so                              */
    529                               bit_mask <<= 1;                             /* Shift the data mask to the next higher bit position.     */
    530                           }
    531                           break;
    532          
    533                      case MODBUS_ERR_RANGE:
    534                      default:
    535                           pch->Err = MODBUS_ERR_FC02_02;
    536                           MBS_ErrRespSet(pch,
    537                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
    538                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
    539                  }
    540              }
    541              pch->Err = MODBUS_ERR_NONE;
    542              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
    543          }
    544          #endif
    545          #endif
    546          
    547          /*$PAGE*/
    548          /*
    549          *********************************************************************************************************
    550          *                                        MBS_FC03_HoldingRegRd()
    551          *
    552          * Description : Obtains the contents of the specified holding registers.
    553          *
    554          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    555          *
    556          * Return(s)   : DEF_TRUE      If a response needs to be sent
    557          *               DEF_FALSE     If not
    558          *
    559          * Caller(s)   : MBS_FCxx_Handler()
    560          *
    561          * Note(s)     : none
    562          *********************************************************************************************************
    563          */
    564          
    565          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    566          #if (MODBUS_CFG_FC03_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    567          static  CPU_BOOLEAN  MBS_FC03_HoldingRegRd (MODBUS_CH  *pch)
    568          {
   \                     MBS_FC03_HoldingRegRd: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    569              CPU_INT08U    *presp;
    570              CPU_INT16U     err;
    571              CPU_INT16U     reg;
    572              CPU_INT16U     nbr_regs;
    573              CPU_INT16U     nbr_bytes;
    574              CPU_INT16U     reg_val_16;
    575          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    576              CPU_INT08U     ix;
    577              CPU_FP32       reg_val_fp;
    578              CPU_INT08U    *pfp;
    579          #endif
    580          
    581          
    582              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000006   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xD001             BEQ.N    ??MBS_FC03_HoldingRegRd_0
    583                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE083             B.N      ??MBS_FC03_HoldingRegRd_1
    584              }
    585              reg       = MBS_RX_DATA_START;
   \                     ??MBS_FC03_HoldingRegRd_0: (+1)
   \   00000012   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000016   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   0000001A   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000001E   0x0006             MOVS     R6,R0
    586              nbr_regs  = MBS_RX_DATA_POINTS;
   \   00000020   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000024   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000028   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000002C   0x0007             MOVS     R7,R0
    587          
    588          #if SE_MODBUS_CODE > 0
    589          
    590              MB_DATA_holdingRegRd(pch, &err);
    591              // will not get this error, responds with NA value if register does not exist
    592              if(err == MODBUS_ERR_RANGE)
    593              {
    594                 pch->Err = MODBUS_ERR_FC03_01;
    595                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    596                 return (DEF_TRUE);
    597              }
    598              pch->Err = MODBUS_ERR_NONE;
    599              return (DEF_TRUE);
    600          
    601          #else // ALL SE_MODBUS_CODE code above here
    602          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    603              if (reg < MODBUS_CFG_FP_START_IX) {                          /* See if we want integer registers                         */
    604                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
    605                      pch->Err = MODBUS_ERR_FC03_03;
    606                      MBS_ErrRespSet(pch,
    607                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    608                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    609                  }
    610                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U)); /* Find #bytes needed for response.                         */
    611              } else {
    612                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
    613                      pch->Err = MODBUS_ERR_FC03_04;
    614                      MBS_ErrRespSet(pch,
    615                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    616                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    617                  }
    618                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_FP32));   /* Find #bytes needed for response.                         */
    619              }
    620          #else
    621              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
   \   0000002E   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000030   0x2F00             CMP      R7,#+0
   \   00000032   0xD002             BEQ.N    ??MBS_FC03_HoldingRegRd_2
   \   00000034   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   00000036   0x2F7E             CMP      R7,#+126
   \   00000038   0xDB08             BLT.N    ??MBS_FC03_HoldingRegRd_3
    622                  pch->Err = MODBUS_ERR_FC03_03;
   \                     ??MBS_FC03_HoldingRegRd_2: (+1)
   \   0000003A   0xF240 0x102F      MOVW     R0,#+303
   \   0000003E   0x82E0             STRH     R0,[R4, #+22]
    623                  MBS_ErrRespSet(pch,
    624                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000040   0x2103             MOVS     R1,#+3
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       MBS_ErrRespSet
    625                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xE066             B.N      ??MBS_FC03_HoldingRegRd_1
    626              }
    627              nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U));     /* Find #bytes needed for response.                         */
   \                     ??MBS_FC03_HoldingRegRd_3: (+1)
   \   0000004C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000004E   0x0078             LSLS     R0,R7,#+1
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x4680             MOV      R8,R0
    628          #endif
    629              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
   \   00000054   0xF118 0x0001      ADDS     R0,R8,#+1
   \   00000058   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
    630              presp                 = &pch->TxFrameData[0];                /* Reset the pointer to the start of the response           */
   \   0000005C   0xF204 0x304E      ADDW     R0,R4,#+846
   \   00000060   0x0005             MOVS     R5,R0
    631              *presp++              =  MBS_RX_FRAME_ADDR;
   \   00000062   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000066   0x7028             STRB     R0,[R5, #+0]
   \   00000068   0x1C6D             ADDS     R5,R5,#+1
    632              *presp++              =  MBS_RX_FRAME_FC;
   \   0000006A   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000006E   0x7028             STRB     R0,[R5, #+0]
   \   00000070   0x1C6D             ADDS     R5,R5,#+1
    633              *presp++              = (CPU_INT08U)nbr_bytes;               /* Set number of data bytes in response message             */
   \   00000072   0xF885 0x8000      STRB     R8,[R5, #+0]
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
    634          
    635              /***********************************************
    636              * 描述： 读多个寄存器回调函数
    637              */
    638              if ( App_MB_RdNRegsHook ( (CPU_INT16U )reg,
    639                                        (CPU_INT16U*)presp,
    640                                        (CPU_INT16U )nbr_regs,
    641                                         &err ) ) {
   \   00000078   0x466B             MOV      R3,SP
   \   0000007A   0x003A             MOVS     R2,R7
   \   0000007C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000007E   0x0029             MOVS     R1,R5
   \   00000080   0x0030             MOVS     R0,R6
   \   00000082   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000084   0x.... 0x....      BL       App_MB_RdNRegsHook
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD00F             BEQ.N    ??MBS_FC03_HoldingRegRd_4
    642                  if ( err != MODBUS_ERR_NONE ) {
   \   0000008C   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000090   0x2800             CMP      R0,#+0
   \   00000092   0xD008             BEQ.N    ??MBS_FC03_HoldingRegRd_5
    643                       pch->Err = MODBUS_ERR_FC03_02;
   \   00000094   0xF44F 0x7097      MOV      R0,#+302
   \   00000098   0x82E0             STRH     R0,[R4, #+22]
    644                       MBS_ErrRespSet(pch,
    645                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   0000009A   0x2102             MOVS     R1,#+2
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       MBS_ErrRespSet
    646                       return (DEF_TRUE);
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0xE039             B.N      ??MBS_FC03_HoldingRegRd_1
    647                  } else {
    648                      nbr_regs    = 0;
   \                     ??MBS_FC03_HoldingRegRd_5: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x0007             MOVS     R7,R0
   \   000000AA   0xE00C             B.N      ??MBS_FC03_HoldingRegRd_6
    649                  }
    650              } else {
    651                  if ( err != MODBUS_ERR_NONE ) {
   \                     ??MBS_FC03_HoldingRegRd_4: (+1)
   \   000000AC   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD008             BEQ.N    ??MBS_FC03_HoldingRegRd_6
    652                       pch->Err = MODBUS_ERR_FC03_02;
   \   000000B4   0xF44F 0x7097      MOV      R0,#+302
   \   000000B8   0x82E0             STRH     R0,[R4, #+22]
    653                       MBS_ErrRespSet(pch,
    654                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000BA   0x2102             MOVS     R1,#+2
   \   000000BC   0x0020             MOVS     R0,R4
   \   000000BE   0x.... 0x....      BL       MBS_ErrRespSet
    655                       return (DEF_TRUE);
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0xE029             B.N      ??MBS_FC03_HoldingRegRd_1
    656                  }
    657              }
    658          
    659              while (nbr_regs > 0) {                                       /* Loop through each register requested.                    */
   \                     ??MBS_FC03_HoldingRegRd_6: (+1)
   \   000000C6   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C8   0x2F00             CMP      R7,#+0
   \   000000CA   0xD023             BEQ.N    ??MBS_FC03_HoldingRegRd_7
    660                  if (reg < MODBUS_CFG_FP_START_IX) {                      /* See if we want an integer register                       */
   \   000000CC   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000CE   0xF64F 0x70DC      MOVW     R0,#+65500
   \   000000D2   0x4286             CMP      R6,R0
   \   000000D4   0xDA1B             BGE.N    ??MBS_FC03_HoldingRegRd_8
    661                      reg_val_16 = MB_HoldingRegRd(reg,                    /* Yes, get its value                                       */
    662                                                   &err);
   \   000000D6   0x4669             MOV      R1,SP
   \   000000D8   0x0030             MOVS     R0,R6
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       MB_HoldingRegRd
   \   000000E0   0x4681             MOV      R9,R0
    663                      switch (err) {
   \   000000E2   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD108             BNE.N    ??MBS_FC03_HoldingRegRd_9
    664                          case MODBUS_ERR_NONE:
    665                               *presp++ = (CPU_INT08U)((reg_val_16 >> 8) & 0x00FF); /*      Get MSB first.                             */
   \   000000EA   0x4648             MOV      R0,R9
   \   000000EC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000EE   0x0A00             LSRS     R0,R0,#+8
   \   000000F0   0x7028             STRB     R0,[R5, #+0]
   \   000000F2   0x1C6D             ADDS     R5,R5,#+1
    666                               *presp++ = (CPU_INT08U)(reg_val_16 & 0x00FF);        /*      Get LSB next.                              */
   \   000000F4   0xF885 0x9000      STRB     R9,[R5, #+0]
   \   000000F8   0x1C6D             ADDS     R5,R5,#+1
    667                               break;
   \   000000FA   0xE008             B.N      ??MBS_FC03_HoldingRegRd_8
    668          
    669                          case MODBUS_ERR_RANGE:
    670                          default:
    671                               pch->Err = MODBUS_ERR_FC03_01;
   \                     ??MBS_FC03_HoldingRegRd_9: (+1)
   \   000000FC   0xF240 0x102D      MOVW     R0,#+301
   \   00000100   0x82E0             STRH     R0,[R4, #+22]
    672                               MBS_ErrRespSet(pch,
    673                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   00000102   0x2102             MOVS     R1,#+2
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       MBS_ErrRespSet
    674                               return (DEF_TRUE);
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE005             B.N      ??MBS_FC03_HoldingRegRd_1
    675                      }
    676                  } else {
    677          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    678                      reg_val_fp = MB_HoldingRegRdFP(reg,                  /* No,  get the value of the FP register                    */
    679                                                     &err);
    680                      switch (err) {
    681                          case MODBUS_ERR_NONE:
    682                               pfp = (CPU_INT08U *)&reg_val_fp;            /* Point to the FP register                                 */
    683          #if (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
    684                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) { /* Copy value to response buffer                            */
    685                                   *presp++ = *pfp++;
    686                               }
    687          #else
    688                               pfp += sizeof(CPU_FP32) - 1;
    689                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) {
    690                                   *presp++ = *pfp--;
    691                               }
    692          #endif
    693                               break;
    694          
    695                          case MODBUS_ERR_RANGE:
    696                          default:
    697                               pch->Err = MODBUS_ERR_FC03_02;
    698                               MBS_ErrRespSet(pch,
    699                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    700                               return (DEF_TRUE);
    701                      }
    702          #endif
    703                  }
    704                  reg++;                                                   /* Increment current register number                        */
   \                     ??MBS_FC03_HoldingRegRd_8: (+1)
   \   0000010E   0x1C76             ADDS     R6,R6,#+1
    705                  nbr_regs--;
   \   00000110   0x1E7F             SUBS     R7,R7,#+1
   \   00000112   0xE7D8             B.N      ??MBS_FC03_HoldingRegRd_6
    706              }
    707          #endif //SE_MODBUS_CODE
    708              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC03_HoldingRegRd_7: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x82E0             STRH     R0,[R4, #+22]
    709              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   00000118   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC03_HoldingRegRd_1: (+1)
   \   0000011A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    710          }
    711          #endif
    712          #endif
    713          
    714          /*$PAGE*/
    715          /*
    716          *********************************************************************************************************
    717          *                                          MBS_FC04_InRegRd()
    718          *
    719          * Description : Obtains the contents of the specified input registers.
    720          *
    721          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    722          *
    723          * Return(s)   : DEF_TRUE      If a response needs to be sent
    724          *               DEF_FALSE     If not
    725          *
    726          * Caller(s)   : MBS_FCxx_Handler()
    727          *
    728          * Note(s)     : none
    729          *********************************************************************************************************
    730          */
    731          
    732          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    733          #if (MODBUS_CFG_FC04_EN  == DEF_ENABLED)
    734          static  CPU_BOOLEAN  MBS_FC04_InRegRd (MODBUS_CH  *pch)
    735          {
    736              CPU_INT08U    *presp;
    737              CPU_INT16U     err;
    738              CPU_INT16U     reg;
    739              CPU_INT16U     nbr_regs;
    740              CPU_INT16U     nbr_bytes;
    741              CPU_INT16U     reg_val_16;
    742          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    743              CPU_INT08U     ix;
    744              CPU_FP32       reg_val_fp;
    745              CPU_INT08U    *pfp;
    746          #endif
    747          
    748          
    749              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
    750                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
    751              }
    752              reg       = MBS_RX_DATA_START;
    753              nbr_regs  = MBS_RX_DATA_POINTS;
    754          
    755          #if SE_MODBUS_CODE > 0
    756          
    757              MB_DATA_inRegRd(pch, &err);
    758          
    759              if(err == MODBUS_ERR_RANGE)
    760              {
    761                 pch->Err = MODBUS_ERR_FC04_01;
    762                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    763                 return (DEF_TRUE);
    764              }
    765              pch->Err = MODBUS_ERR_NONE;
    766              return (DEF_TRUE);
    767          
    768          #else // ALL SE_MODBUS_CODE code above here
    769          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    770              if (reg < MODBUS_CFG_FP_START_IX) {                          /* See if we want integer registers                         */
    771                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
    772                      pch->Err = MODBUS_ERR_FC04_03;
    773                      MBS_ErrRespSet(pch,
    774                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    775                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    776                  }
    777                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U)); /* Find #bytes needed for response.                         */
    778              } else {
    779                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
    780                      pch->Err = MODBUS_ERR_FC04_04;
    781                      MBS_ErrRespSet(pch,
    782                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
    783                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
    784                  }
    785                  nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_FP32));   /* Find #bytes needed for response.                         */
    786              }
    787          #else
    788              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
    789                  pch->Err = MODBUS_ERR_FC04_03;
    790                  MBS_ErrRespSet(pch,
    791                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
    792                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
    793              }
    794              nbr_bytes = (CPU_INT08U)(nbr_regs * sizeof(CPU_INT16U));     /* Find #bytes needed for response.                         */
    795          #endif
    796              pch->TxFrameNDataBytes = nbr_bytes + 1;                      /* Number of data bytes + byte count.                       */
    797              presp                 = &pch->TxFrameData[0];                /* Reset the pointer to the start of the response           */
    798              *presp++              =  MBS_RX_FRAME_ADDR;                  /* Prepare response packet                                  */
    799              *presp++              =  MBS_RX_FRAME_FC;
    800              *presp++              = (CPU_INT08U)nbr_bytes;               /* Set number of data bytes in response message             */
    801              while (nbr_regs > 0) {                                       /* Loop through each register requested.                    */
    802                  if (reg < MODBUS_CFG_FP_START_IX) {                      /* See if we want an integer register                       */
    803                      reg_val_16 = MB_InRegRd(reg,                         /* Yes, get its value                                       */
    804                                              &err);
    805                      switch (err) {
    806                          case MODBUS_ERR_NONE:
    807                               *presp++ = (CPU_INT08U)((reg_val_16 >> 8) & 0x00FF); /*      Get MSB first.                             */
    808                               *presp++ = (CPU_INT08U)(reg_val_16 & 0x00FF);        /*      Get LSB next.                              */
    809                               break;
    810          
    811                          case MODBUS_ERR_RANGE:
    812                          default:
    813                               pch->Err = MODBUS_ERR_FC04_01;
    814                               MBS_ErrRespSet(pch,
    815                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    816                               return (DEF_TRUE);
    817                      }
    818                  } else {
    819          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    820                      reg_val_fp = MB_InRegRdFP(reg,                       /* No,  get the value of the FP register                    */
    821                                                &err);
    822                      switch (err) {
    823                          case MODBUS_ERR_NONE:
    824                               pfp = (CPU_INT08U *)&reg_val_fp;            /* Point to the FP register                                 */
    825          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
    826                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) { /* Copy value to response buffer                            */
    827                                   *presp++ = *pfp++;
    828                               }
    829          #else
    830                               pfp += sizeof(CPU_FP32) - 1;
    831                               for (ix = 0; ix < sizeof(CPU_FP32); ix++) {
    832                                   *presp++ = *pfp--;
    833                               }
    834          #endif
    835                               break;
    836          
    837                          case MODBUS_ERR_RANGE:
    838                          default:
    839                               pch->Err = MODBUS_ERR_FC04_02;
    840                               MBS_ErrRespSet(pch,
    841                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
    842                               return (DEF_TRUE);
    843                      }
    844          #endif
    845                  }
    846                  reg++;                                                   /* Increment current register number                        */
    847                  nbr_regs--;
    848              }
    849          #endif //SE_MODBUS_CODE
    850              pch->Err = MODBUS_ERR_NONE;
    851              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
    852          }
    853          #endif
    854          #endif
    855          
    856          /*$PAGE*/
    857          /*
    858          *********************************************************************************************************
    859          *                                           MBS_FC05_CoilWr()
    860          *
    861          * Description : Responds to a request to force a coil to a specified state.
    862          *
    863          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    864          *
    865          * Return(s)   : DEF_TRUE      If a response needs to be sent
    866          *               DEF_FALSE     If not
    867          *
    868          * Caller(s)   : MBS_FCxx_Handler()
    869          *
    870          * Note(s)     : none
    871          *********************************************************************************************************
    872          */
    873          
    874          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    875          #if (MODBUS_CFG_FC05_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    876          static  CPU_BOOLEAN  MBS_FC05_CoilWr (MODBUS_CH  *pch)
    877          {
   \                     MBS_FC05_CoilWr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    878              CPU_INT08U     *prx_data;
    879              CPU_INT08U     *ptx_data;
    880              CPU_INT08U      i;
    881              CPU_INT16U      coil;
    882              CPU_BOOLEAN     coil_val;
    883              CPU_INT16U      temp;
    884              CPU_INT16U      err;
    885          
    886          
    887              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000008   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD001             BEQ.N    ??MBS_FC05_CoilWr_0
    888                  return (DEF_FALSE);                                      /* Tell caller that we DON'T need to send a response        */
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE057             B.N      ??MBS_FC05_CoilWr_1
    889              }
    890              coil = MBS_RX_DATA_START;                                    /* Get the desired coil number                              */
   \                     ??MBS_FC05_CoilWr_0: (+1)
   \   00000014   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000018   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   0000001C   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000020   0x4680             MOV      R8,R0
    891              temp = MBS_RX_DATA_COIL;
   \   00000022   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000026   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   0000002A   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000002E   0x4682             MOV      R10,R0
    892              if (pch->WrEn == DEF_TRUE) {
   \   00000030   0x7860             LDRB     R0,[R4, #+1]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD120             BNE.N    ??MBS_FC05_CoilWr_2
    893                  if (temp == MODBUS_COIL_OFF_CODE) {                      /* See if coil needs to be OFF?                             */
   \   00000036   0xFA1F 0xFA8A      UXTH     R10,R10          ;; ZeroExt  R10,R10,#+16,#+16
   \   0000003A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000003E   0xD102             BNE.N    ??MBS_FC05_CoilWr_3
    894                      coil_val = 0;                                        /* Yes, Turn coil OFF                                       */
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x4681             MOV      R9,R0
   \   00000044   0xE001             B.N      ??MBS_FC05_CoilWr_4
    895                  } else {
    896                      coil_val = 1;                                        /* No,  Turn coil ON                                        */
   \                     ??MBS_FC05_CoilWr_3: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x4681             MOV      R9,R0
    897                  }
    898                  MB_CoilWr(coil,                                          /* Force coil                                               */
    899                            coil_val,
    900                            &err);
   \                     ??MBS_FC05_CoilWr_4: (+1)
   \   0000004A   0x466A             MOV      R2,SP
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000054   0x.... 0x....      BL       MB_CoilWr
    901                  switch (err) {
   \   00000058   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD103             BNE.N    ??MBS_FC05_CoilWr_5
    902                      case MODBUS_ERR_NONE:                                /* We simply echoe back with the command received           */
    903                           pch->WrCtr++;
   \   00000060   0x6860             LDR      R0,[R4, #+4]
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x6060             STR      R0,[R4, #+4]
    904                           break;
   \   00000066   0xE00E             B.N      ??MBS_FC05_CoilWr_6
    905          
    906                      case MODBUS_ERR_RANGE:
    907                      default:
    908                           pch->Err = MODBUS_ERR_FC05_01;
   \                     ??MBS_FC05_CoilWr_5: (+1)
   \   00000068   0xF240 0x10F5      MOVW     R0,#+501
   \   0000006C   0x82E0             STRH     R0,[R4, #+22]
    909                           MBS_ErrRespSet(pch,
    910                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   0000006E   0x2102             MOVS     R1,#+2
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       MBS_ErrRespSet
    911                           break;
   \   00000076   0xE006             B.N      ??MBS_FC05_CoilWr_6
    912                  }
    913              } else {
    914                  pch->Err = MODBUS_ERR_FC05_02;
   \                     ??MBS_FC05_CoilWr_2: (+1)
   \   00000078   0xF44F 0x70FB      MOV      R0,#+502
   \   0000007C   0x82E0             STRH     R0,[R4, #+22]
    915                  MBS_ErrRespSet(pch,                                      /* Writes are not enabled                                   */
    916                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   0000007E   0x2104             MOVS     R1,#+4
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       MBS_ErrRespSet
    917              }
    918              pch->TxFrameNDataBytes = 4;
   \                     ??MBS_FC05_CoilWr_6: (+1)
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
    919              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet                                  */
   \   0000008C   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000090   0xF884 0x034E      STRB     R0,[R4, #+846]
    920              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
   \   00000094   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   00000098   0xF884 0x034F      STRB     R0,[R4, #+847]
    921              prx_data          = &pch->RxFrameData[2];                    /* Copy four data bytes from the receive packet             */
   \   0000009C   0xF204 0x2046      ADDW     R0,R4,#+582
   \   000000A0   0x0005             MOVS     R5,R0
    922              ptx_data          = &pch->TxFrameData[2];
   \   000000A2   0xF514 0x7054      ADDS     R0,R4,#+848
   \   000000A6   0x0006             MOVS     R6,R0
    923              for (i = 0; i < 4; i++) {
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x0007             MOVS     R7,R0
   \                     ??MBS_FC05_CoilWr_7: (+1)
   \   000000AC   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000AE   0x2F04             CMP      R7,#+4
   \   000000B0   0xDA05             BGE.N    ??MBS_FC05_CoilWr_8
    924                  *ptx_data++ = *prx_data++;
   \   000000B2   0x7828             LDRB     R0,[R5, #+0]
   \   000000B4   0x7030             STRB     R0,[R6, #+0]
   \   000000B6   0x1C6D             ADDS     R5,R5,#+1
   \   000000B8   0x1C76             ADDS     R6,R6,#+1
    925              }
   \   000000BA   0x1C7F             ADDS     R7,R7,#+1
   \   000000BC   0xE7F6             B.N      ??MBS_FC05_CoilWr_7
    926              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC05_CoilWr_8: (+1)
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x82E0             STRH     R0,[R4, #+22]
    927              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   000000C2   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC05_CoilWr_1: (+1)
   \   000000C4   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
    928          }
    929          #endif
    930          #endif
    931          
    932          /*$PAGE*/
    933          /*
    934          *********************************************************************************************************
    935          *                                        MBS_FC06_HoldingRegWr()
    936          *
    937          * Description : Responds to a request to set a single register.
    938          *
    939          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
    940          *
    941          * Return(s)   : DEF_TRUE      If a response needs to be sent
    942          *               DEF_FALSE     If not
    943          *
    944          * Caller(s)   : MBS_FCxx_Handler()
    945          *
    946          * Note(s)     : none
    947          *********************************************************************************************************
    948          */
    949          
    950          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
    951          #if (MODBUS_CFG_FC06_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    952          static  CPU_BOOLEAN  MBS_FC06_HoldingRegWr (MODBUS_CH *pch)
    953          {
   \                     MBS_FC06_HoldingRegWr: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
    954              CPU_INT08U    *prx_data;
    955              CPU_INT08U    *ptx_data;
    956              CPU_INT08U     i;
    957              CPU_INT08U     max;
    958              CPU_INT16U     err;
    959              CPU_INT16U     reg;
    960              CPU_INT16U     reg_val_16;
    961          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    962              CPU_FP32       reg_val_fp;
    963              CPU_INT08U    *pfp;
    964          #endif
    965          
    966          
    967              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000008   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xD001             BEQ.N    ??MBS_FC06_HoldingRegWr_0
    968                  return (DEF_FALSE);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE053             B.N      ??MBS_FC06_HoldingRegWr_1
    969              }
    970              pch->TxFrameNDataBytes = pch->RxFrameNDataBytes;
   \                     ??MBS_FC06_HoldingRegWr_0: (+1)
   \   00000014   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   00000018   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
    971              reg =  MBS_RX_DATA_START;
   \   0000001C   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000020   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   00000024   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000028   0x4681             MOV      R9,R0
    972          #if SE_MODBUS_CODE > 0
    973          
    974              MB_DATA_holdingRegWr(pch, &err);
    975          
    976              //
    977              if(err == MODBUS_ERR_RANGE)
    978              {
    979                 pch->Err = MODBUS_ERR_FC06_01;
    980                 MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
    981                 return (DEF_TRUE);
    982              }
    983          
    984              pch->WrCtr++;
    985              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet (duplicate Rx frame)             */
    986              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
    987              prx_data          = &pch->RxFrameData[2];                    /* Copy received register address and data to response      */
    988              ptx_data          = &pch->TxFrameData[2];
    989          
    990              max = sizeof(CPU_INT16U) + 2;
    991          
    992              for (i = 0; i < max; i++) {
    993                  *ptx_data++ = *prx_data++;
    994              }
    995          
    996          
    997          #else // ALL SE_MODBUS_CODE code above here
    998          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
    999              if (reg < MODBUS_CFG_FP_START_IX) {
   1000                  reg_val_16 = MBS_RX_DATA_REG;
   1001                  MB_HoldingRegWr(reg,                                     /* Write to integer register                                */
   1002                                  reg_val_16,
   1003                                  &err);
   1004              } else {
   1005                  prx_data = &pch->RxFrameData[4];                         /* Point to data in the received frame.                     */
   1006                  pfp      = (CPU_INT08U *)&reg_val_fp;
   1007          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
   1008                  for (i = 0; i < sizeof(CPU_FP32); i++) {
   1009                      *pfp++ = *prx_data++;
   1010                  }
   1011          #else
   1012                  prx_data += sizeof(CPU_FP32) - 1;
   1013                  for (i = 0; i < sizeof(CPU_FP32); i++) {
   1014                      *pfp++ = *prx_data--;
   1015                  }
   1016          #endif
   1017                  MB_HoldingRegWrFP(reg,                                   /* Write to floating point register                         */
   1018                                    reg_val_fp,
   1019                                    &err);
   1020              }
   1021          #else
   1022              reg_val_16 = MBS_RX_DATA_REG;
   \   0000002A   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   0000002E   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000032   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000036   0x4682             MOV      R10,R0
   1023              MB_HoldingRegWr(reg,                                         /* Write to integer register                                */
   1024                              reg_val_16,
   1025                              &err);
   \   00000038   0x466A             MOV      R2,SP
   \   0000003A   0x4651             MOV      R1,R10
   \   0000003C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000003E   0x4648             MOV      R0,R9
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x.... 0x....      BL       MB_HoldingRegWr
   1026          #endif
   1027              switch (err) {
   \   00000046   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD103             BNE.N    ??MBS_FC06_HoldingRegWr_2
   1028                  case MODBUS_ERR_NONE:                                    /* Reply with echoe of command received                     */
   1029                       pch->WrCtr++;
   \   0000004E   0x6860             LDR      R0,[R4, #+4]
   \   00000050   0x1C40             ADDS     R0,R0,#+1
   \   00000052   0x6060             STR      R0,[R4, #+4]
   1030                       break;
   \   00000054   0xE006             B.N      ??MBS_FC06_HoldingRegWr_3
   1031          
   1032                  case MODBUS_ERR_RANGE:
   1033                  default:
   1034                       pch->Err = MODBUS_ERR_FC06_01;
   \                     ??MBS_FC06_HoldingRegWr_2: (+1)
   \   00000056   0xF240 0x2059      MOVW     R0,#+601
   \   0000005A   0x82E0             STRH     R0,[R4, #+22]
   1035                       MBS_ErrRespSet(pch,
   1036                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x0020             MOVS     R0,R4
   \   00000060   0x.... 0x....      BL       MBS_ErrRespSet
   1037                       break;
   1038              }
   1039              pch->TxFrameNDataBytes = 4;
   \                     ??MBS_FC06_HoldingRegWr_3: (+1)
   \   00000064   0x2004             MOVS     R0,#+4
   \   00000066   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
   1040              MBS_TX_FRAME_ADDR = MBS_RX_FRAME_ADDR;                       /* Prepare response packet (duplicate Rx frame)             */
   \   0000006A   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   0000006E   0xF884 0x034E      STRB     R0,[R4, #+846]
   1041              MBS_TX_FRAME_FC   = MBS_RX_FRAME_FC;
   \   00000072   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   00000076   0xF884 0x034F      STRB     R0,[R4, #+847]
   1042              prx_data          = &pch->RxFrameData[2];                    /* Copy received register address and data to response      */
   \   0000007A   0xF204 0x2046      ADDW     R0,R4,#+582
   \   0000007E   0x0005             MOVS     R5,R0
   1043              ptx_data          = &pch->TxFrameData[2];
   \   00000080   0xF514 0x7054      ADDS     R0,R4,#+848
   \   00000084   0x0006             MOVS     R6,R0
   1044              if (reg < MODBUS_CFG_FP_START_IX) {
   \   00000086   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000008A   0xF64F 0x70DC      MOVW     R0,#+65500
   \   0000008E   0x4581             CMP      R9,R0
   \   00000090   0xDA02             BGE.N    ??MBS_FC06_HoldingRegWr_4
   1045                  max = sizeof(CPU_INT16U) + 2;
   \   00000092   0x2004             MOVS     R0,#+4
   \   00000094   0x4680             MOV      R8,R0
   \   00000096   0xE001             B.N      ??MBS_FC06_HoldingRegWr_5
   1046              } else {
   1047                  max = sizeof(CPU_FP32) + 2;
   \                     ??MBS_FC06_HoldingRegWr_4: (+1)
   \   00000098   0x2006             MOVS     R0,#+6
   \   0000009A   0x4680             MOV      R8,R0
   1048              }
   1049              for (i = 0; i < max; i++) {
   \                     ??MBS_FC06_HoldingRegWr_5: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x0007             MOVS     R7,R0
   \                     ??MBS_FC06_HoldingRegWr_6: (+1)
   \   000000A0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000A2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A6   0x4547             CMP      R7,R8
   \   000000A8   0xD205             BCS.N    ??MBS_FC06_HoldingRegWr_7
   1050                  *ptx_data++ = *prx_data++;
   \   000000AA   0x7828             LDRB     R0,[R5, #+0]
   \   000000AC   0x7030             STRB     R0,[R6, #+0]
   \   000000AE   0x1C6D             ADDS     R5,R5,#+1
   \   000000B0   0x1C76             ADDS     R6,R6,#+1
   1051              }
   \   000000B2   0x1C7F             ADDS     R7,R7,#+1
   \   000000B4   0xE7F4             B.N      ??MBS_FC06_HoldingRegWr_6
   1052          #endif //SE_MODBUS_CODE
   1053              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC06_HoldingRegWr_7: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x82E0             STRH     R0,[R4, #+22]
   1054              return (DEF_TRUE);
   \   000000BA   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC06_HoldingRegWr_1: (+1)
   \   000000BC   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1055          }
   1056          #endif
   1057          #endif
   1058          
   1059          /*
   1060          *********************************************************************************************************
   1061          *                                           MBS_FC08_Loopback()
   1062          *
   1063          * Description : The LOOPBACK function contains various diagnostic codes that perform specific actions.
   1064          *               This function processes individual diagnostic requests and formats the response message
   1065          *               frame accordingly.  Unimplemented diagnostic codes will return an Illegal Data Value
   1066          *               Exception Response Code (03).
   1067          *
   1068          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1069          *
   1070          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1071          *               DEF_FALSE     If not
   1072          *
   1073          * Caller(s)   : MBS_FCxx_Handler()
   1074          *
   1075          * Note(s)     : none
   1076          *********************************************************************************************************
   1077          */
   1078          
   1079          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1080          #if (MODBUS_CFG_FC08_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1081          static  CPU_BOOLEAN  MBS_FC08_Loopback (MODBUS_CH  *pch)
   1082          {
   \                     MBS_FC08_Loopback: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1083              CPU_INT16U  diagcode;
   1084          
   1085          
   1086              if (pch->RxFrameNDataBytes != 4) {                           /* Nbr of data bytes must be 4.                             */
   \   00000004   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xD001             BEQ.N    ??MBS_FC08_Loopback_0
   1087                  return (DEF_FALSE);
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE077             B.N      ??MBS_FC08_Loopback_1
   1088              }
   1089              diagcode           = MBS_RX_DIAG_CODE;
   \                     ??MBS_FC08_Loopback_0: (+1)
   \   00000010   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000014   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   00000018   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   0000001C   0x0005             MOVS     R5,R0
   1090              MBS_TX_FRAME_ADDR  = MBS_RX_FRAME_ADDR;                      /* Prepare response packet                                  */
   \   0000001E   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000022   0xF884 0x034E      STRB     R0,[R4, #+846]
   1091              MBS_TX_FRAME_FC    = MBS_RX_FRAME_FC;
   \   00000026   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000002A   0xF884 0x034F      STRB     R0,[R4, #+847]
   1092              MBS_TX_DIAG_CODE_H = MBS_RX_DIAG_CODE_H;
   \   0000002E   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000032   0xF884 0x0350      STRB     R0,[R4, #+848]
   1093              MBS_TX_DIAG_CODE_L = MBS_RX_DIAG_CODE_L;
   \   00000036   0xF894 0x0247      LDRB     R0,[R4, #+583]
   \   0000003A   0xF884 0x0351      STRB     R0,[R4, #+849]
   1094              switch (diagcode) {
   \   0000003E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD00C             BEQ.N    ??MBS_FC08_Loopback_2
   \   00000046   0x280A             CMP      R0,#+10
   \   00000048   0xD015             BEQ.N    ??MBS_FC08_Loopback_3
   \   0000004A   0x280B             CMP      R0,#+11
   \   0000004C   0xD019             BEQ.N    ??MBS_FC08_Loopback_4
   \   0000004E   0x280C             CMP      R0,#+12
   \   00000050   0xD022             BEQ.N    ??MBS_FC08_Loopback_5
   \   00000052   0x280D             CMP      R0,#+13
   \   00000054   0xD02B             BEQ.N    ??MBS_FC08_Loopback_6
   \   00000056   0x280E             CMP      R0,#+14
   \   00000058   0xD034             BEQ.N    ??MBS_FC08_Loopback_7
   \   0000005A   0x280F             CMP      R0,#+15
   \   0000005C   0xD03D             BEQ.N    ??MBS_FC08_Loopback_8
   \   0000005E   0xE047             B.N      ??MBS_FC08_Loopback_9
   1095                  case MODBUS_FC08_LOOPBACK_QUERY:                         /* Return Query function code - no need to do anything.     */
   1096                       MBS_TX_DIAG_DATA_H = MBS_RX_DIAG_DATA_H;
   \                     ??MBS_FC08_Loopback_2: (+1)
   \   00000060   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000064   0xF884 0x0352      STRB     R0,[R4, #+850]
   1097                       MBS_TX_DIAG_DATA_L = MBS_RX_DIAG_DATA_L;
   \   00000068   0xF894 0x0249      LDRB     R0,[R4, #+585]
   \   0000006C   0xF884 0x0353      STRB     R0,[R4, #+851]
   1098                       pch->Err           = MODBUS_ERR_NONE;
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0x82E0             STRH     R0,[R4, #+22]
   1099                       break;
   \   00000074   0xE043             B.N      ??MBS_FC08_Loopback_10
   1100          
   1101                  case MODBUS_FC08_LOOPBACK_CLR_CTR:
   1102          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1103              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)
   1104                       MBS_StatInit(pch);                                  /* Initialize the system counters, echo response back.      */
   \                     ??MBS_FC08_Loopback_3: (+1)
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       MBS_StatInit
   1105          #endif
   1106                       pch->Err = MODBUS_ERR_NONE;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x82E0             STRH     R0,[R4, #+22]
   1107                       break;
   \   00000080   0xE03D             B.N      ??MBS_FC08_Loopback_10
   1108          
   1109                  case MODBUS_FC08_LOOPBACK_BUS_MSG_CTR:                   /* Return the message count in diag information field.      */
   1110                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatMsgCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_4: (+1)
   \   00000082   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000084   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000086   0x0A00             LSRS     R0,R0,#+8
   \   00000088   0xF884 0x0352      STRB     R0,[R4, #+850]
   1111                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatMsgCtr & 0x00FF);
   \   0000008C   0x8BE0             LDRH     R0,[R4, #+30]
   \   0000008E   0xF884 0x0353      STRB     R0,[R4, #+851]
   1112                       pch->Err           = MODBUS_ERR_NONE;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x82E0             STRH     R0,[R4, #+22]
   1113                       break;
   \   00000096   0xE032             B.N      ??MBS_FC08_Loopback_10
   1114          
   1115                  case MODBUS_FC08_LOOPBACK_BUS_CRC_CTR:                   /* Return the CRC error count in diag information field.    */
   1116                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatCRCErrCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_5: (+1)
   \   00000098   0x8C20             LDRH     R0,[R4, #+32]
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x0A00             LSRS     R0,R0,#+8
   \   0000009E   0xF884 0x0352      STRB     R0,[R4, #+850]
   1117                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatCRCErrCtr & 0x00FF);
   \   000000A2   0x8C20             LDRH     R0,[R4, #+32]
   \   000000A4   0xF884 0x0353      STRB     R0,[R4, #+851]
   1118                       pch->Err           = MODBUS_ERR_NONE;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x82E0             STRH     R0,[R4, #+22]
   1119                       break;
   \   000000AC   0xE027             B.N      ??MBS_FC08_Loopback_10
   1120          
   1121                  case MODBUS_FC08_LOOPBACK_BUS_EXCEPT_CTR:                /* Return exception count in diag information field.        */
   1122                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatExceptCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_6: (+1)
   \   000000AE   0x8C60             LDRH     R0,[R4, #+34]
   \   000000B0   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000B2   0x0A00             LSRS     R0,R0,#+8
   \   000000B4   0xF884 0x0352      STRB     R0,[R4, #+850]
   1123                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatExceptCtr & 0x00FF);
   \   000000B8   0x8C60             LDRH     R0,[R4, #+34]
   \   000000BA   0xF884 0x0353      STRB     R0,[R4, #+851]
   1124                       pch->Err           = MODBUS_ERR_NONE;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x82E0             STRH     R0,[R4, #+22]
   1125                       break;
   \   000000C2   0xE01C             B.N      ??MBS_FC08_Loopback_10
   1126          
   1127                  case MODBUS_FC08_LOOPBACK_SLAVE_MSG_CTR:                 /* Return slave message count in diag information field.    */
   1128                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatSlaveMsgCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_7: (+1)
   \   000000C4   0x8CA0             LDRH     R0,[R4, #+36]
   \   000000C6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C8   0x0A00             LSRS     R0,R0,#+8
   \   000000CA   0xF884 0x0352      STRB     R0,[R4, #+850]
   1129                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatSlaveMsgCtr & 0x00FF);
   \   000000CE   0x8CA0             LDRH     R0,[R4, #+36]
   \   000000D0   0xF884 0x0353      STRB     R0,[R4, #+851]
   1130                       pch->Err           = MODBUS_ERR_NONE;
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x82E0             STRH     R0,[R4, #+22]
   1131                       break;
   \   000000D8   0xE011             B.N      ??MBS_FC08_Loopback_10
   1132          
   1133                  case MODBUS_FC08_LOOPBACK_SLAVE_NO_RESP_CTR:             /* Return no response count in diag information field.      */
   1134                       MBS_TX_DIAG_DATA_H = (CPU_INT08U)((pch->StatNoRespCtr & 0xFF00) >> 8);
   \                     ??MBS_FC08_Loopback_8: (+1)
   \   000000DA   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000DC   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DE   0x0A00             LSRS     R0,R0,#+8
   \   000000E0   0xF884 0x0352      STRB     R0,[R4, #+850]
   1135                       MBS_TX_DIAG_DATA_L = (CPU_INT08U) (pch->StatNoRespCtr & 0x00FF);
   \   000000E4   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000E6   0xF884 0x0353      STRB     R0,[R4, #+851]
   1136                       pch->Err           = MODBUS_ERR_NONE;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x82E0             STRH     R0,[R4, #+22]
   1137                       break;
   \   000000EE   0xE006             B.N      ??MBS_FC08_Loopback_10
   1138          
   1139                  default:
   1140                       pch->Err = MODBUS_ERR_FC08_01;
   \                     ??MBS_FC08_Loopback_9: (+1)
   \   000000F0   0xF240 0x3021      MOVW     R0,#+801
   \   000000F4   0x82E0             STRH     R0,[R4, #+22]
   1141                       MBS_ErrRespSet(pch,
   1142                                      MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   000000F6   0x2104             MOVS     R1,#+4
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x.... 0x....      BL       MBS_ErrRespSet
   1143                       break;
   1144              }
   1145              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \                     ??MBS_FC08_Loopback_10: (+1)
   \   000000FE   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC08_Loopback_1: (+1)
   \   00000100   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1146          }
   1147          #endif
   1148          #endif
   1149          
   1150          /*$PAGE*/
   1151          /*
   1152          *********************************************************************************************************
   1153          *                                       MBS_FC15_CoilWrMultiple()
   1154          *
   1155          * Description : Processes the MODBUS "Force Multiple COILS" command and writes the COIL states.
   1156          *
   1157          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1158          *
   1159          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1160          *               DEF_FALSE     If not
   1161          *
   1162          * Caller(s)   : MBS_FCxx_Handler()
   1163          *
   1164          * Note(s)     : none
   1165          *********************************************************************************************************
   1166          */
   1167          
   1168          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1169          #if (MODBUS_CFG_FC15_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1170          static  CPU_BOOLEAN  MBS_FC15_CoilWrMultiple (MODBUS_CH  *pch)
   1171          {
   \                     MBS_FC15_CoilWrMultiple: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1172              CPU_INT16U    ix;
   1173              CPU_INT16U    coil;
   1174              CPU_INT16U    nbr_coils;
   1175              CPU_INT16U    nbr_bytes;
   1176              CPU_INT08U    data_ix;
   1177              CPU_BOOLEAN   coil_val;
   1178              CPU_INT08U    temp;
   1179              CPU_INT16U    err;
   1180          
   1181          
   1182              if (pch->WrEn == DEF_TRUE) {
   \   00000006   0x7860             LDRB     R0,[R4, #+1]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xF040 0x808B      BNE.W    ??MBS_FC15_CoilWrMultiple_0
   1183                  if (pch->RxFrameNDataBytes < 6) {                        /* Minimum Nbr of data bytes must be 6.                     */
   \   0000000E   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   00000012   0x2806             CMP      R0,#+6
   \   00000014   0xDA01             BGE.N    ??MBS_FC15_CoilWrMultiple_1
   1184                      return (DEF_FALSE);                                  /* Tell caller that we DON'T need to send a response        */
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE08C             B.N      ??MBS_FC15_CoilWrMultiple_2
   1185                  }
   1186                  coil      = MBS_RX_DATA_START;
   \                     ??MBS_FC15_CoilWrMultiple_1: (+1)
   \   0000001A   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   0000001E   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   00000022   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000026   0x0006             MOVS     R6,R0
   1187                  nbr_coils = MBS_RX_DATA_POINTS;
   \   00000028   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   0000002C   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000030   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000034   0x0007             MOVS     R7,R0
   1188                  nbr_bytes = MBS_RX_DATA_BYTES;                           /* Get the byte count for the data.                         */
   \   00000036   0xF894 0x024A      LDRB     R0,[R4, #+586]
   \   0000003A   0x4680             MOV      R8,R0
   1189                  if (((((nbr_coils - 1) / 8) + 1) ==  nbr_bytes) &&       /* Be sure #bytes valid for number COILS.                   */
   1190                      (pch->RxFrameNDataBytes  == (nbr_bytes + 5))) {
   \   0000003C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000003E   0x1E78             SUBS     R0,R7,#+1
   \   00000040   0x2108             MOVS     R1,#+8
   \   00000042   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000004C   0x4540             CMP      R0,R8
   \   0000004E   0xD160             BNE.N    ??MBS_FC15_CoilWrMultiple_3
   \   00000050   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   00000054   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000058   0xF118 0x0105      ADDS     R1,R8,#+5
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD158             BNE.N    ??MBS_FC15_CoilWrMultiple_3
   1191                      ix      = 0;                                         /* Initialize COIL/loop counter variable.                   */
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x0005             MOVS     R5,R0
   1192                      data_ix = 7;                                         /* The 1st COIL data byte is 5th element in data frame.     */
   \   00000064   0x2007             MOVS     R0,#+7
   \   00000066   0x4681             MOV      R9,R0
   1193                      while (ix < nbr_coils) {                             /* Loop through each COIL to be forced.                     */
   \                     ??MBS_FC15_CoilWrMultiple_4: (+1)
   \   00000068   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000006A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000006C   0x42BD             CMP      R5,R7
   \   0000006E   0xD232             BCS.N    ??MBS_FC15_CoilWrMultiple_5
   1194                          if ((ix % 8) == 0) {                             /* Move to the next data byte after every eight bits.       */
   \   00000070   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000072   0x2008             MOVS     R0,#+8
   \   00000074   0xFB95 0xF1F0      SDIV     R1,R5,R0
   \   00000078   0xFB01 0x5110      MLS      R1,R1,R0,R5
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD108             BNE.N    ??MBS_FC15_CoilWrMultiple_6
   1195                              temp = pch->RxFrameData[data_ix++];
   \   00000080   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000084   0xEB19 0x0004      ADDS     R0,R9,R4
   \   00000088   0xF890 0x0244      LDRB     R0,[R0, #+580]
   \   0000008C   0x4683             MOV      R11,R0
   \   0000008E   0xF119 0x0901      ADDS     R9,R9,#+1
   1196                          }
   1197                          if (temp & 0x01) {                               /* Get LSBit                                                */
   \                     ??MBS_FC15_CoilWrMultiple_6: (+1)
   \   00000092   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   00000096   0xD502             BPL.N    ??MBS_FC15_CoilWrMultiple_7
   1198                              coil_val = MODBUS_COIL_ON;
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x4682             MOV      R10,R0
   \   0000009C   0xE001             B.N      ??MBS_FC15_CoilWrMultiple_8
   1199                          } else {
   1200                              coil_val = MODBUS_COIL_OFF;
   \                     ??MBS_FC15_CoilWrMultiple_7: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x4682             MOV      R10,R0
   1201                          }
   1202                          MB_CoilWr(coil + ix,
   1203                                    coil_val,
   1204                                    &err);
   \                     ??MBS_FC15_CoilWrMultiple_8: (+1)
   \   000000A2   0x466A             MOV      R2,SP
   \   000000A4   0x4651             MOV      R1,R10
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0x19A8             ADDS     R0,R5,R6
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x.... 0x....      BL       MB_CoilWr
   1205                          switch (err) {
   \   000000B0   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD105             BNE.N    ??MBS_FC15_CoilWrMultiple_9
   1206                              case MODBUS_ERR_NONE:
   1207                                   break;                                  /* Continue with the next coil if no error                  */
   1208          
   1209                              case MODBUS_ERR_RANGE:
   1210                              default:
   1211                                   pch->Err = MODBUS_ERR_FC15_01;
   1212                                   MBS_ErrRespSet(pch,
   1213                                                  MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1214                                   return (DEF_TRUE);                      /* Tell caller that we need to send a response              */
   1215                          }
   1216                          temp >>= 1;                                      /* Shift the data one bit position to the right.            */
   \   000000B8   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BC   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   1217                          ix++;                                            /* Increment the COIL counter.                              */
   \   000000C0   0x1C6D             ADDS     R5,R5,#+1
   \   000000C2   0xE7D1             B.N      ??MBS_FC15_CoilWrMultiple_4
   \                     ??MBS_FC15_CoilWrMultiple_9: (+1)
   \   000000C4   0xF240 0x50DD      MOVW     R0,#+1501
   \   000000C8   0x82E0             STRH     R0,[R4, #+22]
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x0020             MOVS     R0,R4
   \   000000CE   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000D2   0x2001             MOVS     R0,#+1
   \   000000D4   0xE02E             B.N      ??MBS_FC15_CoilWrMultiple_2
   1218                      }
   1219                  } else {
   1220                      pch->Err = MODBUS_ERR_FC15_02;
   1221                      MBS_ErrRespSet(pch,
   1222                                     MODBUS_ERR_ILLEGAL_DATA_VAL);
   1223                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1224                  }
   1225                  pch->TxFrameNDataBytes = 4;                              /* Don't echo the whole message back!                       */
   \                     ??MBS_FC15_CoilWrMultiple_5: (+1)
   \   000000D6   0x2004             MOVS     R0,#+4
   \   000000D8   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
   1226                  MBS_TX_FRAME_ADDR      = MBS_RX_FRAME_ADDR;              /* Prepare response packet                                  */
   \   000000DC   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   000000E0   0xF884 0x034E      STRB     R0,[R4, #+846]
   1227                  MBS_TX_FRAME_FC        = MBS_RX_FRAME_FC;
   \   000000E4   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   000000E8   0xF884 0x034F      STRB     R0,[R4, #+847]
   1228                  MBS_TX_DATA_START_H    = MBS_RX_DATA_START_H;
   \   000000EC   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   000000F0   0xF884 0x0350      STRB     R0,[R4, #+848]
   1229                  MBS_TX_DATA_START_L    = MBS_RX_DATA_START_L;
   \   000000F4   0xF894 0x0247      LDRB     R0,[R4, #+583]
   \   000000F8   0xF884 0x0351      STRB     R0,[R4, #+849]
   1230                  MBS_TX_DATA_POINTS_H   = MBS_RX_DATA_POINTS_H;
   \   000000FC   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000100   0xF884 0x0352      STRB     R0,[R4, #+850]
   1231                  MBS_TX_DATA_POINTS_L   = MBS_RX_DATA_POINTS_L;
   \   00000104   0xF894 0x0249      LDRB     R0,[R4, #+585]
   \   00000108   0xF884 0x0353      STRB     R0,[R4, #+851]
   1232                  pch->Err               = MODBUS_ERR_NONE;
   \   0000010C   0x2000             MOVS     R0,#+0
   \   0000010E   0x82E0             STRH     R0,[R4, #+22]
   \   00000110   0xE00F             B.N      ??MBS_FC15_CoilWrMultiple_10
   \                     ??MBS_FC15_CoilWrMultiple_3: (+1)
   \   00000112   0xF240 0x50DE      MOVW     R0,#+1502
   \   00000116   0x82E0             STRH     R0,[R4, #+22]
   \   00000118   0x2104             MOVS     R1,#+4
   \   0000011A   0x0020             MOVS     R0,R4
   \   0000011C   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0xE007             B.N      ??MBS_FC15_CoilWrMultiple_2
   1233              } else {
   1234                  pch->Err               = MODBUS_ERR_FC15_03;              /* Number of bytes incorrect for number of COILS.           */
   \                     ??MBS_FC15_CoilWrMultiple_0: (+1)
   \   00000124   0xF240 0x50DF      MOVW     R0,#+1503
   \   00000128   0x82E0             STRH     R0,[R4, #+22]
   1235                  MBS_ErrRespSet(pch,
   1236                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   0000012A   0x2104             MOVS     R1,#+4
   \   0000012C   0x0020             MOVS     R0,R4
   \   0000012E   0x.... 0x....      BL       MBS_ErrRespSet
   1237              }
   1238              return (DEF_TRUE);                                            /* Tell caller that we need to send a response              */
   \                     ??MBS_FC15_CoilWrMultiple_10: (+1)
   \   00000132   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC15_CoilWrMultiple_2: (+1)
   \   00000134   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1239          }
   1240          #endif
   1241          #endif
   1242          
   1243          /*$PAGE*/
   1244          /*
   1245          *********************************************************************************************************
   1246          *                                    MBS_FC16_HoldingRegWrMultiple()
   1247          *
   1248          * Description : This function is called to write to multiple holding registers.  If the address of the
   1249          *               rquest exceeds or is equal to MODBUS_CFG_FP_START_IX, then the command would write to
   1250          *               multiple 'floating-point' according to the 'Daniels Flow Meter' extensions.  This means
   1251          *               that each register requested is considered as a 32-bit IEEE-754 floating-point format.
   1252          *
   1253          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1254          *
   1255          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1256          *               DEF_FALSE     If not
   1257          *
   1258          * Caller(s)   : MBS_FCxx_Handler()
   1259          *
   1260          * Note(s)     : none
   1261          *********************************************************************************************************
   1262          */
   1263          
   1264          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1265          #if (MODBUS_CFG_FC16_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1266          static  CPU_BOOLEAN  MBS_FC16_HoldingRegWrMultiple (MODBUS_CH *pch)
   1267          {
   \                     MBS_FC16_HoldingRegWrMultiple: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   1268              CPU_INT08U     *prx_data;
   1269              CPU_INT16U      err;
   1270              CPU_INT16U      reg;
   1271              CPU_INT16U      reg_val_16;
   1272              CPU_INT16U      nbr_regs;
   1273              CPU_INT16U      nbr_bytes;
   1274              CPU_INT08U      data_size;
   1275          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1276              CPU_INT08U      i;
   1277              CPU_FP32        reg_val_fp;
   1278              CPU_INT08U     *pfp;
   1279          #endif
   1280          
   1281          
   1282              reg       = MBS_RX_DATA_START;
   \   00000008   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   0000000C   0xF894 0x1247      LDRB     R1,[R4, #+583]
   \   00000010   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000014   0x0006             MOVS     R6,R0
   1283              nbr_regs  = MBS_RX_DATA_POINTS;
   \   00000016   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   0000001A   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   0000001E   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000022   0x4680             MOV      R8,R0
   1284          #if SE_MODBUS_CODE > 0
   1285          
   1286              MB_DATA_holdingRegWrMultiple(pch, &err);
   1287          
   1288              switch(err)
   1289              {
   1290                 case MODBUS_ERR_RANGE:
   1291                    pch->Err = MODBUS_ERR_FC16_03;
   1292                    MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1293                    return (DEF_TRUE);
   1294                 case MODBUS_ERR_ILLEGAL_DATA_QTY:
   1295                    pch->Err = MODBUS_ERR_FC16_01;
   1296                    MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_QTY);
   1297                    return (DEF_TRUE);
   1298                 case MODBUS_ERR_ILLEGAL_DATA_VAL:
   1299                    pch->Err = MODBUS_ERR_FC16_02;
   1300                     MBS_ErrRespSet(pch, MODBUS_ERR_ILLEGAL_DATA_VAL);
   1301                     return (DEF_TRUE);
   1302                 default:
   1303                    break;
   1304          
   1305              }
   1306          
   1307          #else // ALL SE_MODBUS_CODE code above here
   1308          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1309              if (reg < MODBUS_CFG_FP_START_IX) {
   1310                  if (nbr_regs == 0 || nbr_regs > 125) {                   /* Make sure we don't exceed the allowed limit per request  */
   1311                      pch->Err = MODBUS_ERR_FC16_04;
   1312                      MBS_ErrRespSet(pch,
   1313                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
   1314                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1315                  }
   1316                  data_size  = sizeof(CPU_INT16U);
   1317              } else {
   1318                  if (nbr_regs == 0 || nbr_regs > 62) {                    /* Make sure we don't exceed the allowed limit per request  */
   1319                      pch->Err = MODBUS_ERR_FC16_05;
   1320                      MBS_ErrRespSet(pch,
   1321                                     MODBUS_ERR_ILLEGAL_DATA_QTY);
   1322                      return (DEF_TRUE);                                   /* Tell caller that we need to send a response              */
   1323                  }
   1324                  data_size  = sizeof(CPU_FP32);
   1325              }
   1326          #else
   1327              if (nbr_regs == 0 || nbr_regs > 125) {                       /* Make sure we don't exceed the allowed limit per request  */
   \   00000024   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD004             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_0
   \   0000002E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000032   0xF1B8 0x0F7E      CMP      R8,#+126
   \   00000036   0xDB08             BLT.N    ??MBS_FC16_HoldingRegWrMultiple_1
   1328                  pch->Err = MODBUS_ERR_FC16_04;
   \                     ??MBS_FC16_HoldingRegWrMultiple_0: (+1)
   \   00000038   0xF240 0x6044      MOVW     R0,#+1604
   \   0000003C   0x82E0             STRH     R0,[R4, #+22]
   1329                  MBS_ErrRespSet(pch,
   1330                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   0000003E   0x2103             MOVS     R1,#+3
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       MBS_ErrRespSet
   1331                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xE094             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1332              }
   1333              data_size  = sizeof(CPU_INT16U);
   \                     ??MBS_FC16_HoldingRegWrMultiple_1: (+1)
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x4682             MOV      R10,R0
   1334          #endif
   1335          
   1336              prx_data  = &pch->RxFrameData[6];                            /* Point to number of bytes in request frame                */
   \   0000004E   0xF204 0x204A      ADDW     R0,R4,#+586
   \   00000052   0x0005             MOVS     R5,R0
   1337              nbr_bytes = (CPU_INT16U)*prx_data++;
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0x4681             MOV      R9,R0
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   1338              if ((pch->RxFrameNDataBytes - 5) != nbr_bytes) {             /* Compare actual number of bytes to what they say.         */
   \   0000005A   0xF8B4 0x0344      LDRH     R0,[R4, #+836]
   \   0000005E   0x1F40             SUBS     R0,R0,#+5
   \   00000060   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   00000064   0x4548             CMP      R0,R9
   \   00000066   0xD008             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_3
   1339                  pch->Err = MODBUS_ERR_FC16_01;
   \   00000068   0xF240 0x6041      MOVW     R0,#+1601
   \   0000006C   0x82E0             STRH     R0,[R4, #+22]
   1340                  MBS_ErrRespSet(pch,
   1341                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       MBS_ErrRespSet
   1342                  return (DEF_TRUE);
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0xE07C             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1343              }
   1344              if ((nbr_bytes / nbr_regs) != (CPU_INT16U)data_size) {
   \                     ??MBS_FC16_HoldingRegWrMultiple_3: (+1)
   \   0000007A   0xFA1F 0xF989      UXTH     R9,R9            ;; ZeroExt  R9,R9,#+16,#+16
   \   0000007E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000082   0xFB99 0xF0F8      SDIV     R0,R9,R8
   \   00000086   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000008A   0x4550             CMP      R0,R10
   \   0000008C   0xD008             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_4
   1345                  pch->Err = MODBUS_ERR_FC16_02;
   \   0000008E   0xF240 0x6042      MOVW     R0,#+1602
   \   00000092   0x82E0             STRH     R0,[R4, #+22]
   1346                  MBS_ErrRespSet(pch,
   1347                                 MODBUS_ERR_ILLEGAL_DATA_VAL);
   \   00000094   0x2104             MOVS     R1,#+4
   \   00000096   0x0020             MOVS     R0,R4
   \   00000098   0x.... 0x....      BL       MBS_ErrRespSet
   1348                  return (DEF_TRUE);                                       /* Tell caller that we need to send a response              */
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE069             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1349              }
   1350          
   1351              /***********************************************
   1352              * 描述： 写多个寄存器回调函数
   1353              */
   1354              if ( App_MB_WrNRegsHook ( (CPU_INT16U )reg,
   1355                                        (CPU_INT16U*)prx_data,
   1356                                        (CPU_INT16U )nbr_regs,
   1357                                        &err ) ) {
   \                     ??MBS_FC16_HoldingRegWrMultiple_4: (+1)
   \   000000A0   0x466B             MOV      R3,SP
   \   000000A2   0x4642             MOV      R2,R8
   \   000000A4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   0x0029             MOVS     R1,R5
   \   000000A8   0x0030             MOVS     R0,R6
   \   000000AA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000AC   0x.... 0x....      BL       App_MB_WrNRegsHook
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD00F             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_5
   1358                  if ( err != MODBUS_ERR_NONE ) {
   \   000000B4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD008             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_6
   1359                       pch->Err = MODBUS_ERR_FC16_03;
   \   000000BC   0xF240 0x6043      MOVW     R0,#+1603
   \   000000C0   0x82E0             STRH     R0,[R4, #+22]
   1360                       MBS_ErrRespSet(pch,
   1361                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000C2   0x2102             MOVS     R1,#+2
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       MBS_ErrRespSet
   1362                       return (DEF_TRUE);
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xE052             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1363                  } else {
   1364                      nbr_regs    = 0;
   \                     ??MBS_FC16_HoldingRegWrMultiple_6: (+1)
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x4680             MOV      R8,R0
   \   000000D2   0xE00C             B.N      ??MBS_FC16_HoldingRegWrMultiple_7
   1365                  }
   1366              } else {
   1367                  if ( err != MODBUS_ERR_NONE ) {
   \                     ??MBS_FC16_HoldingRegWrMultiple_5: (+1)
   \   000000D4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD008             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_7
   1368                       pch->Err = MODBUS_ERR_FC03_02;
   \   000000DC   0xF44F 0x7097      MOV      R0,#+302
   \   000000E0   0x82E0             STRH     R0,[R4, #+22]
   1369                       MBS_ErrRespSet(pch,
   1370                                      MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   000000E2   0x2102             MOVS     R1,#+2
   \   000000E4   0x0020             MOVS     R0,R4
   \   000000E6   0x.... 0x....      BL       MBS_ErrRespSet
   1371                       return (DEF_TRUE);
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0xE042             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1372                  }
   1373              }
   1374          
   1375              while (nbr_regs > 0) {
   \                     ??MBS_FC16_HoldingRegWrMultiple_7: (+1)
   \   000000EE   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   000000F2   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000F6   0xD021             BEQ.N    ??MBS_FC16_HoldingRegWrMultiple_8
   1376          #if (MODBUS_CFG_FP_EN == DEF_ENABLED)
   1377                  if (reg < MODBUS_CFG_FP_START_IX) {
   1378                      reg_val_16  = ((CPU_INT16U)*prx_data++) << 8;        /* Get MSB first.                                           */
   1379                      reg_val_16 +=  (CPU_INT16U)*prx_data++;              /* Add in the LSB.                                          */
   1380                      MB_HoldingRegWr(reg,
   1381                                      reg_val_16,
   1382                                      &err);
   1383                  } else {
   1384                      pfp = (CPU_INT08U *)&reg_val_fp;
   1385          #if CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG
   1386                      for (i = 0; i < sizeof(CPU_FP32); i++) {
   1387                          *pfp++   = *prx_data++;
   1388                      }
   1389          #else
   1390                      pfp += sizeof(CPU_FP32) - 1;
   1391                      for (i = 0; i < sizeof(CPU_FP32); i++) {
   1392                          *pfp--   = *prx_data++;
   1393                      }
   1394          #endif
   1395                      MB_HoldingRegWrFP(reg,
   1396                                        reg_val_fp,
   1397                                        &err);
   1398                  }
   1399          #else
   1400                  reg_val_16  = ((CPU_INT16U)*prx_data++) << 8;            /* Get MSB first.                                           */
   \   000000F8   0x7828             LDRB     R0,[R5, #+0]
   \   000000FA   0x0200             LSLS     R0,R0,#+8
   \   000000FC   0x0007             MOVS     R7,R0
   \   000000FE   0x1C6D             ADDS     R5,R5,#+1
   1401                  reg_val_16 +=  (CPU_INT16U)*prx_data++;                  /* Add in the LSB.                                          */
   \   00000100   0x7828             LDRB     R0,[R5, #+0]
   \   00000102   0x19C7             ADDS     R7,R0,R7
   \   00000104   0x1C6D             ADDS     R5,R5,#+1
   1402                  MB_HoldingRegWr(reg,
   1403                                  reg_val_16,
   1404                                  &err);
   \   00000106   0x466A             MOV      R2,SP
   \   00000108   0x0039             MOVS     R1,R7
   \   0000010A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000010C   0x0030             MOVS     R0,R6
   \   0000010E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000110   0x.... 0x....      BL       MB_HoldingRegWr
   1405          #endif
   1406          
   1407                  switch (err) {                                           /* See if any errors in writing the data                    */
   \   00000114   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD106             BNE.N    ??MBS_FC16_HoldingRegWrMultiple_9
   1408                      case MODBUS_ERR_NONE:                                /* Reply with echoe of command received                     */
   1409                           pch->WrCtr++;
   \   0000011C   0x6860             LDR      R0,[R4, #+4]
   \   0000011E   0x1C40             ADDS     R0,R0,#+1
   \   00000120   0x6060             STR      R0,[R4, #+4]
   1410                           reg++;
   \   00000122   0x1C76             ADDS     R6,R6,#+1
   1411                           nbr_regs--;
   \   00000124   0xF1B8 0x0801      SUBS     R8,R8,#+1
   1412                           break;
   \   00000128   0xE7E1             B.N      ??MBS_FC16_HoldingRegWrMultiple_7
   1413          
   1414                      case MODBUS_ERR_RANGE:
   1415                      default:
   1416                           pch->Err = MODBUS_ERR_FC16_03;
   \                     ??MBS_FC16_HoldingRegWrMultiple_9: (+1)
   \   0000012A   0xF240 0x6043      MOVW     R0,#+1603
   \   0000012E   0x82E0             STRH     R0,[R4, #+22]
   1417                           MBS_ErrRespSet(pch,
   1418                                          MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   00000130   0x2102             MOVS     R1,#+2
   \   00000132   0x0020             MOVS     R0,R4
   \   00000134   0x.... 0x....      BL       MBS_ErrRespSet
   1419                           return (DEF_TRUE);                              /* Tell caller that we need to send a response              */
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE01B             B.N      ??MBS_FC16_HoldingRegWrMultiple_2
   1420                  }
   1421              }
   1422          #endif //SE_MODBUS_CODE
   1423              pch->TxFrameNDataBytes = 4;                                  /* Don't echo the whole message back!                       */
   \                     ??MBS_FC16_HoldingRegWrMultiple_8: (+1)
   \   0000013C   0x2004             MOVS     R0,#+4
   \   0000013E   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
   1424              MBS_TX_FRAME_ADDR      = MBS_RX_FRAME_ADDR;                  /* Prepare response packet                                  */
   \   00000142   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000146   0xF884 0x034E      STRB     R0,[R4, #+846]
   1425              MBS_TX_FRAME_FC        = MBS_RX_FRAME_FC;
   \   0000014A   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000014E   0xF884 0x034F      STRB     R0,[R4, #+847]
   1426              MBS_TX_DATA_START_H    = MBS_RX_DATA_START_H;
   \   00000152   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   00000156   0xF884 0x0350      STRB     R0,[R4, #+848]
   1427              MBS_TX_DATA_START_L    = MBS_RX_DATA_START_L;
   \   0000015A   0xF894 0x0247      LDRB     R0,[R4, #+583]
   \   0000015E   0xF884 0x0351      STRB     R0,[R4, #+849]
   1428              MBS_TX_DATA_POINTS_H   = MBS_RX_DATA_POINTS_H;
   \   00000162   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000166   0xF884 0x0352      STRB     R0,[R4, #+850]
   1429              MBS_TX_DATA_POINTS_L   = MBS_RX_DATA_POINTS_L;
   \   0000016A   0xF894 0x0249      LDRB     R0,[R4, #+585]
   \   0000016E   0xF884 0x0353      STRB     R0,[R4, #+851]
   1430              return (DEF_TRUE);                                           /* Tell caller that we need to send a response              */
   \   00000172   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC16_HoldingRegWrMultiple_2: (+1)
   \   00000174   0xE8BD 0x87F6      POP      {R1,R2,R4-R10,PC}  ;; return
   1431          }
   1432          #endif
   1433          #endif
   1434          
   1435          /*$PAGE*/
   1436          /*
   1437          *********************************************************************************************************
   1438          *                                          MBS_FC20_FileRd()
   1439          *
   1440          * Description : Read a record from a file.
   1441          *
   1442          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1443          *
   1444          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1445          *               DEF_FALSE     If not
   1446          *
   1447          * Caller(s)   : MBS_FCxx_Handler()
   1448          *
   1449          * Note(s)     : (1) The current version of this software only supports ONE Sub-request at a time.
   1450          *********************************************************************************************************
   1451          */
   1452          
   1453          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1454          #if (MODBUS_CFG_FC20_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1455          static  CPU_BOOLEAN  MBS_FC20_FileRd (MODBUS_CH  *pch)
   1456          {
   \                     MBS_FC20_FileRd: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   1457              CPU_INT08U    *presp;
   1458              CPU_INT16U     file_nbr;
   1459              CPU_INT16U     record_nbr;
   1460              CPU_INT16U     record_len;
   1461              CPU_INT16U     cmd_len;
   1462              CPU_INT08U     cmd_type;
   1463              CPU_INT16U     err;
   1464              CPU_INT16U     reg_val;
   1465              CPU_INT16U     ix;
   1466          
   1467          
   1468              cmd_len = pch->RxFrameData[2];                                           /* Get the number of bytes in the command received          */
   \   00000008   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   0000000C   0x4680             MOV      R8,R0
   1469              if (cmd_len < 7 || cmd_len > 245) {                                      /* Make sure the byte count Rx'd is within expected range   */
   \   0000000E   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000012   0xF1B8 0x0F07      CMP      R8,#+7
   \   00000016   0xDB04             BLT.N    ??MBS_FC20_FileRd_0
   \   00000018   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000001C   0xF1B8 0x0FF6      CMP      R8,#+246
   \   00000020   0xDB08             BLT.N    ??MBS_FC20_FileRd_1
   1470                  pch->Err = MODBUS_ERR_FC20_01;
   \                     ??MBS_FC20_FileRd_0: (+1)
   \   00000022   0xF240 0x70D1      MOVW     R0,#+2001
   \   00000026   0x82E0             STRH     R0,[R4, #+22]
   1471                  MBS_ErrRespSet(pch,
   1472                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000028   0x2103             MOVS     R1,#+3
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0x.... 0x....      BL       MBS_ErrRespSet
   1473                  return (DEF_TRUE);                                                   /* Tell caller that we need to send a response              */
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE097             B.N      ??MBS_FC20_FileRd_2
   1474              }
   1475              cmd_type    =  pch->RxFrameData[3];                                      /* Get the reference type                                   */
   \                     ??MBS_FC20_FileRd_1: (+1)
   \   00000034   0xF894 0x0247      LDRB     R0,[R4, #+583]
   \   00000038   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1476              file_nbr    = ((CPU_INT16U)pch->RxFrameData[4] << 8)                     /* Get the file number                                      */
   1477                          +  (CPU_INT16U)pch->RxFrameData[5];
   \   0000003C   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   00000040   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000044   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000048   0x0005             MOVS     R5,R0
   1478              record_nbr  = ((CPU_INT16U)pch->RxFrameData[6] << 8)                     /* Get the record number                                    */
   1479                          +  (CPU_INT16U)pch->RxFrameData[7];
   \   0000004A   0xF894 0x024A      LDRB     R0,[R4, #+586]
   \   0000004E   0xF894 0x124B      LDRB     R1,[R4, #+587]
   \   00000052   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000056   0x0006             MOVS     R6,R0
   1480              record_len  = ((CPU_INT16U)pch->RxFrameData[8] << 8)                     /* Get the record length                                    */
   1481                          +  (CPU_INT16U)pch->RxFrameData[9];
   \   00000058   0xF894 0x024C      LDRB     R0,[R4, #+588]
   \   0000005C   0xF894 0x124D      LDRB     R1,[R4, #+589]
   \   00000060   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000064   0x0007             MOVS     R7,R0
   1482              presp       = &pch->TxFrameData[0];                                      /* Point to first location in response buffer               */
   \   00000066   0xF204 0x304E      ADDW     R0,R4,#+846
   \   0000006A   0x4682             MOV      R10,R0
   1483              *presp++    = MBS_RX_FRAME_ADDR;                                         /* Reply back with the node address                         */
   \   0000006C   0xF894 0x0244      LDRB     R0,[R4, #+580]
   \   00000070   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000074   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1484              *presp++    = MBS_RX_FRAME_FC;                                           /* Include the function code                                */
   \   00000078   0xF894 0x0245      LDRB     R0,[R4, #+581]
   \   0000007C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000080   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1485              if (cmd_type == 6) {                                                     /* File type should ALWAYS be 6.                            */
   \   00000084   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000088   0x2806             CMP      R0,#+6
   \   0000008A   0xD163             BNE.N    ??MBS_FC20_FileRd_3
   1486                  pch->TxFrameNDataBytes = record_len * sizeof(CPU_INT16U) + 3;        /* Determine the total number of data bytes in the Tx frame */
   \   0000008C   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000008E   0x0078             LSLS     R0,R7,#+1
   \   00000090   0x1CC0             ADDS     R0,R0,#+3
   \   00000092   0xF8A4 0x044E      STRH     R0,[R4, #+1102]
   1487                  *presp++               = (CPU_INT08U)(pch->TxFrameNDataBytes - 1);   /* Total byte count (excluding byte count)                  */
   \   00000096   0xF8B4 0x044E      LDRH     R0,[R4, #+1102]
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   \   0000009C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000A0   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1488                  *presp++               = (CPU_INT08U)(pch->TxFrameNDataBytes - 2);   /* Sub request byte count (excluding sub-request byte cnt)  */
   \   000000A4   0xF8B4 0x044E      LDRH     R0,[R4, #+1102]
   \   000000A8   0x1E80             SUBS     R0,R0,#+2
   \   000000AA   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000AE   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1489                  *presp++               = 6;                                          /* Reference type is ALWAYS 6.                              */
   \   000000B2   0x2006             MOVS     R0,#+6
   \   000000B4   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000B8   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1490                  ix                     = 0;                                          /* Initialize the index into the record                     */
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x4681             MOV      R9,R0
   1491                  while (record_len > 0) {
   \                     ??MBS_FC20_FileRd_4: (+1)
   \   000000C0   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   000000C2   0x2F00             CMP      R7,#+0
   \   000000C4   0xD042             BEQ.N    ??MBS_FC20_FileRd_5
   1492                      reg_val = MB_FileRd(file_nbr,                                    /* Get one value from the file                              */
   1493                                          record_nbr,
   1494                                          ix,
   1495                                          record_len,
   1496                                          &err);
   \   000000C6   0xF10D 0x0006      ADD      R0,SP,#+6
   \   000000CA   0x9000             STR      R0,[SP, #+0]
   \   000000CC   0x003B             MOVS     R3,R7
   \   000000CE   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000D0   0x464A             MOV      R2,R9
   \   000000D2   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000D4   0x0031             MOVS     R1,R6
   \   000000D6   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000D8   0x0028             MOVS     R0,R5
   \   000000DA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DC   0x.... 0x....      BL       MB_FileRd
   \   000000E0   0x4683             MOV      R11,R0
   1497                      switch (err) {
   \   000000E2   0xF8BD 0x0006      LDRH     R0,[SP, #+6]
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD006             BEQ.N    ??MBS_FC20_FileRd_6
   \   000000EA   0xF640 0x71A1      MOVW     R1,#+4001
   \   000000EE   0x1A40             SUBS     R0,R0,R1
   \   000000F0   0xD011             BEQ.N    ??MBS_FC20_FileRd_7
   \   000000F2   0x1E40             SUBS     R0,R0,#+1
   \   000000F4   0xD018             BEQ.N    ??MBS_FC20_FileRd_8
   \   000000F6   0xE020             B.N      ??MBS_FC20_FileRd_9
   1498                          case MODBUS_ERR_NONE:
   1499                               *presp++ = (CPU_INT08U)(reg_val >> 8);                  /* Store high byte of record data                           */
   \                     ??MBS_FC20_FileRd_6: (+1)
   \   000000F8   0x4658             MOV      R0,R11
   \   000000FA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000FC   0x0A00             LSRS     R0,R0,#+8
   \   000000FE   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000102   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1500                               *presp++ = (CPU_INT08U)(reg_val & 0x00FF);              /* Store low  byte of record data                           */
   \   00000106   0xF88A 0xB000      STRB     R11,[R10, #+0]
   \   0000010A   0xF11A 0x0A01      ADDS     R10,R10,#+1
   1501                               break;
   1502          
   1503                          case MODBUS_ERR_FILE:
   1504                               pch->Err = MODBUS_ERR_FC20_02;
   1505                               MBS_ErrRespSet(pch,
   1506                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1507                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1508          
   1509                          case MODBUS_ERR_RECORD:
   1510                               pch->Err = MODBUS_ERR_FC20_03;
   1511                               MBS_ErrRespSet(pch,
   1512                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1513                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1514          
   1515                          case MODBUS_ERR_IX:
   1516                          default:
   1517                               pch->Err = MODBUS_ERR_FC20_04;
   1518                               MBS_ErrRespSet(pch,
   1519                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1520                               return (DEF_TRUE);                                      /* Tell caller that we need to send a response              */
   1521                      }
   1522                      ix++;
   \   0000010E   0xF119 0x0901      ADDS     R9,R9,#+1
   1523                      record_len--;
   \   00000112   0x1E7F             SUBS     R7,R7,#+1
   \   00000114   0xE7D4             B.N      ??MBS_FC20_FileRd_4
   \                     ??MBS_FC20_FileRd_7: (+1)
   \   00000116   0xF240 0x70D2      MOVW     R0,#+2002
   \   0000011A   0x82E0             STRH     R0,[R4, #+22]
   \   0000011C   0x2102             MOVS     R1,#+2
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000124   0x2001             MOVS     R0,#+1
   \   00000126   0xE01D             B.N      ??MBS_FC20_FileRd_2
   \                     ??MBS_FC20_FileRd_8: (+1)
   \   00000128   0xF240 0x70D3      MOVW     R0,#+2003
   \   0000012C   0x82E0             STRH     R0,[R4, #+22]
   \   0000012E   0x2102             MOVS     R1,#+2
   \   00000130   0x0020             MOVS     R0,R4
   \   00000132   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0xE014             B.N      ??MBS_FC20_FileRd_2
   \                     ??MBS_FC20_FileRd_9: (+1)
   \   0000013A   0xF240 0x70D4      MOVW     R0,#+2004
   \   0000013E   0x82E0             STRH     R0,[R4, #+22]
   \   00000140   0x2102             MOVS     R1,#+2
   \   00000142   0x0020             MOVS     R0,R4
   \   00000144   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000148   0x2001             MOVS     R0,#+1
   \   0000014A   0xE00B             B.N      ??MBS_FC20_FileRd_2
   1524                  }
   1525              } else {
   1526                  pch->Err = MODBUS_ERR_FC20_05;
   1527                  MBS_ErrRespSet(pch,
   1528                                 MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1529                  return (DEF_TRUE);                                                   /* Tell caller that we need to send a response              */
   1530              }
   1531              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC20_FileRd_5: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x82E0             STRH     R0,[R4, #+22]
   1532              return (DEF_TRUE);                                                       /* Tell caller that we need to send a response              */
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0xE007             B.N      ??MBS_FC20_FileRd_2
   \                     ??MBS_FC20_FileRd_3: (+1)
   \   00000154   0xF240 0x70D5      MOVW     R0,#+2005
   \   00000158   0x82E0             STRH     R0,[R4, #+22]
   \   0000015A   0x2102             MOVS     R1,#+2
   \   0000015C   0x0020             MOVS     R0,R4
   \   0000015E   0x.... 0x....      BL       MBS_ErrRespSet
   \   00000162   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC20_FileRd_2: (+1)
   \   00000164   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1533          }
   1534          #endif
   1535          #endif
   1536          
   1537          /*$PAGE*/
   1538          /*
   1539          *********************************************************************************************************
   1540          *                                       MBS_FC21_FileWr()
   1541          *
   1542          * Description : Write a record to a file.
   1543          *
   1544          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1545          *
   1546          * Return(s)   : DEF_TRUE      If a response needs to be sent
   1547          *               DEF_FALSE     If not
   1548          *
   1549          * Caller(s)   : MBS_FCxx_Handler().
   1550          *
   1551          * Note(s)     : (1) The current version of this software only supports ONE Sub-request at a time.
   1552          *********************************************************************************************************
   1553          */
   1554          
   1555          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)
   1556          #if (MODBUS_CFG_FC21_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1557          static  CPU_BOOLEAN  MBS_FC21_FileWr (MODBUS_CH  *pch)
   1558          {
   \                     MBS_FC21_FileWr: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x0004             MOVS     R4,R0
   1559              CPU_INT08U    *prx_data;
   1560              CPU_INT08U    *pcmd;
   1561              CPU_INT08U    *presp;
   1562              CPU_INT16U     file_nbr;
   1563              CPU_INT16U     record_nbr;
   1564              CPU_INT16U     record_len;
   1565              CPU_INT16U     cmd_len;
   1566              CPU_INT08U     cmd_type;
   1567              CPU_INT16U     err;
   1568              CPU_INT08U     max;
   1569              CPU_INT16U     reg_val;
   1570              CPU_INT16U     ix;
   1571          
   1572          
   1573              cmd_len = pch->RxFrameData[2];
   \   00000008   0xF894 0x0246      LDRB     R0,[R4, #+582]
   \   0000000C   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1574              if (cmd_len < 7 || cmd_len > 245) {                                    /* Make sure the byte count Rx'd is within expected range   */
   \   00000010   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \   00000014   0x2807             CMP      R0,#+7
   \   00000016   0xDB03             BLT.N    ??MBS_FC21_FileWr_0
   \   00000018   0xF8BD 0x000A      LDRH     R0,[SP, #+10]
   \   0000001C   0x28F6             CMP      R0,#+246
   \   0000001E   0xDB08             BLT.N    ??MBS_FC21_FileWr_1
   1575                  pch->Err = MODBUS_ERR_FC21_01;
   \                     ??MBS_FC21_FileWr_0: (+1)
   \   00000020   0xF640 0x0035      MOVW     R0,#+2101
   \   00000024   0x82E0             STRH     R0,[R4, #+22]
   1576                  MBS_ErrRespSet(pch,
   1577                                 MODBUS_ERR_ILLEGAL_DATA_QTY);
   \   00000026   0x2103             MOVS     R1,#+3
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0x.... 0x....      BL       MBS_ErrRespSet
   1578                  return (DEF_TRUE);                                                 /* Tell caller that we need to send a response              */
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0xE09A             B.N      ??MBS_FC21_FileWr_2
   1579              }
   1580              cmd_type    =  pch->RxFrameData[3];                                    /* Get the reference type                                   */
   \                     ??MBS_FC21_FileWr_1: (+1)
   \   00000032   0xF894 0x0247      LDRB     R0,[R4, #+583]
   \   00000036   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1581              file_nbr    = ((CPU_INT16U)pch->RxFrameData[4] << 8)                   /* Get the file number                                      */
   1582                          +  (CPU_INT16U)pch->RxFrameData[5];
   \   0000003A   0xF894 0x0248      LDRB     R0,[R4, #+584]
   \   0000003E   0xF894 0x1249      LDRB     R1,[R4, #+585]
   \   00000042   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000046   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   1583              record_nbr  = ((CPU_INT16U)pch->RxFrameData[6] << 8)                   /* Get the record number                                    */
   1584                          + (CPU_INT16U)pch->RxFrameData[7];
   \   0000004A   0xF894 0x024A      LDRB     R0,[R4, #+586]
   \   0000004E   0xF894 0x124B      LDRB     R1,[R4, #+587]
   \   00000052   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000056   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   1585              record_len  = ((CPU_INT16U)pch->RxFrameData[8] << 8)                   /* Get the record length                                    */
   1586                          + (CPU_INT16U)pch->RxFrameData[9];
   \   0000005A   0xF894 0x024C      LDRB     R0,[R4, #+588]
   \   0000005E   0xF894 0x124D      LDRB     R1,[R4, #+589]
   \   00000062   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000066   0x4680             MOV      R8,R0
   1587              prx_data    = &pch->RxFrameData[10];                                   /* Point to first data byte                                 */
   \   00000068   0xF204 0x204E      ADDW     R0,R4,#+590
   \   0000006C   0x0005             MOVS     R5,R0
   1588          
   1589              if (cmd_type == 6) {                                                   /* File type should ALWAYS be 6.                            */
   \   0000006E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000072   0x2806             CMP      R0,#+6
   \   00000074   0xD14B             BNE.N    ??MBS_FC21_FileWr_3
   1590                  ix = 0;                                                            /* Initialize the index into the record                     */
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x4683             MOV      R11,R0
   1591                  while (record_len > 0) {
   \                     ??MBS_FC21_FileWr_4: (+1)
   \   0000007A   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000007E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000082   0xD04B             BEQ.N    ??MBS_FC21_FileWr_5
   1592                      reg_val  = ((CPU_INT16U)*prx_data++ << 8) & 0xFF00;            /* Get data to write to file                                */
   \   00000084   0x7828             LDRB     R0,[R5, #+0]
   \   00000086   0x0200             LSLS     R0,R0,#+8
   \   00000088   0x4682             MOV      R10,R0
   \   0000008A   0x1C6D             ADDS     R5,R5,#+1
   1593                      reg_val |=  (CPU_INT16U)*prx_data++ & 0x00FF;
   \   0000008C   0x7828             LDRB     R0,[R5, #+0]
   \   0000008E   0xEA50 0x0A0A      ORRS     R10,R0,R10
   \   00000092   0x1C6D             ADDS     R5,R5,#+1
   1594                      MB_FileWr(file_nbr,                                            /* Write one value to the file                              */
   1595                                record_nbr,
   1596                                ix,
   1597                                record_len,
   1598                                reg_val,
   1599                                &err);
   \   00000094   0xA803             ADD      R0,SP,#+12
   \   00000096   0x9001             STR      R0,[SP, #+4]
   \   00000098   0x4650             MOV      R0,R10
   \   0000009A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0x4643             MOV      R3,R8
   \   000000A0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A2   0x465A             MOV      R2,R11
   \   000000A4   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   000000A6   0xF8BD 0x100E      LDRH     R1,[SP, #+14]
   \   000000AA   0xF8BD 0x0010      LDRH     R0,[SP, #+16]
   \   000000AE   0x.... 0x....      BL       MB_FileWr
   1600                      switch (err) {
   \   000000B2   0xF8BD 0x000C      LDRH     R0,[SP, #+12]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD006             BEQ.N    ??MBS_FC21_FileWr_6
   \   000000BA   0xF640 0x71A1      MOVW     R1,#+4001
   \   000000BE   0x1A40             SUBS     R0,R0,R1
   \   000000C0   0xD00A             BEQ.N    ??MBS_FC21_FileWr_7
   \   000000C2   0x1E40             SUBS     R0,R0,#+1
   \   000000C4   0xD011             BEQ.N    ??MBS_FC21_FileWr_8
   \   000000C6   0xE019             B.N      ??MBS_FC21_FileWr_9
   1601                          case MODBUS_ERR_NONE:
   1602                               pch->WrCtr++;
   \                     ??MBS_FC21_FileWr_6: (+1)
   \   000000C8   0x6860             LDR      R0,[R4, #+4]
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \   000000CC   0x6060             STR      R0,[R4, #+4]
   1603                               break;
   1604          
   1605                          case MODBUS_ERR_FILE:
   1606                               pch->Err = MODBUS_ERR_FC21_02;
   1607                               MBS_ErrRespSet(pch,
   1608                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1609                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1610          
   1611                          case MODBUS_ERR_RECORD:
   1612                               pch->Err = MODBUS_ERR_FC21_03;
   1613                               MBS_ErrRespSet(pch,
   1614                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1615                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1616          
   1617                          case MODBUS_ERR_IX:
   1618                          default:
   1619                               pch->Err = MODBUS_ERR_FC21_04;
   1620                               MBS_ErrRespSet(pch,
   1621                                              MODBUS_ERR_ILLEGAL_DATA_ADDR);
   1622                               return (DEF_TRUE);                                    /* Tell caller that we need to send a response              */
   1623                      }
   1624                      ix++;
   \   000000CE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1625                      record_len--;
   \   000000D2   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   000000D6   0xE7D0             B.N      ??MBS_FC21_FileWr_4
   \                     ??MBS_FC21_FileWr_7: (+1)
   \   000000D8   0xF640 0x0036      MOVW     R0,#+2102
   \   000000DC   0x82E0             STRH     R0,[R4, #+22]
   \   000000DE   0x2102             MOVS     R1,#+2
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000E6   0x2001             MOVS     R0,#+1
   \   000000E8   0xE03E             B.N      ??MBS_FC21_FileWr_2
   \                     ??MBS_FC21_FileWr_8: (+1)
   \   000000EA   0xF640 0x0037      MOVW     R0,#+2103
   \   000000EE   0x82E0             STRH     R0,[R4, #+22]
   \   000000F0   0x2102             MOVS     R1,#+2
   \   000000F2   0x0020             MOVS     R0,R4
   \   000000F4   0x.... 0x....      BL       MBS_ErrRespSet
   \   000000F8   0x2001             MOVS     R0,#+1
   \   000000FA   0xE035             B.N      ??MBS_FC21_FileWr_2
   \                     ??MBS_FC21_FileWr_9: (+1)
   \   000000FC   0xF640 0x0038      MOVW     R0,#+2104
   \   00000100   0x82E0             STRH     R0,[R4, #+22]
   \   00000102   0x2102             MOVS     R1,#+2
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       MBS_ErrRespSet
   \   0000010A   0x2001             MOVS     R0,#+1
   \   0000010C   0xE02C             B.N      ??MBS_FC21_FileWr_2
   1626                  }
   1627              } else {
   1628                  pch->Err = MODBUS_ERR_FC21_05;
   \                     ??MBS_FC21_FileWr_3: (+1)
   \   0000010E   0xF640 0x0039      MOVW     R0,#+2105
   \   00000112   0x82E0             STRH     R0,[R4, #+22]
   1629                  MBS_ErrRespSet(pch,
   1630                                 MODBUS_ERR_ILLEGAL_DATA_ADDR);
   \   00000114   0x2102             MOVS     R1,#+2
   \   00000116   0x0020             MOVS     R0,R4
   \   00000118   0x.... 0x....      BL       MBS_ErrRespSet
   1631              }
   1632              record_len = ((CPU_INT16U)pch->RxFrameData[8] << 8) + (CPU_INT16U)pch->RxFrameData[9];    /* Get the record length                 */
   \                     ??MBS_FC21_FileWr_5: (+1)
   \   0000011C   0xF894 0x024C      LDRB     R0,[R4, #+588]
   \   00000120   0xF894 0x124D      LDRB     R1,[R4, #+589]
   \   00000124   0xEB11 0x2000      ADDS     R0,R1,R0, LSL #+8
   \   00000128   0x4680             MOV      R8,R0
   1633              pcmd       = &pch->RxFrameData[0];
   \   0000012A   0xF514 0x7011      ADDS     R0,R4,#+580
   \   0000012E   0x0006             MOVS     R6,R0
   1634              presp      = &pch->TxFrameData[0];                                     /* Point to first location in response buffer               */
   \   00000130   0xF204 0x304E      ADDW     R0,R4,#+846
   \   00000134   0x0007             MOVS     R7,R0
   1635              max        = (record_len * 2) + 9;
   \   00000136   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   0000013A   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   0000013E   0x3009             ADDS     R0,R0,#+9
   \   00000140   0x4681             MOV      R9,R0
   1636              for (ix = 0; ix < max; ix++) {                                         /* Copy the request into the transmit packet                */
   \   00000142   0x2000             MOVS     R0,#+0
   \   00000144   0x4683             MOV      R11,R0
   \                     ??MBS_FC21_FileWr_10: (+1)
   \   00000146   0x4648             MOV      R0,R9
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0xFA1F 0xFB8B      UXTH     R11,R11          ;; ZeroExt  R11,R11,#+16,#+16
   \   0000014E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000150   0x4583             CMP      R11,R0
   \   00000152   0xD206             BCS.N    ??MBS_FC21_FileWr_11
   1637                  *presp++ = *pcmd++;
   \   00000154   0x7830             LDRB     R0,[R6, #+0]
   \   00000156   0x7038             STRB     R0,[R7, #+0]
   \   00000158   0x1C76             ADDS     R6,R6,#+1
   \   0000015A   0x1C7F             ADDS     R7,R7,#+1
   1638              }
   \   0000015C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \   00000160   0xE7F1             B.N      ??MBS_FC21_FileWr_10
   1639              pch->Err = MODBUS_ERR_NONE;
   \                     ??MBS_FC21_FileWr_11: (+1)
   \   00000162   0x2000             MOVS     R0,#+0
   \   00000164   0x82E0             STRH     R0,[R4, #+22]
   1640              return (DEF_TRUE);                                                     /* Tell caller that we need to send a response              */
   \   00000166   0x2001             MOVS     R0,#+1
   \                     ??MBS_FC21_FileWr_2: (+1)
   \   00000168   0xB005             ADD      SP,SP,#+20
   \   0000016A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1641          }
   1642          #endif
   1643          #endif
   1644          
   1645          
   1646          /*******************************************************************************
   1647          *                                      READ DEVICE ID
   1648          *
   1649          * Description : Obtains the contents of the devide ID registers.
   1650          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1651          *
   1652          * Return(s)   : TRUE      If a response needs to be sent
   1653          *               FALSE     If not
   1654          *******************************************************************************/
   1655          
   1656          #if MODBUS_CFG_SLAVE_EN > 0
   1657          #if MODBUS_FC43_EN  > 0
   1658          static  CPU_BOOLEAN  MBS_FC43_readDeviceID (MODBUS_CH  *pch)
   1659          {
   1660              CPU_INT08U    *presp;
   1661              CPU_INT16U     err;
   1662              CPU_INT16U     reg;
   1663              CPU_INT16U     nbr_regs;
   1664              CPU_INT16U     nbr_bytes;
   1665              CPU_INT16U     reg_val_16;
   1666          #if MODBUS_FP_EN > 0
   1667              CPU_INT08U     ix;
   1668              CPU_FP32       reg_val_fp;
   1669              CPU_INT08U    *pfp;
   1670          #endif
   1671          
   1672          /* Nbr of data bytes must be 3. */
   1673              if (pch->RxFrameNDataBytes != 3)
   1674              {
   1675                  return (DEF_FALSE);
   1676              }
   1677          
   1678              return(DEF_FALSE);// TODO REMOVE THIS ONCE CODE IS IMPLEMENTED
   1679          // SE TODO implement device ID code
   1680          
   1681              // check for MEI type
   1682          
   1683              // check Object ID
   1684          
   1685              // validate ID category
   1686          
   1687              // setup reply
   1688          
   1689              //1st 4 byte are same as request
   1690          
   1691              // build packect based on id category supported
   1692          }
   1693          #endif
   1694          #endif
   1695          
   1696          
   1697          /*******************************************************************************
   1698          *                                      SCATTERED READ
   1699          *
   1700          * Description : Obtains the contents of various registers.
   1701          * Argument(s) : pch       Is a pointer to the Modbus channel's data structure.
   1702          *
   1703          * Return(s)   : TRUE      If a response needs to be sent
   1704          *               FALSE     If not
   1705          *******************************************************************************/
   1706          
   1707          #if MODBUS_CFG_SLAVE_EN > 0
   1708          #if MODBUS_FC100_EN  > 0
   1709          static  CPU_BOOLEAN  MBS_FC100_scatteredRead (MODBUS_CH  *pch)
   1710          {
   1711              CPU_INT08U    *presp;
   1712              CPU_INT16U     err;
   1713              CPU_INT16U     reg;
   1714              CPU_INT16U     nbr_regs;
   1715              CPU_INT16U     nbr_bytes;
   1716              CPU_INT16U     reg_val_16;
   1717          #if MODBUS_FP_EN > 0
   1718              CPU_INT08U     ix;
   1719              CPU_FP32       reg_val_fp;
   1720              CPU_INT08U    *pfp;
   1721          #endif
   1722          
   1723          /* Nbr of data bytes must be Query data length + 5. */
   1724              if (pch->RxFrameNDataBytes != pch->RxFrameData[2] + MBS_FC100_DATA_BYTES )
   1725              {
   1726                  return (DEF_FALSE);
   1727              }
   1728          
   1729              return(DEF_FALSE);// TODO REMOVE THIS ONCE CODE IS IMPLEMENTED
   1730          
   1731          
   1732              // check for max number of reg
   1733          
   1734          
   1735          
   1736              // setup reply
   1737          
   1738              //1st 4 byte are same as request
   1739          
   1740              // build packect
   1741          }
   1742          #endif
   1743          #endif
   1744          
   1745          /*$PAGE*/
   1746          /*
   1747          *********************************************************************************************************
   1748          *                                            MBS_StatInit()
   1749          *
   1750          * Description : This function is used to initialize/reset the MODBUS statistics/communications counters.
   1751          *
   1752          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1753          *
   1754          * Return(s)   : none.
   1755          *
   1756          * Caller(s)   : MB_Init()
   1757          *               MBS_FC08_Loopback()
   1758          *
   1759          * Note(s)     : none.
   1760          *********************************************************************************************************
   1761          */
   1762          
   1763          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1764              (MODBUS_CFG_FC08_EN  == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1765          void  MBS_StatInit (MODBUS_CH  *pch)
   1766          {
   1767              pch->StatMsgCtr      = 0;                       /* Initialize all MODBUS event counters.                     */
   \                     MBS_StatInit: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x83C1             STRH     R1,[R0, #+30]
   1768              pch->StatCRCErrCtr   = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8401             STRH     R1,[R0, #+32]
   1769              pch->StatExceptCtr   = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8441             STRH     R1,[R0, #+34]
   1770              pch->StatSlaveMsgCtr = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x8481             STRH     R1,[R0, #+36]
   1771              pch->StatNoRespCtr   = 0;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x84C1             STRH     R1,[R0, #+38]
   1772          }
   \   00000014   0x4770             BX       LR               ;; return
   1773          #endif
   1774          
   1775          /*
   1776          *********************************************************************************************************
   1777          *                                           MBS_RxTask()
   1778          *
   1779          * Description : Handle either Modbus ASCII or Modbus RTU received packets.
   1780          *
   1781          * Argument(s) : ch       Specifies the Modbus channel that needs servicing.
   1782          *
   1783          * Return(s)   : none.
   1784          *
   1785          * Caller(s)   : MB_RxTask()
   1786          *
   1787          * Note(s)     : none.
   1788          *********************************************************************************************************
   1789          */
   1790          
   1791          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1792          void  MBS_RxTask (MODBUS_CH *pch)
   1793          {
   \                     MBS_RxTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1794              if (pch != (MODBUS_CH *)0) {
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD005             BEQ.N    ??MBS_RxTask_0
   1795          #if (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
   1796                  if (pch->Mode == MODBUS_MODE_ASCII) {
   1797                      MBS_ASCII_Task(pch);
   1798                  }
   1799          #endif
   1800          
   1801          #if (MODBUS_CFG_RTU_EN == DEF_ENABLED)
   1802                  if (pch->Mode == MODBUS_MODE_RTU) {
   \   00000008   0x7CE0             LDRB     R0,[R4, #+19]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD102             BNE.N    ??MBS_RxTask_0
   1803                      MBS_RTU_Task(pch);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x.... 0x....      BL       MBS_RTU_Task
   1804                  }
   1805          #endif
   1806              }
   1807          }
   \                     ??MBS_RxTask_0: (+1)
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
   1808          #endif
   1809          
   1810          /*$PAGE*/
   1811          /*
   1812          *********************************************************************************************************
   1813          *                                           MBS_ASCII_Task()
   1814          *
   1815          * Description : Received a packet that should be encoded for Modbus ASCII mode.  Process request.
   1816          *
   1817          * Argument(s) : pch         Is a pointer to the Modbus channel's data structure.
   1818          *
   1819          * Return(s)   : none.
   1820          *
   1821          * Caller(s)   : MBS_RxTask()
   1822          *
   1823          * Note(s)     : none.
   1824          *********************************************************************************************************
   1825          */
   1826          
   1827          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1828              (MODBUS_CFG_ASCII_EN == DEF_ENABLED)
   1829          static  void  MBS_ASCII_Task (MODBUS_CH  *pch)
   1830          {
   1831              CPU_BOOLEAN   ok;
   1832              CPU_INT16U    calc_lrc;                               /* Used for LRC                                                    */
   1833              CPU_BOOLEAN   send_reply;
   1834          
   1835          
   1836              pch->StatMsgCtr++;
   1837              if (pch->RxBufByteCtr >= MODBUS_ASCII_MIN_MSG_SIZE) {
   1838                  ok = MB_ASCII_Rx(pch);                            /* Extract received command from .RxBuf[] & move to .RxFrameData[] */
   1839                  if (ok == DEF_TRUE) {
   1840                      calc_lrc = MB_ASCII_RxCalcLRC(pch);           /* Calculate LRC on received ASCII packet                          */
   1841                      if (calc_lrc != pch->RxFrameCRC) {            /* If sum of all data plus received LRC is not the same            */
   1842                          pch->StatCRCErrCtr++;                     /* then the frame was not received properly.                       */
   1843                          pch->StatNoRespCtr++;
   1844                          //COM_incDiaCtr(COM_BADCRC);
   1845                          //COM_incDiaCtr(COM_TIMEOUT);
   1846                      } else {
   1847                          send_reply = MBS_FCxx_Handler(pch);       /* Execute received command and formulate a response               */
   1848                          if (send_reply == DEF_TRUE) {
   1849                              MB_ASCII_Tx(pch);                     /* Send back reply.                                                */
   1850                          } else {
   1851                              pch->StatNoRespCtr++;
   1852                              //COM_incDiaCtr(COM_TIMEOUT);
   1853                          }
   1854                      }
   1855                  } else {
   1856                      pch->StatNoRespCtr++;
   1857                      //COM_incDiaCtr(COM_TIMEOUT);
   1858                  }
   1859              }
   1860              pch->RxBufByteCtr = 0;
   1861              pch->RxBufPtr     = &pch->RxBuf[0];
   1862          }
   1863          #endif
   1864          
   1865          
   1866          
   1867          /*$PAGE*/
   1868          /*
   1869          *********************************************************************************************************
   1870          *                                            MBS_RTU_Task()
   1871          *
   1872          * Description : This function processes a packet received on the Modbus channel assuming that it's an RTU
   1873          *               packet.
   1874          *
   1875          * Argument(s) : pch      Is a pointer to the Modbus channel's data structure.
   1876          *
   1877          * Return(s)   : none.
   1878          *
   1879          * Caller(s)   : MBS_RTU_Task().
   1880          *
   1881          * Note(s)     : none.
   1882          *********************************************************************************************************
   1883          */
   1884          
   1885          #if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1886              (MODBUS_CFG_RTU_EN   == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1887          static  void  MBS_RTU_Task (MODBUS_CH  *pch)
   1888          {
   \                     MBS_RTU_Task: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   1889              CPU_BOOLEAN     ok;
   1890              CPU_INT16U      calc_crc;                            /* Used for CRC                                                    */
   1891              CPU_BOOLEAN     send_reply;
   1892              OS_ERR          err;
   1893          
   1894              pch->StatMsgCtr++;
   \   00000006   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x83E0             STRH     R0,[R4, #+30]
   1895              if (pch->RxBufByteCtr >= MODBUS_RTU_MIN_MSG_SIZE) {
   \   0000000C   0x8E20             LDRH     R0,[R4, #+48]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xDB71             BLT.N    ??MBS_RTU_Task_0
   1896                   /***********************************************
   1897                  * 描述： 判断是否从TAX箱端口接收，TAX特殊处理。进来后直接退出。
   1898                  */
   1899                  if ( sCtrl.DevTax.pch == pch ) {
   \   00000012   0x....             LDR.N    R0,??DataTable0
   \   00000014   0xF8D0 0x07E3      LDR      R0,[R0, #+2019]
   \   00000018   0x42A0             CMP      R0,R4
   \   0000001A   0xD10B             BNE.N    ??MBS_RTU_Task_1
   1900                      send_reply = TAX_FCxx_Handler(pch);
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       TAX_FCxx_Handler
   \   00000022   0x0007             MOVS     R7,R0
   1901                       
   1902                      pch->RTU_TimeoutEn  = DEF_TRUE;                      // 重新启动超时（无名沈添加）
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7720             STRB     R0,[R4, #+28]
   1903                      pch->RxBufByteCtr   = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x8620             STRH     R0,[R4, #+48]
   1904                      pch->RxBufPtr       = &pch->RxBuf[0];
   \   0000002C   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000030   0x6360             STR      R0,[R4, #+52]
   1905                      goto exit;
   \   00000032   0xE067             B.N      ??MBS_RTU_Task_2
   1906                  }       
   1907                  
   1908                  CPU_SR_ALLOC();
   \                     ??MBS_RTU_Task_1: (+1)
   \   00000034   0xF05F 0x0800      MOVS     R8,#+0
   1909              
   1910                  CPU_CRITICAL_ENTER();
   \   00000038   0x.... 0x....      BL       CPU_SR_Save
   \   0000003C   0x4680             MOV      R8,R0
   \   0000003E   0x.... 0x....      BL       CPU_IntDisMeasStart
   1911                  //redmorningcn  从move1位置。取数据长度。
   1912                  pch->RxBufByteCnt   = pch->RxBufByteCtr; 
   \   00000042   0x8E20             LDRH     R0,[R4, #+48]
   \   00000044   0x8660             STRH     R0,[R4, #+50]
   1913                  //redmorningcn  MB_RTU_Rx 最后两字节没取完整。在此补充完整。
   1914                  pch->RxFrameData[pch->RxBufByteCnt-2] = pch->RxBuf[pch->RxBufByteCnt-2];
   \   00000046   0x8E60             LDRH     R0,[R4, #+50]
   \   00000048   0x1900             ADDS     R0,R0,R4
   \   0000004A   0xF890 0x0036      LDRB     R0,[R0, #+54]
   \   0000004E   0x8E61             LDRH     R1,[R4, #+50]
   \   00000050   0x1909             ADDS     R1,R1,R4
   \   00000052   0xF881 0x0242      STRB     R0,[R1, #+578]
   1915                  pch->RxFrameData[pch->RxBufByteCnt-1] = pch->RxBuf[pch->RxBufByteCnt-1];
   \   00000056   0x8E60             LDRH     R0,[R4, #+50]
   \   00000058   0x1900             ADDS     R0,R0,R4
   \   0000005A   0xF890 0x0037      LDRB     R0,[R0, #+55]
   \   0000005E   0x8E61             LDRH     R1,[R4, #+50]
   \   00000060   0x1909             ADDS     R1,R1,R4
   \   00000062   0xF881 0x0243      STRB     R0,[R1, #+579]
   1916                  CPU_CRITICAL_EXIT();
   \   00000066   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   0000006A   0x4640             MOV      R0,R8
   \   0000006C   0x.... 0x....      BL       CPU_SR_Restore
   1917                  
   1918                  ok = MB_RTU_Rx(pch);                           /* Extract received command from .RxBuf[] & move to .RxFrameData[] */
   \   00000070   0x0020             MOVS     R0,R4
   \   00000072   0x.... 0x....      BL       MB_RTU_Rx
   \   00000076   0x0005             MOVS     R5,R0
   1919                  
   1920                  pch->RTU_TimeoutEn  = DEF_TRUE;  
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7720             STRB     R0,[R4, #+28]
   1921                  pch->RxBufByteCtr   = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x8620             STRH     R0,[R4, #+48]
   1922                  pch->RxBufPtr       = &pch->RxBuf[0];   
   \   00000080   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000084   0x6360             STR      R0,[R4, #+52]
   1923                      
   1924                  if (ok == DEF_TRUE) {
   \   00000086   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000088   0x2D01             CMP      R5,#+1
   \   0000008A   0xD13B             BNE.N    ??MBS_RTU_Task_2
   1925                      /***********************************************
   1926                      * 描述： 2015/12/07增加，用于非MODBBUS通信
   1927                      */
   1928          #if MB_NONMODBUS_EN == DEF_ENABLED
   1929                      if ( ( pch->NonModbusEn == DEF_ENABLED ) && 
   1930                         ( ( pch->RxFrameHead != 0 ) || 
   1931                           ( pch->RxFrameTail != 0 ) ) ) {
   \   0000008C   0xF894 0x0452      LDRB     R0,[R4, #+1106]
   \   00000090   0xF3C0 0x0040      UBFX     R0,R0,#+1,#+1
   \   00000094   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD00E             BEQ.N    ??MBS_RTU_Task_3
   \   0000009A   0xF8B4 0x034A      LDRH     R0,[R4, #+842]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD103             BNE.N    ??MBS_RTU_Task_4
   \   000000A2   0xF8B4 0x034C      LDRH     R0,[R4, #+844]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD006             BEQ.N    ??MBS_RTU_Task_3
   1932                            //redmorningcn 20170526   
   1933          //move1         pch->RxBufByteCnt   = pch->RxBufByteCtr;
   1934                                               
   1935                          send_reply = NMBS_FCxx_Handler(pch);
   \                     ??MBS_RTU_Task_4: (+1)
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       NMBS_FCxx_Handler
   \   000000B0   0x0007             MOVS     R7,R0
   1936                          if (send_reply == DEF_TRUE) {
   \   000000B2   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000B4   0x2F01             CMP      R7,#+1
   \   000000B6   0xD025             BEQ.N    ??MBS_RTU_Task_2
   1937                              goto exit;
   1938                          }              
   1939                      }
   1940                  next:
   1941          #endif
   1942                      /***********************************************
   1943                      * 描述： MODBUS RTU 从机数据处理
   1944                      */
   1945                      calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   \                     ??MBS_RTU_Task_3: (+1)
   \   000000B8   0x0020             MOVS     R0,R4
   \   000000BA   0x.... 0x....      BL       MB_RTU_RxCalcCRC
   \   000000BE   0x0006             MOVS     R6,R0
   1946                      if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   \   000000C0   0xF8B4 0x0346      LDRH     R0,[R4, #+838]
   \   000000C4   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   000000C6   0x4286             CMP      R6,R0
   \   000000C8   0xD006             BEQ.N    ??MBS_RTU_Task_5
   1947                          pch->StatCRCErrCtr++;                  /* then the frame is bad.                                          */
   \   000000CA   0x8C20             LDRH     R0,[R4, #+32]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x8420             STRH     R0,[R4, #+32]
   1948                          pch->StatNoRespCtr++;
   \   000000D0   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000D2   0x1C40             ADDS     R0,R0,#+1
   \   000000D4   0x84E0             STRH     R0,[R4, #+38]
   \   000000D6   0xE015             B.N      ??MBS_RTU_Task_2
   1949                          //COM_incDiaCtr(COM_BADCRC);
   1950                          //COM_incDiaCtr(COM_TIMEOUT);
   1951                      } else {
   1952                          send_reply = MBS_FCxx_Handler(pch);    /* Execute received command and formulate a response               */
   \                     ??MBS_RTU_Task_5: (+1)
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x.... 0x....      BL       MBS_FCxx_Handler
   \   000000DE   0x0007             MOVS     R7,R0
   1953                          if (send_reply == DEF_TRUE) {
   \   000000E0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E2   0x2F01             CMP      R7,#+1
   \   000000E4   0xD103             BNE.N    ??MBS_RTU_Task_6
   1954                              MB_RTU_Tx(pch);                    /* Send back reply.                                                */
   \   000000E6   0x0020             MOVS     R0,R4
   \   000000E8   0x.... 0x....      BL       MB_RTU_Tx
   \   000000EC   0xE00A             B.N      ??MBS_RTU_Task_2
   1955                          } else {
   1956                              pch->StatNoRespCtr++;
   \                     ??MBS_RTU_Task_6: (+1)
   \   000000EE   0x8CE0             LDRH     R0,[R4, #+38]
   \   000000F0   0x1C40             ADDS     R0,R0,#+1
   \   000000F2   0x84E0             STRH     R0,[R4, #+38]
   \   000000F4   0xE006             B.N      ??MBS_RTU_Task_2
   1957                              //COM_incDiaCtr(COM_TIMEOUT);
   1958                          }
   1959                      }
   1960                  }
   1961              }
   1962              else
   1963              {
   1964                  pch->RTU_TimeoutEn  = DEF_TRUE;                      // 重新启动超时（无名沈添加）
   \                     ??MBS_RTU_Task_0: (+1)
   \   000000F6   0x2001             MOVS     R0,#+1
   \   000000F8   0x7720             STRB     R0,[R4, #+28]
   1965                  pch->RxBufByteCtr   = 0;
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x8620             STRH     R0,[R4, #+48]
   1966                  pch->RxBufPtr       = &pch->RxBuf[0];
   \   000000FE   0xF114 0x0038      ADDS     R0,R4,#+56
   \   00000102   0x6360             STR      R0,[R4, #+52]
   1967              }
   1968              
   1969          exit:
   1970              //pch->RTU_TimeoutEn  = DEF_TRUE;                      // 重新启动超时（无名沈添加）
   1971              //pch->RxBufByteCtr   = 0;
   1972              //pch->RxBufPtr       = &pch->RxBuf[0];
   1973          }
   \                     ??MBS_RTU_Task_2: (+1)
   \   00000104   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     sCtrl
   1974          //
   1975          //#if (MODBUS_CFG_SLAVE_EN == DEF_ENABLED) && \
   1976          //    (MODBUS_CFG_RTU_EN   == DEF_ENABLED)
   1977          //static  void  MBS_RTU_Task (MODBUS_CH  *pch)
   1978          //{
   1979          //    CPU_BOOLEAN     ok;
   1980          //    CPU_INT16U      calc_crc;                            /* Used for CRC                                                    */
   1981          //    CPU_BOOLEAN     send_reply;
   1982          //    OS_ERR          err;
   1983          //
   1984          //    pch->StatMsgCtr++;
   1985          //    if (pch->RxBufByteCtr >= MODBUS_RTU_MIN_MSG_SIZE) {
   1986          //        ok = MB_RTU_Rx(pch);                           /* Extract received command from .RxBuf[] & move to .RxFrameData[] */
   1987          //        
   1988          //        //redmorningcn  MB_RTU_Rx 最后两字节没取完整。在此补充完整。
   1989          //        pch->RxFrameData[pch->RxBufByteCtr-2] = pch->RxBuf[pch->RxBufByteCtr-2];
   1990          //        pch->RxFrameData[pch->RxBufByteCtr-1] = pch->RxBuf[pch->RxBufByteCtr-1];
   1991          //        
   1992          //        //redmorningcn  从move1位置。取数据长度。
   1993          //         pch->RxBufByteCnt   = pch->RxBufByteCtr;    
   1994          //        //从最后移动到此处。数据复制完后，清空接收缓冲，就可以继续数据接收        
   1995          //        if(pch->RxBufByteCtr)                                   //有数据长度，才重启定时器(redmorningcn 20170526)
   1996          //        { 
   1997          //            //redmorningcn 注释 20170526
   1998          //            //pch->RTU_TimeoutEn  = DEF_TRUE;                      // 重新启动超时（无名沈添加）
   1999          //            pch->RxBufByteCtr   = 0;
   2000          //            pch->RxBufPtr       = &pch->RxBuf[0];
   2001          //        }       
   2002          //            
   2003          //        if (ok == DEF_TRUE) {
   2004          //            /***********************************************
   2005          //            * 描述： 2015/12/07增加，用于非MODBBUS通信
   2006          //            */
   2007          //#if MB_NONMODBUS_EN == DEF_ENABLED
   2008          //            if ( ( pch->NonModbusEn == DEF_ENABLED ) && 
   2009          //               ( ( pch->RxFrameHead != 0 ) || 
   2010          //                 ( pch->RxFrameTail != 0 ) ) ) {
   2011          //                  //redmorningcn 20170526   
   2012          ////move1         pch->RxBufByteCnt   = pch->RxBufByteCtr;
   2013          //                                     
   2014          //                send_reply = NMBS_FCxx_Handler(pch);
   2015          //                if (send_reply == DEF_TRUE) {
   2016          //                    goto exit;
   2017          //                }              
   2018          //            }
   2019          //        next:
   2020          //#endif
   2021          //            /***********************************************
   2022          //            * 描述： MODBUS RTU 从机数据处理
   2023          //            */
   2024          //            calc_crc = MB_RTU_RxCalcCRC(pch);          /* Do our own calculation of the CRC.                              */
   2025          //            if (calc_crc != pch->RxFrameCRC) {         /* If the calculated CRC does not match the CRC received,          */
   2026          //                pch->StatCRCErrCtr++;                  /* then the frame is bad.                                          */
   2027          //                pch->StatNoRespCtr++;
   2028          //                //COM_incDiaCtr(COM_BADCRC);
   2029          //                //COM_incDiaCtr(COM_TIMEOUT);
   2030          //            } else {
   2031          //                send_reply = MBS_FCxx_Handler(pch);    /* Execute received command and formulate a response               */
   2032          //                if (send_reply == DEF_TRUE) {
   2033          //                    MB_RTU_Tx(pch);                    /* Send back reply.                                                */
   2034          //                } else {
   2035          //                    pch->StatNoRespCtr++;
   2036          //                    //COM_incDiaCtr(COM_TIMEOUT);
   2037          //                }
   2038          //            }
   2039          //        }
   2040          //    }else{
   2041          //            if(pch->RxBufByteCtr)                               //有数据长度，才重启定时器(redmorningcn 20170526)
   2042          //            { 
   2043          //                //redmorningcn 注释 20170526
   2044          //                //pch->RTU_TimeoutEn  = DEF_TRUE;               // 重新启动超时（无名沈添加）
   2045          //                pch->RxBufByteCtr   = 0;
   2046          //                pch->RxBufPtr       = &pch->RxBuf[0];
   2047          //            }
   2048          //    }
   2049          //    //
   2050          //exit:
   2051          //    //移动位置
   2052          ////    if(pch->RxBufByteCtr)                                   //有数据长度，才重启定时器(redmorningcn 20170526)
   2053          ////    { 
   2054          ////        //redmorningcn 注释 20170526
   2055          ////        //pch->RTU_TimeoutEn  = DEF_TRUE;                      // 重新启动超时（无名沈添加）
   2056          ////        pch->RxBufByteCtr   = 0;
   2057          ////        pch->RxBufPtr       = &pch->RxBuf[0];
   2058          ////    }
   2059          //}
   2060          #endif
   2061          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MBS_ErrRespSet
      40   MBS_FC01_CoilRd
        40   -> MBS_ErrRespSet
        40   -> MB_CoilRd
      32   MBS_FC03_HoldingRegRd
        32   -> App_MB_RdNRegsHook
        32   -> MBS_ErrRespSet
        32   -> MB_HoldingRegRd
      40   MBS_FC05_CoilWr
        40   -> MBS_ErrRespSet
        40   -> MB_CoilWr
      40   MBS_FC06_HoldingRegWr
        40   -> MBS_ErrRespSet
        40   -> MB_HoldingRegWr
      16   MBS_FC08_Loopback
        16   -> MBS_ErrRespSet
        16   -> MBS_StatInit
      40   MBS_FC15_CoilWrMultiple
        40   -> MBS_ErrRespSet
        40   -> MB_CoilWr
      40   MBS_FC16_HoldingRegWrMultiple
        40   -> App_MB_WrNRegsHook
        40   -> MBS_ErrRespSet
        40   -> MB_HoldingRegWr
      48   MBS_FC20_FileRd
        48   -> MBS_ErrRespSet
        48   -> MB_FileRd
      56   MBS_FC21_FileWr
        56   -> MBS_ErrRespSet
        56   -> MB_FileWr
      16   MBS_FCxx_Handler
        16   -> MBS_ErrRespSet
        16   -> MBS_FC01_CoilRd
        16   -> MBS_FC03_HoldingRegRd
        16   -> MBS_FC05_CoilWr
        16   -> MBS_FC06_HoldingRegWr
        16   -> MBS_FC08_Loopback
        16   -> MBS_FC15_CoilWrMultiple
        16   -> MBS_FC16_HoldingRegWrMultiple
        16   -> MBS_FC20_FileRd
        16   -> MBS_FC21_FileWr
      24   MBS_RTU_Task
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> MBS_FCxx_Handler
        24   -> MB_RTU_Rx
        24   -> MB_RTU_RxCalcCRC
        24   -> MB_RTU_Tx
        24   -> NMBS_FCxx_Handler
        24   -> TAX_FCxx_Handler
       8   MBS_RxTask
         8   -> MBS_RTU_Task
       0   MBS_StatInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      38  MBS_ErrRespSet
     292  MBS_FC01_CoilRd
     286  MBS_FC03_HoldingRegRd
     200  MBS_FC05_CoilWr
     192  MBS_FC06_HoldingRegWr
     258  MBS_FC08_Loopback
     312  MBS_FC15_CoilWrMultiple
     376  MBS_FC16_HoldingRegWrMultiple
     360  MBS_FC20_FileRd
     366  MBS_FC21_FileWr
     302  MBS_FCxx_Handler
     264  MBS_RTU_Task
      22  MBS_RxTask
      22  MBS_StatInit

 
 3 294 bytes in section .text
 
 3 294 bytes of CODE memory

Errors: none
Warnings: 4
