###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       10/Aug/2017  10:56:47
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_pwm.c
#    Command line =  
#        "F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_pwm.c" -lCN
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List"
#        --diag_suppress Pa050 -o "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\" -I
#        "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\"
#        -I "F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\"
#        -I "F:\iar\NC136B-310 统计模块\Application\Library\csnr_package_deal\"
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_pwm.lst
#    Object file  =  
#        F:\iar\NC136B-310
#        统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_pwm.o
#
###############################################################################

F:\iar\NC136B-310 统计模块\Software\CSB\source\lpc17xx_pwm.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_pwm.c				2011-03-31
      3          *//**
      4          * @file		lpc17xx_pwm.c
      5          * @brief	Contains all functions support for PWM firmware library on LPC17xx
      6          * @version	2.1
      7          * @date		31. Mar. 2011
      8          * @author	NXP MCU SW Application Team
      9          *
     10          * Copyright(C) 2011, NXP Semiconductor
     11          * All rights reserved.
     12          *
     13          ***********************************************************************
     14          * Software that is described herein is for illustrative purposes only
     15          * which provides customers with programming information regarding the
     16          * products. This software is supplied "AS IS" without any warranties.
     17          * NXP Semiconductors assumes no responsibility or liability for the
     18          * use of the software, conveys no license or title under any patent,
     19          * copyright, or mask work right to the product. NXP Semiconductors
     20          * reserves the right to make changes in the software without
     21          * notification. NXP Semiconductors also make no representation or
     22          * warranty that such application will be suitable for the specified
     23          * use without further testing or modification.
     24          * Permission to use, copy, modify, and distribute this software and its
     25          * documentation is hereby granted, under NXP Semiconductors'
     26          * relevant copyright in the software, without fee, provided that it
     27          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     28          * copyright, permission, and disclaimer notice must appear in all copies of
     29          * this code.
     30          **********************************************************************/
     31          
     32          /* Peripheral group ----------------------------------------------------------- */
     33          /** @addtogroup PWM
     34           * @{
     35           */
     36          
     37          /* Includes ------------------------------------------------------------------- */
     38          #include "lpc17xx_pwm.h"
     39          #include "lpc17xx_clkpwr.h"
     40          
     41          /* If this source file built with example, the LPC17xx FW library configuration
     42           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     43           * otherwise the default FW library configuration file must be included instead
     44           */
     45          #ifdef __BUILD_WITH_EXAMPLE__
     46          #include "lpc17xx_libcfg.h"
     47          #else
     48          #include "lpc17xx_libcfg_default.h"
     49          #endif /* __BUILD_WITH_EXAMPLE__ */
     50          
     51          
     52          #ifdef _PWM
     53          
     54          
     55          /* Public Functions ----------------------------------------------------------- */
     56          /** @addtogroup PWM_Public_Functions
     57           * @{
     58           */
     59          
     60          
     61          /*********************************************************************//**
     62           * @brief 		Check whether specified interrupt flag in PWM is set or not
     63           * @param[in]	PWMx: PWM peripheral, should be LPC_PWM1
     64           * @param[in]	IntFlag: PWM interrupt flag, should be:
     65           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
     66           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
     67           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
     68           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
     69           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
     70           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
     71           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
     72           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
     73           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
     74           * @return 		New State of PWM interrupt flag (SET or RESET)
     75           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     76          IntStatus PWM_GetIntStatus(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
     77          {
   \                     PWM_GetIntStatus: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     78          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_GetIntStatus_0
   \   0000000E   0x214E             MOVS     R1,#+78
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
     79          	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
   \                     ??PWM_GetIntStatus_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD017             BEQ.N    ??PWM_GetIntStatus_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD015             BEQ.N    ??PWM_GetIntStatus_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD013             BEQ.N    ??PWM_GetIntStatus_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD011             BEQ.N    ??PWM_GetIntStatus_1
   \   00000028   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000002C   0xD00E             BEQ.N    ??PWM_GetIntStatus_1
   \   0000002E   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000032   0xD00B             BEQ.N    ??PWM_GetIntStatus_1
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD008             BEQ.N    ??PWM_GetIntStatus_1
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD006             BEQ.N    ??PWM_GetIntStatus_1
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD004             BEQ.N    ??PWM_GetIntStatus_1
   \   00000042   0x214F             MOVS     R1,#+79
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000048   0x.... 0x....      BL       check_failed
     80          
     81          	return ((PWMx->IR & IntFlag) ? SET : RESET);
   \                     ??PWM_GetIntStatus_1: (+1)
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x4228             TST      R0,R5
   \   00000050   0xD001             BEQ.N    ??PWM_GetIntStatus_2
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE000             B.N      ??PWM_GetIntStatus_3
   \                     ??PWM_GetIntStatus_2: (+1)
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetIntStatus_3: (+1)
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     82          }
     83          
     84          
     85          
     86          /*********************************************************************//**
     87           * @brief 		Clear specified PWM Interrupt pending
     88           * @param[in]	PWMx: PWM peripheral, should be LPC_PWM1
     89           * @param[in]	IntFlag: PWM interrupt flag, should be:
     90           * 				- PWM_INTSTAT_MR0: Interrupt flag for PWM match channel 0
     91           * 				- PWM_INTSTAT_MR1: Interrupt flag for PWM match channel 1
     92           * 				- PWM_INTSTAT_MR2: Interrupt flag for PWM match channel 2
     93           * 				- PWM_INTSTAT_MR3: Interrupt flag for PWM match channel 3
     94           * 				- PWM_INTSTAT_MR4: Interrupt flag for PWM match channel 4
     95           * 				- PWM_INTSTAT_MR5: Interrupt flag for PWM match channel 5
     96           * 				- PWM_INTSTAT_MR6: Interrupt flag for PWM match channel 6
     97           * 				- PWM_INTSTAT_CAP0: Interrupt flag for capture input 0
     98           * 				- PWM_INTSTAT_CAP1: Interrupt flag for capture input 1
     99           * @return 		None
    100           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    101          void PWM_ClearIntPending(LPC_PWM_TypeDef *PWMx, uint32_t IntFlag)
    102          {
   \                     PWM_ClearIntPending: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    103          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ClearIntPending_0
   \   0000000E   0x2167             MOVS     R1,#+103
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
    104          	CHECK_PARAM(PARAM_PWM_INTSTAT(IntFlag));
   \                     ??PWM_ClearIntPending_0: (+1)
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xD017             BEQ.N    ??PWM_ClearIntPending_1
   \   0000001C   0x2D02             CMP      R5,#+2
   \   0000001E   0xD015             BEQ.N    ??PWM_ClearIntPending_1
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD013             BEQ.N    ??PWM_ClearIntPending_1
   \   00000024   0x2D08             CMP      R5,#+8
   \   00000026   0xD011             BEQ.N    ??PWM_ClearIntPending_1
   \   00000028   0xF5B5 0x7F80      CMP      R5,#+256
   \   0000002C   0xD00E             BEQ.N    ??PWM_ClearIntPending_1
   \   0000002E   0xF5B5 0x6F80      CMP      R5,#+1024
   \   00000032   0xD00B             BEQ.N    ??PWM_ClearIntPending_1
   \   00000034   0xF5B5 0x7F00      CMP      R5,#+512
   \   00000038   0xD008             BEQ.N    ??PWM_ClearIntPending_1
   \   0000003A   0x2D10             CMP      R5,#+16
   \   0000003C   0xD006             BEQ.N    ??PWM_ClearIntPending_1
   \   0000003E   0x2D20             CMP      R5,#+32
   \   00000040   0xD004             BEQ.N    ??PWM_ClearIntPending_1
   \   00000042   0x2168             MOVS     R1,#+104
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000048   0x.... 0x....      BL       check_failed
    105          	PWMx->IR = IntFlag;
   \                     ??PWM_ClearIntPending_1: (+1)
   \   0000004C   0x6025             STR      R5,[R4, #+0]
    106          }
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    107          
    108          
    109          
    110          /*****************************************************************************//**
    111          * @brief		Fills each PWM_InitStruct member with its default value:
    112          * 				- If PWMCounterMode = PWM_MODE_TIMER:
    113          * 					+ PrescaleOption = PWM_TIMER_PRESCALE_USVAL
    114          * 					+ PrescaleValue = 1
    115          * 				- If PWMCounterMode = PWM_MODE_COUNTER:
    116          * 					+ CountInputSelect = PWM_COUNTER_PCAP1_0
    117          * 					+ CounterOption = PWM_COUNTER_RISING
    118          * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    119          * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    120          * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    121          * @param[in]	PWM_InitStruct Pointer to structure (PWM_TIMERCFG_Type or
    122          * 				 PWM_COUNTERCFG_Type) which will be initialized.
    123          * @return		None
    124          * Note: PWM_InitStruct pointer will be assigned to corresponding structure
    125          * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    126          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    127          void PWM_ConfigStructInit(uint8_t PWMTimerCounterMode, void *PWM_InitStruct)
    128          {
   \                     PWM_ConfigStructInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    129          	PWM_TIMERCFG_Type *pTimeCfg;
    130          	PWM_COUNTERCFG_Type *pCounterCfg;
    131          	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD007             BEQ.N    ??PWM_ConfigStructInit_0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x2C01             CMP      R4,#+1
   \   00000010   0xD004             BEQ.N    ??PWM_ConfigStructInit_0
   \   00000012   0x2183             MOVS     R1,#+131
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x.... 0x....      BL       check_failed
    132          
    133          	pTimeCfg = (PWM_TIMERCFG_Type *) PWM_InitStruct;
   \                     ??PWM_ConfigStructInit_0: (+1)
   \   0000001C   0x002E             MOVS     R6,R5
    134          	pCounterCfg = (PWM_COUNTERCFG_Type *) PWM_InitStruct;
   \   0000001E   0x002F             MOVS     R7,R5
    135          
    136          	if (PWMTimerCounterMode == PWM_MODE_TIMER )
   \   00000020   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD104             BNE.N    ??PWM_ConfigStructInit_1
    137          	{
    138          		pTimeCfg->PrescaleOption = PWM_TIMER_PRESCALE_USVAL;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7030             STRB     R0,[R6, #+0]
    139          		pTimeCfg->PrescaleValue = 1;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x6070             STR      R0,[R6, #+4]
   \   0000002E   0xE006             B.N      ??PWM_ConfigStructInit_2
    140          	}
    141          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_ConfigStructInit_1: (+1)
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x2C01             CMP      R4,#+1
   \   00000034   0xD103             BNE.N    ??PWM_ConfigStructInit_2
    142          	{
    143          		pCounterCfg->CountInputSelect = PWM_COUNTER_PCAP1_0;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x7078             STRB     R0,[R7, #+1]
    144          		pCounterCfg->CounterOption = PWM_COUNTER_RISING;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7038             STRB     R0,[R7, #+0]
    145          	}
    146          }
   \                     ??PWM_ConfigStructInit_2: (+1)
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    147          
    148          
    149          /*********************************************************************//**
    150           * @brief 		Initializes the PWMx peripheral corresponding to the specified
    151           *               parameters in the PWM_ConfigStruct.
    152           * @param[in]	PWMx PWM peripheral, should be LPC_PWM1
    153           * @param[in]	PWMTimerCounterMode Timer or Counter mode, should be:
    154           * 				- PWM_MODE_TIMER: Counter of PWM peripheral is in Timer mode
    155           * 				- PWM_MODE_COUNTER: Counter of PWM peripheral is in Counter mode
    156           * @param[in]	PWM_ConfigStruct Pointer to structure (PWM_TIMERCFG_Type or
    157           * 				 PWM_COUNTERCFG_Type) which will be initialized.
    158           * @return 		None
    159           * Note: PWM_ConfigStruct pointer will be assigned to corresponding structure
    160           * 		(PWM_TIMERCFG_Type or PWM_COUNTERCFG_Type) due to PWMTimerCounterMode.
    161           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    162          void PWM_Init(LPC_PWM_TypeDef *PWMx, uint32_t PWMTimerCounterMode, void *PWM_ConfigStruct)
    163          {
   \                     PWM_Init: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0006             MOVS     R6,R0
   \   00000006   0x000F             MOVS     R7,R1
   \   00000008   0x4691             MOV      R9,R2
    164          	PWM_TIMERCFG_Type *pTimeCfg;
    165          	PWM_COUNTERCFG_Type *pCounterCfg;
    166          	uint64_t clkdlycnt;
    167          
    168          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000E   0x4286             CMP      R6,R0
   \   00000010   0xD004             BEQ.N    ??PWM_Init_0
   \   00000012   0x21A8             MOVS     R1,#+168
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000018   0x.... 0x....      BL       check_failed
    169          	CHECK_PARAM(PARAM_PWM_TC_MODE(PWMTimerCounterMode));
   \                     ??PWM_Init_0: (+1)
   \   0000001C   0x2F00             CMP      R7,#+0
   \   0000001E   0xD006             BEQ.N    ??PWM_Init_1
   \   00000020   0x2F01             CMP      R7,#+1
   \   00000022   0xD004             BEQ.N    ??PWM_Init_1
   \   00000024   0x21A9             MOVS     R1,#+169
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002A   0x.... 0x....      BL       check_failed
    170          
    171          	pTimeCfg = (PWM_TIMERCFG_Type *)PWM_ConfigStruct;
   \                     ??PWM_Init_1: (+1)
   \   0000002E   0x46CA             MOV      R10,R9
    172          	pCounterCfg = (PWM_COUNTERCFG_Type *)PWM_ConfigStruct;
   \   00000030   0x46C8             MOV      R8,R9
    173          
    174          
    175          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, ENABLE);
   \   00000032   0x2101             MOVS     R1,#+1
   \   00000034   0x2040             MOVS     R0,#+64
   \   00000036   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    176          	CLKPWR_SetPCLKDiv (CLKPWR_PCLKSEL_PWM1, CLKPWR_PCLKSEL_CCLK_DIV_4);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x200C             MOVS     R0,#+12
   \   0000003E   0x.... 0x....      BL       CLKPWR_SetPCLKDiv
    177          	// Get peripheral clock of PWM1
    178          	clkdlycnt = (uint64_t) CLKPWR_GetPCLK (CLKPWR_PCLKSEL_PWM1);
   \   00000042   0x200C             MOVS     R0,#+12
   \   00000044   0x.... 0x....      BL       CLKPWR_GetPCLK
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x0004             MOVS     R4,R0
   \   0000004C   0x000D             MOVS     R5,R1
    179          
    180          
    181          	// Clear all interrupts pending
    182          	PWMx->IR = 0xFF & PWM_IR_BITMASK;
   \   0000004E   0x203F             MOVS     R0,#+63
   \   00000050   0x6030             STR      R0,[R6, #+0]
    183          	PWMx->TCR = 0x00;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x6070             STR      R0,[R6, #+4]
    184          	PWMx->CTCR = 0x00;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x6730             STR      R0,[R6, #+112]
    185          	PWMx->MCR = 0x00;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6170             STR      R0,[R6, #+20]
    186          	PWMx->CCR = 0x00;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x62B0             STR      R0,[R6, #+40]
    187          	PWMx->PCR = 0x00;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x64F0             STR      R0,[R6, #+76]
    188          	PWMx->LER = 0x00;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x6530             STR      R0,[R6, #+80]
    189          
    190          	if (PWMTimerCounterMode == PWM_MODE_TIMER)
   \   0000006A   0x2F00             CMP      R7,#+0
   \   0000006C   0xD128             BNE.N    ??PWM_Init_2
    191          	{
    192          		CHECK_PARAM(PARAM_PWM_TIMER_PRESCALE(pTimeCfg->PrescaleOption));
   \   0000006E   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD008             BEQ.N    ??PWM_Init_3
   \   00000076   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD004             BEQ.N    ??PWM_Init_3
   \   0000007E   0x21C0             MOVS     R1,#+192
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000084   0x.... 0x....      BL       check_failed
    193          
    194          		/* Absolute prescale value */
    195          		if (pTimeCfg->PrescaleOption == PWM_TIMER_PRESCALE_TICKVAL)
   \                     ??PWM_Init_3: (+1)
   \   00000088   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD104             BNE.N    ??PWM_Init_4
    196          		{
    197          			PWMx->PR   = pTimeCfg->PrescaleValue - 1;
   \   00000090   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   00000094   0x1E40             SUBS     R0,R0,#+1
   \   00000096   0x60F0             STR      R0,[R6, #+12]
   \   00000098   0xE03F             B.N      ??PWM_Init_5
    198          		}
    199          		/* uSecond prescale value */
    200          		else
    201          		{
    202          			clkdlycnt = (clkdlycnt * pTimeCfg->PrescaleValue) / 1000000;
   \                     ??PWM_Init_4: (+1)
   \   0000009A   0xF8DA 0x2004      LDR      R2,[R10, #+4]
   \   0000009E   0x2300             MOVS     R3,#+0
   \   000000A0   0xFBA2 0x0104      UMULL    R0,R1,R2,R4
   \   000000A4   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000000A8   0xFB03 0x1104      MLA      R1,R3,R4,R1
   \   000000AC   0x.... 0x....      LDR.W    R2,??DataTable14_2  ;; 0xf4240
   \   000000B0   0x2300             MOVS     R3,#+0
   \   000000B2   0x.... 0x....      BL       __aeabi_uldivmod
   \   000000B6   0x0004             MOVS     R4,R0
   \   000000B8   0x000D             MOVS     R5,R1
    203          			PWMx->PR = ((uint32_t) clkdlycnt) - 1;
   \   000000BA   0x1E60             SUBS     R0,R4,#+1
   \   000000BC   0x60F0             STR      R0,[R6, #+12]
   \   000000BE   0xE02C             B.N      ??PWM_Init_5
    204          		}
    205          
    206          	}
    207          	else if (PWMTimerCounterMode == PWM_MODE_COUNTER)
   \                     ??PWM_Init_2: (+1)
   \   000000C0   0x2F01             CMP      R7,#+1
   \   000000C2   0xD12A             BNE.N    ??PWM_Init_5
    208          	{
    209          		CHECK_PARAM(PARAM_PWM_COUNTER_INPUTSEL(pCounterCfg->CountInputSelect));
   \   000000C4   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD008             BEQ.N    ??PWM_Init_6
   \   000000CC   0xF898 0x0001      LDRB     R0,[R8, #+1]
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD004             BEQ.N    ??PWM_Init_6
   \   000000D4   0x21D1             MOVS     R1,#+209
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000000DA   0x.... 0x....      BL       check_failed
    210          		CHECK_PARAM(PARAM_PWM_COUNTER_EDGE(pCounterCfg->CounterOption));
   \                     ??PWM_Init_6: (+1)
   \   000000DE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000E2   0x2801             CMP      R0,#+1
   \   000000E4   0xD00C             BEQ.N    ??PWM_Init_7
   \   000000E6   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000EA   0x2802             CMP      R0,#+2
   \   000000EC   0xD008             BEQ.N    ??PWM_Init_7
   \   000000EE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   000000F2   0x2803             CMP      R0,#+3
   \   000000F4   0xD004             BEQ.N    ??PWM_Init_7
   \   000000F6   0x21D2             MOVS     R1,#+210
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   000000FC   0x.... 0x....      BL       check_failed
    211          
    212          		PWMx->CTCR |= (PWM_CTCR_MODE((uint32_t)pCounterCfg->CounterOption)) \
    213          						| (PWM_CTCR_SELECT_INPUT((uint32_t)pCounterCfg->CountInputSelect));
   \                     ??PWM_Init_7: (+1)
   \   00000100   0x6F30             LDR      R0,[R6, #+112]
   \   00000102   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000106   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   0000010A   0xF898 0x2001      LDRB     R2,[R8, #+1]
   \   0000010E   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000112   0xEA51 0x0182      ORRS     R1,R1,R2, LSL #+2
   \   00000116   0x4308             ORRS     R0,R1,R0
   \   00000118   0x6730             STR      R0,[R6, #+112]
    214          	}
    215          }
   \                     ??PWM_Init_5: (+1)
   \   0000011A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    216          
    217          /*********************************************************************//**
    218           * @brief		De-initializes the PWM peripheral registers to their
    219          *                  default reset values.
    220           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    221           * @return 		None
    222           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          void PWM_DeInit (LPC_PWM_TypeDef *PWMx)
    224          {
   \                     PWM_DeInit: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    225          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??PWM_DeInit_0
   \   0000000C   0x21E1             MOVS     R1,#+225
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000012   0x.... 0x....      BL       check_failed
    226          
    227          	// Disable PWM control (timer, counter and PWM)
    228          	PWMx->TCR = 0x00;
   \                     ??PWM_DeInit_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6060             STR      R0,[R4, #+4]
    229          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCPWM1, DISABLE);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x2040             MOVS     R0,#+64
   \   0000001E   0x.... 0x....      BL       CLKPWR_ConfigPPWR
    230          
    231          }
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    232          
    233          
    234          /*********************************************************************//**
    235           * @brief	 	Enable/Disable PWM peripheral
    236           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    237           * @param[in]	NewState	New State of this function, should be:
    238           * 							- ENABLE: Enable PWM peripheral
    239           * 							- DISABLE: Disable PWM peripheral
    240           * @return 		None
    241           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          void PWM_Cmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
    243          {
   \                     PWM_Cmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    244          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_Cmd_0
   \   0000000E   0x21F4             MOVS     R1,#+244
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
    245          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??PWM_Cmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD007             BEQ.N    ??PWM_Cmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D01             CMP      R5,#+1
   \   00000022   0xD004             BEQ.N    ??PWM_Cmd_1
   \   00000024   0x21F5             MOVS     R1,#+245
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002A   0x.... 0x....      BL       check_failed
    246          
    247          	if (NewState == ENABLE)
   \                     ??PWM_Cmd_1: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xD104             BNE.N    ??PWM_Cmd_2
    248          	{
    249          		PWMx->TCR	|=  PWM_TCR_PWM_ENABLE;
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   0000003A   0x6060             STR      R0,[R4, #+4]
   \   0000003C   0xE003             B.N      ??PWM_Cmd_3
    250          	}
    251          	else
    252          	{
    253          		PWMx->TCR &= (~PWM_TCR_PWM_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_Cmd_2: (+1)
   \   0000003E   0x6860             LDR      R0,[R4, #+4]
   \   00000040   0xF010 0x0003      ANDS     R0,R0,#0x3
   \   00000044   0x6060             STR      R0,[R4, #+4]
    254          	}
    255          }
   \                     ??PWM_Cmd_3: (+1)
   \   00000046   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    256          
    257          
    258          /*********************************************************************//**
    259           * @brief 		Enable/Disable Counter in PWM peripheral
    260           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    261           * @param[in]	NewState New State of this function, should be:
    262           * 							- ENABLE: Enable Counter in PWM peripheral
    263           * 							- DISABLE: Disable Counter in PWM peripheral
    264           * @return 		None
    265           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          void PWM_CounterCmd(LPC_PWM_TypeDef *PWMx, FunctionalState NewState)
    267          {
   \                     PWM_CounterCmd: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    268          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??PWM_CounterCmd_0
   \   0000000E   0xF44F 0x7186      MOV      R1,#+268
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000016   0x.... 0x....      BL       check_failed
    269          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
   \                     ??PWM_CounterCmd_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD008             BEQ.N    ??PWM_CounterCmd_1
   \   00000020   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000022   0x2D01             CMP      R5,#+1
   \   00000024   0xD005             BEQ.N    ??PWM_CounterCmd_1
   \   00000026   0xF240 0x110D      MOVW     R1,#+269
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002E   0x.... 0x....      BL       check_failed
    270          	if (NewState == ENABLE)
   \                     ??PWM_CounterCmd_1: (+1)
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x2D01             CMP      R5,#+1
   \   00000036   0xD104             BNE.N    ??PWM_CounterCmd_2
    271          	{
    272          		PWMx->TCR	|=  PWM_TCR_COUNTER_ENABLE;
   \   00000038   0x6860             LDR      R0,[R4, #+4]
   \   0000003A   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000003E   0x6060             STR      R0,[R4, #+4]
   \   00000040   0xE003             B.N      ??PWM_CounterCmd_3
    273          	}
    274          	else
    275          	{
    276          		PWMx->TCR &= (~PWM_TCR_COUNTER_ENABLE) & PWM_TCR_BITMASK;
   \                     ??PWM_CounterCmd_2: (+1)
   \   00000042   0x6860             LDR      R0,[R4, #+4]
   \   00000044   0xF010 0x000A      ANDS     R0,R0,#0xA
   \   00000048   0x6060             STR      R0,[R4, #+4]
    277          	}
    278          }
   \                     ??PWM_CounterCmd_3: (+1)
   \   0000004A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    279          
    280          
    281          /*********************************************************************//**
    282           * @brief 		Reset Counter in PWM peripheral
    283           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    284           * @return 		None
    285           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    286          void PWM_ResetCounter(LPC_PWM_TypeDef *PWMx)
    287          {
   \                     PWM_ResetCounter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    288          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD005             BEQ.N    ??PWM_ResetCounter_0
   \   0000000C   0xF44F 0x7190      MOV      R1,#+288
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
    289          	PWMx->TCR |= PWM_TCR_COUNTER_RESET;
   \                     ??PWM_ResetCounter_0: (+1)
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000001E   0x6060             STR      R0,[R4, #+4]
    290          	PWMx->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000020   0x6860             LDR      R0,[R4, #+4]
   \   00000022   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   00000026   0x6060             STR      R0,[R4, #+4]
    291          }
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    292          
    293          
    294          /*********************************************************************//**
    295           * @brief 		Configures match for PWM peripheral
    296           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    297           * @param[in]   PWM_MatchConfigStruct	Pointer to a PWM_MATCHCFG_Type structure
    298          *                    that contains the configuration information for the
    299          *                    specified PWM match function.
    300           * @return 		None
    301           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    302          void PWM_ConfigMatch(LPC_PWM_TypeDef *PWMx, PWM_MATCHCFG_Type *PWM_MatchConfigStruct)
    303          {
   \                     PWM_ConfigMatch: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    304          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??PWM_ConfigMatch_0
   \   0000000E   0xF44F 0x7198      MOV      R1,#+304
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000016   0x.... 0x....      BL       check_failed
    305          	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(PWM_MatchConfigStruct->MatchChannel));
   \                     ??PWM_ConfigMatch_0: (+1)
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x2807             CMP      R0,#+7
   \   0000001E   0xDB05             BLT.N    ??PWM_ConfigMatch_1
   \   00000020   0xF240 0x1131      MOVW     R1,#+305
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000028   0x.... 0x....      BL       check_failed
    306          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->IntOnMatch));
   \                     ??PWM_ConfigMatch_1: (+1)
   \   0000002C   0x7868             LDRB     R0,[R5, #+1]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD008             BEQ.N    ??PWM_ConfigMatch_2
   \   00000032   0x7868             LDRB     R0,[R5, #+1]
   \   00000034   0x2801             CMP      R0,#+1
   \   00000036   0xD005             BEQ.N    ??PWM_ConfigMatch_2
   \   00000038   0xF44F 0x7199      MOV      R1,#+306
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000040   0x.... 0x....      BL       check_failed
    307          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->ResetOnMatch));
   \                     ??PWM_ConfigMatch_2: (+1)
   \   00000044   0x78E8             LDRB     R0,[R5, #+3]
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD008             BEQ.N    ??PWM_ConfigMatch_3
   \   0000004A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004C   0x2801             CMP      R0,#+1
   \   0000004E   0xD005             BEQ.N    ??PWM_ConfigMatch_3
   \   00000050   0xF240 0x1133      MOVW     R1,#+307
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000058   0x.... 0x....      BL       check_failed
    308          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_MatchConfigStruct->StopOnMatch));
   \                     ??PWM_ConfigMatch_3: (+1)
   \   0000005C   0x78A8             LDRB     R0,[R5, #+2]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD008             BEQ.N    ??PWM_ConfigMatch_4
   \   00000062   0x78A8             LDRB     R0,[R5, #+2]
   \   00000064   0x2801             CMP      R0,#+1
   \   00000066   0xD005             BEQ.N    ??PWM_ConfigMatch_4
   \   00000068   0xF44F 0x719A      MOV      R1,#+308
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000070   0x.... 0x....      BL       check_failed
    309          
    310          	//interrupt on MRn
    311          	if (PWM_MatchConfigStruct->IntOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_4: (+1)
   \   00000074   0x7868             LDRB     R0,[R5, #+1]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD10D             BNE.N    ??PWM_ConfigMatch_5
    312          	{
    313          		PWMx->MCR |= PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   0000007A   0x6960             LDR      R0,[R4, #+20]
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x782A             LDRB     R2,[R5, #+0]
   \   00000080   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   00000084   0x782B             LDRB     R3,[R5, #+0]
   \   00000086   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   0000008A   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   0000008E   0x4091             LSLS     R1,R1,R2
   \   00000090   0x4308             ORRS     R0,R1,R0
   \   00000092   0x6160             STR      R0,[R4, #+20]
   \   00000094   0xE00F             B.N      ??PWM_ConfigMatch_6
    314          	}
    315          	else
    316          	{
    317          		PWMx->MCR &= (~PWM_MCR_INT_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    318          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_5: (+1)
   \   00000096   0x6960             LDR      R0,[R4, #+20]
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x782A             LDRB     R2,[R5, #+0]
   \   0000009C   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   000000A0   0x782B             LDRB     R3,[R5, #+0]
   \   000000A2   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000A6   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000AA   0x4091             LSLS     R1,R1,R2
   \   000000AC   0x43C9             MVNS     R1,R1
   \   000000AE   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   000000B0   0x0AC9             LSRS     R1,R1,#+11
   \   000000B2   0x4008             ANDS     R0,R1,R0
   \   000000B4   0x6160             STR      R0,[R4, #+20]
    319          	}
    320          
    321          	//reset on MRn
    322          	if (PWM_MatchConfigStruct->ResetOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_6: (+1)
   \   000000B6   0x78E8             LDRB     R0,[R5, #+3]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD10E             BNE.N    ??PWM_ConfigMatch_7
    323          	{
    324          		PWMx->MCR |= PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   000000BC   0x6960             LDR      R0,[R4, #+20]
   \   000000BE   0x2101             MOVS     R1,#+1
   \   000000C0   0x782A             LDRB     R2,[R5, #+0]
   \   000000C2   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   000000C6   0x782B             LDRB     R3,[R5, #+0]
   \   000000C8   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000CC   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000D0   0x1C52             ADDS     R2,R2,#+1
   \   000000D2   0x4091             LSLS     R1,R1,R2
   \   000000D4   0x4308             ORRS     R0,R1,R0
   \   000000D6   0x6160             STR      R0,[R4, #+20]
   \   000000D8   0xE010             B.N      ??PWM_ConfigMatch_8
    325          	}
    326          	else
    327          	{
    328          		PWMx->MCR &= (~PWM_MCR_RESET_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    329          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_7: (+1)
   \   000000DA   0x6960             LDR      R0,[R4, #+20]
   \   000000DC   0x2101             MOVS     R1,#+1
   \   000000DE   0x782A             LDRB     R2,[R5, #+0]
   \   000000E0   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   000000E4   0x782B             LDRB     R3,[R5, #+0]
   \   000000E6   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   000000EA   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000EE   0x1C52             ADDS     R2,R2,#+1
   \   000000F0   0x4091             LSLS     R1,R1,R2
   \   000000F2   0x43C9             MVNS     R1,R1
   \   000000F4   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   000000F6   0x0AC9             LSRS     R1,R1,#+11
   \   000000F8   0x4008             ANDS     R0,R1,R0
   \   000000FA   0x6160             STR      R0,[R4, #+20]
    330          	}
    331          
    332          	//stop on MRn
    333          	if (PWM_MatchConfigStruct->StopOnMatch == ENABLE)
   \                     ??PWM_ConfigMatch_8: (+1)
   \   000000FC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD10E             BNE.N    ??PWM_ConfigMatch_9
    334          	{
    335          		PWMx->MCR |= PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel);
   \   00000102   0x6960             LDR      R0,[R4, #+20]
   \   00000104   0x2101             MOVS     R1,#+1
   \   00000106   0x782A             LDRB     R2,[R5, #+0]
   \   00000108   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   0000010C   0x782B             LDRB     R3,[R5, #+0]
   \   0000010E   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000112   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   00000116   0x1C92             ADDS     R2,R2,#+2
   \   00000118   0x4091             LSLS     R1,R1,R2
   \   0000011A   0x4308             ORRS     R0,R1,R0
   \   0000011C   0x6160             STR      R0,[R4, #+20]
   \   0000011E   0xE010             B.N      ??PWM_ConfigMatch_10
    336          	}
    337          	else
    338          	{
    339          		PWMx->MCR &= (~PWM_MCR_STOP_ON_MATCH(PWM_MatchConfigStruct->MatchChannel)) \
    340          					& PWM_MCR_BITMASK;
   \                     ??PWM_ConfigMatch_9: (+1)
   \   00000120   0x6960             LDR      R0,[R4, #+20]
   \   00000122   0x2101             MOVS     R1,#+1
   \   00000124   0x782A             LDRB     R2,[R5, #+0]
   \   00000126   0xF012 0x0207      ANDS     R2,R2,#0x7
   \   0000012A   0x782B             LDRB     R3,[R5, #+0]
   \   0000012C   0xF013 0x0307      ANDS     R3,R3,#0x7
   \   00000130   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   00000134   0x1C92             ADDS     R2,R2,#+2
   \   00000136   0x4091             LSLS     R1,R1,R2
   \   00000138   0x43C9             MVNS     R1,R1
   \   0000013A   0x02C9             LSLS     R1,R1,#+11       ;; ZeroExtS R1,R1,#+11,#+11
   \   0000013C   0x0AC9             LSRS     R1,R1,#+11
   \   0000013E   0x4008             ANDS     R0,R1,R0
   \   00000140   0x6160             STR      R0,[R4, #+20]
    341          	}
    342          }
   \                     ??PWM_ConfigMatch_10: (+1)
   \   00000142   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    343          
    344          
    345          /*********************************************************************//**
    346           * @brief 		Configures capture input for PWM peripheral
    347           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    348           * @param[in]   PWM_CaptureConfigStruct	Pointer to a PWM_CAPTURECFG_Type structure
    349          *                    that contains the configuration information for the
    350          *                    specified PWM capture input function.
    351           * @return 		None
    352           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    353          void PWM_ConfigCapture(LPC_PWM_TypeDef *PWMx, PWM_CAPTURECFG_Type *PWM_CaptureConfigStruct)
    354          {
   \                     PWM_ConfigCapture: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    355          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD005             BEQ.N    ??PWM_ConfigCapture_0
   \   0000000E   0xF240 0x1163      MOVW     R1,#+355
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000016   0x.... 0x....      BL       check_failed
    356          	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(PWM_CaptureConfigStruct->CaptureChannel));
   \                     ??PWM_ConfigCapture_0: (+1)
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD008             BEQ.N    ??PWM_ConfigCapture_1
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD005             BEQ.N    ??PWM_ConfigCapture_1
   \   00000026   0xF44F 0x71B2      MOV      R1,#+356
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000002E   0x.... 0x....      BL       check_failed
    357          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->FallingEdge));
   \                     ??PWM_ConfigCapture_1: (+1)
   \   00000032   0x78A8             LDRB     R0,[R5, #+2]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD008             BEQ.N    ??PWM_ConfigCapture_2
   \   00000038   0x78A8             LDRB     R0,[R5, #+2]
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xD005             BEQ.N    ??PWM_ConfigCapture_2
   \   0000003E   0xF240 0x1165      MOVW     R1,#+357
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000046   0x.... 0x....      BL       check_failed
    358          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->IntOnCaption));
   \                     ??PWM_ConfigCapture_2: (+1)
   \   0000004A   0x78E8             LDRB     R0,[R5, #+3]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD008             BEQ.N    ??PWM_ConfigCapture_3
   \   00000050   0x78E8             LDRB     R0,[R5, #+3]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD005             BEQ.N    ??PWM_ConfigCapture_3
   \   00000056   0xF44F 0x71B3      MOV      R1,#+358
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   0000005E   0x.... 0x....      BL       check_failed
    359          	CHECK_PARAM(PARAM_FUNCTIONALSTATE(PWM_CaptureConfigStruct->RisingEdge));
   \                     ??PWM_ConfigCapture_3: (+1)
   \   00000062   0x7868             LDRB     R0,[R5, #+1]
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD008             BEQ.N    ??PWM_ConfigCapture_4
   \   00000068   0x7868             LDRB     R0,[R5, #+1]
   \   0000006A   0x2801             CMP      R0,#+1
   \   0000006C   0xD005             BEQ.N    ??PWM_ConfigCapture_4
   \   0000006E   0xF240 0x1167      MOVW     R1,#+359
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable14_1
   \   00000076   0x.... 0x....      BL       check_failed
    360          
    361          	if (PWM_CaptureConfigStruct->RisingEdge == ENABLE)
   \                     ??PWM_ConfigCapture_4: (+1)
   \   0000007A   0x7868             LDRB     R0,[R5, #+1]
   \   0000007C   0x2801             CMP      R0,#+1
   \   0000007E   0xD10D             BNE.N    ??PWM_ConfigCapture_5
    362          	{
    363          		PWMx->CCR |= PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel);
   \   00000080   0x6AA0             LDR      R0,[R4, #+40]
   \   00000082   0x2101             MOVS     R1,#+1
   \   00000084   0x782A             LDRB     R2,[R5, #+0]
   \   00000086   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   0000008A   0x782B             LDRB     R3,[R5, #+0]
   \   0000008C   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000090   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   00000094   0x4091             LSLS     R1,R1,R2
   \   00000096   0x4308             ORRS     R0,R1,R0
   \   00000098   0x62A0             STR      R0,[R4, #+40]
   \   0000009A   0xE00F             B.N      ??PWM_ConfigCapture_6
    364          	}
    365          	else
    366          	{
    367          		PWMx->CCR &= (~PWM_CCR_CAP_RISING(PWM_CaptureConfigStruct->CaptureChannel)) \
    368          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_5: (+1)
   \   0000009C   0x6AA0             LDR      R0,[R4, #+40]
   \   0000009E   0x2101             MOVS     R1,#+1
   \   000000A0   0x782A             LDRB     R2,[R5, #+0]
   \   000000A2   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   000000A6   0x782B             LDRB     R3,[R5, #+0]
   \   000000A8   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000AC   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000B0   0x4091             LSLS     R1,R1,R2
   \   000000B2   0x43C9             MVNS     R1,R1
   \   000000B4   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   000000B8   0x4008             ANDS     R0,R1,R0
   \   000000BA   0x62A0             STR      R0,[R4, #+40]
    369          	}
    370          
    371          	if (PWM_CaptureConfigStruct->FallingEdge == ENABLE)
   \                     ??PWM_ConfigCapture_6: (+1)
   \   000000BC   0x78A8             LDRB     R0,[R5, #+2]
   \   000000BE   0x2801             CMP      R0,#+1
   \   000000C0   0xD10E             BNE.N    ??PWM_ConfigCapture_7
    372          	{
    373          		PWMx->CCR |= PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel);
   \   000000C2   0x6AA0             LDR      R0,[R4, #+40]
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x782A             LDRB     R2,[R5, #+0]
   \   000000C8   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   000000CC   0x782B             LDRB     R3,[R5, #+0]
   \   000000CE   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000D2   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000D6   0x1C52             ADDS     R2,R2,#+1
   \   000000D8   0x4091             LSLS     R1,R1,R2
   \   000000DA   0x4308             ORRS     R0,R1,R0
   \   000000DC   0x62A0             STR      R0,[R4, #+40]
   \   000000DE   0xE010             B.N      ??PWM_ConfigCapture_8
    374          	}
    375          	else
    376          	{
    377          		PWMx->CCR &= (~PWM_CCR_CAP_FALLING(PWM_CaptureConfigStruct->CaptureChannel)) \
    378          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_7: (+1)
   \   000000E0   0x6AA0             LDR      R0,[R4, #+40]
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0x782A             LDRB     R2,[R5, #+0]
   \   000000E6   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   000000EA   0x782B             LDRB     R3,[R5, #+0]
   \   000000EC   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   000000F0   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   000000F4   0x1C52             ADDS     R2,R2,#+1
   \   000000F6   0x4091             LSLS     R1,R1,R2
   \   000000F8   0x43C9             MVNS     R1,R1
   \   000000FA   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   000000FE   0x4008             ANDS     R0,R1,R0
   \   00000100   0x62A0             STR      R0,[R4, #+40]
    379          	}
    380          
    381          	if (PWM_CaptureConfigStruct->IntOnCaption == ENABLE)
   \                     ??PWM_ConfigCapture_8: (+1)
   \   00000102   0x78E8             LDRB     R0,[R5, #+3]
   \   00000104   0x2801             CMP      R0,#+1
   \   00000106   0xD10E             BNE.N    ??PWM_ConfigCapture_9
    382          	{
    383          		PWMx->CCR |= PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel);
   \   00000108   0x6AA0             LDR      R0,[R4, #+40]
   \   0000010A   0x2101             MOVS     R1,#+1
   \   0000010C   0x782A             LDRB     R2,[R5, #+0]
   \   0000010E   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   00000112   0x782B             LDRB     R3,[R5, #+0]
   \   00000114   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000118   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   0000011C   0x1C92             ADDS     R2,R2,#+2
   \   0000011E   0x4091             LSLS     R1,R1,R2
   \   00000120   0x4308             ORRS     R0,R1,R0
   \   00000122   0x62A0             STR      R0,[R4, #+40]
   \   00000124   0xE010             B.N      ??PWM_ConfigCapture_10
    384          	}
    385          	else
    386          	{
    387          		PWMx->CCR &= (~PWM_CCR_INT_ON_CAP(PWM_CaptureConfigStruct->CaptureChannel)) \
    388          					& PWM_CCR_BITMASK;
   \                     ??PWM_ConfigCapture_9: (+1)
   \   00000126   0x6AA0             LDR      R0,[R4, #+40]
   \   00000128   0x2101             MOVS     R1,#+1
   \   0000012A   0x782A             LDRB     R2,[R5, #+0]
   \   0000012C   0xF012 0x0202      ANDS     R2,R2,#0x2
   \   00000130   0x782B             LDRB     R3,[R5, #+0]
   \   00000132   0xF013 0x0301      ANDS     R3,R3,#0x1
   \   00000136   0xEB13 0x0242      ADDS     R2,R3,R2, LSL #+1
   \   0000013A   0x1C92             ADDS     R2,R2,#+2
   \   0000013C   0x4091             LSLS     R1,R1,R2
   \   0000013E   0x43C9             MVNS     R1,R1
   \   00000140   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   00000144   0x4008             ANDS     R0,R1,R0
   \   00000146   0x62A0             STR      R0,[R4, #+40]
    389          	}
    390          }
   \                     ??PWM_ConfigCapture_10: (+1)
   \   00000148   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    391          
    392          
    393          /*********************************************************************//**
    394           * @brief 		Read value of capture register PWM peripheral
    395           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    396           * @param[in]	CaptureChannel: capture channel number, should be in
    397           * 				range 0 to 1
    398           * @return 		Value of capture register
    399           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    400          uint32_t PWM_GetCaptureValue(LPC_PWM_TypeDef *PWMx, uint8_t CaptureChannel)
    401          {
   \                     PWM_GetCaptureValue: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    402          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000006   0x....             LDR.N    R0,??DataTable14  ;; 0x40018000
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??PWM_GetCaptureValue_0
   \   0000000C   0xF44F 0x71C9      MOV      R1,#+402
   \   00000010   0x....             LDR.N    R0,??DataTable14_1
   \   00000012   0x.... 0x....      BL       check_failed
    403          	CHECK_PARAM(PARAM_PWM1_CAPTURE_CHANNEL(CaptureChannel));
   \                     ??PWM_GetCaptureValue_0: (+1)
   \   00000016   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD007             BEQ.N    ??PWM_GetCaptureValue_1
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD004             BEQ.N    ??PWM_GetCaptureValue_1
   \   00000022   0xF240 0x1193      MOVW     R1,#+403
   \   00000026   0x....             LDR.N    R0,??DataTable14_1
   \   00000028   0x.... 0x....      BL       check_failed
    404          
    405          	switch (CaptureChannel)
   \                     ??PWM_GetCaptureValue_1: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD002             BEQ.N    ??PWM_GetCaptureValue_2
   \   00000032   0x2D01             CMP      R5,#+1
   \   00000034   0xD002             BEQ.N    ??PWM_GetCaptureValue_3
   \   00000036   0xE003             B.N      ??PWM_GetCaptureValue_4
    406          	{
    407          	case 0:
    408          		return PWMx->CR0;
   \                     ??PWM_GetCaptureValue_2: (+1)
   \   00000038   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003A   0xE002             B.N      ??PWM_GetCaptureValue_5
    409          
    410          	case 1:
    411          		return PWMx->CR1;
   \                     ??PWM_GetCaptureValue_3: (+1)
   \   0000003C   0x6B20             LDR      R0,[R4, #+48]
   \   0000003E   0xE000             B.N      ??PWM_GetCaptureValue_5
    412          
    413          	default:
    414          		return (0);
   \                     ??PWM_GetCaptureValue_4: (+1)
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??PWM_GetCaptureValue_5: (+1)
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    415          	}
    416          }
    417          
    418          
    419          /********************************************************************//**
    420           * @brief 		Update value for each PWM channel with update type option
    421           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    422           * @param[in]	MatchChannel Match channel
    423           * @param[in]	MatchValue Match value
    424           * @param[in]	UpdateType Type of Update, should be:
    425           * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
    426           * 					this channel immediately
    427           * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
    428           * 					this channel on next reset by a PWM Match event.
    429           * @return		None
    430           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    431          void PWM_MatchUpdate(LPC_PWM_TypeDef *PWMx, uint8_t MatchChannel, \
    432          					uint32_t MatchValue, uint8_t UpdateType)
    433          {
   \                     PWM_MatchUpdate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x001F             MOVS     R7,R3
    434          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   0000000A   0x....             LDR.N    R0,??DataTable14  ;; 0x40018000
   \   0000000C   0x4284             CMP      R4,R0
   \   0000000E   0xD004             BEQ.N    ??PWM_MatchUpdate_0
   \   00000010   0xF44F 0x71D9      MOV      R1,#+434
   \   00000014   0x....             LDR.N    R0,??DataTable14_1
   \   00000016   0x.... 0x....      BL       check_failed
    435          	CHECK_PARAM(PARAM_PWM1_MATCH_CHANNEL(MatchChannel));
   \                     ??PWM_MatchUpdate_0: (+1)
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x2D07             CMP      R5,#+7
   \   0000001E   0xDB04             BLT.N    ??PWM_MatchUpdate_1
   \   00000020   0xF240 0x11B3      MOVW     R1,#+435
   \   00000024   0x....             LDR.N    R0,??DataTable14_1
   \   00000026   0x.... 0x....      BL       check_failed
    436          	CHECK_PARAM(PARAM_PWM_MATCH_UPDATE(UpdateType));
   \                     ??PWM_MatchUpdate_1: (+1)
   \   0000002A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000002C   0x2F00             CMP      R7,#+0
   \   0000002E   0xD007             BEQ.N    ??PWM_MatchUpdate_2
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2F01             CMP      R7,#+1
   \   00000034   0xD004             BEQ.N    ??PWM_MatchUpdate_2
   \   00000036   0xF44F 0x71DA      MOV      R1,#+436
   \   0000003A   0x....             LDR.N    R0,??DataTable14_1
   \   0000003C   0x.... 0x....      BL       check_failed
    437          
    438          	switch (MatchChannel)
   \                     ??PWM_MatchUpdate_2: (+1)
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD009             BEQ.N    ??PWM_MatchUpdate_3
   \   00000046   0x2D02             CMP      R5,#+2
   \   00000048   0xD00B             BEQ.N    ??PWM_MatchUpdate_4
   \   0000004A   0xD308             BCC.N    ??PWM_MatchUpdate_5
   \   0000004C   0x2D04             CMP      R5,#+4
   \   0000004E   0xD00C             BEQ.N    ??PWM_MatchUpdate_6
   \   00000050   0xD309             BCC.N    ??PWM_MatchUpdate_7
   \   00000052   0x2D06             CMP      R5,#+6
   \   00000054   0xD00D             BEQ.N    ??PWM_MatchUpdate_8
   \   00000056   0xD30A             BCC.N    ??PWM_MatchUpdate_9
   \   00000058   0xE00C             B.N      ??PWM_MatchUpdate_10
    439          	{
    440          	case 0:
    441          		PWMx->MR0 = MatchValue;
   \                     ??PWM_MatchUpdate_3: (+1)
   \   0000005A   0x61A6             STR      R6,[R4, #+24]
    442          		break;
   \   0000005C   0xE00A             B.N      ??PWM_MatchUpdate_10
    443          
    444          	case 1:
    445          		PWMx->MR1 = MatchValue;
   \                     ??PWM_MatchUpdate_5: (+1)
   \   0000005E   0x61E6             STR      R6,[R4, #+28]
    446          		break;
   \   00000060   0xE008             B.N      ??PWM_MatchUpdate_10
    447          
    448          	case 2:
    449          		PWMx->MR2 = MatchValue;
   \                     ??PWM_MatchUpdate_4: (+1)
   \   00000062   0x6226             STR      R6,[R4, #+32]
    450          		break;
   \   00000064   0xE006             B.N      ??PWM_MatchUpdate_10
    451          
    452          	case 3:
    453          		PWMx->MR3 = MatchValue;
   \                     ??PWM_MatchUpdate_7: (+1)
   \   00000066   0x6266             STR      R6,[R4, #+36]
    454          		break;
   \   00000068   0xE004             B.N      ??PWM_MatchUpdate_10
    455          
    456          	case 4:
    457          		PWMx->MR4 = MatchValue;
   \                     ??PWM_MatchUpdate_6: (+1)
   \   0000006A   0x6426             STR      R6,[R4, #+64]
    458          		break;
   \   0000006C   0xE002             B.N      ??PWM_MatchUpdate_10
    459          
    460          	case 5:
    461          		PWMx->MR5 = MatchValue;
   \                     ??PWM_MatchUpdate_9: (+1)
   \   0000006E   0x6466             STR      R6,[R4, #+68]
    462          		break;
   \   00000070   0xE000             B.N      ??PWM_MatchUpdate_10
    463          
    464          	case 6:
    465          		PWMx->MR6 = MatchValue;
   \                     ??PWM_MatchUpdate_8: (+1)
   \   00000072   0x64A6             STR      R6,[R4, #+72]
    466          		break;
    467          	}
    468          
    469          	// Write Latch register
    470          	PWMx->LER |= PWM_LER_EN_MATCHn_LATCH(MatchChannel);
   \                     ??PWM_MatchUpdate_10: (+1)
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x2D07             CMP      R5,#+7
   \   00000078   0xDA02             BGE.N    ??PWM_MatchUpdate_11
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x40A8             LSLS     R0,R0,R5
   \   0000007E   0xE000             B.N      ??PWM_MatchUpdate_12
   \                     ??PWM_MatchUpdate_11: (+1)
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??PWM_MatchUpdate_12: (+1)
   \   00000082   0x6D21             LDR      R1,[R4, #+80]
   \   00000084   0x4308             ORRS     R0,R0,R1
   \   00000086   0x6520             STR      R0,[R4, #+80]
    471          
    472          	// In case of update now
    473          	if (UpdateType == PWM_MATCH_UPDATE_NOW)
   \   00000088   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008A   0x2F00             CMP      R7,#+0
   \   0000008C   0xD107             BNE.N    ??PWM_MatchUpdate_13
    474          	{
    475          		PWMx->TCR |= PWM_TCR_COUNTER_RESET;
   \   0000008E   0x6860             LDR      R0,[R4, #+4]
   \   00000090   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000094   0x6060             STR      R0,[R4, #+4]
    476          		PWMx->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   0000009C   0x6060             STR      R0,[R4, #+4]
    477          	}
    478          }
   \                     ??PWM_MatchUpdate_13: (+1)
   \   0000009E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    479          
    480          /********************************************************************//**
    481           * @brief 		Update value for multi PWM channel with update type option
    482           * 				at the same time
    483           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    484           * @param[in]	MatchStruct Structure that contents match value of 7 pwm channels
    485           * @param[in]	UpdateType Type of Update, should be:
    486           * 				- PWM_MATCH_UPDATE_NOW: The update value will be updated for
    487           * 					this channel immediately
    488           * 				- PWM_MATCH_UPDATE_NEXT_RST: The update value will be updated for
    489           * 					this channel on next reset by a PWM Match event.
    490           * @return		None
    491           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    492          void PWM_MultiMatchUpdate(LPC_PWM_TypeDef *PWMx, PWM_Match_T *MatchStruct , uint8_t UpdateType)
    493          {
   \                     PWM_MultiMatchUpdate: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    494          	uint8_t LatchValue = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
    495          	uint8_t i;
    496          
    497          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   0000000C   0x....             LDR.N    R0,??DataTable14  ;; 0x40018000
   \   0000000E   0x4284             CMP      R4,R0
   \   00000010   0xD004             BEQ.N    ??PWM_MultiMatchUpdate_0
   \   00000012   0xF240 0x11F1      MOVW     R1,#+497
   \   00000016   0x....             LDR.N    R0,??DataTable14_1
   \   00000018   0x.... 0x....      BL       check_failed
    498          	CHECK_PARAM(PARAM_PWM_MATCH_UPDATE(UpdateType));
   \                     ??PWM_MultiMatchUpdate_0: (+1)
   \   0000001C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD007             BEQ.N    ??PWM_MultiMatchUpdate_1
   \   00000022   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD004             BEQ.N    ??PWM_MultiMatchUpdate_1
   \   00000028   0xF44F 0x71F9      MOV      R1,#+498
   \   0000002C   0x....             LDR.N    R0,??DataTable14_1
   \   0000002E   0x.... 0x....      BL       check_failed
    499          
    500          	//Update match value
    501          	for(i=0;i<7;i++)
   \                     ??PWM_MultiMatchUpdate_1: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4680             MOV      R8,R0
   \                     ??PWM_MultiMatchUpdate_2: (+1)
   \   00000036   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000003A   0xF1B8 0x0F07      CMP      R8,#+7
   \   0000003E   0xDA25             BGE.N    ??PWM_MultiMatchUpdate_3
    502          	{
    503          		if(MatchStruct[i].Status == SET)
   \   00000040   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000044   0xEB15 0x00C8      ADDS     R0,R5,R8, LSL #+3
   \   00000048   0x7900             LDRB     R0,[R0, #+4]
   \   0000004A   0x2801             CMP      R0,#+1
   \   0000004C   0xD11B             BNE.N    ??PWM_MultiMatchUpdate_4
    504          		{
    505          			if(i<4)
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000056   0xDA09             BGE.N    ??PWM_MultiMatchUpdate_5
    506          				*((volatile unsigned int *)(&(PWMx->MR0) + i)) = MatchStruct[i].Matchvalue;
   \   00000058   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005C   0xF855 0x0038      LDR      R0,[R5, R8, LSL #+3]
   \   00000060   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000064   0xEB14 0x0188      ADDS     R1,R4,R8, LSL #+2
   \   00000068   0x6188             STR      R0,[R1, #+24]
   \   0000006A   0xE008             B.N      ??PWM_MultiMatchUpdate_6
    507          			else
    508          			{
    509          				*((volatile unsigned int *)(&(PWMx->MR4) + (i-4))) = MatchStruct[i].Matchvalue;
   \                     ??PWM_MultiMatchUpdate_5: (+1)
   \   0000006C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000070   0xF855 0x0038      LDR      R0,[R5, R8, LSL #+3]
   \   00000074   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000078   0xEB14 0x0188      ADDS     R1,R4,R8, LSL #+2
   \   0000007C   0x6308             STR      R0,[R1, #+48]
    510          			}
    511          			LatchValue |=(1<<i);
   \                     ??PWM_MultiMatchUpdate_6: (+1)
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xFA10 0xF008      LSLS     R0,R0,R8
   \   00000084   0x4307             ORRS     R7,R0,R7
    512          		}
    513          	}
   \                     ??PWM_MultiMatchUpdate_4: (+1)
   \   00000086   0xF118 0x0801      ADDS     R8,R8,#+1
   \   0000008A   0xE7D4             B.N      ??PWM_MultiMatchUpdate_2
    514          	//set update for multi-channel at the same time
    515          	PWMx->LER = LatchValue;
   \                     ??PWM_MultiMatchUpdate_3: (+1)
   \   0000008C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000008E   0x6527             STR      R7,[R4, #+80]
    516          
    517          	// In case of update now
    518          	if (UpdateType == PWM_MATCH_UPDATE_NOW)
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E00             CMP      R6,#+0
   \   00000094   0xD107             BNE.N    ??PWM_MultiMatchUpdate_7
    519          	{
    520          		PWMx->TCR |= PWM_TCR_COUNTER_RESET;
   \   00000096   0x6860             LDR      R0,[R4, #+4]
   \   00000098   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000009C   0x6060             STR      R0,[R4, #+4]
    521          		PWMx->TCR &= (~PWM_TCR_COUNTER_RESET) & PWM_TCR_BITMASK;
   \   0000009E   0x6860             LDR      R0,[R4, #+4]
   \   000000A0   0xF010 0x0009      ANDS     R0,R0,#0x9
   \   000000A4   0x6060             STR      R0,[R4, #+4]
    522          	}
    523          }
   \                     ??PWM_MultiMatchUpdate_7: (+1)
   \   000000A6   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    524          /********************************************************************//**
    525           * @brief 		Configure Edge mode for each PWM channel
    526           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    527           * @param[in]	PWMChannel PWM channel, should be in range from 2 to 6
    528           * @param[in]	ModeOption PWM mode option, should be:
    529           * 				- PWM_CHANNEL_SINGLE_EDGE: Single Edge mode
    530           * 				- PWM_CHANNEL_DUAL_EDGE: Dual Edge mode
    531           * @return 		None
    532           * Note: PWM Channel 1 can not be selected for mode option
    533           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          void PWM_ChannelConfig(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, uint8_t ModeOption)
    535          {
   \                     PWM_ChannelConfig: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    536          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000008   0x....             LDR.N    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ChannelConfig_0
   \   0000000E   0xF44F 0x7106      MOV      R1,#+536
   \   00000012   0x....             LDR.N    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
    537          	CHECK_PARAM(PARAM_PWM1_EDGE_MODE_CHANNEL(PWMChannel));
   \                     ??PWM_ChannelConfig_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xDB02             BLT.N    ??PWM_ChannelConfig_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D07             CMP      R5,#+7
   \   00000022   0xDB04             BLT.N    ??PWM_ChannelConfig_2
   \                     ??PWM_ChannelConfig_1: (+1)
   \   00000024   0xF240 0x2119      MOVW     R1,#+537
   \   00000028   0x....             LDR.N    R0,??DataTable14_1
   \   0000002A   0x.... 0x....      BL       check_failed
    538          	CHECK_PARAM(PARAM_PWM_CHANNEL_EDGE(ModeOption));
   \                     ??PWM_ChannelConfig_2: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD007             BEQ.N    ??PWM_ChannelConfig_3
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD004             BEQ.N    ??PWM_ChannelConfig_3
   \   0000003A   0xF240 0x211A      MOVW     R1,#+538
   \   0000003E   0x....             LDR.N    R0,??DataTable14_1
   \   00000040   0x.... 0x....      BL       check_failed
    539          
    540          	// Single edge mode
    541          	if (ModeOption == PWM_CHANNEL_SINGLE_EDGE)
   \                     ??PWM_ChannelConfig_3: (+1)
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x2E00             CMP      R6,#+0
   \   00000048   0xD110             BNE.N    ??PWM_ChannelConfig_4
    542          	{
    543          		PWMx->PCR &= (~PWM_PCR_PWMSELn(PWMChannel)) & PWM_PCR_BITMASK;
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xDA01             BGE.N    ??PWM_ChannelConfig_5
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE001             B.N      ??PWM_ChannelConfig_6
   \                     ??PWM_ChannelConfig_5: (+1)
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x40A8             LSLS     R0,R0,R5
   \                     ??PWM_ChannelConfig_6: (+1)
   \   0000005C   0x6CE1             LDR      R1,[R4, #+76]
   \   0000005E   0xF647 0x627C      MOVW     R2,#+32380
   \   00000062   0xEA32 0x0000      BICS     R0,R2,R0
   \   00000066   0x4008             ANDS     R0,R0,R1
   \   00000068   0x64E0             STR      R0,[R4, #+76]
   \   0000006A   0xE00B             B.N      ??PWM_ChannelConfig_7
    544          	}
    545          	// Double edge mode
    546          	else if (PWM_CHANNEL_DUAL_EDGE)
    547          	{
    548          		PWMx->PCR |= PWM_PCR_PWMSELn(PWMChannel);
   \                     ??PWM_ChannelConfig_4: (+1)
   \   0000006C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006E   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xDA01             BGE.N    ??PWM_ChannelConfig_8
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE001             B.N      ??PWM_ChannelConfig_9
   \                     ??PWM_ChannelConfig_8: (+1)
   \   0000007A   0x2001             MOVS     R0,#+1
   \   0000007C   0x40A8             LSLS     R0,R0,R5
   \                     ??PWM_ChannelConfig_9: (+1)
   \   0000007E   0x6CE1             LDR      R1,[R4, #+76]
   \   00000080   0x4308             ORRS     R0,R0,R1
   \   00000082   0x64E0             STR      R0,[R4, #+76]
    549          	}
    550          }
   \                     ??PWM_ChannelConfig_7: (+1)
   \   00000084   0xBD70             POP      {R4-R6,PC}       ;; return
    551          
    552          
    553          
    554          /********************************************************************//**
    555           * @brief 		Enable/Disable PWM channel output
    556           * @param[in]	PWMx	PWM peripheral selected, should be LPC_PWM1
    557           * @param[in]	PWMChannel PWM channel, should be in range from 1 to 6
    558           * @param[in]	NewState New State of this function, should be:
    559           * 				- ENABLE: Enable this PWM channel output
    560           * 				- DISABLE: Disable this PWM channel output
    561           * @return		None
    562           *********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void PWM_ChannelCmd(LPC_PWM_TypeDef *PWMx, uint8_t PWMChannel, FunctionalState NewState)
    564          {
   \                     PWM_ChannelCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    565          	CHECK_PARAM(PARAM_PWMx(PWMx));
   \   00000008   0x....             LDR.N    R0,??DataTable14  ;; 0x40018000
   \   0000000A   0x4284             CMP      R4,R0
   \   0000000C   0xD004             BEQ.N    ??PWM_ChannelCmd_0
   \   0000000E   0xF240 0x2135      MOVW     R1,#+565
   \   00000012   0x....             LDR.N    R0,??DataTable14_1
   \   00000014   0x.... 0x....      BL       check_failed
    566          	CHECK_PARAM(PARAM_PWM1_CHANNEL(PWMChannel));
   \                     ??PWM_ChannelCmd_0: (+1)
   \   00000018   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001A   0x2D00             CMP      R5,#+0
   \   0000001C   0xD002             BEQ.N    ??PWM_ChannelCmd_1
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x2D07             CMP      R5,#+7
   \   00000022   0xDB04             BLT.N    ??PWM_ChannelCmd_2
   \                     ??PWM_ChannelCmd_1: (+1)
   \   00000024   0xF240 0x2136      MOVW     R1,#+566
   \   00000028   0x....             LDR.N    R0,??DataTable14_1
   \   0000002A   0x.... 0x....      BL       check_failed
    567          
    568          	if (NewState == ENABLE)
   \                     ??PWM_ChannelCmd_2: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD10E             BNE.N    ??PWM_ChannelCmd_3
    569          	{
    570          		PWMx->PCR |= PWM_PCR_PWMENAn(PWMChannel);
   \   00000034   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000036   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   0000003A   0x2801             CMP      R0,#+1
   \   0000003C   0xDA01             BGE.N    ??PWM_ChannelCmd_4
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE003             B.N      ??PWM_ChannelCmd_5
   \                     ??PWM_ChannelCmd_4: (+1)
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xF115 0x0108      ADDS     R1,R5,#+8
   \   00000048   0x4088             LSLS     R0,R0,R1
   \                     ??PWM_ChannelCmd_5: (+1)
   \   0000004A   0x6CE1             LDR      R1,[R4, #+76]
   \   0000004C   0x4308             ORRS     R0,R0,R1
   \   0000004E   0x64E0             STR      R0,[R4, #+76]
   \   00000050   0xE011             B.N      ??PWM_ChannelCmd_6
    571          	}
    572          	else
    573          	{
    574          		PWMx->PCR &= (~PWM_PCR_PWMENAn(PWMChannel)) & PWM_PCR_BITMASK;
   \                     ??PWM_ChannelCmd_3: (+1)
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0xF015 0x0007      ANDS     R0,R5,#0x7
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDA01             BGE.N    ??PWM_ChannelCmd_7
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??PWM_ChannelCmd_8
   \                     ??PWM_ChannelCmd_7: (+1)
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0xF115 0x0108      ADDS     R1,R5,#+8
   \   00000066   0x4088             LSLS     R0,R0,R1
   \                     ??PWM_ChannelCmd_8: (+1)
   \   00000068   0x6CE1             LDR      R1,[R4, #+76]
   \   0000006A   0xF647 0x627C      MOVW     R2,#+32380
   \   0000006E   0xEA32 0x0000      BICS     R0,R2,R0
   \   00000072   0x4008             ANDS     R0,R0,R1
   \   00000074   0x64E0             STR      R0,[R4, #+76]
    575          	}
    576          }
   \                     ??PWM_ChannelCmd_6: (+1)
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40018000         DC32     0x40018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 69H, 61H, 72H, 5CH, 4EH
   \              0x5C 0x69    
   \              0x61 0x72    
   \              0x5C 0x4E    
   \   00000008   0x43 0x31          DC8 43H, 31H, 33H, 36H, 42H, 2DH, 33H, 31H
   \              0x33 0x36    
   \              0x42 0x2D    
   \              0x33 0x31    
   \   00000010   0x30 0x20          DC8 30H, 20H, 0CDH, 0B3H, 0BCH, 0C6H, 0C4H, 0A3H
   \              0xCD 0xB3    
   \              0xBC 0xC6    
   \              0xC4 0xA3    
   \   00000018   0xBF 0xE9          DC8 0BFH, 0E9H, 5CH, 53H, 6FH, 66H, 74H, 77H
   \              0x5C 0x53    
   \              0x6F 0x66    
   \              0x74 0x77    
   \   00000020   0x61 0x72          DC8 61H, 72H, 65H, 5CH, 43H, 53H, 42H, 5CH
   \              0x65 0x5C    
   \              0x43 0x53    
   \              0x42 0x5C    
   \   00000028   0x73 0x6F          DC8 73H, 6FH, 75H, 72H, 63H, 65H, 5CH, 6CH
   \              0x75 0x72    
   \              0x63 0x65    
   \              0x5C 0x6C    
   \   00000030   0x70 0x63          DC8 70H, 63H, 31H, 37H, 78H, 78H, 5FH, 70H
   \              0x31 0x37    
   \              0x78 0x78    
   \              0x5F 0x70    
   \   00000038   0x77 0x6D          DC8 77H, 6DH, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   0000003D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    577          
    578          /**
    579           * @}
    580           */
    581          
    582          #endif /* _PWM */
    583          
    584          /**
    585           * @}
    586           */
    587          
    588          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   PWM_ChannelCmd
        16   -> check_failed
      16   PWM_ChannelConfig
        16   -> check_failed
      16   PWM_ClearIntPending
        16   -> check_failed
      16   PWM_Cmd
        16   -> check_failed
      16   PWM_ConfigCapture
        16   -> check_failed
      16   PWM_ConfigMatch
        16   -> check_failed
      24   PWM_ConfigStructInit
        24   -> check_failed
      16   PWM_CounterCmd
        16   -> check_failed
       8   PWM_DeInit
         8   -> CLKPWR_ConfigPPWR
         8   -> check_failed
      16   PWM_GetCaptureValue
        16   -> check_failed
      16   PWM_GetIntStatus
        16   -> check_failed
      32   PWM_Init
        32   -> CLKPWR_ConfigPPWR
        32   -> CLKPWR_GetPCLK
        32   -> CLKPWR_SetPCLKDiv
        32   -> check_failed
        32 __aeabi_uldivmod
      24   PWM_MatchUpdate
        24   -> check_failed
      24   PWM_MultiMatchUpdate
        24   -> check_failed
       8   PWM_ResetCounter
         8   -> check_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
      64  ?_0
     120  PWM_ChannelCmd
     134  PWM_ChannelConfig
      80  PWM_ClearIntPending
      72  PWM_Cmd
     330  PWM_ConfigCapture
     324  PWM_ConfigMatch
      64  PWM_ConfigStructInit
      76  PWM_CounterCmd
      36  PWM_DeInit
      68  PWM_GetCaptureValue
      92  PWM_GetIntStatus
     286  PWM_Init
     160  PWM_MatchUpdate
     170  PWM_MultiMatchUpdate
      42  PWM_ResetCounter

 
    64 bytes in section .rodata
 2 066 bytes in section .text
 
 2 066 bytes of CODE  memory
    64 bytes of CONST memory

Errors: none
Warnings: none
