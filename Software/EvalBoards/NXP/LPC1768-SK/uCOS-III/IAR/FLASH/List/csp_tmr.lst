###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       21/Aug/2017  10:05:21
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_tmr.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_tmr.c
#        -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\csp_tmr.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\csp_tmr.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\uC-CSP\MCU\NXP\LPC17xx\csp_tmr.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              uC/CSP
      4          *                                        Chip Support Package
      5          *
      6          *                            (c) Copyright 2010; Micrium, Inc.; Weston, FL
      7          *                         (c) Copyright 2003-2010; Micrium, Inc.; Weston, FL
      8          *
      9          *               All rights reserved. Protected by international copyright laws.
     10          *
     11          *               uC/CSP is provided in source form to registered licensees ONLY.  It is
     12          *               illegal to distribute this source code to any third party unless you receive
     13          *               written permission by an authorized Micrium representative.  Knowledge of
     14          *               the source code may NOT be used to develop a similar product.
     15          *
     16          *               Please help us continue to provide the Embedded community with the finest
     17          *               software available.  Your honesty is greatly appreciated.
     18          *
     19          *               You can contact us at www.micrium.com.
     20          *********************************************************************************************************
     21          */
     22          
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                          TIMER MANAGEMENT
     28          *                                            NXP LPC17xx 
     29          *
     30          * Filename      : csp_tmr.c
     31          * Version       : V1.00
     32          * Programmer(s) : FT
     33          *********************************************************************************************************
     34          * Note(s)       : 
     35          *********************************************************************************************************
     36          */
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            INCLUDE FILES
     42          *********************************************************************************************************
     43          */
     44          
     45          #define  CSP_TMR_MODULE
     46          #include  <csp.h>
     47          
     48          /*
     49          *********************************************************************************************************
     50          *                                    REGISTER & BIT-FIELD DEFINITION
     51          *********************************************************************************************************
     52          */
     53          
     54          #define  CSP_TMR_ADDR_TMR0                  (CPU_INT32U)(0x40004000)
     55          #define  CSP_TMR_ADDR_TMR1                  (CPU_INT32U)(0x40008000)
     56          #define  CSP_TMR_ADDR_TMR2                  (CPU_INT32U)(0x40090000)
     57          #define  CSP_TMR_ADDR_TMR3                  (CPU_INT32U)(0x40094000)
     58          
     59          
     60          #define  CSP_TMR_BIT_CR_START                   DEF_BIT_00
     61          #define  CSP_TMR_BIT_CR_RST                     DEF_BIT_01
     62          
     63          #define  CSP_TMR_MASK_TCR_MODE                  DEF_BIT_FIELD(2, 0)
     64          #define  CSP_TMR_BIT_TCR_TMR_MODE               DEF_BIT_NONE
     65          
     66          
     67          #define  CSP_TMR_MASK_MCR_MR                    DEF_BIT_FIELD(3, 0)
     68          
     69          #define  CSP_TMR_MASK_MCR_MRx(match_nbr)        DEF_BIT_MASK(CSP_TMR_MASK_MCR_MR, 3u * (match_nbr))
     70          
     71          
     72                                                                          /* --------------- MATCH CONTROL REGISTER ------------- */
     73          #define  CSP_TMR_BIT_MCR_MRI                    DEF_BIT_00      /* Interrupt on match.                                  */
     74          #define  CSP_TMR_BIT_MCR_MRR                    DEF_BIT_01      /* Reset on match.                                      */
     75          #define  CSP_TMR_BIT_MCR_MRS                    DEF_BIT_02      /* Stop on match.                                       */
     76          
     77          #define  CSP_TMR_BIT_MCR_MRIx(match_nbr)        DEF_BIT_MASK(CSP_TMR_BIT_MCR_MRI, 3u * (match_nbr))
     78          #define  CSP_TMR_BIT_MCR_MRRx(match_nbr)        DEF_BIT_MASK(CSP_TMR_BIT_MCR_MRR, 3u * (match_nbr))
     79          #define  CSP_TMR_BIT_MCR_MRSx(match_nbr)        DEF_BIT_MASK(CSP_TMR_BIT_MCR_MRS, 3u * (match_nbr))
     80          
     81          
     82          /*
     83          *********************************************************************************************************
     84          *                                           LOCAL CONSTANTS
     85          *********************************************************************************************************
     86          */
     87          
     88          
     89          /*
     90          *********************************************************************************************************
     91          *                                          LOCAL DATA TYPES
     92          *********************************************************************************************************
     93          */
     94          
     95          typedef  struct  csp_tmr_reg {
     96              CPU_REG32  IR;
     97              CPU_REG32  TCR;
     98              CPU_REG32  TC;
     99              CPU_REG32  PR;
    100              CPU_REG32  PC;
    101              CPU_REG32  MCR;
    102              CPU_REG32  MRx[4];
    103              CPU_REG32  CCR;
    104              CPU_REG32  CCRx[2];
    105              CPU_REG32  RESERVED0[2];
    106              CPU_REG32  EMR;
    107              CPU_REG32  RESERVED1[12];
    108          } CSP_TMR_REG;
    109          
    110          
    111          /*
    112          *********************************************************************************************************
    113          *                                            LOCAL TABLES
    114          *********************************************************************************************************
    115          */
    116          

   \                                 In section .rodata, align 4
    117          static  const  CPU_ADDR     CSP_TmrAddrTbl[4] = {
   \                     CSP_TmrAddrTbl:
   \   00000000   0x40004000         DC32 1073758208, 1073774592, 1074331648, 1074348032
   \              0x40008000   
   \              0x40090000   
   \              0x40094000   
    118              CSP_TMR_ADDR_TMR0,
    119              CSP_TMR_ADDR_TMR1,
    120              CSP_TMR_ADDR_TMR2,
    121              CSP_TMR_ADDR_TMR3
    122          };
    123          

   \                                 In section .rodata, align 4
    124          static  const  CSP_DEV_NBR  CSP_TmrPerTbl[4] = {
   \                     CSP_TmrPerTbl:
   \   00000000   0x0001 0x0002      DC16 1, 2, 22, 23
   \              0x0016 0x0017
    125              CSP_PM_PER_CLK_NBR_TMR_00,
    126              CSP_PM_PER_CLK_NBR_TMR_01,
    127              CSP_PM_PER_CLK_NBR_TMR_02,
    128              CSP_PM_PER_CLK_NBR_TMR_03
    129          };
    130          
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                       LOCAL GLOBAL VARIABLES
    135          *********************************************************************************************************
    136          */
    137          
    138          
    139          /*
    140          *********************************************************************************************************
    141          *                                            LOCAL MACRO's
    142          *********************************************************************************************************
    143          */
    144          
    145          
    146          /*
    147          *********************************************************************************************************
    148          *                                      LOCAL FUNCTION PROTOTYPES
    149          *********************************************************************************************************
    150          */
    151          
    152          
    153          /*
    154          *********************************************************************************************************
    155          *                                     LOCAL CONFIGURATION ERRORS
    156          *********************************************************************************************************
    157          */
    158          
    159          
    160          /*
    161          *********************************************************************************************************
    162          *********************************************************************************************************
    163          *                                           LOCAL FUNCTIONS
    164          *********************************************************************************************************
    165          *********************************************************************************************************
    166          */
    167          
    168          /*
    169          *********************************************************************************************************
    170          *                                        CSP_TmrInit()
    171          *
    172          * Description : Initialize & disable all the timers.
    173          *                   
    174          * Argument(s) : none.
    175          *
    176          * Return(s)   : none
    177          *
    178          * Caller(s)   : Application.
    179          *
    180          * Note(s)     : none.
    181          *********************************************************************************************************
    182          */
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void  CSP_TmrInit (void)
    185          {
   \                     CSP_TmrInit: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    186              CSP_DEV_NBR  per_nbr;
    187              CSP_DEV_NBR  tmr_nbr;
    188              CSP_TMR_REG  *p_tmr_reg;
    189              CPU_SR_ALLOC();
   \   00000002   0x2700             MOVS     R7,#+0
    190          
    191          
    192              for (tmr_nbr = CSP_TMR_NBR_00; tmr_nbr <= CSP_TMR_NBR_03; tmr_nbr++) {
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??CSP_TmrInit_0: (+1)
   \   00000008   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000000A   0x2D04             CMP      R5,#+4
   \   0000000C   0xDA2F             BGE.N    ??CSP_TmrInit_1
    193                  p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable8
   \   00000012   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000014   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000018   0x0006             MOVS     R6,R0
    194                  per_nbr   = (CSP_DEV_NBR  )CSP_TmrPerTbl[tmr_nbr];
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000001E   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000020   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000024   0x0004             MOVS     R4,R0
    195                  
    196                  CPU_CRITICAL_ENTER();
   \   00000026   0x.... 0x....      BL       CPU_SR_Save
   \   0000002A   0x0007             MOVS     R7,R0
   \   0000002C   0x.... 0x....      BL       CPU_IntDisMeasStart
    197                  CSP_PM_PerClkEn(per_nbr);
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0x.... 0x....      BL       CSP_PM_PerClkEn
    198                  p_tmr_reg->MCR    = DEF_BIT_NONE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6170             STR      R0,[R6, #+20]
    199                  p_tmr_reg->MRx[0] = 0u;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x61B0             STR      R0,[R6, #+24]
    200                  p_tmr_reg->MRx[1] = 0u;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x61F0             STR      R0,[R6, #+28]
    201                  p_tmr_reg->MRx[2] = 0u;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6230             STR      R0,[R6, #+32]
    202                  p_tmr_reg->IR     = DEF_BIT_FIELD(5u, 0u);
   \   00000048   0x201F             MOVS     R0,#+31
   \   0000004A   0x6030             STR      R0,[R6, #+0]
    203                  p_tmr_reg->TCR    = DEF_BIT_NONE;        
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x6070             STR      R0,[R6, #+4]
    204                  p_tmr_reg->MCR    = DEF_BIT_NONE;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x6170             STR      R0,[R6, #+20]
    205                  p_tmr_reg->EMR    = DEF_BIT_NONE;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x63F0             STR      R0,[R6, #+60]
    206                  CSP_PM_PerClkDis(per_nbr);        
   \   00000058   0x0020             MOVS     R0,R4
   \   0000005A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000005C   0x.... 0x....      BL       CSP_PM_PerClkDis
    207                  CPU_CRITICAL_EXIT();
   \   00000060   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000064   0x0038             MOVS     R0,R7
   \   00000066   0x.... 0x....      BL       CPU_SR_Restore
    208              }
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   \   0000006C   0xE7CC             B.N      ??CSP_TmrInit_0
    209          }
   \                     ??CSP_TmrInit_1: (+1)
   \   0000006E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    210          
    211          /*
    212          *********************************************************************************************************
    213          *                                        CSP_TmrCfg()
    214          *
    215          * Description : Configure a specific periodic/free running timer 
    216          *                   
    217          * Argument(s) : tmr_nbr    Timer number identifier (see note #1).
    218          *
    219          *               freq       Periodic timer frequency. (see note #2)
    220          *                          
    221          * Return(s)   : none
    222          *
    223          * Caller(s)   : Application.
    224          *
    225          * Note(s)     : (1) If the timer is configured to be used in periodic mode the interrupt handler needs
    226          *                   to be installed first in the interrupt controller and the interrupt needs to be enabled
    227          *                   before calling this function.
    228          *
    229          *               (2) If 'freq' == 0 Timer is configured as free-running timer.
    230          *                   If 'freq' > 0  Timer will be configured to generate a interrupt event every
    231          *                   (1/freq) seconds.
    232          *
    233          *               (3) MATCH 0 register is always used to generate periodic events.
    234          *********************************************************************************************************
    235          */
    236          

   \                                 In section .text, align 2, keep-with-next
    237          CPU_BOOLEAN  CSP_TmrCfg (CSP_DEV_NBR   tmr_nbr,
    238                                   CPU_INT32U    freq)
    239          {
   \                     CSP_TmrCfg: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    240              CSP_TMR_REG  *p_tmr_reg;
    241              CPU_INT32U    match_val;
    242              CPU_INT32U    per_freq;
    243              CSP_DEV_NBR   per_nbr;    
    244              CPU_SR_ALLOC();
   \   00000008   0xF05F 0x0A00      MOVS     R10,#+0
    245              
    246          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)     
    247              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x2C04             CMP      R4,#+4
   \   00000010   0xDB01             BLT.N    ??CSP_TmrCfg_0
    248                  return (DEF_FAIL);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE062             B.N      ??CSP_TmrCfg_1
    249              }
    250          #endif
    251          
    252              
    253              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrCfg_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000001A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001C   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000020   0x0006             MOVS     R6,R0
    254              per_nbr   = (CSP_DEV_NBR  )CSP_TmrPerTbl[tmr_nbr];    
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000026   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000028   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   0000002C   0x4681             MOV      R9,R0
    255              
    256              if (freq == 0u) {                                           /* -------- FREE RUNNING TIMER CONFIGURATION --------- */
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD11A             BNE.N    ??CSP_TmrCfg_2
    257                  CSP_PM_PerClkEn(per_nbr);                               /* Enable peripheral clock                             */                                                               
   \   00000032   0x4648             MOV      R0,R9
   \   00000034   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000036   0x.... 0x....      BL       CSP_PM_PerClkEn
    258                  
    259                  CPU_CRITICAL_ENTER();        
   \   0000003A   0x.... 0x....      BL       CPU_SR_Save
   \   0000003E   0x4682             MOV      R10,R0
   \   00000040   0x.... 0x....      BL       CPU_IntDisMeasStart
    260                  p_tmr_reg->MCR = DEF_BIT_NONE;                          /* Disable theInterrupt, Reset and Stop feauture on    */
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6170             STR      R0,[R6, #+20]
    261                                                                          /* ... Match channels.                                 */
    262                  
    263                  DEF_BIT_CLR(p_tmr_reg->TCR, CSP_TMR_MASK_TCR_MODE);     /* Clear the Mode.                                     */
   \   00000048   0x6870             LDR      R0,[R6, #+4]
   \   0000004A   0x0880             LSRS     R0,R0,#+2
   \   0000004C   0x0080             LSLS     R0,R0,#+2
   \   0000004E   0x6070             STR      R0,[R6, #+4]
    264                  DEF_BIT_SET(p_tmr_reg->TCR, CSP_TMR_BIT_TCR_TMR_MODE);  /* Set the Timer Mode.                                 */
   \   00000050   0x6870             LDR      R0,[R6, #+4]
   \   00000052   0x6070             STR      R0,[R6, #+4]
    265                  
    266                  p_tmr_reg->PR  = 0u;                                    /* Set the prescaler to 0.                             */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x60F0             STR      R0,[R6, #+12]
    267                  p_tmr_reg->TCR = CSP_TMR_BIT_CR_RST;                    /* Reset the timer.                                    */
   \   00000058   0x2002             MOVS     R0,#+2
   \   0000005A   0x6070             STR      R0,[R6, #+4]
    268                  CPU_CRITICAL_EXIT();
   \   0000005C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000060   0x4650             MOV      R0,R10
   \   00000062   0x.... 0x....      BL       CPU_SR_Restore
   \   00000066   0xE038             B.N      ??CSP_TmrCfg_3
    269          
    270              } else {                                                    /* ---------- PERIODIC TIMER CONFIGURATION ----------- */
    271                  per_freq = CSP_PM_PerClkFreqGet(per_nbr);               /* Get the peripheral clock.                           */
   \                     ??CSP_TmrCfg_2: (+1)
   \   00000068   0x4648             MOV      R0,R9
   \   0000006A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006C   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   00000070   0x4680             MOV      R8,R0
    272          
    273                  if (freq > per_freq) {
   \   00000072   0x45A8             CMP      R8,R5
   \   00000074   0xD201             BCS.N    ??CSP_TmrCfg_4
    274                      return (DEF_FAIL);
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xE030             B.N      ??CSP_TmrCfg_1
    275                  }
    276          
    277                  match_val = ((2u * per_freq / freq) + 1u) / 2u;
   \                     ??CSP_TmrCfg_4: (+1)
   \   0000007A   0xEA5F 0x0048      LSLS     R0,R8,#+1
   \   0000007E   0xFBB0 0xF0F5      UDIV     R0,R0,R5
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x0840             LSRS     R0,R0,#+1
   \   00000086   0x0007             MOVS     R7,R0
    278                  if (match_val == 0u) {
   \   00000088   0x2F00             CMP      R7,#+0
   \   0000008A   0xD101             BNE.N    ??CSP_TmrCfg_5
    279                      return (DEF_FAIL);
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE025             B.N      ??CSP_TmrCfg_1
    280                  }
    281                  
    282                  
    283                  CSP_PM_PerClkEn(per_nbr);                               /* Enable peripheral clock.                           */                                                               
   \                     ??CSP_TmrCfg_5: (+1)
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000094   0x.... 0x....      BL       CSP_PM_PerClkEn
    284                  CPU_CRITICAL_ENTER();
   \   00000098   0x.... 0x....      BL       CPU_SR_Save
   \   0000009C   0x4682             MOV      R10,R0
   \   0000009E   0x.... 0x....      BL       CPU_IntDisMeasStart
    285                  DEF_BIT_CLR(p_tmr_reg->EMR, DEF_BIT_MASK(3u, (2u * 0u) + 4u));
   \   000000A2   0x6BF0             LDR      R0,[R6, #+60]
   \   000000A4   0xF030 0x0030      BICS     R0,R0,#0x30
   \   000000A8   0x63F0             STR      R0,[R6, #+60]
    286          
    287                                                                          /* Disable the Interrupt, Reset and Stop features on   */        
    288                                                                          /* ... Match channel 0, 1, 2 or 3.                     */
    289                  DEF_BIT_CLR(p_tmr_reg->MCR, CSP_TMR_MASK_MCR_MRx(0u));
   \   000000AA   0x6970             LDR      R0,[R6, #+20]
   \   000000AC   0x08C0             LSRS     R0,R0,#+3
   \   000000AE   0x00C0             LSLS     R0,R0,#+3
   \   000000B0   0x6170             STR      R0,[R6, #+20]
    290                                              
    291                  DEF_BIT_CLR(p_tmr_reg->TCR, CSP_TMR_MASK_TCR_MODE);     /* Clear the Mode                                      */
   \   000000B2   0x6870             LDR      R0,[R6, #+4]
   \   000000B4   0x0880             LSRS     R0,R0,#+2
   \   000000B6   0x0080             LSLS     R0,R0,#+2
   \   000000B8   0x6070             STR      R0,[R6, #+4]
    292                  DEF_BIT_SET(p_tmr_reg->TCR, CSP_TMR_BIT_TCR_TMR_MODE);  /* Set the Timer Mode                                  */
   \   000000BA   0x6870             LDR      R0,[R6, #+4]
   \   000000BC   0x6070             STR      R0,[R6, #+4]
    293          
    294                  p_tmr_reg->PR     = 0u;                                 /* Set the prescaler to 0                              */
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x60F0             STR      R0,[R6, #+12]
    295                  p_tmr_reg->MRx[0] = match_val;
   \   000000C2   0x61B7             STR      R7,[R6, #+24]
    296                  p_tmr_reg->TCR    = CSP_TMR_BIT_CR_RST;                 /* Reset the timer                                     */
   \   000000C4   0x2002             MOVS     R0,#+2
   \   000000C6   0x6070             STR      R0,[R6, #+4]
    297                                                                          /* Enable Interrupt and Reset when TC matches MR0, ... */
    298                                                                          /* MR1, MR2, etc                                       */        
    299                  DEF_BIT_SET(p_tmr_reg->MCR, CSP_TMR_BIT_MCR_MRIx(0u) | 
    300                                              CSP_TMR_BIT_MCR_MRRx(0u));
   \   000000C8   0x6970             LDR      R0,[R6, #+20]
   \   000000CA   0xF050 0x0003      ORRS     R0,R0,#0x3
   \   000000CE   0x6170             STR      R0,[R6, #+20]
    301                  CPU_CRITICAL_EXIT();
   \   000000D0   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   000000D4   0x4650             MOV      R0,R10
   \   000000D6   0x.... 0x....      BL       CPU_SR_Restore
    302              }
    303          
    304              return (DEF_OK);
   \                     ??CSP_TmrCfg_3: (+1)
   \   000000DA   0x2001             MOVS     R0,#+1
   \                     ??CSP_TmrCfg_1: (+1)
   \   000000DC   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    305          }
    306          
    307          
    308          
    309          /*
    310          *********************************************************************************************************
    311          *                                           CSP_TmrOutCmpCfg()
    312          *
    313          * Description : Configure a timer for compare mode.  
    314          *                   
    315          * Argument(s) : tmr_nbr    Timer number identifier.
    316          *                              CSP_TMR_NBR_00
    317          *                              CSP_TMR_NBR_01
    318          *                              CSP_TMR_NBR_02
    319          *                              CSP_TMR_NBR_03
    320          *
    321          *               pin_nbr    Pin number.
    322          *
    323          *               pin_action  Output compare pin action
    324          *
    325          *                              CSP_TMR_OPT_PIN_OUT_NONE      Do nothing.
    326          *                              CSP_TMR_OPT_PIN_OUT_CLR       Clear  the corresponding external pin for output compare.
    327          *                              CSP_TMR_OPT_PIN_OUT_SET       Set    the corresponding external pin for output compare.
    328          *                              CSP_TMR_OPT_PIN_OUT_TOGGLE    Toggle the corresponding external pin for output compare.
    329          * 
    330          * Return(s)   : none
    331          *
    332          * Caller(s)   : Application.
    333          *
    334          * Note(s)     : (1) The LPC17xx series timers implements 4 match register and 4 externals outputs.
    335          *********************************************************************************************************
    336          */
    337          

   \                                 In section .text, align 2, keep-with-next
    338          CPU_BOOLEAN CSP_TmrOutCmpCfg  (CSP_DEV_NBR    tmr_nbr,
    339                                         CSP_DEV_NBR    pin,
    340                                         CSP_OPT        pin_action,
    341                                         CPU_INT32U     freq)
    342          
    343          {
   \                     CSP_TmrOutCmpCfg: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    344              CSP_TMR_REG  *p_tmr_reg;
    345              CPU_INT08U    match_nbr;
    346              CPU_INT32U    match_val;
    347              CPU_INT32U    per_freq;
    348              CSP_DEV_NBR   per_nbr;
    349              CPU_SR_ALLOC();
   \   0000000E   0xF05F 0x0B00      MOVS     R11,#+0
    350              
    351                                                                          /* ---------------- ARGUMENTS CHECKING -------------- */
    352          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    353              if (tmr_nbr > CSP_TMR_NBR_01) {
   \   00000012   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000014   0x2C02             CMP      R4,#+2
   \   00000016   0xDB01             BLT.N    ??CSP_TmrOutCmpCfg_0
    354                  return (DEF_FAIL);
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE0AD             B.N      ??CSP_TmrOutCmpCfg_1
    355              }
    356              
    357              if (pin > CSP_TMR_PIN_OUT_NBR_03) {
   \                     ??CSP_TmrOutCmpCfg_0: (+1)
   \   0000001C   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   0000001E   0x2D04             CMP      R5,#+4
   \   00000020   0xDB01             BLT.N    ??CSP_TmrOutCmpCfg_2
    358                  return (DEF_FAIL);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE0A8             B.N      ??CSP_TmrOutCmpCfg_1
    359              }
    360          
    361              if (freq == 0u) {
   \                     ??CSP_TmrOutCmpCfg_2: (+1)
   \   00000026   0x2F00             CMP      R7,#+0
   \   00000028   0xD101             BNE.N    ??CSP_TmrOutCmpCfg_3
    362                  return (DEF_FAIL);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE0A4             B.N      ??CSP_TmrOutCmpCfg_1
    363              }
    364          #endif
    365              
    366              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrOutCmpCfg_3: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable8
   \   00000030   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000032   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000036   0x4680             MOV      R8,R0
    367              per_nbr   = (CSP_DEV_NBR  )CSP_TmrPerTbl[tmr_nbr];    
   \   00000038   0x....             LDR.N    R0,??DataTable8_1
   \   0000003A   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000003C   0xF830 0x0014      LDRH     R0,[R0, R4, LSL #+1]
   \   00000040   0x4682             MOV      R10,R0
    368              
    369              match_nbr = pin,
    370              per_freq  = CSP_PM_PerClkFreqGet(per_nbr);                  /* Get the peripheral clock.                           */
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x4681             MOV      R9,R0
   \   00000046   0x4650             MOV      R0,R10
   \   00000048   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004A   0x.... 0x....      BL       CSP_PM_PerClkFreqGet
   \   0000004E   0x9000             STR      R0,[SP, #+0]
    371          
    372              if (freq > per_freq) {
   \   00000050   0x9800             LDR      R0,[SP, #+0]
   \   00000052   0x42B8             CMP      R0,R7
   \   00000054   0xD201             BCS.N    ??CSP_TmrOutCmpCfg_4
    373                  return (DEF_FAIL);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE08E             B.N      ??CSP_TmrOutCmpCfg_1
    374              }
    375          
    376              match_val = ((2u * per_freq / freq) + 1u) / 2u;
   \                     ??CSP_TmrOutCmpCfg_4: (+1)
   \   0000005A   0x9800             LDR      R0,[SP, #+0]
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0xFBB0 0xF0F7      UDIV     R0,R0,R7
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x0840             LSRS     R0,R0,#+1
   \   00000066   0x9001             STR      R0,[SP, #+4]
    377              if (match_val == 0u) {
   \   00000068   0x9801             LDR      R0,[SP, #+4]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD101             BNE.N    ??CSP_TmrOutCmpCfg_5
    378                  return (DEF_FAIL);
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xE082             B.N      ??CSP_TmrOutCmpCfg_1
    379              }
    380              
    381              
    382              CSP_PM_PerClkEn(per_nbr);                                   /* Enable Peripherical clock.                          */                                                               
   \                     ??CSP_TmrOutCmpCfg_5: (+1)
   \   00000072   0x4650             MOV      R0,R10
   \   00000074   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000076   0x.... 0x....      BL       CSP_PM_PerClkEn
    383              CPU_CRITICAL_ENTER();
   \   0000007A   0x.... 0x....      BL       CPU_SR_Save
   \   0000007E   0x4683             MOV      R11,R0
   \   00000080   0x.... 0x....      BL       CPU_IntDisMeasStart
    384          
    385              DEF_BIT_CLR(p_tmr_reg->EMR, DEF_BIT_MASK(3u, (2u * match_nbr) + 4u));
   \   00000084   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   00000088   0x2103             MOVS     R1,#+3
   \   0000008A   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000008E   0xEA5F 0x0249      LSLS     R2,R9,#+1
   \   00000092   0x1D12             ADDS     R2,R2,#+4
   \   00000094   0x4091             LSLS     R1,R1,R2
   \   00000096   0x4388             BICS     R0,R0,R1
   \   00000098   0xF8C8 0x003C      STR      R0,[R8, #+60]
    386                  
    387              switch (pin_action) {
   \   0000009C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000009E   0x2E00             CMP      R6,#+0
   \   000000A0   0xD005             BEQ.N    ??CSP_TmrOutCmpCfg_6
   \   000000A2   0x2E02             CMP      R6,#+2
   \   000000A4   0xD011             BEQ.N    ??CSP_TmrOutCmpCfg_7
   \   000000A6   0xD303             BCC.N    ??CSP_TmrOutCmpCfg_8
   \   000000A8   0x2E03             CMP      R6,#+3
   \   000000AA   0xD01B             BEQ.N    ??CSP_TmrOutCmpCfg_9
   \   000000AC   0xE027             B.N      ??CSP_TmrOutCmpCfg_10
    388                  case CSP_TMR_OPT_PIN_OUT_NONE:
    389                       break;
   \                     ??CSP_TmrOutCmpCfg_6: (+1)
   \   000000AE   0xE02D             B.N      ??CSP_TmrOutCmpCfg_11
    390                                        
    391                  case CSP_TMR_OPT_PIN_OUT_CLR:
    392                       DEF_BIT_SET(p_tmr_reg->EMR, DEF_BIT_MASK(1u, (2u * match_nbr) + 4u));
   \                     ??CSP_TmrOutCmpCfg_8: (+1)
   \   000000B0   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   000000B4   0x2101             MOVS     R1,#+1
   \   000000B6   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000BA   0xEA5F 0x0249      LSLS     R2,R9,#+1
   \   000000BE   0x1D12             ADDS     R2,R2,#+4
   \   000000C0   0x4091             LSLS     R1,R1,R2
   \   000000C2   0x4308             ORRS     R0,R1,R0
   \   000000C4   0xF8C8 0x003C      STR      R0,[R8, #+60]
    393                       break;
   \   000000C8   0xE020             B.N      ??CSP_TmrOutCmpCfg_11
    394                                   
    395                  case CSP_TMR_OPT_PIN_OUT_SET:
    396                       DEF_BIT_SET(p_tmr_reg->EMR, DEF_BIT_MASK(2u, (2u * match_nbr) + 4u));
   \                     ??CSP_TmrOutCmpCfg_7: (+1)
   \   000000CA   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   000000CE   0x2102             MOVS     R1,#+2
   \   000000D0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D4   0xEA5F 0x0249      LSLS     R2,R9,#+1
   \   000000D8   0x1D12             ADDS     R2,R2,#+4
   \   000000DA   0x4091             LSLS     R1,R1,R2
   \   000000DC   0x4308             ORRS     R0,R1,R0
   \   000000DE   0xF8C8 0x003C      STR      R0,[R8, #+60]
    397                       break;
   \   000000E2   0xE013             B.N      ??CSP_TmrOutCmpCfg_11
    398                  
    399                  case CSP_TMR_OPT_PIN_OUT_TOGGLE:
    400                       DEF_BIT_SET(p_tmr_reg->EMR, DEF_BIT_MASK(3u, (2u * match_nbr) + 4u));
   \                     ??CSP_TmrOutCmpCfg_9: (+1)
   \   000000E4   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   000000E8   0x2103             MOVS     R1,#+3
   \   000000EA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000EE   0xEA5F 0x0249      LSLS     R2,R9,#+1
   \   000000F2   0x1D12             ADDS     R2,R2,#+4
   \   000000F4   0x4091             LSLS     R1,R1,R2
   \   000000F6   0x4308             ORRS     R0,R1,R0
   \   000000F8   0xF8C8 0x003C      STR      R0,[R8, #+60]
    401                       break;
   \   000000FC   0xE006             B.N      ??CSP_TmrOutCmpCfg_11
    402                       
    403                  default:
    404                       CPU_CRITICAL_EXIT();
   \                     ??CSP_TmrOutCmpCfg_10: (+1)
   \   000000FE   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000102   0x4658             MOV      R0,R11
   \   00000104   0x.... 0x....      BL       CPU_SR_Restore
    405                       return (DEF_FAIL);            
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0xE035             B.N      ??CSP_TmrOutCmpCfg_1
    406              }
    407                                                                      /* Disable the Interrupt, Reset and Stop features on   */        
    408                                                                      /* ... Match channel 0, 1, 2 or 3.                     */
    409              DEF_BIT_CLR(p_tmr_reg->MCR, CSP_TMR_MASK_MCR_MRx(match_nbr));
   \                     ??CSP_TmrOutCmpCfg_11: (+1)
   \   0000010C   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   00000110   0x2107             MOVS     R1,#+7
   \   00000112   0x2203             MOVS     R2,#+3
   \   00000114   0xFB02 0xF209      MUL      R2,R2,R9
   \   00000118   0x4091             LSLS     R1,R1,R2
   \   0000011A   0x4388             BICS     R0,R0,R1
   \   0000011C   0xF8C8 0x0014      STR      R0,[R8, #+20]
    410                                          
    411              DEF_BIT_CLR(p_tmr_reg->TCR, CSP_TMR_MASK_TCR_MODE);     /* Clear the Mode                                      */
   \   00000120   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000124   0x0880             LSRS     R0,R0,#+2
   \   00000126   0x0080             LSLS     R0,R0,#+2
   \   00000128   0xF8C8 0x0004      STR      R0,[R8, #+4]
    412              DEF_BIT_SET(p_tmr_reg->TCR, CSP_TMR_BIT_TCR_TMR_MODE);  /* Set the Timer Mode                                  */
   \   0000012C   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000130   0xF8C8 0x0004      STR      R0,[R8, #+4]
    413          
    414              p_tmr_reg->PR             = 0u;                         /* Set the prescaler to 0                              */
   \   00000134   0x2000             MOVS     R0,#+0
   \   00000136   0xF8C8 0x000C      STR      R0,[R8, #+12]
    415              p_tmr_reg->MRx[match_nbr] = match_val;
   \   0000013A   0x9801             LDR      R0,[SP, #+4]
   \   0000013C   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000140   0xEB18 0x0189      ADDS     R1,R8,R9, LSL #+2
   \   00000144   0x6188             STR      R0,[R1, #+24]
    416              p_tmr_reg->TCR            = CSP_TMR_BIT_CR_RST;         /* Reset the timer                                     */
   \   00000146   0x2002             MOVS     R0,#+2
   \   00000148   0xF8C8 0x0004      STR      R0,[R8, #+4]
    417                                                                      /* Enable Interrupt and Reset when TC matches MR0, ... */
    418                                                                      /* MR1, MR2, etc                                       */
    419              DEF_BIT_SET(p_tmr_reg->MCR, CSP_TMR_BIT_MCR_MRIx(match_nbr) | 
    420                                          CSP_TMR_BIT_MCR_MRRx(match_nbr));
   \   0000014C   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   00000150   0x2101             MOVS     R1,#+1
   \   00000152   0x2203             MOVS     R2,#+3
   \   00000154   0xFB02 0xF209      MUL      R2,R2,R9
   \   00000158   0x4091             LSLS     R1,R1,R2
   \   0000015A   0x2202             MOVS     R2,#+2
   \   0000015C   0x2303             MOVS     R3,#+3
   \   0000015E   0xFB03 0xF309      MUL      R3,R3,R9
   \   00000162   0x409A             LSLS     R2,R2,R3
   \   00000164   0x4311             ORRS     R1,R2,R1
   \   00000166   0x4308             ORRS     R0,R1,R0
   \   00000168   0xF8C8 0x0014      STR      R0,[R8, #+20]
    421              CPU_CRITICAL_EXIT();
   \   0000016C   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000170   0x4658             MOV      R0,R11
   \   00000172   0x.... 0x....      BL       CPU_SR_Restore
    422          
    423              return (DEF_OK);
   \   00000176   0x2001             MOVS     R0,#+1
   \                     ??CSP_TmrOutCmpCfg_1: (+1)
   \   00000178   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    424          }
    425          
    426          
    427          /*
    428          *********************************************************************************************************
    429          *                                           CSP_TmrIntClr()
    430          *
    431          * Description : Clear a periodic timer interrupt.
    432          *                   
    433          * Argument(s) : tmr_nbr    Timer number identifier.
    434          *                              CSP_TMR_NBR_00
    435          *                              CSP_TMR_NBR_01
    436          *                              CSP_TMR_NBR_02
    437          *                              CSP_TMR_NBR_03
    438          *
    439          * Return(s)   : none
    440          *
    441          * Caller(s)   : Application.
    442          *
    443          * Note(s)     : none.
    444          *********************************************************************************************************
    445          */
    446          

   \                                 In section .text, align 2, keep-with-next
    447          void  CSP_TmrIntClr (CSP_DEV_NBR tmr_nbr)
    448          {
   \                     CSP_TmrIntClr: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    449              CSP_TMR_REG  *p_tmr_reg;
    450              CSP_DEV_NBR   match_nbr;
    451              CPU_INT32U    reg_msk;
    452              CPU_INT32U    reg_stat;
    453              CPU_INT32U    reg_clr;
    454              
    455          
    456          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)         
    457              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x2804             CMP      R0,#+4
   \   00000006   0xDA40             BGE.N    ??CSP_TmrIntClr_0
    458                  return;
    459              }
    460          #endif
    461              
    462              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrIntClr_1: (+1)
   \   00000008   0x....             LDR.N    R6,??DataTable8
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   00000010   0x0031             MOVS     R1,R6
    463              reg_clr   = DEF_BIT_NONE;
   \   00000012   0x2600             MOVS     R6,#+0
   \   00000014   0x0035             MOVS     R5,R6
    464              reg_msk   = p_tmr_reg->MCR;
   \   00000016   0x694E             LDR      R6,[R1, #+20]
   \   00000018   0x0033             MOVS     R3,R6
    465              reg_stat  = p_tmr_reg->IR;
   \   0000001A   0x680E             LDR      R6,[R1, #+0]
   \   0000001C   0x0034             MOVS     R4,R6
    466              
    467              for (match_nbr =  CSP_TMR_MATCH_NBR_00; match_nbr < CSP_TMR_MATCH_NBR_03; match_nbr++) {
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0x0032             MOVS     R2,R6
   \                     ??CSP_TmrIntClr_2: (+1)
   \   00000022   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000024   0x2A03             CMP      R2,#+3
   \   00000026   0xDA2F             BGE.N    ??CSP_TmrIntClr_3
    468                  if ((DEF_BIT_IS_SET(reg_msk,  CSP_TMR_BIT_MCR_MRIx(match_nbr)) == DEF_YES) &&
    469                      (DEF_BIT_IS_SET(reg_stat, DEF_BIT(match_nbr))              == DEF_YES)) {
   \   00000028   0x2601             MOVS     R6,#+1
   \   0000002A   0x2703             MOVS     R7,#+3
   \   0000002C   0xFB07 0xF702      MUL      R7,R7,R2
   \   00000030   0x40BE             LSLS     R6,R6,R7
   \   00000032   0x2E00             CMP      R6,#+0
   \   00000034   0xD010             BEQ.N    ??CSP_TmrIntClr_4
   \   00000036   0x2601             MOVS     R6,#+1
   \   00000038   0x2703             MOVS     R7,#+3
   \   0000003A   0xFB07 0xF702      MUL      R7,R7,R2
   \   0000003E   0x40BE             LSLS     R6,R6,R7
   \   00000040   0x401E             ANDS     R6,R6,R3
   \   00000042   0x2701             MOVS     R7,#+1
   \   00000044   0xF05F 0x0C03      MOVS     R12,#+3
   \   00000048   0xFB0C 0xFC02      MUL      R12,R12,R2
   \   0000004C   0xFA17 0xF70C      LSLS     R7,R7,R12
   \   00000050   0x42BE             CMP      R6,R7
   \   00000052   0xD101             BNE.N    ??CSP_TmrIntClr_4
   \   00000054   0x2601             MOVS     R6,#+1
   \   00000056   0xE000             B.N      ??CSP_TmrIntClr_5
   \                     ??CSP_TmrIntClr_4: (+1)
   \   00000058   0x2600             MOVS     R6,#+0
   \                     ??CSP_TmrIntClr_5: (+1)
   \   0000005A   0x2E01             CMP      R6,#+1
   \   0000005C   0xD112             BNE.N    ??CSP_TmrIntClr_6
   \   0000005E   0x2601             MOVS     R6,#+1
   \   00000060   0x4096             LSLS     R6,R6,R2
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD008             BEQ.N    ??CSP_TmrIntClr_7
   \   00000066   0x2601             MOVS     R6,#+1
   \   00000068   0x4096             LSLS     R6,R6,R2
   \   0000006A   0x4026             ANDS     R6,R6,R4
   \   0000006C   0x2701             MOVS     R7,#+1
   \   0000006E   0x4097             LSLS     R7,R7,R2
   \   00000070   0x42BE             CMP      R6,R7
   \   00000072   0xD101             BNE.N    ??CSP_TmrIntClr_7
   \   00000074   0x2601             MOVS     R6,#+1
   \   00000076   0xE000             B.N      ??CSP_TmrIntClr_8
   \                     ??CSP_TmrIntClr_7: (+1)
   \   00000078   0x2600             MOVS     R6,#+0
   \                     ??CSP_TmrIntClr_8: (+1)
   \   0000007A   0x2E01             CMP      R6,#+1
   \   0000007C   0xD102             BNE.N    ??CSP_TmrIntClr_6
    470                      DEF_BIT_SET(reg_clr, DEF_BIT(match_nbr));
   \   0000007E   0x2601             MOVS     R6,#+1
   \   00000080   0x4096             LSLS     R6,R6,R2
   \   00000082   0x4335             ORRS     R5,R6,R5
    471                  }
    472              }
   \                     ??CSP_TmrIntClr_6: (+1)
   \   00000084   0x1C52             ADDS     R2,R2,#+1
   \   00000086   0xE7CC             B.N      ??CSP_TmrIntClr_2
    473                  
    474              p_tmr_reg->IR = reg_clr;
   \                     ??CSP_TmrIntClr_3: (+1)
   \   00000088   0x600D             STR      R5,[R1, #+0]
    475          }
   \                     ??CSP_TmrIntClr_0: (+1)
   \   0000008A   0xBCF0             POP      {R4-R7}
   \   0000008C   0x4770             BX       LR               ;; return
    476          
    477          /*
    478          *********************************************************************************************************
    479          *                                        CSP_TmrRst()
    480          *
    481          * Description : Resets a timer
    482          *                   
    483          * Argument(s) : tmr_nbr    Timer number identifier.
    484          *                              CSP_TMR_NBR_00
    485          *                              CSP_TMR_NBR_01
    486          *                              CSP_TMR_NBR_02
    487          *                              CSP_TMR_NBR_03
    488          *
    489          * Return(s)   : none
    490          *
    491          * Caller(s)   : Application.
    492          *
    493          * Note(s)     : none.
    494          *********************************************************************************************************
    495          */
    496          

   \                                 In section .text, align 2, keep-with-next
    497          void  CSP_TmrRst (CSP_DEV_NBR  tmr_nbr)
    498          {
   \                     CSP_TmrRst: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    499              CSP_TMR_REG  *p_tmr_reg;
    500              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    501              
    502          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    503              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C04             CMP      R4,#+4
   \   0000000A   0xDA10             BGE.N    ??CSP_TmrRst_0
    504                  return;    
    505              }
    506          #endif
    507              
    508              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrRst_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable8
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x0005             MOVS     R5,R0
    509              
    510              CPU_CRITICAL_ENTER();
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStart
    511              p_tmr_reg->TCR = CSP_TMR_BIT_CR_RST;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x6068             STR      R0,[R5, #+4]
    512              CPU_CRITICAL_EXIT();       
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       CPU_SR_Restore
    513          }
   \                     ??CSP_TmrRst_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    514          
    515          
    516          /*
    517          *********************************************************************************************************
    518          *                                          CSP_TmrRd()
    519          *
    520          * Description : Read the current value of a timer.
    521          *                   
    522          * Argument(s) : tmr_nbr    Timer number identifier.
    523          *                              CSP_TMR_NBR_00
    524          *                              CSP_TMR_NBR_01
    525          *                              CSP_TMR_NBR_02
    526          *                              CSP_TMR_NBR_03
    527          *
    528          * Return(s)   : The current value of the timer.
    529          *
    530          * Caller(s)   : Application.
    531          *
    532          * Note(s)     : none.
    533          *********************************************************************************************************
    534          */
    535          

   \                                 In section .text, align 2, keep-with-next
    536          CSP_TMR_VAL  CSP_TmrRd  (CSP_DEV_NBR  tmr_nbr)
    537          {
   \                     CSP_TmrRd: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    538              CSP_TMR_VAL  tmr_val;
    539              CSP_TMR_REG *p_tmr_reg;
    540          
    541          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    542              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000002   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000004   0x2904             CMP      R1,#+4
   \   00000006   0xDB01             BLT.N    ??CSP_TmrRd_0
    543                  return ((CSP_TMR_VAL)(0u));
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE007             B.N      ??CSP_TmrRd_1
    544              }
    545          #endif
    546              
    547              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrRd_0: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable8
   \   0000000E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000010   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000014   0x0003             MOVS     R3,R0
    548                    
    549              tmr_val = p_tmr_reg->TC;
   \   00000016   0x6898             LDR      R0,[R3, #+8]
   \   00000018   0x0002             MOVS     R2,R0
    550              return (tmr_val);
   \   0000001A   0x0010             MOVS     R0,R2
   \                     ??CSP_TmrRd_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    551          }
    552          
    553          /*
    554          *********************************************************************************************************
    555          *                                     CSP_TmrStart()
    556          *
    557          * Description : Start a timer.
    558          *                   
    559          * Argument(s) : tmr_nbr    Timer number identifier.
    560          *                              CSP_TMR_NBR_00
    561          *                              CSP_TMR_NBR_01
    562          *                              CSP_TMR_NBR_02
    563          *                              CSP_TMR_NBR_03
    564          *
    565          * Return(s)   : none
    566          *
    567          * Caller(s)   : Application.
    568          *
    569          * Note(s)     : none.
    570          *********************************************************************************************************
    571          */
    572          

   \                                 In section .text, align 2, keep-with-next
    573          void  CSP_TmrStart (CSP_DEV_NBR  tmr_nbr)
    574          {
   \                     CSP_TmrStart: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    575              CSP_TMR_REG *p_tmr_reg;    
    576              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    577          
    578          
    579          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    580              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C04             CMP      R4,#+4
   \   0000000A   0xDA10             BGE.N    ??CSP_TmrStart_0
    581                  return;
    582              }
    583          #endif
    584              
    585              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrStart_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable8
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x0005             MOVS     R5,R0
    586              
    587              CPU_CRITICAL_ENTER();
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStart
    588              p_tmr_reg->TCR = CSP_TMR_BIT_CR_START;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x6068             STR      R0,[R5, #+4]
    589              CPU_CRITICAL_EXIT();    
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       CPU_SR_Restore
    590          }
   \                     ??CSP_TmrStart_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    591          
    592          
    593          /*
    594          *********************************************************************************************************
    595          *                                        CSP_TmrStop()
    596          *
    597          * Description : Stop a Timer.
    598          *                   
    599          * Argument(s) : tmr_nbr    Timer number identifier.
    600          *
    601          * Return(s)   : none
    602          *
    603          * Caller(s)   : Application.
    604          *
    605          * Note(s)     : none.
    606          *********************************************************************************************************
    607          */
    608          

   \                                 In section .text, align 2, keep-with-next
    609          void  CSP_TmrStop (CSP_DEV_NBR  tmr_nbr)
    610          {
   \                     CSP_TmrStop: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    611              CSP_TMR_REG *p_tmr_reg;    
    612              CPU_SR_ALLOC();
   \   00000004   0x2600             MOVS     R6,#+0
    613              
    614          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    615              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000006   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000008   0x2C04             CMP      R4,#+4
   \   0000000A   0xDA10             BGE.N    ??CSP_TmrStop_0
    616                  return;
    617              }
    618          #endif
    619              
    620              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrStop_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable8
   \   0000000E   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000010   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000014   0x0005             MOVS     R5,R0
    621              
    622              CPU_CRITICAL_ENTER();
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x0006             MOVS     R6,R0
   \   0000001C   0x.... 0x....      BL       CPU_IntDisMeasStart
    623              p_tmr_reg->TCR = 0u;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x6068             STR      R0,[R5, #+4]
    624              CPU_CRITICAL_EXIT();    
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0x.... 0x....      BL       CPU_SR_Restore
    625          }
   \                     ??CSP_TmrStop_0: (+1)
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    626          
    627          /*
    628          *********************************************************************************************************
    629          *                                         CSP_TmrWr()
    630          *
    631          * Description : Write a value to the timer.
    632          *                   
    633          * Argument(s) : tmr_nbr    Timer number identifier.
    634          *
    635          *               tmr_val    value to write.
    636          *
    637          * Return(s)   : none
    638          *
    639          * Caller(s)   : Application.
    640          *
    641          * Note(s)     : none.
    642          *********************************************************************************************************
    643          */
    644          

   \                                 In section .text, align 2, keep-with-next
    645          void  CSP_TmrWr  (CSP_DEV_NBR  tmr_nbr,
    646                            CSP_TMR_VAL  tmr_val)
    647          {
   \                     CSP_TmrWr: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    648              CSP_TMR_REG *p_tmr_reg;    
    649              CPU_SR_ALLOC();
   \   00000006   0x2700             MOVS     R7,#+0
    650              
    651          #if (CSP_CFG_ARG_CHK_EN == DEF_ENABLED)
    652              if (tmr_nbr > CSP_TMR_NBR_03) {
   \   00000008   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000A   0x2C04             CMP      R4,#+4
   \   0000000C   0xDA0F             BGE.N    ??CSP_TmrWr_0
    653                  return;
    654              }
    655          #endif
    656              
    657              p_tmr_reg = (CSP_TMR_REG *)CSP_TmrAddrTbl[tmr_nbr];
   \                     ??CSP_TmrWr_1: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable8
   \   00000010   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000012   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000016   0x0006             MOVS     R6,R0
    658              
    659              CPU_CRITICAL_ENTER();
   \   00000018   0x.... 0x....      BL       CPU_SR_Save
   \   0000001C   0x0007             MOVS     R7,R0
   \   0000001E   0x.... 0x....      BL       CPU_IntDisMeasStart
    660              p_tmr_reg->TCR = tmr_val;
   \   00000022   0x6075             STR      R5,[R6, #+4]
    661              CPU_CRITICAL_EXIT();    
   \   00000024   0x.... 0x....      BL       CPU_IntDisMeasStop
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0x.... 0x....      BL       CPU_SR_Restore
    662          }
   \                     ??CSP_TmrWr_0: (+1)
   \   0000002E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     CSP_TmrAddrTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     CSP_TmrPerTbl

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   CSP_TmrCfg
        32   -> CPU_IntDisMeasStart
        32   -> CPU_IntDisMeasStop
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> CSP_PM_PerClkEn
        32   -> CSP_PM_PerClkFreqGet
      24   CSP_TmrInit
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> CSP_PM_PerClkDis
        24   -> CSP_PM_PerClkEn
      16   CSP_TmrIntClr
      48   CSP_TmrOutCmpCfg
        48   -> CPU_IntDisMeasStart
        48   -> CPU_IntDisMeasStop
        48   -> CPU_SR_Restore
        48   -> CPU_SR_Save
        48   -> CSP_PM_PerClkEn
        48   -> CSP_PM_PerClkFreqGet
       0   CSP_TmrRd
      16   CSP_TmrRst
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   CSP_TmrStart
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      16   CSP_TmrStop
        16   -> CPU_IntDisMeasStart
        16   -> CPU_IntDisMeasStop
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
      24   CSP_TmrWr
        24   -> CPU_IntDisMeasStart
        24   -> CPU_IntDisMeasStop
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
      16  CSP_TmrAddrTbl
     224  CSP_TmrCfg
     112  CSP_TmrInit
     142  CSP_TmrIntClr
     380  CSP_TmrOutCmpCfg
       8  CSP_TmrPerTbl
      30  CSP_TmrRd
      48  CSP_TmrRst
      48  CSP_TmrStart
      48  CSP_TmrStop
      48  CSP_TmrWr

 
    24 bytes in section .rodata
 1 088 bytes in section .text
 
 1 088 bytes of CODE  memory
    24 bytes of CONST memory

Errors: none
Warnings: none
