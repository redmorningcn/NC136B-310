###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       07/Sep/2017  21:02:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_mcpwm.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_mcpwm.c -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\lpc17xx_mcpwm.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\lpc17xx_mcpwm.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Software\CSB\source\lpc17xx_mcpwm.c
      1          /**********************************************************************
      2          * $Id$		lpc17xx_mcpwm.c				2010-05-21
      3          *//**
      4          * @file		lpc17xx_mcpwm.c
      5          * @brief	Contains all functions support for Motor Control PWM firmware
      6          * 			library on LPC17xx
      7          * @version	2.0
      8          * @date		21. May. 2010
      9          * @author	NXP MCU SW Application Team
     10          *
     11          * Copyright(C) 2010, NXP Semiconductor
     12          * All rights reserved.
     13          *
     14          ***********************************************************************
     15          * Software that is described herein is for illustrative purposes only
     16          * which provides customers with programming information regarding the
     17          * products. This software is supplied "AS IS" without any warranties.
     18          * NXP Semiconductors assumes no responsibility or liability for the
     19          * use of the software, conveys no license or title under any patent,
     20          * copyright, or mask work right to the product. NXP Semiconductors
     21          * reserves the right to make changes in the software without
     22          * notification. NXP Semiconductors also make no representation or
     23          * warranty that such application will be suitable for the specified
     24          * use without further testing or modification.
     25          * Permission to use, copy, modify, and distribute this software and its
     26          * documentation is hereby granted, under NXP Semiconductors'
     27          * relevant copyright in the software, without fee, provided that it
     28          * is used in conjunction with NXP Semiconductors microcontrollers.  This
     29          * copyright, permission, and disclaimer notice must appear in all copies of
     30          * this code.
     31          **********************************************************************/
     32          
     33          /* Peripheral group ----------------------------------------------------------- */
     34          /** @addtogroup MCPWM
     35           * @{
     36           */
     37          
     38          /* Includes ------------------------------------------------------------------- */
     39          #include "lpc17xx_mcpwm.h"
     40          #include "lpc17xx_clkpwr.h"
     41          
     42          /* If this source file built with example, the LPC17xx FW library configuration
     43           * file in each example directory ("lpc17xx_libcfg.h") must be included,
     44           * otherwise the default FW library configuration file must be included instead
     45           */
     46          #ifdef __BUILD_WITH_EXAMPLE__
     47          #include "lpc17xx_libcfg.h"
     48          #else
     49          #include "lpc17xx_libcfg_default.h"
     50          #endif /* __BUILD_WITH_EXAMPLE__ */
     51          
     52          
     53          #ifdef _MCPWM
     54          
     55          /* Public Functions ----------------------------------------------------------- */
     56          /** @addtogroup MCPWM_Public_Functions
     57           * @{
     58           */
     59          
     60          /*********************************************************************//**
     61           * @brief		Initializes the MCPWM peripheral
     62           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected,
     63           * 				Should be: LPC_MCPWM
     64           * @return		None
     65           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     66          void MCPWM_Init(LPC_MCPWM_TypeDef *MCPWMx)
     67          {
   \                     MCPWM_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     68          
     69          	/* Turn On MCPWM PCLK */
     70          	CLKPWR_ConfigPPWR (CLKPWR_PCONP_PCMC, ENABLE);
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0xF45F 0x3000      MOVS     R0,#+131072
   \   0000000A   0x.... 0x....      BL       CLKPWR_ConfigPPWR
     71          	/* As default, peripheral clock for MCPWM module
     72          	 * is set to FCCLK / 2 */
     73          	// CLKPWR_SetPCLKDiv(CLKPWR_PCLKSEL_MC, CLKPWR_PCLKSEL_CCLK_DIV_2);
     74          
     75          	MCPWMx->MCCAP_CLR = MCPWM_CAPCLR_CAP(0) | MCPWM_CAPCLR_CAP(1) | MCPWM_CAPCLR_CAP(2);
   \   0000000E   0x2007             MOVS     R0,#+7
   \   00000010   0x6760             STR      R0,[R4, #+116]
     76          	MCPWMx->MCINTFLAG_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
     77          							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
     78          							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
   \   00000012   0xF240 0x7077      MOVW     R0,#+1911
   \   00000016   0x6720             STR      R0,[R4, #+112]
     79          	MCPWMx->MCINTEN_CLR = MCPWM_INT_ILIM(0) | MCPWM_INT_ILIM(1) | MCPWM_INT_ILIM(2) \
     80          							| MCPWM_INT_IMAT(0) | MCPWM_INT_IMAT(1) | MCPWM_INT_IMAT(2) \
     81          							| MCPWM_INT_ICAP(0) | MCPWM_INT_ICAP(1) | MCPWM_INT_ICAP(2);
   \   00000018   0xF240 0x7077      MOVW     R0,#+1911
   \   0000001C   0x65A0             STR      R0,[R4, #+88]
     82          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     83          
     84          
     85          /*********************************************************************//**
     86           * @brief		Configures each channel in MCPWM peripheral according to the
     87           * 				specified parameters in the MCPWM_CHANNEL_CFG_Type.
     88           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected
     89           * 								should be: LPC_MCPWM
     90           * @param[in]	channelNum		Channel number, should be: 0..2.
     91           * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
     92          *                    			that contains the configuration information for the
     93          *                    			specified MCPWM channel.
     94           * @return		None
     95           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     96          void MCPWM_ConfigChannel(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
     97          						MCPWM_CHANNEL_CFG_Type * channelSetup)
     98          {
   \                     MCPWM_ConfigChannel: (+1)
   \   00000000   0xB410             PUSH     {R4}
     99          	if (channelNum <= 2) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xF080 0x8090      BCS.W    ??MCPWM_ConfigChannel_0
    100          		if (channelNum == 0) {
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD106             BNE.N    ??MCPWM_ConfigChannel_1
    101          			MCPWMx->MCTIM0 = channelSetup->channelTimercounterValue;
   \   0000000C   0x6953             LDR      R3,[R2, #+20]
   \   0000000E   0x6183             STR      R3,[R0, #+24]
    102          			MCPWMx->MCPER0 = channelSetup->channelPeriodValue;
   \   00000010   0x6993             LDR      R3,[R2, #+24]
   \   00000012   0x6243             STR      R3,[R0, #+36]
    103          			MCPWMx->MCPW0 = channelSetup->channelPulsewidthValue;
   \   00000014   0x69D3             LDR      R3,[R2, #+28]
   \   00000016   0x6303             STR      R3,[R0, #+48]
   \   00000018   0xE012             B.N      ??MCPWM_ConfigChannel_2
    104          		} else if (channelNum == 1) {
   \                     ??MCPWM_ConfigChannel_1: (+1)
   \   0000001A   0x2901             CMP      R1,#+1
   \   0000001C   0xD106             BNE.N    ??MCPWM_ConfigChannel_3
    105          			MCPWMx->MCTIM1 = channelSetup->channelTimercounterValue;
   \   0000001E   0x6953             LDR      R3,[R2, #+20]
   \   00000020   0x61C3             STR      R3,[R0, #+28]
    106          			MCPWMx->MCPER1 = channelSetup->channelPeriodValue;
   \   00000022   0x6993             LDR      R3,[R2, #+24]
   \   00000024   0x6283             STR      R3,[R0, #+40]
    107          			MCPWMx->MCPW1 = channelSetup->channelPulsewidthValue;
   \   00000026   0x69D3             LDR      R3,[R2, #+28]
   \   00000028   0x6343             STR      R3,[R0, #+52]
   \   0000002A   0xE009             B.N      ??MCPWM_ConfigChannel_2
    108          		} else if (channelNum == 2) {
   \                     ??MCPWM_ConfigChannel_3: (+1)
   \   0000002C   0x2902             CMP      R1,#+2
   \   0000002E   0xD106             BNE.N    ??MCPWM_ConfigChannel_4
    109          			MCPWMx->MCTIM2 = channelSetup->channelTimercounterValue;
   \   00000030   0x6953             LDR      R3,[R2, #+20]
   \   00000032   0x6203             STR      R3,[R0, #+32]
    110          			MCPWMx->MCPER2 = channelSetup->channelPeriodValue;
   \   00000034   0x6993             LDR      R3,[R2, #+24]
   \   00000036   0x62C3             STR      R3,[R0, #+44]
    111          			MCPWMx->MCPW2 = channelSetup->channelPulsewidthValue;
   \   00000038   0x69D3             LDR      R3,[R2, #+28]
   \   0000003A   0x6383             STR      R3,[R0, #+56]
   \   0000003C   0xE000             B.N      ??MCPWM_ConfigChannel_2
    112          		} else {
    113          			return;
   \                     ??MCPWM_ConfigChannel_4: (+1)
   \   0000003E   0xE073             B.N      ??MCPWM_ConfigChannel_5
    114          		}
    115          
    116          		if (channelSetup->channelType /* == MCPWM_CHANNEL_CENTER_MODE */){
   \                     ??MCPWM_ConfigChannel_2: (+1)
   \   00000040   0x6813             LDR      R3,[R2, #+0]
   \   00000042   0x2B00             CMP      R3,#+0
   \   00000044   0xD009             BEQ.N    ??MCPWM_ConfigChannel_6
    117          			MCPWMx->MCCON_SET = MCPWM_CON_CENTER(channelNum);
   \   00000046   0x2903             CMP      R1,#+3
   \   00000048   0xD204             BCS.N    ??MCPWM_ConfigChannel_7
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x00CC             LSLS     R4,R1,#+3
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
   \   00000050   0x40A3             LSLS     R3,R3,R4
   \   00000052   0xE000             B.N      ??MCPWM_ConfigChannel_8
   \                     ??MCPWM_ConfigChannel_7: (+1)
   \   00000054   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_8: (+1)
   \   00000056   0x6043             STR      R3,[R0, #+4]
   \   00000058   0xE008             B.N      ??MCPWM_ConfigChannel_9
    118          		} else {
    119          			MCPWMx->MCCON_CLR = MCPWM_CON_CENTER(channelNum);
   \                     ??MCPWM_ConfigChannel_6: (+1)
   \   0000005A   0x2903             CMP      R1,#+3
   \   0000005C   0xD204             BCS.N    ??MCPWM_ConfigChannel_10
   \   0000005E   0x2301             MOVS     R3,#+1
   \   00000060   0x00CC             LSLS     R4,R1,#+3
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0x40A3             LSLS     R3,R3,R4
   \   00000066   0xE000             B.N      ??MCPWM_ConfigChannel_11
   \                     ??MCPWM_ConfigChannel_10: (+1)
   \   00000068   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_11: (+1)
   \   0000006A   0x6083             STR      R3,[R0, #+8]
    120          		}
    121          
    122          		if (channelSetup->channelPolarity /* == MCPWM_CHANNEL_PASSIVE_HI */){
   \                     ??MCPWM_ConfigChannel_9: (+1)
   \   0000006C   0x6853             LDR      R3,[R2, #+4]
   \   0000006E   0x2B00             CMP      R3,#+0
   \   00000070   0xD009             BEQ.N    ??MCPWM_ConfigChannel_12
    123          			MCPWMx->MCCON_SET = MCPWM_CON_POLAR(channelNum);
   \   00000072   0x2903             CMP      R1,#+3
   \   00000074   0xD204             BCS.N    ??MCPWM_ConfigChannel_13
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0x00CC             LSLS     R4,R1,#+3
   \   0000007A   0x1CA4             ADDS     R4,R4,#+2
   \   0000007C   0x40A3             LSLS     R3,R3,R4
   \   0000007E   0xE000             B.N      ??MCPWM_ConfigChannel_14
   \                     ??MCPWM_ConfigChannel_13: (+1)
   \   00000080   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_14: (+1)
   \   00000082   0x6043             STR      R3,[R0, #+4]
   \   00000084   0xE008             B.N      ??MCPWM_ConfigChannel_15
    124          		} else {
    125          			MCPWMx->MCCON_CLR = MCPWM_CON_POLAR(channelNum);
   \                     ??MCPWM_ConfigChannel_12: (+1)
   \   00000086   0x2903             CMP      R1,#+3
   \   00000088   0xD204             BCS.N    ??MCPWM_ConfigChannel_16
   \   0000008A   0x2301             MOVS     R3,#+1
   \   0000008C   0x00CC             LSLS     R4,R1,#+3
   \   0000008E   0x1CA4             ADDS     R4,R4,#+2
   \   00000090   0x40A3             LSLS     R3,R3,R4
   \   00000092   0xE000             B.N      ??MCPWM_ConfigChannel_17
   \                     ??MCPWM_ConfigChannel_16: (+1)
   \   00000094   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_17: (+1)
   \   00000096   0x6083             STR      R3,[R0, #+8]
    126          		}
    127          
    128          		if (channelSetup->channelDeadtimeEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigChannel_15: (+1)
   \   00000098   0x6893             LDR      R3,[R2, #+8]
   \   0000009A   0x2B00             CMP      R3,#+0
   \   0000009C   0xD025             BEQ.N    ??MCPWM_ConfigChannel_18
    129          			MCPWMx->MCCON_SET = MCPWM_CON_DTE(channelNum);
   \   0000009E   0x2903             CMP      R1,#+3
   \   000000A0   0xD204             BCS.N    ??MCPWM_ConfigChannel_19
   \   000000A2   0x2301             MOVS     R3,#+1
   \   000000A4   0x00CC             LSLS     R4,R1,#+3
   \   000000A6   0x1CE4             ADDS     R4,R4,#+3
   \   000000A8   0x40A3             LSLS     R3,R3,R4
   \   000000AA   0xE000             B.N      ??MCPWM_ConfigChannel_20
   \                     ??MCPWM_ConfigChannel_19: (+1)
   \   000000AC   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_20: (+1)
   \   000000AE   0x6043             STR      R3,[R0, #+4]
    130          			MCPWMx->MCDEADTIME &= ~(MCPWM_DT(channelNum, 0x3FF));
   \   000000B0   0x2903             CMP      R1,#+3
   \   000000B2   0xD206             BCS.N    ??MCPWM_ConfigChannel_21
   \   000000B4   0xF240 0x33FF      MOVW     R3,#+1023
   \   000000B8   0x240A             MOVS     R4,#+10
   \   000000BA   0xFB04 0xF401      MUL      R4,R4,R1
   \   000000BE   0x40A3             LSLS     R3,R3,R4
   \   000000C0   0xE000             B.N      ??MCPWM_ConfigChannel_22
   \                     ??MCPWM_ConfigChannel_21: (+1)
   \   000000C2   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_22: (+1)
   \   000000C4   0x6BC4             LDR      R4,[R0, #+60]
   \   000000C6   0xEA34 0x0303      BICS     R3,R4,R3
   \   000000CA   0x63C3             STR      R3,[R0, #+60]
    131          			MCPWMx->MCDEADTIME |= MCPWM_DT(channelNum, channelSetup->channelDeadtimeValue);
   \   000000CC   0x2903             CMP      R1,#+3
   \   000000CE   0xD207             BCS.N    ??MCPWM_ConfigChannel_23
   \   000000D0   0x68D3             LDR      R3,[R2, #+12]
   \   000000D2   0x059B             LSLS     R3,R3,#+22       ;; ZeroExtS R3,R3,#+22,#+22
   \   000000D4   0x0D9B             LSRS     R3,R3,#+22
   \   000000D6   0x240A             MOVS     R4,#+10
   \   000000D8   0xFB04 0xF401      MUL      R4,R4,R1
   \   000000DC   0x40A3             LSLS     R3,R3,R4
   \   000000DE   0xE000             B.N      ??MCPWM_ConfigChannel_24
   \                     ??MCPWM_ConfigChannel_23: (+1)
   \   000000E0   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_24: (+1)
   \   000000E2   0x6BC4             LDR      R4,[R0, #+60]
   \   000000E4   0x4323             ORRS     R3,R3,R4
   \   000000E6   0x63C3             STR      R3,[R0, #+60]
   \   000000E8   0xE008             B.N      ??MCPWM_ConfigChannel_25
    132          		} else {
    133          			MCPWMx->MCCON_CLR = MCPWM_CON_DTE(channelNum);
   \                     ??MCPWM_ConfigChannel_18: (+1)
   \   000000EA   0x2903             CMP      R1,#+3
   \   000000EC   0xD204             BCS.N    ??MCPWM_ConfigChannel_26
   \   000000EE   0x2301             MOVS     R3,#+1
   \   000000F0   0x00CC             LSLS     R4,R1,#+3
   \   000000F2   0x1CE4             ADDS     R4,R4,#+3
   \   000000F4   0x40A3             LSLS     R3,R3,R4
   \   000000F6   0xE000             B.N      ??MCPWM_ConfigChannel_27
   \                     ??MCPWM_ConfigChannel_26: (+1)
   \   000000F8   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_27: (+1)
   \   000000FA   0x6083             STR      R3,[R0, #+8]
    134          		}
    135          
    136          		if (channelSetup->channelUpdateEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigChannel_25: (+1)
   \   000000FC   0x6913             LDR      R3,[R2, #+16]
   \   000000FE   0x2B00             CMP      R3,#+0
   \   00000100   0xD009             BEQ.N    ??MCPWM_ConfigChannel_28
    137          			MCPWMx->MCCON_CLR = MCPWM_CON_DISUP(channelNum);
   \   00000102   0x2903             CMP      R1,#+3
   \   00000104   0xD204             BCS.N    ??MCPWM_ConfigChannel_29
   \   00000106   0x2301             MOVS     R3,#+1
   \   00000108   0x00CC             LSLS     R4,R1,#+3
   \   0000010A   0x1D24             ADDS     R4,R4,#+4
   \   0000010C   0x40A3             LSLS     R3,R3,R4
   \   0000010E   0xE000             B.N      ??MCPWM_ConfigChannel_30
   \                     ??MCPWM_ConfigChannel_29: (+1)
   \   00000110   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_30: (+1)
   \   00000112   0x6083             STR      R3,[R0, #+8]
   \   00000114   0xE008             B.N      ??MCPWM_ConfigChannel_0
    138          		} else {
    139          			MCPWMx->MCCON_SET = MCPWM_CON_DISUP(channelNum);
   \                     ??MCPWM_ConfigChannel_28: (+1)
   \   00000116   0x2903             CMP      R1,#+3
   \   00000118   0xD204             BCS.N    ??MCPWM_ConfigChannel_31
   \   0000011A   0x2301             MOVS     R3,#+1
   \   0000011C   0x00CC             LSLS     R4,R1,#+3
   \   0000011E   0x1D24             ADDS     R4,R4,#+4
   \   00000120   0x40A3             LSLS     R3,R3,R4
   \   00000122   0xE000             B.N      ??MCPWM_ConfigChannel_32
   \                     ??MCPWM_ConfigChannel_31: (+1)
   \   00000124   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigChannel_32: (+1)
   \   00000126   0x6043             STR      R3,[R0, #+4]
    140          		}
    141          	}
    142          }
   \                     ??MCPWM_ConfigChannel_0: (+1)
   \                     ??MCPWM_ConfigChannel_5: (+1)
   \   00000128   0xBC10             POP      {R4}
   \   0000012A   0x4770             BX       LR               ;; return
    143          
    144          
    145          /*********************************************************************//**
    146           * @brief		Write to MCPWM shadow registers - Update the value for period
    147           * 				and pulse width in MCPWM peripheral.
    148           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected
    149           * 								Should be: LPC_MCPWM
    150           * @param[in]	channelNum		Channel Number, should be: 0..2.
    151           * @param[in]	channelSetup	Pointer to a MCPWM_CHANNEL_CFG_Type structure
    152          *                    			that contains the configuration information for the
    153          *                    			specified MCPWM channel.
    154           * @return		None
    155           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          void MCPWM_WriteToShadow(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    157          								MCPWM_CHANNEL_CFG_Type *channelSetup)
    158          {
    159          	if (channelNum == 0){
   \                     MCPWM_WriteToShadow: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD104             BNE.N    ??MCPWM_WriteToShadow_0
    160          		MCPWMx->MCPER0 = channelSetup->channelPeriodValue;
   \   00000004   0x6993             LDR      R3,[R2, #+24]
   \   00000006   0x6243             STR      R3,[R0, #+36]
    161          		MCPWMx->MCPW0 = channelSetup->channelPulsewidthValue;
   \   00000008   0x69D3             LDR      R3,[R2, #+28]
   \   0000000A   0x6303             STR      R3,[R0, #+48]
   \   0000000C   0xE00C             B.N      ??MCPWM_WriteToShadow_1
    162          	} else if (channelNum == 1) {
   \                     ??MCPWM_WriteToShadow_0: (+1)
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD104             BNE.N    ??MCPWM_WriteToShadow_2
    163          		MCPWMx->MCPER1 = channelSetup->channelPeriodValue;
   \   00000012   0x6993             LDR      R3,[R2, #+24]
   \   00000014   0x6283             STR      R3,[R0, #+40]
    164          		MCPWMx->MCPW1 = channelSetup->channelPulsewidthValue;
   \   00000016   0x69D3             LDR      R3,[R2, #+28]
   \   00000018   0x6343             STR      R3,[R0, #+52]
   \   0000001A   0xE005             B.N      ??MCPWM_WriteToShadow_1
    165          	} else if (channelNum == 2) {
   \                     ??MCPWM_WriteToShadow_2: (+1)
   \   0000001C   0x2902             CMP      R1,#+2
   \   0000001E   0xD103             BNE.N    ??MCPWM_WriteToShadow_1
    166          		MCPWMx->MCPER2 = channelSetup->channelPeriodValue;
   \   00000020   0x6993             LDR      R3,[R2, #+24]
   \   00000022   0x62C3             STR      R3,[R0, #+44]
    167          		MCPWMx->MCPW2 = channelSetup->channelPulsewidthValue;
   \   00000024   0x69D3             LDR      R3,[R2, #+28]
   \   00000026   0x6383             STR      R3,[R0, #+56]
    168          	}
    169          }
   \                     ??MCPWM_WriteToShadow_1: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    170          
    171          
    172          
    173          /*********************************************************************//**
    174           * @brief		Configures capture function in MCPWM peripheral
    175           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected
    176           * 								Should be: LPC_MCPWM
    177           * @param[in]	channelNum		MCI (Motor Control Input pin) number
    178           * 								Should be: 0..2
    179           * @param[in]	captureConfig	Pointer to a MCPWM_CAPTURE_CFG_Type structure
    180          *                    			that contains the configuration information for the
    181          *                    			specified MCPWM capture.
    182           * @return
    183           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    184          void MCPWM_ConfigCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    185          						MCPWM_CAPTURE_CFG_Type *captureConfig)
    186          {
   \                     MCPWM_ConfigCapture: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    187          	if (channelNum <= 2) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xD277             BCS.N    ??MCPWM_ConfigCapture_0
    188          
    189          		if (captureConfig->captureFalling /* == ENABLE */) {
   \   00000006   0x6893             LDR      R3,[R2, #+8]
   \   00000008   0x2B00             CMP      R3,#+0
   \   0000000A   0xD012             BEQ.N    ??MCPWM_ConfigCapture_1
    190          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_FE(captureConfig->captureChannel, channelNum);
   \   0000000C   0x6813             LDR      R3,[R2, #+0]
   \   0000000E   0x2B03             CMP      R3,#+3
   \   00000010   0xD20C             BCS.N    ??MCPWM_ConfigCapture_2
   \   00000012   0x2903             CMP      R1,#+3
   \   00000014   0xD20A             BCS.N    ??MCPWM_ConfigCapture_2
   \   00000016   0x2301             MOVS     R3,#+1
   \   00000018   0x6814             LDR      R4,[R2, #+0]
   \   0000001A   0x2506             MOVS     R5,#+6
   \   0000001C   0x000E             MOVS     R6,R1
   \   0000001E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000020   0x0076             LSLS     R6,R6,#+1
   \   00000022   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x40A3             LSLS     R3,R3,R4
   \   0000002A   0xE000             B.N      ??MCPWM_ConfigCapture_3
   \                     ??MCPWM_ConfigCapture_2: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_3: (+1)
   \   0000002E   0x6103             STR      R3,[R0, #+16]
   \   00000030   0xE011             B.N      ??MCPWM_ConfigCapture_4
    191          		} else {
    192          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_FE(captureConfig->captureChannel, channelNum);
   \                     ??MCPWM_ConfigCapture_1: (+1)
   \   00000032   0x6813             LDR      R3,[R2, #+0]
   \   00000034   0x2B03             CMP      R3,#+3
   \   00000036   0xD20C             BCS.N    ??MCPWM_ConfigCapture_5
   \   00000038   0x2903             CMP      R1,#+3
   \   0000003A   0xD20A             BCS.N    ??MCPWM_ConfigCapture_5
   \   0000003C   0x2301             MOVS     R3,#+1
   \   0000003E   0x6814             LDR      R4,[R2, #+0]
   \   00000040   0x2506             MOVS     R5,#+6
   \   00000042   0x000E             MOVS     R6,R1
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0x0076             LSLS     R6,R6,#+1
   \   00000048   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   0000004C   0x1C64             ADDS     R4,R4,#+1
   \   0000004E   0x40A3             LSLS     R3,R3,R4
   \   00000050   0xE000             B.N      ??MCPWM_ConfigCapture_6
   \                     ??MCPWM_ConfigCapture_5: (+1)
   \   00000052   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_6: (+1)
   \   00000054   0x6143             STR      R3,[R0, #+20]
    193          		}
    194          
    195          		if (captureConfig->captureRising /* == ENABLE */) {
   \                     ??MCPWM_ConfigCapture_4: (+1)
   \   00000056   0x6853             LDR      R3,[R2, #+4]
   \   00000058   0x2B00             CMP      R3,#+0
   \   0000005A   0xD00F             BEQ.N    ??MCPWM_ConfigCapture_7
    196          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_CAPMCI_RE(captureConfig->captureChannel, channelNum);
   \   0000005C   0x6813             LDR      R3,[R2, #+0]
   \   0000005E   0x2B03             CMP      R3,#+3
   \   00000060   0xD209             BCS.N    ??MCPWM_ConfigCapture_8
   \   00000062   0x2903             CMP      R1,#+3
   \   00000064   0xD207             BCS.N    ??MCPWM_ConfigCapture_8
   \   00000066   0x2301             MOVS     R3,#+1
   \   00000068   0x6814             LDR      R4,[R2, #+0]
   \   0000006A   0x2506             MOVS     R5,#+6
   \   0000006C   0x004E             LSLS     R6,R1,#+1
   \   0000006E   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000072   0x40A3             LSLS     R3,R3,R4
   \   00000074   0xE000             B.N      ??MCPWM_ConfigCapture_9
   \                     ??MCPWM_ConfigCapture_8: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_9: (+1)
   \   00000078   0x6103             STR      R3,[R0, #+16]
   \   0000007A   0xE00E             B.N      ??MCPWM_ConfigCapture_10
    197          		} else {
    198          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_CAPMCI_RE(captureConfig->captureChannel, channelNum);
   \                     ??MCPWM_ConfigCapture_7: (+1)
   \   0000007C   0x6813             LDR      R3,[R2, #+0]
   \   0000007E   0x2B03             CMP      R3,#+3
   \   00000080   0xD209             BCS.N    ??MCPWM_ConfigCapture_11
   \   00000082   0x2903             CMP      R1,#+3
   \   00000084   0xD207             BCS.N    ??MCPWM_ConfigCapture_11
   \   00000086   0x2301             MOVS     R3,#+1
   \   00000088   0x6814             LDR      R4,[R2, #+0]
   \   0000008A   0x2506             MOVS     R5,#+6
   \   0000008C   0x004E             LSLS     R6,R1,#+1
   \   0000008E   0xFB05 0x6404      MLA      R4,R5,R4,R6
   \   00000092   0x40A3             LSLS     R3,R3,R4
   \   00000094   0xE000             B.N      ??MCPWM_ConfigCapture_12
   \                     ??MCPWM_ConfigCapture_11: (+1)
   \   00000096   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_12: (+1)
   \   00000098   0x6143             STR      R3,[R0, #+20]
    199          		}
    200          
    201          		if (captureConfig->timerReset /* == ENABLE */){
   \                     ??MCPWM_ConfigCapture_10: (+1)
   \   0000009A   0x68D3             LDR      R3,[R2, #+12]
   \   0000009C   0x2B00             CMP      R3,#+0
   \   0000009E   0xD00A             BEQ.N    ??MCPWM_ConfigCapture_13
    202          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_RT(captureConfig->captureChannel);
   \   000000A0   0x6813             LDR      R3,[R2, #+0]
   \   000000A2   0x2B03             CMP      R3,#+3
   \   000000A4   0xD204             BCS.N    ??MCPWM_ConfigCapture_14
   \   000000A6   0x2301             MOVS     R3,#+1
   \   000000A8   0x6814             LDR      R4,[R2, #+0]
   \   000000AA   0x3412             ADDS     R4,R4,#+18
   \   000000AC   0x40A3             LSLS     R3,R3,R4
   \   000000AE   0xE000             B.N      ??MCPWM_ConfigCapture_15
   \                     ??MCPWM_ConfigCapture_14: (+1)
   \   000000B0   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_15: (+1)
   \   000000B2   0x6103             STR      R3,[R0, #+16]
   \   000000B4   0xE009             B.N      ??MCPWM_ConfigCapture_16
    203          		} else {
    204          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_RT(captureConfig->captureChannel);
   \                     ??MCPWM_ConfigCapture_13: (+1)
   \   000000B6   0x6813             LDR      R3,[R2, #+0]
   \   000000B8   0x2B03             CMP      R3,#+3
   \   000000BA   0xD204             BCS.N    ??MCPWM_ConfigCapture_17
   \   000000BC   0x2301             MOVS     R3,#+1
   \   000000BE   0x6814             LDR      R4,[R2, #+0]
   \   000000C0   0x3412             ADDS     R4,R4,#+18
   \   000000C2   0x40A3             LSLS     R3,R3,R4
   \   000000C4   0xE000             B.N      ??MCPWM_ConfigCapture_18
   \                     ??MCPWM_ConfigCapture_17: (+1)
   \   000000C6   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_18: (+1)
   \   000000C8   0x6143             STR      R3,[R0, #+20]
    205          		}
    206          
    207          		if (captureConfig->hnfEnable /* == ENABLE */){
   \                     ??MCPWM_ConfigCapture_16: (+1)
   \   000000CA   0x6913             LDR      R3,[R2, #+16]
   \   000000CC   0x2B00             CMP      R3,#+0
   \   000000CE   0xD009             BEQ.N    ??MCPWM_ConfigCapture_19
    208          			MCPWMx->MCCAPCON_SET = MCPWM_CAPCON_HNFCAP(channelNum);
   \   000000D0   0x2903             CMP      R1,#+3
   \   000000D2   0xD204             BCS.N    ??MCPWM_ConfigCapture_20
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0xF111 0x0415      ADDS     R4,R1,#+21
   \   000000DA   0x40A3             LSLS     R3,R3,R4
   \   000000DC   0xE000             B.N      ??MCPWM_ConfigCapture_21
   \                     ??MCPWM_ConfigCapture_20: (+1)
   \   000000DE   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_21: (+1)
   \   000000E0   0x6103             STR      R3,[R0, #+16]
   \   000000E2   0xE008             B.N      ??MCPWM_ConfigCapture_0
    209          		} else {
    210          			MCPWMx->MCCAPCON_CLR = MCPWM_CAPCON_HNFCAP(channelNum);
   \                     ??MCPWM_ConfigCapture_19: (+1)
   \   000000E4   0x2903             CMP      R1,#+3
   \   000000E6   0xD204             BCS.N    ??MCPWM_ConfigCapture_22
   \   000000E8   0x2301             MOVS     R3,#+1
   \   000000EA   0xF111 0x0415      ADDS     R4,R1,#+21
   \   000000EE   0x40A3             LSLS     R3,R3,R4
   \   000000F0   0xE000             B.N      ??MCPWM_ConfigCapture_23
   \                     ??MCPWM_ConfigCapture_22: (+1)
   \   000000F2   0x2300             MOVS     R3,#+0
   \                     ??MCPWM_ConfigCapture_23: (+1)
   \   000000F4   0x6143             STR      R3,[R0, #+20]
    211          		}
    212          	}
    213          }
   \                     ??MCPWM_ConfigCapture_0: (+1)
   \   000000F6   0xBC70             POP      {R4-R6}
   \   000000F8   0x4770             BX       LR               ;; return
    214          
    215          
    216          /*********************************************************************//**
    217           * @brief		Clears current captured value in specified capture channel
    218           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    219           * 							Should be: LPC_MCPWM
    220           * @param[in]	captureChannel	Capture channel number, should be: 0..2
    221           * @return		None
    222           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    223          void MCPWM_ClearCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
    224          {
    225          	MCPWMx->MCCAP_CLR = MCPWM_CAPCLR_CAP(captureChannel);
   \                     MCPWM_ClearCapture: (+1)
   \   00000000   0x2903             CMP      R1,#+3
   \   00000002   0xD202             BCS.N    ??MCPWM_ClearCapture_0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x408A             LSLS     R2,R2,R1
   \   00000008   0xE000             B.N      ??MCPWM_ClearCapture_1
   \                     ??MCPWM_ClearCapture_0: (+1)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??MCPWM_ClearCapture_1: (+1)
   \   0000000C   0x6742             STR      R2,[R0, #+116]
    226          }
   \   0000000E   0x4770             BX       LR               ;; return
    227          
    228          /*********************************************************************//**
    229           * @brief		Get current captured value in specified capture channel
    230           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected,
    231           * 							Should be: LPC_MCPWM
    232           * @param[in]	captureChannel	Capture channel number, should be: 0..2
    233           * @return		None
    234           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    235          uint32_t MCPWM_GetCapture(LPC_MCPWM_TypeDef *MCPWMx, uint32_t captureChannel)
    236          {
   \                     MCPWM_GetCapture: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    237          	if (captureChannel == 0){
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD101             BNE.N    ??MCPWM_GetCapture_0
    238          		return (MCPWMx->MCCR0);
   \   00000006   0x6C50             LDR      R0,[R2, #+68]
   \   00000008   0xE008             B.N      ??MCPWM_GetCapture_1
    239          	} else if (captureChannel == 1) {
   \                     ??MCPWM_GetCapture_0: (+1)
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD101             BNE.N    ??MCPWM_GetCapture_2
    240          		return (MCPWMx->MCCR1);
   \   0000000E   0x6C90             LDR      R0,[R2, #+72]
   \   00000010   0xE004             B.N      ??MCPWM_GetCapture_1
    241          	} else if (captureChannel == 2) {
   \                     ??MCPWM_GetCapture_2: (+1)
   \   00000012   0x2902             CMP      R1,#+2
   \   00000014   0xD101             BNE.N    ??MCPWM_GetCapture_3
    242          		return (MCPWMx->MCCR2);
   \   00000016   0x6CD0             LDR      R0,[R2, #+76]
   \   00000018   0xE000             B.N      ??MCPWM_GetCapture_1
    243          	}
    244          	return (0);
   \                     ??MCPWM_GetCapture_3: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??MCPWM_GetCapture_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    245          }
    246          
    247          
    248          /*********************************************************************//**
    249           * @brief		Configures Count control in MCPWM peripheral
    250           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    251           * 							Should be: LPC_MCPWM
    252           * @param[in]	channelNum	Channel number, should be: 0..2
    253           * @param[in]	countMode	Count mode, should be:
    254           * 							- ENABLE: Enables count mode.
    255           * 							- DISABLE: Disable count mode, the channel is in timer mode.
    256           * @param[in]	countConfig	Pointer to a MCPWM_COUNT_CFG_Type structure
    257          *                    		that contains the configuration information for the
    258          *                    		specified MCPWM count control.
    259           * @return		None
    260           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void MCPWM_CountConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channelNum,
    262          					uint32_t countMode, MCPWM_COUNT_CFG_Type *countConfig)
    263          {
   \                     MCPWM_CountConfig: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
    264          	if (channelNum <= 2) {
   \   00000002   0x2903             CMP      R1,#+3
   \   00000004   0xD25E             BCS.N    ??MCPWM_CountConfig_0
    265          		if (countMode /* == ENABLE */){
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD053             BEQ.N    ??MCPWM_CountConfig_1
    266          			MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_CNTR(channelNum);
   \   0000000A   0x2903             CMP      R1,#+3
   \   0000000C   0xD204             BCS.N    ??MCPWM_CountConfig_2
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xF111 0x051D      ADDS     R5,R1,#+29
   \   00000014   0x40AC             LSLS     R4,R4,R5
   \   00000016   0xE000             B.N      ??MCPWM_CountConfig_3
   \                     ??MCPWM_CountConfig_2: (+1)
   \   00000018   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_3: (+1)
   \   0000001A   0x6604             STR      R4,[R0, #+96]
    267          			if (countConfig->countFalling /* == ENABLE */) {
   \   0000001C   0x689C             LDR      R4,[R3, #+8]
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD012             BEQ.N    ??MCPWM_CountConfig_4
    268          				MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_TCMCI_FE(countConfig->counterChannel,channelNum);
   \   00000022   0x681C             LDR      R4,[R3, #+0]
   \   00000024   0x2C03             CMP      R4,#+3
   \   00000026   0xD20C             BCS.N    ??MCPWM_CountConfig_5
   \   00000028   0x2903             CMP      R1,#+3
   \   0000002A   0xD20A             BCS.N    ??MCPWM_CountConfig_5
   \   0000002C   0x2401             MOVS     R4,#+1
   \   0000002E   0x681D             LDR      R5,[R3, #+0]
   \   00000030   0x2606             MOVS     R6,#+6
   \   00000032   0x000F             MOVS     R7,R1
   \   00000034   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000036   0x007F             LSLS     R7,R7,#+1
   \   00000038   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \   0000003E   0x40AC             LSLS     R4,R4,R5
   \   00000040   0xE000             B.N      ??MCPWM_CountConfig_6
   \                     ??MCPWM_CountConfig_5: (+1)
   \   00000042   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_6: (+1)
   \   00000044   0x6604             STR      R4,[R0, #+96]
   \   00000046   0xE011             B.N      ??MCPWM_CountConfig_7
    269          			} else {
    270          				MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_FE(countConfig->counterChannel,channelNum);
   \                     ??MCPWM_CountConfig_4: (+1)
   \   00000048   0x681C             LDR      R4,[R3, #+0]
   \   0000004A   0x2C03             CMP      R4,#+3
   \   0000004C   0xD20C             BCS.N    ??MCPWM_CountConfig_8
   \   0000004E   0x2903             CMP      R1,#+3
   \   00000050   0xD20A             BCS.N    ??MCPWM_CountConfig_8
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0x681D             LDR      R5,[R3, #+0]
   \   00000056   0x2606             MOVS     R6,#+6
   \   00000058   0x000F             MOVS     R7,R1
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0x007F             LSLS     R7,R7,#+1
   \   0000005E   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   00000062   0x1C6D             ADDS     R5,R5,#+1
   \   00000064   0x40AC             LSLS     R4,R4,R5
   \   00000066   0xE000             B.N      ??MCPWM_CountConfig_9
   \                     ??MCPWM_CountConfig_8: (+1)
   \   00000068   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_9: (+1)
   \   0000006A   0x6644             STR      R4,[R0, #+100]
    271          			}
    272          			if (countConfig->countRising /* == ENABLE */) {
   \                     ??MCPWM_CountConfig_7: (+1)
   \   0000006C   0x685C             LDR      R4,[R3, #+4]
   \   0000006E   0x2C00             CMP      R4,#+0
   \   00000070   0xD00F             BEQ.N    ??MCPWM_CountConfig_10
    273          				MCPWMx->MCCNTCON_SET = MCPWM_CNTCON_TCMCI_RE(countConfig->counterChannel,channelNum);
   \   00000072   0x681C             LDR      R4,[R3, #+0]
   \   00000074   0x2C03             CMP      R4,#+3
   \   00000076   0xD209             BCS.N    ??MCPWM_CountConfig_11
   \   00000078   0x2903             CMP      R1,#+3
   \   0000007A   0xD207             BCS.N    ??MCPWM_CountConfig_11
   \   0000007C   0x2401             MOVS     R4,#+1
   \   0000007E   0x681D             LDR      R5,[R3, #+0]
   \   00000080   0x2606             MOVS     R6,#+6
   \   00000082   0x004F             LSLS     R7,R1,#+1
   \   00000084   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   00000088   0x40AC             LSLS     R4,R4,R5
   \   0000008A   0xE000             B.N      ??MCPWM_CountConfig_12
   \                     ??MCPWM_CountConfig_11: (+1)
   \   0000008C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_12: (+1)
   \   0000008E   0x6604             STR      R4,[R0, #+96]
   \   00000090   0xE018             B.N      ??MCPWM_CountConfig_0
    274          			} else {
    275          				MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_TCMCI_RE(countConfig->counterChannel,channelNum);
   \                     ??MCPWM_CountConfig_10: (+1)
   \   00000092   0x681C             LDR      R4,[R3, #+0]
   \   00000094   0x2C03             CMP      R4,#+3
   \   00000096   0xD209             BCS.N    ??MCPWM_CountConfig_13
   \   00000098   0x2903             CMP      R1,#+3
   \   0000009A   0xD207             BCS.N    ??MCPWM_CountConfig_13
   \   0000009C   0x2401             MOVS     R4,#+1
   \   0000009E   0x681D             LDR      R5,[R3, #+0]
   \   000000A0   0x2606             MOVS     R6,#+6
   \   000000A2   0x004F             LSLS     R7,R1,#+1
   \   000000A4   0xFB06 0x7505      MLA      R5,R6,R5,R7
   \   000000A8   0x40AC             LSLS     R4,R4,R5
   \   000000AA   0xE000             B.N      ??MCPWM_CountConfig_14
   \                     ??MCPWM_CountConfig_13: (+1)
   \   000000AC   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_14: (+1)
   \   000000AE   0x6644             STR      R4,[R0, #+100]
   \   000000B0   0xE008             B.N      ??MCPWM_CountConfig_0
    276          			}
    277          		} else {
    278          			MCPWMx->MCCNTCON_CLR = MCPWM_CNTCON_CNTR(channelNum);
   \                     ??MCPWM_CountConfig_1: (+1)
   \   000000B2   0x2903             CMP      R1,#+3
   \   000000B4   0xD204             BCS.N    ??MCPWM_CountConfig_15
   \   000000B6   0x2401             MOVS     R4,#+1
   \   000000B8   0xF111 0x051D      ADDS     R5,R1,#+29
   \   000000BC   0x40AC             LSLS     R4,R4,R5
   \   000000BE   0xE000             B.N      ??MCPWM_CountConfig_16
   \                     ??MCPWM_CountConfig_15: (+1)
   \   000000C0   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_CountConfig_16: (+1)
   \   000000C2   0x6644             STR      R4,[R0, #+100]
    279          		}
    280          	}
    281          }
   \                     ??MCPWM_CountConfig_0: (+1)
   \   000000C4   0xBCF0             POP      {R4-R7}
   \   000000C6   0x4770             BX       LR               ;; return
    282          
    283          
    284          /*********************************************************************//**
    285           * @brief		Start MCPWM activity for each MCPWM channel
    286           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    287           * 							Should be: LPC_MCPWM
    288           * @param[in]	channel0	State of this command on channel 0:
    289           * 							- ENABLE: 'Start' command will effect on channel 0
    290           * 							- DISABLE: 'Start' command will not effect on channel 0
    291           * @param[in]	channel1	State of this command on channel 1:
    292           * 							- ENABLE: 'Start' command will effect on channel 1
    293           * 							- DISABLE: 'Start' command will not effect on channel 1
    294           * @param[in]	channel2	State of this command on channel 2:
    295           * 							- ENABLE: 'Start' command will effect on channel 2
    296           * 							- DISABLE: 'Start' command will not effect on channel 2
    297           * @return		None
    298           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    299          void MCPWM_Start(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
    300          					uint32_t channel1, uint32_t channel2)
    301          {
   \                     MCPWM_Start: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    302          	uint32_t regVal = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    303          	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
    304          				| (channel2 ? MCPWM_CON_RUN(2) : 0);
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??MCPWM_Start_0
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0xE000             B.N      ??MCPWM_Start_1
   \                     ??MCPWM_Start_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_Start_1: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD002             BEQ.N    ??MCPWM_Start_2
   \   00000012   0xF44F 0x7580      MOV      R5,#+256
   \   00000016   0xE000             B.N      ??MCPWM_Start_3
   \                     ??MCPWM_Start_2: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??MCPWM_Start_3: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD002             BEQ.N    ??MCPWM_Start_4
   \   0000001E   0xF45F 0x3680      MOVS     R6,#+65536
   \   00000022   0xE000             B.N      ??MCPWM_Start_5
   \                     ??MCPWM_Start_4: (+1)
   \   00000024   0x2600             MOVS     R6,#+0
   \                     ??MCPWM_Start_5: (+1)
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x4334             ORRS     R4,R6,R4
    305          	MCPWMx->MCCON_SET = regVal;
   \   0000002A   0x6044             STR      R4,[R0, #+4]
    306          }
   \   0000002C   0xBC70             POP      {R4-R6}
   \   0000002E   0x4770             BX       LR               ;; return
    307          
    308          
    309          /*********************************************************************//**
    310           * @brief		Stop MCPWM activity for each MCPWM channel
    311           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    312           * 							Should be: LPC_MCPWM
    313           * @param[in]	channel0	State of this command on channel 0:
    314           * 							- ENABLE: 'Stop' command will effect on channel 0
    315           * 							- DISABLE: 'Stop' command will not effect on channel 0
    316           * @param[in]	channel1	State of this command on channel 1:
    317           * 							- ENABLE: 'Stop' command will effect on channel 1
    318           * 							- DISABLE: 'Stop' command will not effect on channel 1
    319           * @param[in]	channel2	State of this command on channel 2:
    320           * 							- ENABLE: 'Stop' command will effect on channel 2
    321           * 							- DISABLE: 'Stop' command will not effect on channel 2
    322           * @return		None
    323           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    324          void MCPWM_Stop(LPC_MCPWM_TypeDef *MCPWMx, uint32_t channel0,
    325          		uint32_t channel1, uint32_t channel2)
    326          {
   \                     MCPWM_Stop: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    327          	uint32_t regVal = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    328          	regVal = (channel0 ? MCPWM_CON_RUN(0) : 0) | (channel1 ? MCPWM_CON_RUN(1) : 0) \
    329          				| (channel2 ? MCPWM_CON_RUN(2) : 0);
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD001             BEQ.N    ??MCPWM_Stop_0
   \   00000008   0x2401             MOVS     R4,#+1
   \   0000000A   0xE000             B.N      ??MCPWM_Stop_1
   \                     ??MCPWM_Stop_0: (+1)
   \   0000000C   0x2400             MOVS     R4,#+0
   \                     ??MCPWM_Stop_1: (+1)
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD002             BEQ.N    ??MCPWM_Stop_2
   \   00000012   0xF44F 0x7580      MOV      R5,#+256
   \   00000016   0xE000             B.N      ??MCPWM_Stop_3
   \                     ??MCPWM_Stop_2: (+1)
   \   00000018   0x2500             MOVS     R5,#+0
   \                     ??MCPWM_Stop_3: (+1)
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD002             BEQ.N    ??MCPWM_Stop_4
   \   0000001E   0xF45F 0x3680      MOVS     R6,#+65536
   \   00000022   0xE000             B.N      ??MCPWM_Stop_5
   \                     ??MCPWM_Stop_4: (+1)
   \   00000024   0x2600             MOVS     R6,#+0
   \                     ??MCPWM_Stop_5: (+1)
   \   00000026   0x432C             ORRS     R4,R5,R4
   \   00000028   0x4334             ORRS     R4,R6,R4
    330          	MCPWMx->MCCON_CLR = regVal;
   \   0000002A   0x6084             STR      R4,[R0, #+8]
    331          }
   \   0000002C   0xBC70             POP      {R4-R6}
   \   0000002E   0x4770             BX       LR               ;; return
    332          
    333          
    334          /*********************************************************************//**
    335           * @brief		Enables/Disables 3-phase AC motor mode on MCPWM peripheral
    336           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    337           * 							Should be: LPC_MCPWM
    338           * @param[in]	acMode		State of this command, should be:
    339           * 							- ENABLE.
    340           * 							- DISABLE.
    341           * @return		None
    342           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    343          void MCPWM_ACMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t acMode)
    344          {
    345          	if (acMode){
   \                     MCPWM_ACMode: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD003             BEQ.N    ??MCPWM_ACMode_0
    346          		MCPWMx->MCCON_SET = MCPWM_CON_ACMODE;
   \   00000004   0xF05F 0x4280      MOVS     R2,#+1073741824
   \   00000008   0x6042             STR      R2,[R0, #+4]
   \   0000000A   0xE002             B.N      ??MCPWM_ACMode_1
    347          	} else {
    348          		MCPWMx->MCCON_CLR = MCPWM_CON_ACMODE;
   \                     ??MCPWM_ACMode_0: (+1)
   \   0000000C   0xF05F 0x4280      MOVS     R2,#+1073741824
   \   00000010   0x6082             STR      R2,[R0, #+8]
    349          	}
    350          }
   \                     ??MCPWM_ACMode_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    351          
    352          
    353          /*********************************************************************//**
    354           * @brief		Enables/Disables 3-phase DC motor mode on MCPWM peripheral
    355           * @param[in]	MCPWMx 			Motor Control PWM peripheral selected
    356           * 								Should be: LPC_MCPWM
    357           * @param[in]	dcMode			State of this command, should be:
    358           * 								- ENABLE.
    359           * 								- DISABLE.
    360           * @param[in]	outputInvered	Polarity of the MCOB outputs for all 3 channels,
    361           * 								should be:
    362           * 								- ENABLE: The MCOB outputs have opposite polarity
    363           * 									from the MCOA outputs.
    364           * 								- DISABLE: The MCOB outputs have the same basic
    365           * 									polarity as the MCOA outputs.
    366           * @param[in]	outputPattern	A value contains bits that enables/disables the specified
    367           * 								output pins route to the internal MCOA0 signal, should be:
    368          								- MCPWM_PATENT_A0: 	 MCOA0 tracks internal MCOA0
    369          								- MCPWM_PATENT_B0: 	 MCOB0 tracks internal MCOA0
    370          								- MCPWM_PATENT_A1: 	 MCOA1 tracks internal MCOA0
    371          								- MCPWM_PATENT_B1: 	 MCOB1 tracks internal MCOA0
    372          								- MCPWM_PATENT_A2: 	 MCOA2 tracks internal MCOA0
    373          								- MCPWM_PATENT_B2: 	 MCOB2 tracks internal MCOA0
    374           * @return		None
    375           *
    376           * Note: all these outputPatent values above can be ORed together for using as input parameter.
    377           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    378          void MCPWM_DCMode(LPC_MCPWM_TypeDef *MCPWMx, uint32_t dcMode,
    379          					uint32_t outputInvered, uint32_t outputPattern)
    380          {
   \                     MCPWM_DCMode: (+1)
   \   00000000   0xB410             PUSH     {R4}
    381          	if (dcMode){
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD003             BEQ.N    ??MCPWM_DCMode_0
    382          		MCPWMx->MCCON_SET = MCPWM_CON_DCMODE;
   \   00000006   0xF05F 0x4400      MOVS     R4,#-2147483648
   \   0000000A   0x6044             STR      R4,[R0, #+4]
   \   0000000C   0xE002             B.N      ??MCPWM_DCMode_1
    383          	} else {
    384          		MCPWMx->MCCON_CLR = MCPWM_CON_DCMODE;
   \                     ??MCPWM_DCMode_0: (+1)
   \   0000000E   0xF05F 0x4400      MOVS     R4,#-2147483648
   \   00000012   0x6084             STR      R4,[R0, #+8]
    385          	}
    386          
    387          	if (outputInvered) {
   \                     ??MCPWM_DCMode_1: (+1)
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD003             BEQ.N    ??MCPWM_DCMode_2
    388          		MCPWMx->MCCON_SET = MCPWM_CON_INVBDC;
   \   00000018   0xF05F 0x5400      MOVS     R4,#+536870912
   \   0000001C   0x6044             STR      R4,[R0, #+4]
   \   0000001E   0xE002             B.N      ??MCPWM_DCMode_3
    389          	} else {
    390          		MCPWMx->MCCON_CLR = MCPWM_CON_INVBDC;
   \                     ??MCPWM_DCMode_2: (+1)
   \   00000020   0xF05F 0x5400      MOVS     R4,#+536870912
   \   00000024   0x6084             STR      R4,[R0, #+8]
    391          	}
    392          
    393          	MCPWMx->MCCCP = outputPattern;
   \                     ??MCPWM_DCMode_3: (+1)
   \   00000026   0x6403             STR      R3,[R0, #+64]
    394          }
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    395          
    396          
    397          /*********************************************************************//**
    398           * @brief		Configures the specified interrupt in MCPWM peripheral
    399           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    400           * 							Should be: LPC_MCPWM
    401           * @param[in]	ulIntType	Interrupt type, should be:
    402           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    403           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    404           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    405           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    406           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    407           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    408           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    409           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    410           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    411           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    412           * @param[in]	NewState	New State of this command, should be:
    413           * 							- ENABLE.
    414           * 							- DISABLE.
    415           * @return		None
    416           *
    417           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    418           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    419          void MCPWM_IntConfig(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType, FunctionalState NewState)
    420          {
    421          	if (NewState) {
   \                     MCPWM_IntConfig: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD001             BEQ.N    ??MCPWM_IntConfig_0
    422          		MCPWMx->MCINTEN_SET = ulIntType;
   \   00000006   0x6541             STR      R1,[R0, #+84]
   \   00000008   0xE000             B.N      ??MCPWM_IntConfig_1
    423          	} else {
    424          		MCPWMx->MCINTEN_CLR = ulIntType;
   \                     ??MCPWM_IntConfig_0: (+1)
   \   0000000A   0x6581             STR      R1,[R0, #+88]
    425          	}
    426          }
   \                     ??MCPWM_IntConfig_1: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    427          
    428          
    429          /*********************************************************************//**
    430           * @brief		Sets/Forces the specified interrupt for MCPWM peripheral
    431           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected
    432           * 							Should be LPC_MCPWM
    433           * @param[in]	ulIntType	Interrupt type, should be:
    434           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    435           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    436           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    437           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    438           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    439           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    440           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    441           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    442           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    443           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    444           * @return		None
    445           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    446           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    447          void MCPWM_IntSet(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    448          {
    449          	MCPWMx->MCINTFLAG_SET = ulIntType;
   \                     MCPWM_IntSet: (+1)
   \   00000000   0x66C1             STR      R1,[R0, #+108]
    450          }
   \   00000002   0x4770             BX       LR               ;; return
    451          
    452          
    453          /*********************************************************************//**
    454           * @brief		Clear the specified interrupt pending for MCPWM peripheral
    455           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected,
    456           * 							should be: LPC_MCPWM
    457           * @param[in]	ulIntType	Interrupt type, should be:
    458           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    459           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    460           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    461           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    462           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    463           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    464           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    465           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    466           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    467           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    468           * @return		None
    469           * Note: all these ulIntType values above can be ORed together for using as input parameter.
    470           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    471          void MCPWM_IntClear(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    472          {
    473          	MCPWMx->MCINTFLAG_CLR = ulIntType;
   \                     MCPWM_IntClear: (+1)
   \   00000000   0x6701             STR      R1,[R0, #+112]
    474          }
   \   00000002   0x4770             BX       LR               ;; return
    475          
    476          
    477          /*********************************************************************//**
    478           * @brief		Check whether if the specified interrupt in MCPWM is set or not
    479           * @param[in]	MCPWMx 		Motor Control PWM peripheral selected,
    480           * 							should be: LPC_MCPWM
    481           * @param[in]	ulIntType	Interrupt type, should be:
    482           * 							- MCPWM_INTFLAG_LIM0: Limit interrupt for channel (0)
    483           * 							- MCPWM_INTFLAG_MAT0: Match interrupt for channel (0)
    484           * 							- MCPWM_INTFLAG_CAP0: Capture interrupt for channel (0)
    485           * 							- MCPWM_INTFLAG_LIM1: Limit interrupt for channel (1)
    486           * 							- MCPWM_INTFLAG_MAT1: Match interrupt for channel (1)
    487           * 							- MCPWM_INTFLAG_CAP1: Capture interrupt for channel (1)
    488           * 							- MCPWM_INTFLAG_LIM2: Limit interrupt for channel (2)
    489           * 							- MCPWM_INTFLAG_MAT2: Match interrupt for channel (2)
    490           * 							- MCPWM_INTFLAG_CAP2: Capture interrupt for channel (2)
    491           * 							- MCPWM_INTFLAG_ABORT: Fast abort interrupt
    492           * @return		None
    493           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    494          FlagStatus MCPWM_GetIntStatus(LPC_MCPWM_TypeDef *MCPWMx, uint32_t ulIntType)
    495          {
    496          	return ((MCPWMx->MCINTFLAG & ulIntType) ? SET : RESET);
   \                     MCPWM_GetIntStatus: (+1)
   \   00000000   0x6E80             LDR      R0,[R0, #+104]
   \   00000002   0x4208             TST      R0,R1
   \   00000004   0xD001             BEQ.N    ??MCPWM_GetIntStatus_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??MCPWM_GetIntStatus_1
   \                     ??MCPWM_GetIntStatus_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??MCPWM_GetIntStatus_1: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return
    497          }
    498          
    499          /**
    500           * @}
    501           */
    502          
    503          #endif /* _MCPWM */
    504          
    505          /**
    506           * @}
    507           */
    508          
    509          /* --------------------------------- End Of File ------------------------------ */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   MCPWM_ACMode
       0   MCPWM_ClearCapture
      12   MCPWM_ConfigCapture
       4   MCPWM_ConfigChannel
      16   MCPWM_CountConfig
       4   MCPWM_DCMode
       0   MCPWM_GetCapture
       0   MCPWM_GetIntStatus
       8   MCPWM_Init
         8   -> CLKPWR_ConfigPPWR
       0   MCPWM_IntClear
       0   MCPWM_IntConfig
       0   MCPWM_IntSet
      12   MCPWM_Start
      12   MCPWM_Stop
       0   MCPWM_WriteToShadow


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  MCPWM_ACMode
      16  MCPWM_ClearCapture
     250  MCPWM_ConfigCapture
     300  MCPWM_ConfigChannel
     200  MCPWM_CountConfig
      44  MCPWM_DCMode
      30  MCPWM_GetCapture
      16  MCPWM_GetIntStatus
      32  MCPWM_Init
       4  MCPWM_IntClear
      14  MCPWM_IntConfig
       4  MCPWM_IntSet
      48  MCPWM_Start
      48  MCPWM_Stop
      42  MCPWM_WriteToShadow

 
 1 068 bytes in section .text
 
 1 068 bytes of CODE memory

Errors: none
Warnings: none
