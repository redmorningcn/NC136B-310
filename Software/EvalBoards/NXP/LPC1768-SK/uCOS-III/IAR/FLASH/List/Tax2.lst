###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       16/May/2017  11:41:33
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\SlaveConTask\Tax2.c
#    Command line =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\SlaveConTask\Tax2.c
#        -lCN
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pe174 -o
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\Tax2.lst
#    Object file  =  
#        F:\iar\Micrium_LPC1768-SK_uCOS-III\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\Tax2.o
#
###############################################################################

F:\iar\Micrium_LPC1768-SK_uCOS-III\Application\Library\SlaveConTask\Tax2.c
      1          //#include    "config.h" 
      2          //#include    "string.h" 
      3          //#include    "CpuDrive.h" 
      4          //#include    "Globe.h" 
      5          //#include    "Tax2.h" 
      6          //
      7          #include 	<includes.h>
      8          #include    "Tax2.h"
      9          

   \                                 In section .bss, align 4
     10          stcTAX2Full     l_sTAX2 = { 0 };                 		//外部缓冲区 放置完整的一 TAX2 供外部调用
   \                     l_sTAX2:
   \   00000000                      DS8 72
     11          
     12          #define         TAX2_BCK_HEADER     	0x39         	//TAX2协议后部,起始标识
     13          #define         TAX2_BEF_HEADER     	0x38        	//TAX2协议前部,起始标识
     14          //

   \                                 In section .data, align 1
     15          uint8			l_TaxBefFlg = NO_ERROR;					
   \                     l_TaxBefFlg:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
     16          uint8			l_TaxBakFlg = NO_ERROR;
   \                     l_TaxBakFlg:
   \   00000000   0x01               DC8 1
     17          //
     18          ////----------------------------------------------------------------------------
     19          //// 名    称：   uint8 GetCheckSum(uint8 *Buf uint32 Len)
     20          //// 功    能:    取校验和
     21          //// 入口参数：   Buf：求数组   Len：数组长度
     22          //// 出口参数：   校验和
     23          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     24          uint8 GetCheckSum(uint8  Buf[], uint32 Len)
     25          {
   \                     GetCheckSum: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
     26              uint32  i;
     27              uint8   CheckSum = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     28              
     29              for(i = 0;i < Len; i++)
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0023             MOVS     R3,R4
   \                     ??GetCheckSum_0: (+1)
   \   0000000A   0x428B             CMP      R3,R1
   \   0000000C   0xD203             BCS.N    ??GetCheckSum_1
     30              {
     31                  CheckSum += Buf[i];                             //求和
   \   0000000E   0x5C9C             LDRB     R4,[R3, R2]
   \   00000010   0x1820             ADDS     R0,R4,R0
     32              }
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \   00000014   0xE7F9             B.N      ??GetCheckSum_0
     33              
     34              CheckSum = ~CheckSum + 1;                           //取反+1
   \                     ??GetCheckSum_1: (+1)
   \   00000016   0x43C0             MVNS     R0,R0
   \   00000018   0x1C40             ADDS     R0,R0,#+1
     35              
     36              return  CheckSum;
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBC10             POP      {R4}
   \   0000001E   0x4770             BX       LR               ;; return
     37          }
     38          
     39          //南瑞

   \                                 In section .text, align 2, keep-with-next
     40          uint8 GetCheckSumNR(uint8  Buf[], uint32 Len)
     41          {
   \                     GetCheckSumNR: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
     42              int32  i;
     43              int8   CheckSum = 0;
   \   00000004   0x2000             MOVS     R0,#+0
     44              
     45              for(i = 0;i < Len; i++)
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x0023             MOVS     R3,R4
   \                     ??GetCheckSumNR_0: (+1)
   \   0000000A   0x428B             CMP      R3,R1
   \   0000000C   0xD203             BCS.N    ??GetCheckSumNR_1
     46              {
     47                  CheckSum += Buf[i];                             //求和
   \   0000000E   0x569C             LDRSB    R4,[R3, R2]
   \   00000010   0x1820             ADDS     R0,R4,R0
     48              }
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \   00000014   0xE7F9             B.N      ??GetCheckSumNR_0
     49              
     50              if((unsigned char)CheckSum >= 0x80)
   \                     ??GetCheckSumNR_1: (+1)
   \   00000016   0x0004             MOVS     R4,R0
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x2C80             CMP      R4,#+128
   \   0000001C   0xDB02             BLT.N    ??GetCheckSumNR_2
     51              {
     52              	CheckSum = ~CheckSum + 1 +0x80;                       //取反+1
   \   0000001E   0x43C0             MVNS     R0,R0
   \   00000020   0x387F             SUBS     R0,R0,#+127
   \   00000022   0xE7FF             B.N      ??GetCheckSumNR_3
     53              }
     54              else
     55              {
     56              	CheckSum = CheckSum;                       	//取反+1
     57              }
     58              return  CheckSum;
   \                     ??GetCheckSumNR_2: (+1)
   \                     ??GetCheckSumNR_3: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0xBC10             POP      {R4}
   \   00000028   0x4770             BX       LR               ;; return
     59          }
     60          
     61          //
     62          ////#define		EN_TAX2			P225						//油尺通信控制
     63          ////------------------------------------------------------------------------
     64          //// 名    称：   void OpenTax2(void) 
     65          //// 功    能：   打开Tax接收功能
     66          //// 入口参数：   
     67          //// 出口参数：   
     68          ////------------------------------------------------------------------------
     69          //void OpenTax2(void) 
     70          //{
     71          ////201400
     72          ////    IO2DIR_OUT(EN_TAX2);              
     73          ////                  					
     74          ////	IO2PIN_W(0,EN_TAX2);              					 
     75          //		
     76          ////	OpenCOM0Tax(28800);								
     77          //}
     78          
     79          ////------------------------------------------------------------------------
     80          //// 名    称：   void OpenTax2(void) 
     81          //// 功    能：   打开Tax接收功能
     82          //// 入口参数：   
     83          //// 出口参数：   
     84          ////------------------------------------------------------------------------
     85          //void CloseTax2(void) 
     86          //{
     87          ////201400
     88          ////    IO2DIR_OUT(EN_TAX2);              
     89          //                  					
     90          ////	IO2PIN_W(1,EN_TAX2);              					 							
     91          //}
     92          ////----------------------------------------------------------------------------
     93          //// 名    称：   uint8  RecTAX2Bak(void)
     94          //// 功    能：   接收TAX2后部分。
     95          //// 入口参数：   无
     96          //// 出口参数：   无
     97          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     98          uint8  RecTAX2Bak(uint8	*Buf,uint32	RecBufLen)
     99          {
   \                     RecTAX2Bak: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    100              uint16		i;
    101              uint32		SizeofTaxBak;
    102              
    103              SizeofTaxBak = sizeof(l_sTAX2.sTAX2Bak);
   \   00000008   0x2028             MOVS     R0,#+40
   \   0000000A   0x0007             MOVS     R7,R0
    104          
    105              if( RecBufLen >= SizeofTaxBak)
   \   0000000C   0x42BD             CMP      R5,R7
   \   0000000E   0xD324             BCC.N    ??RecTAX2Bak_0
    106              {
    107          	    for(i = 0; i <= (RecBufLen - SizeofTaxBak);i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??RecTAX2Bak_1: (+1)
   \   00000014   0x1BE8             SUBS     R0,R5,R7
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x42B0             CMP      R0,R6
   \   0000001A   0xD31E             BCC.N    ??RecTAX2Bak_0
    108          	    {
    109          			if((Buf[i] == TAX2_BCK_HEADER))
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x5D30             LDRB     R0,[R6, R4]
   \   00000020   0x2839             CMP      R0,#+57
   \   00000022   0xD118             BNE.N    ??RecTAX2Bak_2
    110          			{
    111          				if(Buf[i + SizeofTaxBak - 1] == GetCheckSum(&Buf[i],SizeofTaxBak - 1))
   \   00000024   0x1E79             SUBS     R1,R7,#+1
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x1930             ADDS     R0,R6,R4
   \   0000002A   0x.... 0x....      BL       GetCheckSum
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x19B9             ADDS     R1,R7,R6
   \   00000032   0x1909             ADDS     R1,R1,R4
   \   00000034   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x4281             CMP      R1,R0
   \   0000003C   0xD10B             BNE.N    ??RecTAX2Bak_2
    112          				{
    113          					memcpy((uint8 *)&l_sTAX2.sTAX2Bak,&Buf[i],SizeofTaxBak);
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0xEB16 0x0804      ADDS     R8,R6,R4
   \   00000044   0x.... 0x....      LDR.W    R9,??DataTable10
   \   00000048   0x003A             MOVS     R2,R7
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy
    114          
    115          					return	1;								//接收成功，退出
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE002             B.N      ??RecTAX2Bak_3
    116          				}
    117          			}
    118          	    }
   \                     ??RecTAX2Bak_2: (+1)
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \   00000058   0xE7DC             B.N      ??RecTAX2Bak_1
    119              }
    120          
    121              return	0;
   \                     ??RecTAX2Bak_0: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??RecTAX2Bak_3: (+1)
   \   0000005C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    122          }
    123          ///*
    124          ////----------------------------------------------------------------------------
    125          //// 名    称：   uint8  RecTAX2Bak(void)
    126          //// 功    能：   接收TAX2后部分。
    127          //// 入口参数：   无
    128          //// 出口参数：   无
    129          ////----------------------------------------------------------------------------
    130          //uint8  RecTAX2Bak(uint8	*Buf,uint32	RecBufLen)
    131          //{
    132          //	uint8		TaxBakBuf[sizeof(l_sTAX2.sTAX2Bak)] = {0}; 
    133          //    uint16		i;
    134          //    uint32		SizeofTaxBak;
    135          //    
    136          //    SizeofTaxBak = sizeof(l_sTAX2.sTAX2Bak);
    137          //
    138          //    if( RecBufLen >= SizeofTaxBak)
    139          //    {
    140          //	    for(i = 0; i <= (RecBufLen - SizeofTaxBak);i++)
    141          //	    {
    142          //			if((Buf[i] == TAX2_BCK_HEADER))
    143          //			{
    144          //				memcpy(TaxBakBuf,&Buf[i],SizeofTaxBak);
    145          //				
    146          //				if(TaxBakBuf[SizeofTaxBak - 1] == GetCheckSum(TaxBakBuf,SizeofTaxBak - 1))
    147          //				{
    148          //					memcpy((uint8 *)&l_sTAX2.sTAX2Bak,TaxBakBuf,SizeofTaxBak);
    149          //										
    150          //					l_TaxBakFlg = 1;
    151          //					return	1;								//接收成功，退出
    152          //				}
    153          //			}
    154          //	    }
    155          //    }
    156          //    
    157          //    l_TaxBakFlg = 0;
    158          //    return	0;
    159          //}
    160          //
    161          //
    162          ////----------------------------------------------------------------------------
    163          //// 名    称：   uint8  RecTAX2Bef(void)
    164          //// 功    能：   接收TAX2前部分。
    165          //// 入口参数：   无
    166          //// 出口参数：   无
    167          ////----------------------------------------------------------------------------
    168          //uint8  RecTAX2Bef(uint8	*Buf,uint32	RecBufLen)
    169          //{
    170          //    uint8		TaxBefBuf[sizeof(l_sTAX2.sTAX2Bef)] = {0};
    171          //    uint16		i;
    172          //    uint32		SizeofTaxBef;
    173          //    
    174          //    SizeofTaxBef = sizeof(l_sTAX2.sTAX2Bef);
    175          //    
    176          //    if( RecBufLen >= SizeofTaxBef)
    177          //    {
    178          //		for(i = 0; i <= (RecBufLen  - SizeofTaxBef);i++)
    179          //	    {
    180          //			if(Buf[i] == TAX2_BEF_HEADER)
    181          //			{
    182          //				memcpy(TaxBefBuf,&Buf[i],SizeofTaxBef);
    183          //				
    184          //				if(TaxBefBuf[SizeofTaxBef - 1] == GetCheckSum(TaxBefBuf,SizeofTaxBef - 1))
    185          //				{
    186          //					memcpy((uint8 *)&l_sTAX2.sTAX2Bef,TaxBefBuf,SizeofTaxBef);
    187          //										
    188          //					l_TaxBefFlg = 1;
    189          //					return 	1;								//接收成功，退出
    190          //				}
    191          //			}
    192          //		}
    193          //    }    
    194          //	
    195          //	l_TaxBefFlg = 0;
    196          //    return	0;												//接收失败
    197          //}
    198          //*/
    199          ////----------------------------------------------------------------------------
    200          //// 名    称：   uint8  RecTAX2Bef(void)
    201          //// 功    能：   接收TAX2前部分。
    202          //// 入口参数：   无
    203          //// 出口参数：   无
    204          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    205          uint8  RecTAX2Bef(uint8	*Buf,uint32	RecBufLen)
    206          {
   \                     RecTAX2Bef: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    207              uint16		i;
    208              uint32		SizeofTaxBef;
    209              
    210              SizeofTaxBef = sizeof(l_sTAX2.sTAX2Bef);
   \   00000008   0x2020             MOVS     R0,#+32
   \   0000000A   0x0007             MOVS     R7,R0
    211              
    212              if( RecBufLen >= SizeofTaxBef)
   \   0000000C   0x42BD             CMP      R5,R7
   \   0000000E   0xD324             BCC.N    ??RecTAX2Bef_0
    213              {
    214          		for(i = 0; i <= (RecBufLen  - SizeofTaxBef);i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x0006             MOVS     R6,R0
   \                     ??RecTAX2Bef_1: (+1)
   \   00000014   0x1BE8             SUBS     R0,R5,R7
   \   00000016   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000018   0x42B0             CMP      R0,R6
   \   0000001A   0xD31E             BCC.N    ??RecTAX2Bef_0
    215          	    {
    216          			if(Buf[i] == TAX2_BEF_HEADER )
   \   0000001C   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   0000001E   0x5D30             LDRB     R0,[R6, R4]
   \   00000020   0x2838             CMP      R0,#+56
   \   00000022   0xD118             BNE.N    ??RecTAX2Bef_2
    217          			{
    218          				if(Buf[i + SizeofTaxBef - 1] == GetCheckSum(&Buf[i],SizeofTaxBef - 1))
   \   00000024   0x1E79             SUBS     R1,R7,#+1
   \   00000026   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000028   0x1930             ADDS     R0,R6,R4
   \   0000002A   0x.... 0x....      BL       GetCheckSum
   \   0000002E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000030   0x19B9             ADDS     R1,R7,R6
   \   00000032   0x1909             ADDS     R1,R1,R4
   \   00000034   0xF811 0x1C01      LDRB     R1,[R1, #-1]
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x4281             CMP      R1,R0
   \   0000003C   0xD10B             BNE.N    ??RecTAX2Bef_2
    219          				{
    220          					memcpy((uint8 *)&l_sTAX2.sTAX2Bef,&Buf[i],SizeofTaxBef);
   \   0000003E   0xB2B6             UXTH     R6,R6            ;; ZeroExt  R6,R6,#+16,#+16
   \   00000040   0xEB16 0x0804      ADDS     R8,R6,R4
   \   00000044   0x.... 0x....      LDR.W    R9,??DataTable10_1
   \   00000048   0x003A             MOVS     R2,R7
   \   0000004A   0x4641             MOV      R1,R8
   \   0000004C   0x4648             MOV      R0,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy
    221          										
    222          					return 	1;								//接收成功，退出
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE002             B.N      ??RecTAX2Bef_3
    223          				}
    224          			}
    225          		}
   \                     ??RecTAX2Bef_2: (+1)
   \   00000056   0x1C76             ADDS     R6,R6,#+1
   \   00000058   0xE7DC             B.N      ??RecTAX2Bef_1
    226              }    
    227          
    228              return	0;												//接收失败
   \                     ??RecTAX2Bef_0: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   \                     ??RecTAX2Bef_3: (+1)
   \   0000005C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    229          }
    230          	

   \                                 In section .data, align 1
    231          uint8	l_Tax2ComErrFlg = NO_ERROR;
   \                     l_Tax2ComErrFlg:
   \   00000000   0x01               DC8 1
    232          //uint8	l_Tax2BefPackErrFlg = NO_ERROR;
    233          //uint8	l_Tax2BakPackErrFlg = NO_ERROR;
    234          //
    235          

   \                                 In section .text, align 2, keep-with-next
    236          uint8	GetTax2BefPackErrFlg(void)
    237          {
    238          	return	l_TaxBefFlg;
   \                     GetTax2BefPackErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    239          }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          uint8	GetTax2BakPackErrFlg(void)
    242          {
    243          	return	l_TaxBakFlg;
   \                     GetTax2BakPackErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    244          }
    245          
    246          #define		TAX_BUF_LEN		128
    247          ////----------------------------------------------------------------------------
    248          //// 名    称：   void  RecTAX2Info(void)
    249          //// 功    能：   接收TAX2信息。
    250          //// 入口参数：   无
    251          //// 出口参数：   无
    252          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    253          void  RecTAX2Info(void)
    254          {
   \                     RecTAX2Info: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB0A0             SUB      SP,SP,#+128
    255          	uint8		Buf[TAX_BUF_LEN] = {0};								//接收缓冲区
   \   00000004   0x4668             MOV      R0,SP
   \   00000006   0x2180             MOVS     R1,#+128
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
    256          	uint32		RecLen;				
    257          	static		uint32		Time = 0;
    258          	
    259          	if( GetSysTime() - Time > 100)	
   \   0000000C   0x.... 0x....      BL       GetSysTime
   \   00000010   0x....             LDR.N    R1,??DataTable10_4
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x1A40             SUBS     R0,R0,R1
   \   00000016   0x2865             CMP      R0,#+101
   \   00000018   0xD32B             BCC.N    ??RecTAX2Info_0
    260          	{
    261          		RecLen 		= 	ReadCOM2(Buf,sizeof(Buf));	
   \   0000001A   0x2180             MOVS     R1,#+128
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x.... 0x....      BL       ReadCOM2
   \   00000022   0x0004             MOVS     R4,R0
    262          
    263          		if(	RecLen)	
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD01D             BEQ.N    ??RecTAX2Info_1
    264          		{	
    265          			l_Tax2ComErrFlg = NO_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable10_5
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    266          			
    267          			if(RecTAX2Bef(Buf,RecLen))
   \   0000002E   0x0021             MOVS     R1,R4
   \   00000030   0x4668             MOV      R0,SP
   \   00000032   0x.... 0x....      BL       RecTAX2Bef
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD003             BEQ.N    ??RecTAX2Info_2
    268          			{
    269          				l_TaxBefFlg = NO_ERROR;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable10_2
   \   0000003E   0x7008             STRB     R0,[R1, #+0]
   \   00000040   0xE002             B.N      ??RecTAX2Info_3
    270          			}
    271          			else
    272          			{
    273          				l_TaxBefFlg = ERROR;
   \                     ??RecTAX2Info_2: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x....             LDR.N    R1,??DataTable10_2
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    274          			}	
    275          									
    276          			if(RecTAX2Bak(Buf,RecLen))		
   \                     ??RecTAX2Info_3: (+1)
   \   00000048   0x0021             MOVS     R1,R4
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x.... 0x....      BL       RecTAX2Bak
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD003             BEQ.N    ??RecTAX2Info_4
    277          			{
    278          				l_TaxBakFlg = NO_ERROR;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x....             LDR.N    R1,??DataTable10_3
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   \   0000005A   0xE006             B.N      ??RecTAX2Info_5
    279          			}
    280          			else
    281          			{
    282          				l_TaxBakFlg = ERROR;
   \                     ??RecTAX2Info_4: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x....             LDR.N    R1,??DataTable10_3
   \   00000060   0x7008             STRB     R0,[R1, #+0]
   \   00000062   0xE002             B.N      ??RecTAX2Info_5
    283          			}								
    284          		}
    285          		else
    286          		{
    287          			l_Tax2ComErrFlg = ERROR;
   \                     ??RecTAX2Info_1: (+1)
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x....             LDR.N    R1,??DataTable10_5
   \   00000068   0x7008             STRB     R0,[R1, #+0]
    288          		}	
    289          		
    290          		Time = GetSysTime();
   \                     ??RecTAX2Info_5: (+1)
   \   0000006A   0x.... 0x....      BL       GetSysTime
   \   0000006E   0x....             LDR.N    R1,??DataTable10_4
   \   00000070   0x6008             STR      R0,[R1, #+0]
    291          	}
    292          }
   \                     ??RecTAX2Info_0: (+1)
   \   00000072   0xB020             ADD      SP,SP,#+128
   \   00000074   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??Time:
   \   00000000                      DS8 4
    293          
    294          ////----------------------------------------------------------------------------
    295          //// 名    称：   void  TestTAX2Info(void)
    296          //// 功    能：   测试TAX2箱信息。
    297          //// 入口参数：   无
    298          //// 出口参数：   无
    299          ////----------------------------------------------------------------------------
    300          //void  TestTAX2Info(void)
    301          //{
    302          //	static		uint32		Time = 0;
    303          //	static		uint32		Times = 0;
    304          //	uint8		Buf[sizeof(l_sTAX2)] = {0};
    305          //	//OpenTax2();								//打开TAX2通信
    306          //
    307          //	if(GetSysTime() - Time > 50)
    308          //	{
    309          //		
    310          //		RecTAX2Info();
    311          //		
    312          //		if(l_Tax2ComErrFlg == NO_ERROR &&Times > 5)
    313          //		{
    314          //			SendCOM0((uint8 *)&l_sTAX2.sTAX2Bef,sizeof(l_sTAX2.sTAX2Bef));
    315          //			
    316          //			SendCOM0((uint8 *)&l_sTAX2.sTAX2Bak,sizeof(l_sTAX2.sTAX2Bak));
    317          //		}
    318          //				
    319          //		Time = GetSysTime();
    320          //		Times++;
    321          //		//////printfcom0("%u\r\n",Times);
    322          //		
    323          //		memcpy((uint8 *)&l_sTAX2,Buf,sizeof(Buf));
    324          //	}
    325          //	
    326          //	//////printfcom0("%u\r\n",Time);
    327          //}
    328          //
    329          ////----------------------------------------------------------------------------
    330          //// 名    称：   stcTAX2Full GetTAX2Info( void )
    331          //// 功    能：   获取TAX2信息 供外部访问
    332          //// 入口参数：  
    333          //// 出口参数：   
    334          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    335          uint8 GetTAX2Info( stcTAX2Full	* sTAX2Full )
    336          {
   \                     GetTAX2Info: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    337          	if(GetTax2BefPackErrFlg() == NO_ERROR )
   \   00000004   0x.... 0x....      BL       GetTax2BefPackErrFlg
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD104             BNE.N    ??GetTAX2Info_0
    338          	{
    339          		sTAX2Full->sTAX2Bef = l_sTAX2.sTAX2Bef;
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x....             LDR.N    R1,??DataTable10_1
   \   00000010   0x2220             MOVS     R2,#+32
   \   00000012   0x.... 0x....      BL       __aeabi_memcpy
    340          	}
    341          
    342          	if(GetTax2BakPackErrFlg() == NO_ERROR)
   \                     ??GetTAX2Info_0: (+1)
   \   00000016   0x.... 0x....      BL       GetTax2BakPackErrFlg
   \   0000001A   0x2801             CMP      R0,#+1
   \   0000001C   0xD105             BNE.N    ??GetTAX2Info_1
    343          	{
    344          		sTAX2Full->sTAX2Bak = l_sTAX2.sTAX2Bak;
   \   0000001E   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000022   0x....             LDR.N    R1,??DataTable10
   \   00000024   0x2228             MOVS     R2,#+40
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
    345          	}
    346          	
    347              return  1;
   \                     ??GetTAX2Info_1: (+1)
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xBD10             POP      {R4,PC}          ;; return
    348          }
    349          //
    350          ////----------------------------------------------------------------------------
    351          //// 名    称：   uint8 GetTax2ComErrFlg( void )
    352          //// 功    能：   TAX2无通信信号
    353          //// 入口参数：  
    354          //// 出口参数：   
    355          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    356          uint8 GetTax2ComErrFlg( void )
    357          {
    358          	return	l_Tax2ComErrFlg;
   \                     GetTax2ComErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_5
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    359          }
    360          //

   \                                 In section .data, align 1
    361          uint8	l_TaxBefErrFlg = NO_ERROR;
   \                     l_TaxBefErrFlg:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
    362          uint8	l_TaxBakErrFlg = NO_ERROR;
   \                     l_TaxBakErrFlg:
   \   00000000   0x01               DC8 1
    363          //----------------------------------------------------------------------------
    364          // 名    称：   uint8 GetTaxBefErrFlg( void )
    365          // 功    能：   取TAX2前部分信号错误
    366          // 入口参数：  
    367          // 出口参数：   
    368          //----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    369          uint8 GetTaxBefErrFlg( void )
    370          {
    371          	static	uint32	ErrTime = 0;
    372          	
    373          	if(l_TaxBefFlg == ERROR)
   \                     GetTaxBefErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD10C             BNE.N    ??GetTaxBefErrFlg_0
    374          	{
    375          		ErrTime++;
   \   00000008   0x....             LDR.N    R0,??DataTable10_6
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable10_6
   \   00000010   0x6008             STR      R0,[R1, #+0]
    376          		if(ErrTime > 5)
   \   00000012   0x....             LDR.N    R0,??DataTable10_6
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2806             CMP      R0,#+6
   \   00000018   0xD309             BCC.N    ??GetTaxBefErrFlg_1
    377          		{
    378          			l_TaxBefErrFlg = ERROR;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable10_7
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   \   00000020   0xE005             B.N      ??GetTaxBefErrFlg_1
    379          		}
    380          	}
    381          	else
    382          	{
    383          		ErrTime = 0;
   \                     ??GetTaxBefErrFlg_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable10_6
   \   00000026   0x6008             STR      R0,[R1, #+0]
    384          		l_TaxBefErrFlg = NO_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable10_7
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    385          	}
    386          
    387          	return	l_TaxBefErrFlg;
   \                     ??GetTaxBefErrFlg_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable10_7
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x4770             BX       LR               ;; return
    388          }

   \                                 In section .bss, align 4
   \                     ??ErrTime:
   \   00000000                      DS8 4
    389          //
    390          ////----------------------------------------------------------------------------
    391          //// 名    称：   uint8 GetTaxBakErrFlg( void )
    392          //// 功    能：   取TAX2后部分信号错误
    393          //// 入口参数：  
    394          //// 出口参数：   
    395          ////----------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    396          uint8 GetTaxBakErrFlg( void )
    397          {
    398          	static	uint32	ErrTime = 0;
    399          	
    400          	if(l_TaxBakFlg == ERROR)
   \                     GetTaxBakErrFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_3
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD10C             BNE.N    ??GetTaxBakErrFlg_0
    401          	{
    402          		ErrTime++;
   \   00000008   0x....             LDR.N    R0,??DataTable10_8
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable10_8
   \   00000010   0x6008             STR      R0,[R1, #+0]
    403          		if(ErrTime > 5)
   \   00000012   0x....             LDR.N    R0,??DataTable10_8
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2806             CMP      R0,#+6
   \   00000018   0xD309             BCC.N    ??GetTaxBakErrFlg_1
    404          		{
    405          			l_TaxBakErrFlg = ERROR;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable10_9
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   \   00000020   0xE005             B.N      ??GetTaxBakErrFlg_1
    406          		}
    407          	}
    408          	else
    409          	{
    410          		ErrTime = 0;
   \                     ??GetTaxBakErrFlg_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable10_8
   \   00000026   0x6008             STR      R0,[R1, #+0]
    411          		l_TaxBakErrFlg = NO_ERROR;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable10_9
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    412          	}
    413          
    414          	return	l_TaxBakErrFlg;
   \                     ??GetTaxBakErrFlg_1: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable10_9
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x4770             BX       LR               ;; return
    415          }

   \                                 In section .bss, align 4
   \                     ??ErrTime_1:
   \   00000000                      DS8 4
    416          
    417          //uint8	l_RoadNumChgEvtFlg = RIGHT_DATA;
    418          ////-------------------------------------------------------------------------------------------------
    419          ////函数名称:             uint8  JudgeTAX2Data(stcTAX2Full sTAX) 
    420          ////函数功能:             对TAX2的数据进行合理、合法性进行判断
    421          ////入口参数:             TAX2信息
    422          ////出口参数:             内部故障类型
    423          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    424          uint8  JudgeTAX2Data(stcTAX2Full sTAX) 
    425          {
   \                     JudgeTAX2Data: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
    426          //    uint8       		Sec,Min,Data,Mouth,Hour,RoadNum;
    427          //    static	uint32     	Times;
    428          //    static	uint32   	Time = 0,LstTime = 0;
    429          //    static	uint32   	TimeSys = 0;
    430          //    static	stcTAX2Full	sTAXTmp;
    431          //    static	uint8		LstRoadNum;
    432          //    static	uint8		LstLstRoadNum;
    433          //
    434          //    RoadNum = sTAX.sTAX2Bak.RoadNum;					//交号改变判断	
    435          //    if( Times++ )
    436          //    {
    437          //    	if((RoadNum == LstRoadNum) && (LstRoadNum != LstLstRoadNum) && (Times > 2))
    438          //    	{
    439          ////2014    		l_RoadNumChgEvtFlg = TAX_ROAD_NUM_CHG_EVT;
    440          //    	}
    441          //    	else
    442          //    	{
    443          ////2014    		l_RoadNumChgEvtFlg = RIGHT_DATA;
    444          //    	}
    445          //    }
    446          //  
    447          //  	LstLstRoadNum 	= LstRoadNum;
    448          //    LstRoadNum 		= RoadNum;
    449          //        
    450          //    memcpy((uint8 *)&Time,sTAX.sTAX2Bak.Time,sizeof(Time));
    451          //
    452          //    Sec	  	= Time  & (0xff >> 2);
    453          //    Min		= (Time >> 6 ) & (0xff >> 2);
    454          //    Hour    = (Time >> 12) & (0xff >> 3);
    455          //    Data    = (Time >> 17) & (0xff >> 3);
    456          //    Mouth   = (Time >> 22) & (0xff >> 4);
    457          //    
    458          //    if(( Sec > 60) || (Min  > 60) || ( Hour  >  24) 
    459          //    		|| (Data  > 31) || (Mouth  >  12))			//时间不合法
    460          //    {
    461          ////2014        return  TAX_TIME_RULE_ERR;
    462          //    }
    463          //
    464          //    if(GetSysTime() - TimeSys > 100*5 && GetSysTime() > 100*60)			//30S判断一次
    465          //    {
    466          //		if( memcmp((uint8 *)&sTAXTmp,(uint8 *)&sTAX,sizeof(sTAX)) == 0) //数据不更新
    467          //		{
    468          ////2014			return 	TAX_INFO_NO_CHG_ERR;
    469          //		}
    470          //		
    471          //		if(Time < LstTime)							//时间不合理
    472          //		{
    473          ////2014			return	TAX_TIME_REASON_ERR;
    474          //		}
    475          //    	
    476          //		LstTime 	= Time;
    477          //		sTAXTmp 	= sTAX;
    478          //		
    479          //		TimeSys 	= GetSysTime();
    480          //	} 
    481          //	
    482          	return	RIGHT_DATA;   
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0xB004             ADD      SP,SP,#+16
   \   00000006   0x4770             BX       LR               ;; return
    483          	 
    484          }
    485          //
    486          ////-------------------------------------------------------------------------------------------------
    487          ////函数名称:             uint8  GetRoadNumChgEvtFlg(void)  
    488          ////函数功能:             TAX箱交路号改变事件
    489          ////入口参数:             TAX2信息
    490          ////出口参数:             时间合理,返回TRUE
    491          ////--------------------------------------------------------------------------------------------------
    492          //uint8  GetRoadNumChgEvtFlg(void) 
    493          //{
    494          //	return	l_RoadNumChgEvtFlg;
    495          //}
    496          //
    497          ////-------------------------------------------------------------------------------------------------
    498          ////函数名称:            	uint8  JudgeTAX2Evt(void)  
    499          ////函数功能:             对TAX2箱信息通信中的事件判断
    500          ////入口参数:             
    501          ////出口参数:             
    502          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    503          uint8  JudgeTAX2Evt(void) 
    504          {
    505          //	uint8	TaxEvtType;
    506          //	
    507          //	TaxEvtType = GetRoadNumChgEvtFlg();			//交号改变事件
    508          //	
    509          //	return	TaxEvtType;
    510          	return 1;
   \                     JudgeTAX2Evt: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4770             BX       LR               ;; return
    511          }
    512          

   \                                 In section .data, align 1
    513          uint8	m_TaxNoErrFlg = TRUE;
   \                     m_TaxNoErrFlg:
   \   00000000   0x01               DC8 1
    514          ////-------------------------------------------------------------------------------------------------
    515          ////函数名称:             uint8  JudgeTAX2Error(stcTAX2Full sTAX) 
    516          ////函数功能:             对TAX2箱信息通信正确性可靠性进行判断
    517          ////入口参数:             TAX2信息
    518          ////出口参数:             时间合理,返回TRUE
    519          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    520          uint8  JudgeTAX2Error(void) 
    521          {
   \                     JudgeTAX2Error: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    522          	uint8			TaxErrorType = RIGHT_DATA;
   \   00000004   0x24FF             MOVS     R4,#+255
    523          	stcTAX2Full		sTAX;
    524          //	static			uint32		Time = 0;
    525          	
    526          	GetTAX2Info((stcTAX2Full *)&sTAX);
   \   00000006   0x4668             MOV      R0,SP
   \   00000008   0x.... 0x....      BL       GetTAX2Info
    527          
    528          //	if( GetSysTime() - Time > 100)	//大于2分钟
    529          	{
    530          //		Time = GetSysTime();
    531          
    532          		if(GetTax2ComErrFlg() == NO_ERROR)
   \   0000000C   0x.... 0x....      BL       GetTax2ComErrFlg
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD111             BNE.N    ??JudgeTAX2Error_0
    533          		{
    534          			if(GetTaxBefErrFlg() == NO_ERROR && GetTaxBakErrFlg() == NO_ERROR)
   \   00000014   0x.... 0x....      BL       GetTaxBefErrFlg
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD103             BNE.N    ??JudgeTAX2Error_1
   \   0000001C   0x.... 0x....      BL       GetTaxBakErrFlg
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD00B             BEQ.N    ??JudgeTAX2Error_2
    535          			{
    536          //				TaxErrorType = JudgeTAX2Data(sTAX);				//判断内容故障类型
    537          			}
    538          			else if(GetTaxBakErrFlg() == NO_ERROR)
   \                     ??JudgeTAX2Error_1: (+1)
   \   00000024   0x.... 0x....      BL       GetTaxBakErrFlg
   \   00000028   0x2801             CMP      R0,#+1
   \   0000002A   0xD102             BNE.N    ??JudgeTAX2Error_3
    539          			{
    540          				TaxErrorType = TAX_BEF_REC_ERR;
   \   0000002C   0x205C             MOVS     R0,#+92
   \   0000002E   0x0004             MOVS     R4,R0
   \   00000030   0xE004             B.N      ??JudgeTAX2Error_2
    541          			}
    542          			else
    543          			{
    544          				TaxErrorType = TAX_BAK_REC_ERR;
   \                     ??JudgeTAX2Error_3: (+1)
   \   00000032   0x205D             MOVS     R0,#+93
   \   00000034   0x0004             MOVS     R4,R0
   \   00000036   0xE001             B.N      ??JudgeTAX2Error_2
    545          			}
    546          		}
    547          		else
    548          		{
    549          			TaxErrorType = NO_TAX_COM_ERR;
   \                     ??JudgeTAX2Error_0: (+1)
   \   00000038   0x205B             MOVS     R0,#+91
   \   0000003A   0x0004             MOVS     R4,R0
    550          		}
    551          		
    552          		if(TaxErrorType == RIGHT_DATA)
   \                     ??JudgeTAX2Error_2: (+1)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2CFF             CMP      R4,#+255
   \   00000040   0xD103             BNE.N    ??JudgeTAX2Error_4
    553          		{
    554          			m_TaxNoErrFlg = TRUE;
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR.N    R1,??DataTable10_10
   \   00000046   0x7008             STRB     R0,[R1, #+0]
   \   00000048   0xE002             B.N      ??JudgeTAX2Error_5
    555          		}
    556          		else
    557          		{
    558          			m_TaxNoErrFlg = FALSE;
   \                     ??JudgeTAX2Error_4: (+1)
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR.N    R1,??DataTable10_10
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    559          		}
    560          	}
    561          	
    562          	return	TaxErrorType;
   \                     ??JudgeTAX2Error_5: (+1)
   \   00000050   0x0020             MOVS     R0,R4
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xB012             ADD      SP,SP,#+72
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    563          }
    564          

   \                                 In section .bss, align 1
    565          uint8	m_NoSpeedFlg = FALSE;
   \                     m_NoSpeedFlg:
   \   00000000                      DS8 1
    566          ////-------------------------------------------------------------------------------------------------
    567          ////函数名称:             void  ShowTAX2Info(stcTAX2Full sTAX) 
    568          ////函数功能:             打印TAX2时间,公里标信息
    569          ////入口参数:             无
    570          ////出口参数:             无
    571          ////说明:                 
    572          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    573          void  GetTAX2SpeedInfo(void) 
    574          {
    575          //	stcTAX2Full		sTAX;
    576          //	uint32			TaxSpeed;
    577          //	static	uint32	Time = 0;		
    578          //	static	uint32	Times = 0;		
    579          //	
    580          //	GetTAX2Info((stcTAX2Full *)&sTAX);
    581          //	
    582          //	if(GetSysTime() - Time > 100)
    583          //	{
    584          //		Time = GetSysTime();
    585          //		
    586          //		Times++;
    587          //		
    588          //		if(Times > 30)
    589          //		{
    590          //			if(m_TaxNoErrFlg == TRUE)
    591          //			{
    592          //				TaxSpeed = (uint32)sTAX.sTAX2Bak.RelSpeed[0] + (uint32)((sTAX.sTAX2Bak.RelSpeed[1]<<7)>>7)*256;
    593          //				
    594          //				if(TaxSpeed == 0) 					//速度为零
    595          //				{
    596          //					m_NoSpeedFlg = TRUE;
    597          //					//////printfcom0("\r\n 速度为零");
    598          //				}
    599          //				else
    600          //				{
    601          //					//////printfcom0("\r\n 速度为%u",TaxSpeed);
    602          //				
    603          //					m_NoSpeedFlg = FALSE;
    604          //				}
    605          //			}
    606          //		}
    607          //	}
    608          }
   \                     GetTAX2SpeedInfo: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    609          
    610          ////-------------------------------------------------------------------------------------------------
    611          ////函数名称:             uint8	GetNoSpeedFlg(void)
    612          ////函数功能:             取速度为零的标识
    613          ////入口参数:             无
    614          ////出口参数:             无
    615          ////说明:                 
    616          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    617          uint8	GetNoSpeedFlg(void)
    618          {
    619          	return	m_NoSpeedFlg;
   \                     GetNoSpeedFlg: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable10_11
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    620          }
    621          
    622          ////-------------------------------------------------------------------------------------------------
    623          ////函数名称:             void  ShowTAX2Info(stcTAX2Full sTAX) 
    624          ////函数功能:             打印TAX2时间,公里标信息
    625          ////入口参数:             无
    626          ////出口参数:             无
    627          ////说明:                 
    628          ////--------------------------------------------------------------------------------------------------
    629          //void  ShowTAX2Info(stcTAX2Full sTAX) 
    630          //{
    631          //    uint16      RelSpeed;
    632          //    uint8       Second,Minute,Data,Mouth,Hour;
    633          //    uint16      Year;
    634          //    uint32      Time;
    635          //    float       KmMark;
    636          //    
    637          //    RelSpeed= (uint16)sTAX.sTAX2Bak.RelSpeed[0] + (sTAX.sTAX2Bak.RelSpeed[1] &(1))*256;
    638          //
    639          //    memcpy((uint8 *)&Time,sTAX.sTAX2Bak.Time,sizeof(Time));
    640          //    	
    641          //    Second  = Time  & (0xff >> 2);
    642          //    Minute  = (Time >> 6 ) & (0xff >> 2);
    643          //    Hour    = (Time >> 12) & (0xff >> 3);
    644          //    Data    = (Time >> 17) & (0xff >> 3);
    645          //    Mouth   = (Time >> 22) & (0xff >> 4);
    646          //    Year    = 2009;
    647          //    
    648          //    KmMark = ((uint32)sTAX.sTAX2Bak.KmMark[0] + (uint32)sTAX.sTAX2Bak.KmMark[1]*256 
    649          //            + (uint32)sTAX.sTAX2Bak.KmMark[2]*256*256)/1000;
    650          //    
    651          //    ////printfcom0("\r\n %u-%u %u:%u:%u,%u,%f",
    652          ////    Mouth,Data,Hour,Minute,Second,RelSpeed,KmMark);    //记录输出	
    653          //}
    654          //
    655          ////-------------------------------------------------------------------------------------------------
    656          ////函数名称:             void  Tax2Task(void)
    657          ////函数功能:             TAX2处理
    658          ////入口参数:             无
    659          ////出口参数:             无
    660          ////说明:                 
    661          ////--------------------------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    662          void  Tax2Task(void)
    663          {
   \                     Tax2Task: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    664          //	////printfcom0("\r\n\r\nTax2Task(void)");
    665              
    666          	RecTAX2Info();
   \   00000002   0x.... 0x....      BL       RecTAX2Info
    667          	
    668          //	GetTAX2SpeedInfo();
    669          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     l_sTAX2+0x20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     l_sTAX2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     l_TaxBefFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     l_TaxBakFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     ??Time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     l_Tax2ComErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     ??ErrTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     l_TaxBefErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     ??ErrTime_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     l_TaxBakErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     m_TaxNoErrFlg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     m_NoSpeedFlg

   \                                 In section .rodata, align 4
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000073   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
    670          //
    671          //#ifdef	TEST_OPEN
    672          ////-------------------------------------------------------------------------------------------------
    673          ////函数名称:             void  SimulateTax(void)
    674          ////函数功能:             TAX2模拟器
    675          ////入口参数:             无
    676          ////出口参数:             无
    677          ////说明:                 
    678          ////--------------------------------------------------------------------------------------------------
    679          //void  ReadSimsTaxData(stcTAX2Full *sTax)
    680          //{
    681          //    uint8   	CheckSum;        		//检查和            1   为前面所有字节累加和的二进制补码  
    682          //	stcTime		sTime;
    683          //	uint32		RealSpeed;
    684          //	uint32		Time;
    685          //	uint32		KmMark;
    686          //	uint16		LocoNum;
    687          //	uint16		MstDriverNum;
    688          //	
    689          //	sTax->sTAX2Bef.TAX2BefAdrCod 	= 0x38;
    690          //	sTax->sTAX2Bef.NewFlg			= 0x67;
    691          //	sTax->sTAX2Bef.CheckSum = GetCheckSum((uint8 *)&sTax->sTAX2Bef,sizeof(sTax->sTAX2Bef) -1);
    692          //
    693          //    sTax->sTAX2Bak.TAX2BakAdrCod = 0x39;
    694          //
    695          //    ReadTime((stcTime *)&sTime);											// 时间 
    696          //	Time	=  sTime.Sec + sTime.Min * (1 << 6) + sTime.Hour * (1 << 12) 
    697          //				+ sTime.Date * (1 << 17) + sTime.Month * (1 << 22) + sTime.Year * (1 << 26);
    698          //	memcpy((uint8 *)&sTax->sTAX2Bak.Time,(uint8 *)&Time,sizeof(Time));
    699          //	   
    700          //    RealSpeed	= GetSetTaxSpeed();		// 取TAX箱信息]
    701          //	memcpy((uint8 *)&sTax->sTAX2Bak.RelSpeed,(uint8 *)&RealSpeed,sizeof(sTax->sTAX2Bak.RelSpeed));
    702          //
    703          //	KmMark	= RealSpeed * ((GetSysTime()/10)/36);  	//((GetSysTime()/100)/3600) 单位：m
    704          //	memcpy((uint8 *)&sTax->sTAX2Bak.KmMark,(uint8 *)&KmMark,sizeof(KmMark));
    705          //
    706          //    //sTax->sTAX2Bak.LocoTyp						=  GetSetTaxLocoTyp();		// 取TAX箱机车型号    
    707          //    sTax->sTAX2Bak.LocoTyp						=  0;		// 取TAX箱机车型号  
    708          //      
    709          //	//LocoNum	=  GetSetTaxLocoNum();					// 取TAX箱机车编号
    710          //	LocoNum	=  0;					// 取TAX箱机车编号
    711          //	memcpy((uint8 *)&sTax->sTAX2Bak.LocoNum,(uint8 *)&LocoNum,sizeof(sTax->sTAX2Bak.LocoNum));
    712          //
    713          //	MstDriverNum	=  GetSetTaxDriverNum();		// 取TAX箱司机号
    714          //	memcpy((uint8 *)&sTax->sTAX2Bak.MstDriverNum,(uint8 *)&MstDriverNum,sizeof(sTax->sTAX2Bak.MstDriverNum));
    715          //													// 公里标
    716          //
    717          //	sTax->sTAX2Bak.CheckSum = GetCheckSum((uint8 *)&sTax->sTAX2Bak,sizeof(sTax->sTAX2Bak) -1);
    718          //        
    719          //}
    720          //
    721          //#define	USB_INT_SUCCESS		0x14			/* USB事务或者传输操作成功 */
    722          //
    723          ////-------------------------------------------------------------------------------------------------
    724          ////函数名称:             void	SendSimsTaxData(stcTAX2Full *sTax);			//发送TAX数据
    725          ////函数功能:             发送TAX数据
    726          ////入口参数:             无
    727          ////出口参数:             无
    728          ////说明:                 
    729          ////--------------------------------------------------------------------------------------------------
    730          //void	SendSimsTaxData(stcTAX2Full * sTax)			//发送TAX数据
    731          //{
    732          //	SendCOM0((uint8 *)sTax,sizeof(stcTAX2Full));	//发送TAX信息
    733          //}
    734          //
    735          //extern	void  	ReadSimsTaxData(stcTAX2Full *sTax);
    736          //extern	void	SendSimsTaxData(stcTAX2Full * sTax);			//发送TAX数据
    737          //#endif
    738          //
    739          //
    740          ////-------------------------------------------------------------------------------------------------
    741          ////函数名称:             void  SimulateTax(void)
    742          ////函数功能:             TAX2模拟器
    743          ////入口参数:             无
    744          ////出口参数:             无
    745          ////说明:                 
    746          ////--------------------------------------------------------------------------------------------------
    747          //void  SimulateTax(void)
    748          //{
    749          //
    750          //#ifdef	TEST_OPEN
    751          //	stcTAX2Full	sTax;
    752          //	uint32		Time;
    753          //	
    754          ////   OpenTaxSent();								//打开串口，准备数据发送
    755          //
    756          ////	memset((uint8 *)&sTax,0,sizeof(stcTAX2Full));
    757          //	
    758          //    //while(1)
    759          //    {	
    760          ////    	SysHoldTast();
    761          //    	
    762          //    	if(GetSysTime() - Time > 100)				//20ms
    763          //    	{
    764          //    	#ifdef	HARD_VER_111122	
    765          //
    766          //		//	if( CH376DiskConnect() == USB_INT_SUCCESS )//连接USB,U盘插入
    767          //		//	{
    768          //	   	//		UsbSetTaxHost();						//用U盘设置TAX信息					
    769          //	   	//	}
    770          //	   		
    771          //		#endif
    772          //			ReadSimsTaxData((stcTAX2Full *)&sTax);		//读TAX箱模拟器数据
    773          //
    774          //			SendSimsTaxData((stcTAX2Full *)&sTax);		//发送TAX数据
    775          //			
    776          //			Time = GetSysTime();
    777          //			
    778          //			//DelayX10ms(100);
    779          //		}
    780          //	}
    781          //	
    782          //#endif
    783          //}
    784          //
    785          //
    786          //#ifdef	TEST_OPEN
    787          //
    788          //
    789          //#define	LOCO_KEY	P021
    790          //#define	ON_LINE		P024
    791          //#define	CS_IN		P022
    792          //
    793          //void	InitIO(void)
    794          //{
    795          //	SETFUN_P016_31X(GPIO,LOCO_KEY);
    796          //	IO0DIR_OUT(LOCO_KEY);
    797          //	
    798          //	SETFUN_P016_31X(GPIO,ON_LINE);
    799          //	IO0DIR_OUT(ON_LINE);
    800          //	
    801          //	SETFUN_P016_31X(GPIO,CS_IN);
    802          //	IO0DIR_OUT(CS_IN);
    803          //}
    804          //
    805          //void  SimulatePluse(void)
    806          //{
    807          //	//SimulateDip();							//仿真油尺		
    808          //	static	uint32	Time;
    809          //	static	uint32	Times;
    810          //	
    811          //	if(GetSysTime() - Time > 10 )
    812          //	{
    813          //		Time = GetSysTime();
    814          //		Times++;
    815          //		
    816          //		if(Times %2 == 0)
    817          //		{
    818          //			IO0SET_W(LOCO_KEY);
    819          //			IO0SET_W(ON_LINE);
    820          //		}
    821          //		else
    822          //		{
    823          //			IO0CLR_W(LOCO_KEY);
    824          //			IO0CLR_W(ON_LINE);
    825          //		}
    826          //	}
    827          //}
    828          //	
    829          //uint32	CS_Times;
    830          //
    831          //void	SimulateHoldCs(void)
    832          //{
    833          //	CS_Times++;
    834          //	if(CS_Times %2 ==0)
    835          //	{
    836          //		IO0SET_W(CS_IN);
    837          //	}
    838          //	else
    839          //	{
    840          //		IO0CLR_W(CS_IN);
    841          //	}
    842          //}
    843          //	
    844          //#endif
    845          //
    846          //
    847          //void Simulate(void)
    848          //{
    849          //#ifdef	TEST_OPEN
    850          //	
    851          //	InitIO();								//初始化脉冲发送的IO口
    852          //
    853          //	while(1)
    854          //	{
    855          //		if(SetKeyPressed() == FALSE)
    856          //		{
    857          ////			SysHoldTast();
    858          //
    859          //			SimulateTax();						//仿真TAX箱
    860          //		
    861          //			SimulateDip();						//仿真油尺		
    862          //			
    863          //			SimulatePluse();					//模拟脉冲发送
    864          //		}
    865          //	}
    866          //	
    867          //#endif
    868          //}
    869          //	  
    870          //
    871          //	

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   GetCheckSum
       4   GetCheckSumNR
       0   GetNoSpeedFlg
       8   GetTAX2Info
         8   -> GetTax2BakPackErrFlg
         8   -> GetTax2BefPackErrFlg
         8   -> __aeabi_memcpy
       0   GetTAX2SpeedInfo
       0   GetTax2BakPackErrFlg
       0   GetTax2BefPackErrFlg
       0   GetTax2ComErrFlg
       0   GetTaxBakErrFlg
       0   GetTaxBefErrFlg
      16   JudgeTAX2Data
      80   JudgeTAX2Error
        80   -> GetTAX2Info
        80   -> GetTax2ComErrFlg
        80   -> GetTaxBakErrFlg
        80   -> GetTaxBefErrFlg
       0   JudgeTAX2Evt
      32   RecTAX2Bak
        32   -> GetCheckSum
        32   -> __aeabi_memcpy
      32   RecTAX2Bef
        32   -> GetCheckSum
        32   -> __aeabi_memcpy
     136   RecTAX2Info
       136   -> GetSysTime
       136   -> ReadCOM2
       136   -> RecTAX2Bak
       136   -> RecTAX2Bef
       136   -> __aeabi_memclr4
       8   Tax2Task
         8   -> RecTAX2Info


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
     128  ?_0
       4  ErrTime
       4  ErrTime
      32  GetCheckSum
      42  GetCheckSumNR
       6  GetNoSpeedFlg
      46  GetTAX2Info
       2  GetTAX2SpeedInfo
       6  GetTax2BakPackErrFlg
       6  GetTax2BefPackErrFlg
       6  GetTax2ComErrFlg
      52  GetTaxBakErrFlg
      52  GetTaxBefErrFlg
       8  JudgeTAX2Data
      88  JudgeTAX2Error
       4  JudgeTAX2Evt
      96  RecTAX2Bak
      96  RecTAX2Bef
     118  RecTAX2Info
       8  Tax2Task
       4  Time
       1  l_Tax2ComErrFlg
       1  l_TaxBakErrFlg
       1  l_TaxBakFlg
       1  l_TaxBefErrFlg
       1  l_TaxBefFlg
      72  l_sTAX2
       1  m_NoSpeedFlg
       1  m_TaxNoErrFlg

 
  85 bytes in section .bss
   6 bytes in section .data
 128 bytes in section .rodata
 716 bytes in section .text
 
 716 bytes of CODE  memory
 128 bytes of CONST memory
  91 bytes of DATA  memory

Errors: none
Warnings: 1
