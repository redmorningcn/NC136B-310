###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.1.10123/W32 for ARM       11/Oct/2017  18:40:20
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\iar\NC136B-310统计模块\Application\Library\Driver\MX25L1602Drv.c
#    Command line =  
#        F:\iar\NC136B-310统计模块\Application\Library\Driver\MX25L1602Drv.c
#        -lCN
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List
#        --diag_suppress Pa050 -o
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.3\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\BSP\OS\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\LPC1768\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CSP\MCU\NXP\LPC17xx\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\Generic\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Ports\ARM-Cortex-M3\CSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uCOS-III\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-LIB\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Source\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Cfg\Template\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\uC-MB\Os\uCOS-III\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\OS\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\OSAL\Ports\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Protocol\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\Tasks\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\APP\AES\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\OS\OSAL\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\CSB\include\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\BSP\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\MX25L1602Drv\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\APP\OCM800600T80\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\User\BSP\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\CardOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\DataDeal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Driver\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\EquipmentOperations\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\Global\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\MastConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SlaveConTask\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\SpeedTest\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\csnr_package_deal\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\iap\
#        -I
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\..\..\..\..\..\..\Application\Library\tax\
#        -On --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.3\arm\CMSIS\Include\"
#    List file    =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\List\MX25L1602Drv.lst
#    Object file  =  
#        F:\iar\NC136B-310统计模块\Software\EvalBoards\NXP\LPC1768-SK\uCOS-III\IAR\FLASH\Obj\MX25L1602Drv.o
#
###############################################################################

F:\iar\NC136B-310统计模块\Application\Library\Driver\MX25L1602Drv.c
      1          /****************************************Copyright (c)**************************************************
      2          **                               Guangzou ZLG-MCU Development Co.,LTD.
      3          **                                      graduate school
      4          **                                 http://www.zlgmcu.com
      5          **
      6          **--------------File Info-------------------------------------------------------------------------------
      7          ** File name:       MX25L1602.c
      8          ** Descriptions:    SST25VF016B驱动
      9          **
     10          **------------------------------------------------------------------------------------------------------
     11          ** Created by:      Litiantian
     12          ** Created date:    2007-04-16
     13          ** Version:         1.0
     14          ** Descriptions:    The original version
     15          **
     16          **------------------------------------------------------------------------------------------------------
     17          ** Modified by:     
     18          ** Modified date:   
     19          ** Version:         
     20          ** Descriptions:    
     21          ********************************************************************************************************/
     22          #include   "MX25L1602Drv.h"
     23          #include   "includes.h"
     24          /*
     25           * 移植本软件包时需要修改以下的函数或宏 
     26           */
     27          //#define     CE_Low()    LPC_GPIO0->FIOCLR |= SPI_CS;
     28          //#define     CE_High()   LPC_GPIO0->FIOSET |= SPI_CS;
     29          
     30          
     31          extern	void WriteSoftSpiCSF(uint8 temp);
     32          

   \                                 In section .text, align 2, keep-with-next
     33          void	CE_Low(void)
     34          {
   \                     CE_Low: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     35          	WriteSoftSpiCSF(0);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       WriteSoftSpiCSF
     36          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
     37          

   \                                 In section .text, align 2, keep-with-next
     38          void	CE_High(void)
     39          {
   \                     CE_High: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     40          	WriteSoftSpiCSF(1);
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      BL       WriteSoftSpiCSF
     41          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
     42          
     43          #define			SCKF					204    	//p1.20  
     44          #define			MISOF					203			//p1.23  
     45          #define			MOSIF					205			//p1.24 
     46          #define   		SOFT_SPI_CSF			202			//p1.22
     47          
     48          
     49          #define	uint8	uint8_t
     50          

   \                                 In section .text, align 2, keep-with-next
     51          void	InitFlashIO(void)
     52          {
   \                     InitFlashIO: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     53          	GPIO_PinselConfig(MOSIF,0);	
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x20CD             MOVS     R0,#+205
   \   00000006   0x.... 0x....      BL       GPIO_PinselConfig
     54          	GPIO_PinselConfig(MISOF,0);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x20CB             MOVS     R0,#+203
   \   0000000E   0x.... 0x....      BL       GPIO_PinselConfig
     55          	GPIO_PinselConfig(MISOF,0);	
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x20CB             MOVS     R0,#+203
   \   00000016   0x.... 0x....      BL       GPIO_PinselConfig
     56          	GPIO_PinselConfig(SOFT_SPI_CSF,0);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x20CA             MOVS     R0,#+202
   \   0000001E   0x.... 0x....      BL       GPIO_PinselConfig
     57          	GPIO_PinselConfig(MOSIF,0);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x20CD             MOVS     R0,#+205
   \   00000026   0x.... 0x....      BL       GPIO_PinselConfig
     58          	GPIO_PinselConfig(SCKF,0);
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x20CC             MOVS     R0,#+204
   \   0000002E   0x.... 0x....      BL       GPIO_PinselConfig
     59          	GPIO_PinselConfig(SCKF,0);
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x20CC             MOVS     R0,#+204
   \   00000036   0x.... 0x....      BL       GPIO_PinselConfig
     60          }
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
     61          
     62          //------------------------------------------------------------------------
     63          //  名  称 ：void WriteSCKF( uint8 temp )
     64          //  功  能 ：设置 SCKF
     65          // 入口参数：无
     66          // 出口参数：无
     67          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     68          void WriteSCKF(uint8 temp)
     69          {
   \                     WriteSCKF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     70          	
     71          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSCKF_0
     72          	{
     73          		GPIO_SetOrClearValue(SCKF,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20CC             MOVS     R0,#+204
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSCKF_1
     74          	}
     75          	else
     76          	{
     77          		GPIO_SetOrClearValue(SCKF,0);		
   \                     ??WriteSCKF_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20CC             MOVS     R0,#+204
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
     78          	}	
     79          	nop();	
   \                     ??WriteSCKF_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
     80          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          //------------------------------------------------------------------------
     83          //  名  称 ：uint8 ReadSCKF(void)
     84          //  功  能 ：读取 SCKF 的值
     85          // 入口参数：无
     86          // 出口参数：无
     87          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
     88          uint8 ReadSCKF(void)
     89          {
   \                     ReadSCKF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     90          	uint8 temp;
     91          
     92          	temp = 	GPIO_ReadIoVal(SCKF);
   \   00000002   0x20CC             MOVS     R0,#+204
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
     93          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
     94          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
     95          }
     96          
     97          //------------------------------------------------------------------------
     98          //  名  称 ：void WriteMOSIF( uint8 temp )
     99          //  功  能 ：设置 MOSIF
    100          // 入口参数：无
    101          // 出口参数：无
    102          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    103          void WriteMOSIF(uint8 temp)
    104          {	
   \                     WriteMOSIF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    105          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteMOSIF_0
    106          	{
    107          		GPIO_SetOrClearValue(MOSIF,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20CD             MOVS     R0,#+205
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteMOSIF_1
    108          	}
    109          	else
    110          	{
    111          		GPIO_SetOrClearValue(MOSIF,0);		
   \                     ??WriteMOSIF_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20CD             MOVS     R0,#+205
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    112          	}	
    113          	nop();		
   \                     ??WriteMOSIF_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    114          
    115          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    116          
    117          //------------------------------------------------------------------------
    118          //  名  称 ：uint8 ReadMOSIF(void)
    119          //  功  能 ：读取 MOSIF 的值
    120          // 入口参数：无
    121          // 出口参数：无
    122          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    123          uint8 ReadMOSIF(void)
    124          {
   \                     ReadMOSIF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    125          	uint8 temp;
    126          	
    127          	temp = 	GPIO_ReadIoVal(MOSIF);
   \   00000002   0x20CD             MOVS     R0,#+205
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
    128          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    129          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    130          }
    131          
    132          //------------------------------------------------------------------------
    133          //  名  称 ：void WriteMOSIF( uint8 temp )
    134          //  功  能 ：设置 MOSIF
    135          // 入口参数：无
    136          // 出口参数：无
    137          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    138          void WriteMISOF(uint8 temp)
    139          {	
   \                     WriteMISOF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    140          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteMISOF_0
    141          	{
    142          		GPIO_SetOrClearValue(MISOF,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20CB             MOVS     R0,#+203
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteMISOF_1
    143          	}
    144          	else
    145          	{
    146          		GPIO_SetOrClearValue(MISOF,0);		
   \                     ??WriteMISOF_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20CB             MOVS     R0,#+203
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    147          	}
    148          		
    149          	nop();		
   \                     ??WriteMISOF_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    150          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    151          
    152          //------------------------------------------------------------------------
    153          //  名  称 ：uint8 ReadMOSIF(void)
    154          //  功  能 ：读取 MOSIF 的值
    155          // 入口参数：无
    156          // 出口参数：无
    157          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    158          uint8 ReadMISOF(void)
    159          {
   \                     ReadMISOF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    160          	uint8 temp;
    161          
    162          	temp = 	GPIO_ReadIoVal(MISOF);
   \   00000002   0x20CB             MOVS     R0,#+203
   \   00000004   0x.... 0x....      BL       GPIO_ReadIoVal
   \   00000008   0x0004             MOVS     R4,R0
    163          
    164          	nop();
   \   0000000A   0x.... 0x....      BL       `nop`
    165          	return temp;
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    166          }
    167          
    168          //------------------------------------------------------------------------
    169          //  名  称 ：void WriteMOSIF( uint8 temp )
    170          //  功  能 ：设置 MOSIF
    171          // 入口参数：无
    172          // 出口参数：无
    173          //------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    174          void WriteSoftSpiCSF(uint8 temp)
    175          {
   \                     WriteSoftSpiCSF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    176          	if(temp)		
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD004             BEQ.N    ??WriteSoftSpiCSF_0
    177          	{
    178          		GPIO_SetOrClearValue(SOFT_SPI_CSF,1);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x20CA             MOVS     R0,#+202
   \   0000000E   0x.... 0x....      BL       GPIO_SetOrClearValue
   \   00000012   0xE003             B.N      ??WriteSoftSpiCSF_1
    179          	}
    180          	else
    181          	{
    182          		GPIO_SetOrClearValue(SOFT_SPI_CSF,0);		
   \                     ??WriteSoftSpiCSF_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x20CA             MOVS     R0,#+202
   \   00000018   0x.... 0x....      BL       GPIO_SetOrClearValue
    183          	}	
    184          
    185          	nop();		
   \                     ??WriteSoftSpiCSF_1: (+1)
   \   0000001C   0x.... 0x....      BL       `nop`
    186          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    187          
    188          //---------------------------------------------------------------------------------
    189          //函数名称:             SentByte_SPI()
    190          //功    能:             SPI发送一字节数据
    191          //入口参数:             Data8
    192          //出口参数:             无
    193          //说    明:				以模拟SPI总线方式发送数据
    194          //----------------------------------------------------------------------------------

   \                                 In section .text, align 2, keep-with-next
    195          uint8 SendOrRecByte_SPIF(uint8 ch)
    196          {
   \                     SendOrRecByte_SPIF: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    197          	uint8 i,temp;   
    198          	
    199              for (i=0;i<8;i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   \                     ??SendOrRecByte_SPIF_0: (+1)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0x2D08             CMP      R5,#+8
   \   0000000C   0xDA1F             BGE.N    ??SendOrRecByte_SPIF_1
    200              {
    201          		temp=ch&0x80;
   \   0000000E   0xF014 0x0080      ANDS     R0,R4,#0x80
   \   00000012   0x0006             MOVS     R6,R0
    202              	ch=ch<<1;
   \   00000014   0x0064             LSLS     R4,R4,#+1
    203                if(temp)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD009             BEQ.N    ??SendOrRecByte_SPIF_2
    204                {
    205                	WriteMOSIF( 1 );	
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       WriteMOSIF
    206          
    207                	WriteSCKF ( 0 );
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       WriteSCKF
    208          
    209                	WriteSCKF ( 1 );	        	
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x.... 0x....      BL       WriteSCKF
   \   0000002E   0xE008             B.N      ??SendOrRecByte_SPIF_3
    210                }
    211                else
    212                {
    213                	WriteMOSIF( 0 );	
   \                     ??SendOrRecByte_SPIF_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       WriteMOSIF
    214          
    215                  WriteSCKF ( 0 );
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      BL       WriteSCKF
    216                    
    217                	WriteSCKF ( 1 );
   \   0000003C   0x2001             MOVS     R0,#+1
   \   0000003E   0x.... 0x....      BL       WriteSCKF
    218                }
    219                
    220                ch |= ReadMISOF();
   \                     ??SendOrRecByte_SPIF_3: (+1)
   \   00000042   0x.... 0x....      BL       ReadMISOF
   \   00000046   0x4320             ORRS     R0,R0,R4
   \   00000048   0x0004             MOVS     R4,R0
    221              }
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0xE7DC             B.N      ??SendOrRecByte_SPIF_0
    222              
    223              return	ch;
   \                     ??SendOrRecByte_SPIF_1: (+1)
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xBD70             POP      {R4-R6,PC}       ;; return
    224          }
    225          

   \                                 In section .text, align 2, keep-with-next
    226          void	SendByte_SPIF(uint8	ch)
    227          {
   \                     SendByte_SPIF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    228          	SendOrRecByte_SPIF(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPIF
    229          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    230          

   \                                 In section .text, align 2, keep-with-next
    231          uint8	RecByte_SPIF(void)
    232          {
   \                     RecByte_SPIF: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    233          	uint8		ch =0;
   \   00000002   0x2400             MOVS     R4,#+0
    234          	return	SendOrRecByte_SPIF(ch);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendOrRecByte_SPIF
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    235          }
    236          
    237          /*********************************************************************************************************
    238          ** 函数名称：SPIInit
    239          ** 功能说明：初始化SPI
    240          ** 输入参数：无
    241          ** 输出参数：无
    242          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          void  SPIInit (void)
    244          {
    245          
    246          }
   \                     SPIInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    247          
    248          /*********************************************************************************************************
    249          ** 函数名称: Send_Byte
    250          ** 函数功能：SPI发送一个字节数据
    251          ** 输入参数: data
    252          ** 输出参数: 无
    253          ** 返 回 值：无
    254          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    255          void Send_Byte (INT8U data)
    256          {
   \                     Send_Byte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    257          	SendByte_SPIF(data);    
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x.... 0x....      BL       SendByte_SPIF
    258          }
   \   0000000C   0xBD10             POP      {R4,PC}          ;; return
    259          
    260          /*********************************************************************************************************
    261          ** 函数名称:Get_Byte
    262          ** 函数功能:SPI接口接收一个字节数据
    263          ** 输入参数:无
    264          ** 输出参数:无
    265          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    266          INT8U Get_Byte (void)
    267          {
   \                     Get_Byte: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    268          	return	RecByte_SPIF();
   \   00000002   0x.... 0x....      BL       RecByte_SPIF
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    269          }
    270           
    271          /*********************************************************************************************************
    272          ** 用户接口层
    273          ** 以下函数在移植时无需修改
    274          *********************************************************************************************************/
    275          /********************************************************************************************************
    276          ** 函数名称:MX25L1602_RD
    277          ** 函数功能:MX25L1602的读函数,可选择读ID和读数据操作
    278          ** 输入参数:
    279          **          INT32U Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）
    280          **          INT32U NByte:  要读取的数据字节数
    281          **          INT8U* RcvBufPt:接收缓存的指针
    282          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    283          ** 特殊说明:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    284          **********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    285          INT8U MX25L1602_RD(INT32U Dst, INT32U NByte,INT8U* RcvBufPt)
    286          {
   \                     MX25L1602_RD: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    287                INT32U i = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    288                if ((Dst+NByte > MAX_ADDR)||(NByte == 0))  return (ERROR_0);            /*  检查入口参数                */
   \   0000000A   0x1928             ADDS     R0,R5,R4
   \   0000000C   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   00000010   0xD201             BCS.N    ??MX25L1602_RD_0
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD101             BNE.N    ??MX25L1602_RD_1
   \                     ??MX25L1602_RD_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE01F             B.N      ??MX25L1602_RD_2
    289                
    290                CE_Low();
   \                     ??MX25L1602_RD_1: (+1)
   \   0000001A   0x.... 0x....      BL       CE_Low
    291                Send_Byte(0x0B);                                                      /* 发送读命令                   */
   \   0000001E   0x200B             MOVS     R0,#+11
   \   00000020   0x.... 0x....      BL       Send_Byte
    292                Send_Byte(((Dst & 0xFFFFFF) >> 16));                                  /* 发送地址信息:该地址为3个字节 */
   \   00000024   0x0C20             LSRS     R0,R4,#+16
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x.... 0x....      BL       Send_Byte
    293                Send_Byte(((Dst & 0xFFFF) >> 8));
   \   0000002C   0x0A20             LSRS     R0,R4,#+8
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x.... 0x....      BL       Send_Byte
    294                Send_Byte(Dst & 0xFF);
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x.... 0x....      BL       Send_Byte
    295                Send_Byte(0xFF);                                                      /* 发送一个哑字节以读取数据     */
   \   0000003C   0x20FF             MOVS     R0,#+255
   \   0000003E   0x.... 0x....      BL       Send_Byte
    296                for (i = 0; i < NByte; i++) {
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x0007             MOVS     R7,R0
   \                     ??MX25L1602_RD_3: (+1)
   \   00000046   0x42AF             CMP      R7,R5
   \   00000048   0xD204             BCS.N    ??MX25L1602_RD_4
    297                  RcvBufPt[i] = Get_Byte();
   \   0000004A   0x.... 0x....      BL       Get_Byte
   \   0000004E   0x55B8             STRB     R0,[R7, R6]
    298                }
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \   00000052   0xE7F8             B.N      ??MX25L1602_RD_3
    299                CE_High();
   \                     ??MX25L1602_RD_4: (+1)
   \   00000054   0x.... 0x....      BL       CE_High
    300                return (OK);
   \   00000058   0x2001             MOVS     R0,#+1
   \                     ??MX25L1602_RD_2: (+1)
   \   0000005A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    301          }
    302          
    303          /*********************************************************************************************************
    304          ** 函数名称:MX25L1602_RdID
    305          ** 函数功能:MX25L1602的读ID函数,可选择读ID和读数据操作
    306          ** 输入参数:
    307          **          idtype IDType:ID类型。用户可在Jedec_ID,Dev_ID,Manu_ID三者里选择
    308          **          INT32U* RcvbufPt:存储ID变量的指针
    309          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    310          ** 特殊说明:若填入的参数不符合要求，则返回ERROR_0
    311          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    312          INT8U MX25L1602_RdID(idtype IDType, INT32U* RcvbufPt)
    313          {
   \                     MX25L1602_RdID: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    314                INT32U temp = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    315                if (IDType == Jedec_ID) {
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x2C02             CMP      R4,#+2
   \   0000000C   0xD117             BNE.N    ??MX25L1602_RdID_0
    316                  CE_Low();
   \   0000000E   0x.... 0x....      BL       CE_Low
    317                  Send_Byte(0x9F);                                                    /* 发送读JEDEC ID命令(9Fh)      */
   \   00000012   0x209F             MOVS     R0,#+159
   \   00000014   0x.... 0x....      BL       Send_Byte
    318                  temp = (temp | Get_Byte()) << 8;                                    /* 接收数据                     */
   \   00000018   0x.... 0x....      BL       Get_Byte
   \   0000001C   0x4330             ORRS     R0,R0,R6
   \   0000001E   0x0200             LSLS     R0,R0,#+8
   \   00000020   0x0006             MOVS     R6,R0
    319                  temp = (temp | Get_Byte()) << 8;
   \   00000022   0x.... 0x....      BL       Get_Byte
   \   00000026   0x4330             ORRS     R0,R0,R6
   \   00000028   0x0200             LSLS     R0,R0,#+8
   \   0000002A   0x0006             MOVS     R6,R0
    320                  temp = (temp | Get_Byte());                                         /* 在本例中,temp的值应为0xBF2541*/
   \   0000002C   0x.... 0x....      BL       Get_Byte
   \   00000030   0x4330             ORRS     R0,R0,R6
   \   00000032   0x0006             MOVS     R6,R0
    321                  CE_High();
   \   00000034   0x.... 0x....      BL       CE_High
    322                  *RcvbufPt = temp;
   \   00000038   0x602E             STR      R6,[R5, #+0]
    323                  return (OK);
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE01D             B.N      ??MX25L1602_RdID_1
    324                }
    325              
    326                if ((IDType == Manu_ID) || (IDType == Dev_ID) ) {
   \                     ??MX25L1602_RdID_0: (+1)
   \   0000003E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD002             BEQ.N    ??MX25L1602_RdID_2
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x2C01             CMP      R4,#+1
   \   00000048   0xD116             BNE.N    ??MX25L1602_RdID_3
    327                  CE_Low();
   \                     ??MX25L1602_RdID_2: (+1)
   \   0000004A   0x.... 0x....      BL       CE_Low
    328                  Send_Byte(0x90);                                                    /* 发送读ID命令 (90h or ABh)    */
   \   0000004E   0x2090             MOVS     R0,#+144
   \   00000050   0x.... 0x....      BL       Send_Byte
    329                  Send_Byte(0x00);                                                    /* 发送地址                     */
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       Send_Byte
    330                  Send_Byte(0x00);                                                    /* 发送地址                     */
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       Send_Byte
    331                  Send_Byte(IDType);                                                  /* 发送地址 - 不是00H就是01H    */
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0x.... 0x....      BL       Send_Byte
    332                  temp = Get_Byte();                                                  /* 接收获取的数据字节           */
   \   00000068   0x.... 0x....      BL       Get_Byte
   \   0000006C   0x0006             MOVS     R6,R0
    333                  CE_High();
   \   0000006E   0x.... 0x....      BL       CE_High
    334                  *RcvbufPt = temp;
   \   00000072   0x602E             STR      R6,[R5, #+0]
    335                  return (OK);
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xE000             B.N      ??MX25L1602_RdID_1
    336                } else {
    337                  return (ERROR_0);
   \                     ??MX25L1602_RdID_3: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \                     ??MX25L1602_RdID_1: (+1)
   \   0000007A   0xBD70             POP      {R4-R6,PC}       ;; return
    338                }
    339          }
    340          
    341          /*********************************************************************************************************
    342          ** 函数名称:MX25L1602_WR
    343          ** 函数功能:MX25L1602的写函数，可写1个和多个数据到指定地址
    344          ** 输入参数:
    345          **          INT32U Dst：目标地址,范围 0x0 - MAX_ADDR（MAX_ADDR = 0x1FFFFF）
    346          **          INT8U* SndbufPt:发送缓存区指针
    347          **          INT32U NByte:要写的数据字节数
    348          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    349          ** 特殊说明:若某功能下,某一入口参数无效,可在该入口参数处填Invalid，该参数将被忽略
    350          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    351          INT8U MX25L1602_WR(INT32U Dst, INT8U* SndbufPt, INT32U NByte)
    352          {
   \                     MX25L1602_WR: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    353                INT32U temp = 0,i = 0,StatRgVal = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    354                if (( (Dst+NByte-1 > MAX_ADDR)||(NByte == 0) )) {
   \   00000014   0x1930             ADDS     R0,R6,R4
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0xF5B0 0x0F00      CMP      R0,#+8388608
   \   0000001C   0xD201             BCS.N    ??MX25L1602_WR_0
   \   0000001E   0x2E00             CMP      R6,#+0
   \   00000020   0xD101             BNE.N    ??MX25L1602_WR_1
    355                  return (ERROR_0);                                                     /*  检查入口参数                */
   \                     ??MX25L1602_WR_0: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE080             B.N      ??MX25L1602_WR_2
    356                }
    357                CE_Low();
   \                     ??MX25L1602_WR_1: (+1)
   \   00000026   0x.... 0x....      BL       CE_Low
    358                Send_Byte(0x05);                                                      /* 发送读状态寄存器命令         */
   \   0000002A   0x2005             MOVS     R0,#+5
   \   0000002C   0x.... 0x....      BL       Send_Byte
    359                temp = Get_Byte();                                                    /* 保存读得的状态寄存器值       */
   \   00000030   0x.... 0x....      BL       Get_Byte
   \   00000034   0x0007             MOVS     R7,R0
    360                CE_High();
   \   00000036   0x.... 0x....      BL       CE_High
    361              
    362                CE_Low();
   \   0000003A   0x.... 0x....      BL       CE_Low
    363               Send_Byte(0x50);                                                      /* 使状态寄存器可写             */
   \   0000003E   0x2050             MOVS     R0,#+80
   \   00000040   0x.... 0x....      BL       Send_Byte
    364          //         Send_Byte(0x06);                                                    /* 发送写使能命令               */
    365                CE_High();
   \   00000044   0x.... 0x....      BL       CE_High
    366                CE_Low();
   \   00000048   0x.... 0x....      BL       CE_Low
    367                Send_Byte(0x01);                                                      /* 发送写状态寄存器指令         */
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      BL       Send_Byte
    368                Send_Byte(0);                                                         /* 清0BPx位，使Flash芯片全区可写*/
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       Send_Byte
    369                CE_High();
   \   00000058   0x.... 0x....      BL       CE_High
    370              
    371                for(i = 0; i < NByte; i++) {
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x4680             MOV      R8,R0
   \                     ??MX25L1602_WR_3: (+1)
   \   00000060   0x45B0             CMP      R8,R6
   \   00000062   0xD247             BCS.N    ??MX25L1602_WR_4
    372          ////新增20131126  跨块擦除扇
    373          //		printfcom0(" %d,%d, ",Dst+i,Dst+i % 4096);
    374          		if((Dst+i) % 4096 == 0)
   \   00000064   0xEB18 0x0004      ADDS     R0,R8,R4
   \   00000068   0xF44F 0x5180      MOV      R1,#+4096
   \   0000006C   0xFBB0 0xF2F1      UDIV     R2,R0,R1
   \   00000070   0xFB02 0x0211      MLS      R2,R2,R1,R0
   \   00000074   0x2A00             CMP      R2,#+0
   \   00000076   0xD10A             BNE.N    ??MX25L1602_WR_5
    375          		{
    376          			MX25L1602_Erase((Dst+i)/4096,(Dst+i)/4096);
   \   00000078   0xEB18 0x0004      ADDS     R0,R8,R4
   \   0000007C   0x0B01             LSRS     R1,R0,#+12
   \   0000007E   0xEB18 0x0004      ADDS     R0,R8,R4
   \   00000082   0x0B00             LSRS     R0,R0,#+12
   \   00000084   0x.... 0x....      BL       MX25L1602_Erase
    377          			printfcom0("\r\n EraseEraseEraseErase");
   \   00000088   0x....             LDR.N    R0,??DataTable1
   \   0000008A   0x.... 0x....      BL       printfcom0
    378          		}
    379          //////		
    380           
    381                  CE_Low();
   \                     ??MX25L1602_WR_5: (+1)
   \   0000008E   0x.... 0x....      BL       CE_Low
    382                  Send_Byte(0x06);                                                    /* 发送写使能命令               */
   \   00000092   0x2006             MOVS     R0,#+6
   \   00000094   0x.... 0x....      BL       Send_Byte
    383                  CE_High();
   \   00000098   0x.... 0x....      BL       CE_High
    384              
    385                  CE_Low();
   \   0000009C   0x.... 0x....      BL       CE_Low
    386                  Send_Byte(0x02);                                                    /* 发送字节数据烧写命令         */
   \   000000A0   0x2002             MOVS     R0,#+2
   \   000000A2   0x.... 0x....      BL       Send_Byte
    387                  Send_Byte((((Dst+i) & 0xFFFFFF) >> 16));                            /* 发送3个字节的地址信息        */
   \   000000A6   0xEB18 0x0004      ADDS     R0,R8,R4
   \   000000AA   0x0C00             LSRS     R0,R0,#+16
   \   000000AC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AE   0x.... 0x....      BL       Send_Byte
    388                  Send_Byte((((Dst+i) & 0xFFFF) >> 8));
   \   000000B2   0xEB18 0x0004      ADDS     R0,R8,R4
   \   000000B6   0x0A00             LSRS     R0,R0,#+8
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0x.... 0x....      BL       Send_Byte
    389                  Send_Byte((Dst+i) & 0xFF);
   \   000000BE   0xEB18 0x0004      ADDS     R0,R8,R4
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0x.... 0x....      BL       Send_Byte
    390                  Send_Byte(SndbufPt[i]);                                             /* 发送被烧写的数据             */
   \   000000C8   0xF818 0x0005      LDRB     R0,[R8, R5]
   \   000000CC   0x.... 0x....      BL       Send_Byte
    391                  CE_High();
   \   000000D0   0x.... 0x....      BL       CE_High
    392              
    393                  do {
    394                    CE_Low();
   \                     ??MX25L1602_WR_6: (+1)
   \   000000D4   0x.... 0x....      BL       CE_Low
    395                    Send_Byte(0x05);                                                  /* 发送读状态寄存器命令         */
   \   000000D8   0x2005             MOVS     R0,#+5
   \   000000DA   0x.... 0x....      BL       Send_Byte
    396                    StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值       */
   \   000000DE   0x.... 0x....      BL       Get_Byte
   \   000000E2   0x4681             MOV      R9,R0
    397                    CE_High();
   \   000000E4   0x.... 0x....      BL       CE_High
    398                  } while (StatRgVal == 0x03);                                        /* 一直等待，直到芯片空闲       */
   \   000000E8   0xF1B9 0x0F03      CMP      R9,#+3
   \   000000EC   0xD0F2             BEQ.N    ??MX25L1602_WR_6
    399                }
   \   000000EE   0xF118 0x0801      ADDS     R8,R8,#+1
   \   000000F2   0xE7B5             B.N      ??MX25L1602_WR_3
    400              
    401                CE_Low();
   \                     ??MX25L1602_WR_4: (+1)
   \   000000F4   0x.... 0x....      BL       CE_Low
    402                Send_Byte(0x06);                                                      /* 发送写使能命令               */
   \   000000F8   0x2006             MOVS     R0,#+6
   \   000000FA   0x.... 0x....      BL       Send_Byte
    403                CE_High();
   \   000000FE   0x.... 0x....      BL       CE_High
    404              
    405                CE_Low();
   \   00000102   0x.... 0x....      BL       CE_Low
    406                Send_Byte(0x50);                                                      /* 使状态寄存器可写             */
   \   00000106   0x2050             MOVS     R0,#+80
   \   00000108   0x.... 0x....      BL       Send_Byte
    407                CE_High();
   \   0000010C   0x.... 0x....      BL       CE_High
    408                CE_Low();
   \   00000110   0x.... 0x....      BL       CE_Low
    409                Send_Byte(0x01);                                                      /* 发送写状态寄存器指令         */
   \   00000114   0x2001             MOVS     R0,#+1
   \   00000116   0x.... 0x....      BL       Send_Byte
    410                Send_Byte(temp);                                                      /* 恢复状态寄存器设置信息       */
   \   0000011A   0x0038             MOVS     R0,R7
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x.... 0x....      BL       Send_Byte
    411                CE_High();
   \   00000122   0x.... 0x....      BL       CE_High
    412              
    413                return (OK);
   \   00000126   0x2001             MOVS     R0,#+1
   \                     ??MX25L1602_WR_2: (+1)
   \   00000128   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    414          }
    415          
    416          /*********************************************************************************************************
    417          ** 函数名称:MX25L1602_Erase
    418          ** 函数功能:根据指定的扇区号选取最高效的算法擦除
    419          ** 输入参数:
    420          **          INT32U sec1：起始扇区号,范围(0~499)
    421          **          INT32U sec2：终止扇区号,范围(0~499)
    422          ** 输出参数:操作成功则返回OK,失败则返回ERROR_0
    423          *********************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    424          INT8U MX25L1602_Erase(INT32U sec1, INT32U sec2)
    425          {
   \                     MX25L1602_Erase: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   \   00000006   0x000C             MOVS     R4,R1
    426            INT8U  temp1 = 0,temp2 = 0,StatRgVal = 0;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
    427            INT32U SecnHdAddr = 0;
   \   0000000E   0xF05F 0x0800      MOVS     R8,#+0
    428            INT32U no_SecsToEr = 0;                                               /* 要擦除的扇区数目             */
   \   00000012   0xF05F 0x0900      MOVS     R9,#+0
    429            INT32U CurSecToEr = 0;                                                /* 当前要擦除的扇区号           */
   \   00000016   0xF05F 0x0A00      MOVS     R10,#+0
    430          
    431            /*
    432             *  检查入口参数
    433             */
    434            if ((sec1 > SEC_MAX)||(sec2 > SEC_MAX)) {
   \   0000001A   0xF5BB 0x6F00      CMP      R11,#+2048
   \   0000001E   0xD802             BHI.N    ??MX25L1602_Erase_0
   \   00000020   0xF5B4 0x6F00      CMP      R4,#+2048
   \   00000024   0xD901             BLS.N    ??MX25L1602_Erase_1
    435              return (ERROR_0);
   \                     ??MX25L1602_Erase_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE0F5             B.N      ??MX25L1602_Erase_2
    436            }
    437          
    438            CE_Low();
   \                     ??MX25L1602_Erase_1: (+1)
   \   0000002A   0x.... 0x....      BL       CE_Low
    439            Send_Byte(0x05);                                                     /* 发送读状态寄存器命令          */
   \   0000002E   0x2005             MOVS     R0,#+5
   \   00000030   0x.... 0x....      BL       Send_Byte
    440            temp1 = Get_Byte();                                                  /* 保存读得的状态寄存器值        */
   \   00000034   0x.... 0x....      BL       Get_Byte
   \   00000038   0x0005             MOVS     R5,R0
    441            CE_High();
   \   0000003A   0x.... 0x....      BL       CE_High
    442          
    443            CE_Low();
   \   0000003E   0x.... 0x....      BL       CE_Low
    444          //  Send_Byte(0x50);                                                     /* 使状态寄存器可写              */
    445          
    446            Send_Byte(0x06);
   \   00000042   0x2006             MOVS     R0,#+6
   \   00000044   0x.... 0x....      BL       Send_Byte
    447            CE_High();
   \   00000048   0x.... 0x....      BL       CE_High
    448          
    449            CE_Low();
   \   0000004C   0x.... 0x....      BL       CE_Low
    450            Send_Byte(0x01);                                                     /* 发送写状态寄存器指令          */
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x.... 0x....      BL       Send_Byte
    451            Send_Byte(0);                                                        /* 清0BPx位，使Flash芯片全区可写 */
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       Send_Byte
    452            CE_High();
   \   0000005C   0x.... 0x....      BL       CE_High
    453          
    454            CE_Low();
   \   00000060   0x.... 0x....      BL       CE_Low
    455            Send_Byte(0x06);                                                      /* 发送写使能命令               */
   \   00000064   0x2006             MOVS     R0,#+6
   \   00000066   0x.... 0x....      BL       Send_Byte
    456            CE_High();
   \   0000006A   0x.... 0x....      BL       CE_High
    457          
    458            /*
    459             * 如果用户输入的起始扇区号大于终止扇区号，则在内部作出调整
    460             */
    461            if (sec1 > sec2)
   \   0000006E   0x455C             CMP      R4,R11
   \   00000070   0xD204             BCS.N    ??MX25L1602_Erase_3
    462            {
    463              temp2 = sec1;
   \   00000072   0x4658             MOV      R0,R11
   \   00000074   0x0006             MOVS     R6,R0
    464              sec1  = sec2;
   \   00000076   0x46A3             MOV      R11,R4
    465              sec2  = temp2;
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0x0034             MOVS     R4,R6
    466            }
    467            /*
    468             * 若起止扇区号相等则擦除单个扇区
    469             */
    470            if (sec1 == sec2)
   \                     ??MX25L1602_Erase_3: (+1)
   \   0000007C   0x45A3             CMP      R11,R4
   \   0000007E   0xD127             BNE.N    ??MX25L1602_Erase_4
    471            {
    472              SecnHdAddr = SEC_SIZE * sec1;                                       /* 计算扇区的起始地址           */
   \   00000080   0xF44F 0x5080      MOV      R0,#+4096
   \   00000084   0xFB00 0xF00B      MUL      R0,R0,R11
   \   00000088   0x4680             MOV      R8,R0
    473              CE_Low();
   \   0000008A   0x.... 0x....      BL       CE_Low
    474              Send_Byte(0x20);                                                    /* 发送扇区擦除指令             */
   \   0000008E   0x2020             MOVS     R0,#+32
   \   00000090   0x.... 0x....      BL       Send_Byte
    475              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                         /* 发送3个字节的地址信息        */
   \   00000094   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x.... 0x....      BL       Send_Byte
    476              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   0000009E   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   000000A2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A4   0x.... 0x....      BL       Send_Byte
    477              Send_Byte(SecnHdAddr & 0xFF);
   \   000000A8   0x4640             MOV      R0,R8
   \   000000AA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AC   0x.... 0x....      BL       Send_Byte
    478              CE_High();
   \   000000B0   0x.... 0x....      BL       CE_High
    479              do {
    480                CE_Low();
   \                     ??MX25L1602_Erase_5: (+1)
   \   000000B4   0x.... 0x....      BL       CE_Low
    481                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令        */
   \   000000B8   0x2005             MOVS     R0,#+5
   \   000000BA   0x.... 0x....      BL       Send_Byte
    482                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值      */
   \   000000BE   0x.... 0x....      BL       Get_Byte
   \   000000C2   0x0007             MOVS     R7,R0
    483                CE_High();
   \   000000C4   0x.... 0x....      BL       CE_High
    484              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲      */
   \   000000C8   0x07F8             LSLS     R0,R7,#+31
   \   000000CA   0xD4F3             BMI.N    ??MX25L1602_Erase_5
    485              return (OK);
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0xE0A2             B.N      ??MX25L1602_Erase_2
    486            }
    487          
    488            /*
    489             * 根据起始扇区和终止扇区间距调用最快速的擦除功能
    490             */
    491          
    492            if (sec2 - sec1 == SEC_MAX) {
   \                     ??MX25L1602_Erase_4: (+1)
   \   000000D0   0xEBB4 0x000B      SUBS     R0,R4,R11
   \   000000D4   0xF5B0 0x6F00      CMP      R0,#+2048
   \   000000D8   0xD114             BNE.N    ??MX25L1602_Erase_6
    493              CE_Low();
   \   000000DA   0x.... 0x....      BL       CE_Low
    494              Send_Byte(0x60);                                                    /* 发送芯片擦除指令(60h or C7h) */
   \   000000DE   0x2060             MOVS     R0,#+96
   \   000000E0   0x.... 0x....      BL       Send_Byte
    495              CE_High();
   \   000000E4   0x.... 0x....      BL       CE_High
    496              do {
    497                CE_Low();
   \                     ??MX25L1602_Erase_7: (+1)
   \   000000E8   0x.... 0x....      BL       CE_Low
    498                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令         */
   \   000000EC   0x2005             MOVS     R0,#+5
   \   000000EE   0x.... 0x....      BL       Send_Byte
    499                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值       */
   \   000000F2   0x.... 0x....      BL       Get_Byte
   \   000000F6   0x0007             MOVS     R7,R0
    500                CE_High();
   \   000000F8   0x.... 0x....      BL       CE_High
    501              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲       */
   \   000000FC   0x07F8             LSLS     R0,R7,#+31
   \   000000FE   0xD4F3             BMI.N    ??MX25L1602_Erase_7
    502              return (OK);
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0xE088             B.N      ??MX25L1602_Erase_2
    503            }
    504          
    505            no_SecsToEr = sec2 - sec1 +1;                                         /* 获取要擦除的扇区数目         */
   \                     ??MX25L1602_Erase_6: (+1)
   \   00000104   0xEBB4 0x000B      SUBS     R0,R4,R11
   \   00000108   0x1C40             ADDS     R0,R0,#+1
   \   0000010A   0x4681             MOV      R9,R0
    506            CurSecToEr  = sec1;                                                   /* 从起始扇区开始擦除           */
   \   0000010C   0x46DA             MOV      R10,R11
    507          
    508            /*
    509             * 若两个扇区之间的间隔够大，则采取16扇区擦除算法
    510             */
    511            while (no_SecsToEr >= 16)
   \                     ??MX25L1602_Erase_8: (+1)
   \   0000010E   0xF1B9 0x0F10      CMP      R9,#+16
   \   00000112   0xD331             BCC.N    ??MX25L1602_Erase_9
    512            {
    513              CE_Low();
   \   00000114   0x.... 0x....      BL       CE_Low
    514              Send_Byte(0x06);                                                     /* 发送允许写命令              */
   \   00000118   0x2006             MOVS     R0,#+6
   \   0000011A   0x.... 0x....      BL       Send_Byte
    515              CE_High();
   \   0000011E   0x.... 0x....      BL       CE_High
    516          
    517              SecnHdAddr = SEC_SIZE * CurSecToEr;                                  /* 计算扇区的起始地址          */
   \   00000122   0xF44F 0x5080      MOV      R0,#+4096
   \   00000126   0xFB00 0xF00A      MUL      R0,R0,R10
   \   0000012A   0x4680             MOV      R8,R0
    518              CE_Low();
   \   0000012C   0x.... 0x....      BL       CE_Low
    519              Send_Byte(0xD8);                                                     /* 发送64KB块擦除指令          */
   \   00000130   0x20D8             MOVS     R0,#+216
   \   00000132   0x.... 0x....      BL       Send_Byte
    520              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                          /* 发送3个字节的地址信息       */
   \   00000136   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   0000013A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000013C   0x.... 0x....      BL       Send_Byte
    521              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   00000140   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   00000144   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000146   0x.... 0x....      BL       Send_Byte
    522              Send_Byte(SecnHdAddr & 0xFF);
   \   0000014A   0x4640             MOV      R0,R8
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x.... 0x....      BL       Send_Byte
    523              CE_High();
   \   00000152   0x.... 0x....      BL       CE_High
    524              do {
    525                CE_Low();
   \                     ??MX25L1602_Erase_10: (+1)
   \   00000156   0x.... 0x....      BL       CE_Low
    526                Send_Byte(0x05);                                                  /* 发送读状态寄存器命令        */
   \   0000015A   0x2005             MOVS     R0,#+5
   \   0000015C   0x.... 0x....      BL       Send_Byte
    527                StatRgVal = Get_Byte();                                           /* 保存读得的状态寄存器值      */
   \   00000160   0x.... 0x....      BL       Get_Byte
   \   00000164   0x0007             MOVS     R7,R0
    528                CE_High();
   \   00000166   0x.... 0x....      BL       CE_High
    529              } while (StatRgVal & 0x01);                                         /* 一直等待，直到芯片空闲      */
   \   0000016A   0x07F8             LSLS     R0,R7,#+31
   \   0000016C   0xD4F3             BMI.N    ??MX25L1602_Erase_10
    530              CurSecToEr  += 16;                                                  /* 计算擦除了16个扇区后和擦除区*/
   \   0000016E   0xF11A 0x0A10      ADDS     R10,R10,#+16
    531                                                                                  /* 域相邻的待擦除扇区号        */
    532              no_SecsToEr -=  16;                                                 /* 对需擦除的扇区总数作出调整  */
   \   00000172   0xF1B9 0x0910      SUBS     R9,R9,#+16
   \   00000176   0xE7CA             B.N      ??MX25L1602_Erase_8
    533            }
    534          
    535            /*
    536             * 采用扇区擦除算法擦除剩余的扇区
    537             */
    538            while (no_SecsToEr >= 1) {
   \                     ??MX25L1602_Erase_9: (+1)
   \   00000178   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000017C   0xD031             BEQ.N    ??MX25L1602_Erase_11
    539              CE_Low();
   \   0000017E   0x.... 0x....      BL       CE_Low
    540              Send_Byte(0x06);                                                   /* 发送允许写命令              */
   \   00000182   0x2006             MOVS     R0,#+6
   \   00000184   0x.... 0x....      BL       Send_Byte
    541              CE_High();
   \   00000188   0x.... 0x....      BL       CE_High
    542          
    543              SecnHdAddr = SEC_SIZE * CurSecToEr;                                /* 计算扇区的起始地址          */
   \   0000018C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000190   0xFB00 0xF00A      MUL      R0,R0,R10
   \   00000194   0x4680             MOV      R8,R0
    544              CE_Low();
   \   00000196   0x.... 0x....      BL       CE_Low
    545              Send_Byte(0x20);                                                   /* 发送扇区擦除指令            */
   \   0000019A   0x2020             MOVS     R0,#+32
   \   0000019C   0x.... 0x....      BL       Send_Byte
    546              Send_Byte(((SecnHdAddr & 0xFFFFFF) >> 16));                        /* 发送3个字节的地址信息       */
   \   000001A0   0xEA5F 0x4018      LSRS     R0,R8,#+16
   \   000001A4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001A6   0x.... 0x....      BL       Send_Byte
    547              Send_Byte(((SecnHdAddr & 0xFFFF) >> 8));
   \   000001AA   0xEA5F 0x2018      LSRS     R0,R8,#+8
   \   000001AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B0   0x.... 0x....      BL       Send_Byte
    548              Send_Byte(SecnHdAddr & 0xFF);
   \   000001B4   0x4640             MOV      R0,R8
   \   000001B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B8   0x.... 0x....      BL       Send_Byte
    549              CE_High();
   \   000001BC   0x.... 0x....      BL       CE_High
    550              do {
    551                CE_Low();
   \                     ??MX25L1602_Erase_12: (+1)
   \   000001C0   0x.... 0x....      BL       CE_Low
    552                Send_Byte(0x05);                                                 /* 发送读状态寄存器命令        */
   \   000001C4   0x2005             MOVS     R0,#+5
   \   000001C6   0x.... 0x....      BL       Send_Byte
    553                StatRgVal = Get_Byte();                                          /* 保存读得的状态寄存器值      */
   \   000001CA   0x.... 0x....      BL       Get_Byte
   \   000001CE   0x0007             MOVS     R7,R0
    554                CE_High();
   \   000001D0   0x.... 0x....      BL       CE_High
    555              } while (StatRgVal & 0x01 );                                       /* 一直等待，直到芯片空闲      */
   \   000001D4   0x07F8             LSLS     R0,R7,#+31
   \   000001D6   0xD4F3             BMI.N    ??MX25L1602_Erase_12
    556              CurSecToEr  += 1;
   \   000001D8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    557              no_SecsToEr -=  1;
   \   000001DC   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   000001E0   0xE7CA             B.N      ??MX25L1602_Erase_9
    558            }
    559            /*
    560             * 擦除结束,恢复状态寄存器信息
    561             */
    562            CE_Low();
   \                     ??MX25L1602_Erase_11: (+1)
   \   000001E2   0x.... 0x....      BL       CE_Low
    563            Send_Byte(0x06);                                                    /* 发送写使能命令               */
   \   000001E6   0x2006             MOVS     R0,#+6
   \   000001E8   0x.... 0x....      BL       Send_Byte
    564            CE_High();
   \   000001EC   0x.... 0x....      BL       CE_High
    565          
    566            CE_Low();
   \   000001F0   0x.... 0x....      BL       CE_Low
    567            Send_Byte(0x50);                                                    /* 使状态寄存器可写             */
   \   000001F4   0x2050             MOVS     R0,#+80
   \   000001F6   0x.... 0x....      BL       Send_Byte
    568            CE_High();
   \   000001FA   0x.... 0x....      BL       CE_High
    569            CE_Low();
   \   000001FE   0x.... 0x....      BL       CE_Low
    570            Send_Byte(0x01);                                                    /* 发送写状态寄存器指令         */
   \   00000202   0x2001             MOVS     R0,#+1
   \   00000204   0x.... 0x....      BL       Send_Byte
    571            Send_Byte(temp1);                                                   /* 恢复状态寄存器设置信息       */
   \   00000208   0x0028             MOVS     R0,R5
   \   0000020A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020C   0x.... 0x....      BL       Send_Byte
    572            CE_High();
   \   00000210   0x.... 0x....      BL       CE_High
    573            return (OK);
   \   00000214   0x2001             MOVS     R0,#+1
   \                     ??MX25L1602_Erase_2: (+1)
   \   00000216   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    574          }
    575          
    576          #define		FLSH_ERR  36

   \                                 In section .data, align 1
    577          uint8	flsherrflg = 0xff;
   \                     flsherrflg:
   \   00000000   0xFF               DC8 255

   \                                 In section .text, align 2, keep-with-next
    578          uint8 JudgeFlashIDErrFlg(void)   
    579          {
   \                     JudgeFlashIDErrFlg: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    580          	uint32_t 	GulChipID = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x9000             STR      R0,[SP, #+0]
    581          
    582          	//if(GetSysTime() %100*30==1 || GetSysTime() < 60*100)
    583          	{
    584          	    MX25L1602_RdID(Jedec_ID, &GulChipID);		                        /* 单步运行到此处时,在IAR里查看 */
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       MX25L1602_RdID
    585          
    586          	    GulChipID &= ~0xFF000000;                                           /* 仅保留低24位数据             */            
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000012   0x0A00             LSRS     R0,R0,#+8
   \   00000014   0x9000             STR      R0,[SP, #+0]
    587          	    if (GulChipID != 0x00C22017)//c22015 
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x....             LDR.N    R1,??DataTable1_1  ;; 0xc22017
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD003             BEQ.N    ??JudgeFlashIDErrFlg_0
    588          		{
    589          			flsherrflg = FLSH_ERR;
   \   0000001E   0x2024             MOVS     R0,#+36
   \   00000020   0x....             LDR.N    R1,??DataTable1_2
   \   00000022   0x7008             STRB     R0,[R1, #+0]
   \   00000024   0xE002             B.N      ??JudgeFlashIDErrFlg_1
    590          	   	}
    591          		else
    592          		{
    593          			flsherrflg = 0xff;
   \                     ??JudgeFlashIDErrFlg_0: (+1)
   \   00000026   0x20FF             MOVS     R0,#+255
   \   00000028   0x....             LDR.N    R1,??DataTable1_2
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    594          		}
    595          	}
    596          
    597          	return 	flsherrflg;
   \                     ??JudgeFlashIDErrFlg_1: (+1)
   \   0000002C   0x....             LDR.N    R0,??DataTable1_2
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xBD02             POP      {R1,PC}          ;; return
    598          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x00C22017         DC32     0xc22017

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     flsherrflg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012 EraseEraseEraseErase"
   \              0x20 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x00    
    599          
    600          /*********************************************************************************************************
    601          ** End Of File
    602          *********************************************************************************************************/
    603          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CE_High
         8   -> WriteSoftSpiCSF
       8   CE_Low
         8   -> WriteSoftSpiCSF
       8   Get_Byte
         8   -> RecByte_SPIF
       8   InitFlashIO
         8   -> GPIO_PinselConfig
       8   JudgeFlashIDErrFlg
         8   -> MX25L1602_RdID
      40   MX25L1602_Erase
        40   -> CE_High
        40   -> CE_Low
        40   -> Get_Byte
        40   -> Send_Byte
      24   MX25L1602_RD
        24   -> CE_High
        24   -> CE_Low
        24   -> Get_Byte
        24   -> Send_Byte
      16   MX25L1602_RdID
        16   -> CE_High
        16   -> CE_Low
        16   -> Get_Byte
        16   -> Send_Byte
      32   MX25L1602_WR
        32   -> CE_High
        32   -> CE_Low
        32   -> Get_Byte
        32   -> MX25L1602_Erase
        32   -> Send_Byte
        32   -> printfcom0
       8   ReadMISOF
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadMOSIF
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   ReadSCKF
         8   -> GPIO_ReadIoVal
         8   -> nop
       8   RecByte_SPIF
         8   -> SendOrRecByte_SPIF
       0   SPIInit
       8   SendByte_SPIF
         8   -> SendOrRecByte_SPIF
      16   SendOrRecByte_SPIF
        16   -> ReadMISOF
        16   -> WriteMOSIF
        16   -> WriteSCKF
       8   Send_Byte
         8   -> SendByte_SPIF
       8   WriteMISOF
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteMOSIF
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteSCKF
         8   -> GPIO_SetOrClearValue
         8   -> nop
       8   WriteSoftSpiCSF
         8   -> GPIO_SetOrClearValue
         8   -> nop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      24  ?_0
      10  CE_High
      10  CE_Low
       8  Get_Byte
      60  InitFlashIO
      50  JudgeFlashIDErrFlg
     538  MX25L1602_Erase
      92  MX25L1602_RD
     124  MX25L1602_RdID
     300  MX25L1602_WR
      20  ReadMISOF
      20  ReadMOSIF
      20  ReadSCKF
      14  RecByte_SPIF
       2  SPIInit
      14  SendByte_SPIF
      84  SendOrRecByte_SPIF
      14  Send_Byte
      34  WriteMISOF
      34  WriteMOSIF
      34  WriteSCKF
      34  WriteSoftSpiCSF
       1  flsherrflg

 
     1 byte  in section .data
    24 bytes in section .rodata
 1 528 bytes in section .text
 
 1 528 bytes of CODE  memory
    24 bytes of CONST memory
     1 byte  of DATA  memory

Errors: none
Warnings: none
